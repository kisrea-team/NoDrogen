"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_react-notion-x_build_third-party_equation_js"],{

/***/ "(app-pages-browser)/./node_modules/@matejmazur/react-katex/dist/react-katex.m.js":
/*!********************************************************************!*\
  !*** ./node_modules/@matejmazur/react-katex/dist/react-katex.m.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var katex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! katex */ \"(app-pages-browser)/./node_modules/katex/dist/katex.mjs\");\nfunction a(){return(a=Object.assign||function(r){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(r[t]=n[t])}return r}).apply(this,arguments)}var i=(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function(e){var i=e.children,l=e.math,s=e.block,c=e.errorColor,f=e.renderError,m=e.settings,u=e.as,h=function(r,e){if(null==r)return{};var n,t,o={},a=Object.keys(r);for(t=0;t<a.length;t++)e.indexOf(n=a[t])>=0||(o[n]=r[n]);return o}(e,[\"children\",\"math\",\"block\",\"errorColor\",\"renderError\",\"settings\",\"as\"]),d=u||(s?\"div\":\"span\"),p=null!=i?i:l,g=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({innerHtml:\"\"}),E=g[0],v=g[1];return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){try{var r=katex__WEBPACK_IMPORTED_MODULE_1__[\"default\"].renderToString(p,a({displayMode:!!s,errorColor:c,throwOnError:!!f},m));v({innerHtml:r})}catch(r){if(!(r instanceof katex__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ParseError||r instanceof TypeError))throw r;v(f?{errorElement:f(r)}:{innerHtml:r.message})}},[s,p,c,f,m]),\"errorElement\"in E?E.errorElement:react__WEBPACK_IMPORTED_MODULE_0___default().createElement(d,Object.assign({},h,{dangerouslySetInnerHTML:{__html:E.innerHtml}}))});/* harmony default export */ __webpack_exports__[\"default\"] = (i);\n//# sourceMappingURL=react-katex.m.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWF0ZWptYXp1ci9yZWFjdC1rYXRleC9kaXN0L3JlYWN0LWthdGV4Lm0uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFrRixhQUFhLG9DQUFvQyxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixzRUFBc0UsU0FBUyx3QkFBd0IsTUFBTSwyQ0FBQyxhQUFhLHVHQUF1RyxvQkFBb0IsWUFBWSxrQkFBa0IsUUFBUSxXQUFXLHNDQUFzQyxTQUFTLGlIQUFpSCwrQ0FBQyxFQUFFLGFBQWEsZ0JBQWdCLE9BQU8sZ0RBQUMsWUFBWSxJQUFJLE1BQU0sNkNBQUMscUJBQXFCLDhDQUE4QyxLQUFLLEdBQUcsWUFBWSxFQUFFLFNBQVMsa0JBQWtCLDZDQUFDLDZDQUE2QyxLQUFLLGtCQUFrQixFQUFFLG9CQUFvQixHQUFHLGdEQUFnRCwwREFBZSxtQkFBbUIsSUFBSSx5QkFBeUIsb0JBQW9CLEdBQUcsRUFBRSwrREFBZSxDQUFDLEVBQUM7QUFDM2lDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbWF0ZWptYXp1ci9yZWFjdC1rYXRleC9kaXN0L3JlYWN0LWthdGV4Lm0uanM/OWMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcix7bWVtbyBhcyBlLHVzZVN0YXRlIGFzIG4sdXNlRWZmZWN0IGFzIHR9ZnJvbVwicmVhY3RcIjtpbXBvcnQgbyBmcm9tXCJrYXRleFwiO2Z1bmN0aW9uIGEoKXtyZXR1cm4oYT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihyKXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07Zm9yKHZhciB0IGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCkmJihyW3RdPW5bdF0pfXJldHVybiByfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBpPWUoZnVuY3Rpb24oZSl7dmFyIGk9ZS5jaGlsZHJlbixsPWUubWF0aCxzPWUuYmxvY2ssYz1lLmVycm9yQ29sb3IsZj1lLnJlbmRlckVycm9yLG09ZS5zZXR0aW5ncyx1PWUuYXMsaD1mdW5jdGlvbihyLGUpe2lmKG51bGw9PXIpcmV0dXJue307dmFyIG4sdCxvPXt9LGE9T2JqZWN0LmtleXMocik7Zm9yKHQ9MDt0PGEubGVuZ3RoO3QrKyllLmluZGV4T2Yobj1hW3RdKT49MHx8KG9bbl09cltuXSk7cmV0dXJuIG99KGUsW1wiY2hpbGRyZW5cIixcIm1hdGhcIixcImJsb2NrXCIsXCJlcnJvckNvbG9yXCIsXCJyZW5kZXJFcnJvclwiLFwic2V0dGluZ3NcIixcImFzXCJdKSxkPXV8fChzP1wiZGl2XCI6XCJzcGFuXCIpLHA9bnVsbCE9aT9pOmwsZz1uKHtpbm5lckh0bWw6XCJcIn0pLEU9Z1swXSx2PWdbMV07cmV0dXJuIHQoZnVuY3Rpb24oKXt0cnl7dmFyIHI9by5yZW5kZXJUb1N0cmluZyhwLGEoe2Rpc3BsYXlNb2RlOiEhcyxlcnJvckNvbG9yOmMsdGhyb3dPbkVycm9yOiEhZn0sbSkpO3Yoe2lubmVySHRtbDpyfSl9Y2F0Y2gocil7aWYoIShyIGluc3RhbmNlb2Ygby5QYXJzZUVycm9yfHxyIGluc3RhbmNlb2YgVHlwZUVycm9yKSl0aHJvdyByO3YoZj97ZXJyb3JFbGVtZW50OmYocil9Ontpbm5lckh0bWw6ci5tZXNzYWdlfSl9fSxbcyxwLGMsZixtXSksXCJlcnJvckVsZW1lbnRcImluIEU/RS5lcnJvckVsZW1lbnQ6ci5jcmVhdGVFbGVtZW50KGQsT2JqZWN0LmFzc2lnbih7fSxoLHtkYW5nZXJvdXNseVNldElubmVySFRNTDp7X19odG1sOkUuaW5uZXJIdG1sfX0pKX0pO2V4cG9ydCBkZWZhdWx0IGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1rYXRleC5tLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@matejmazur/react-katex/dist/react-katex.m.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/katex/dist/katex.mjs":
/*!*******************************************!*\
  !*** ./node_modules/katex/dist/katex.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ katex; }\n/* harmony export */ });\n/**\n * Lexing or parsing positional information for error reporting.\n * This object is immutable.\n */\nclass SourceLocation {\n  // The + prefix indicates that these fields aren't writeable\n  // Lexer holding the input string.\n  // Start offset, zero-based inclusive.\n  // End offset, zero-based exclusive.\n  constructor(lexer, start, end) {\n    this.lexer = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.lexer = lexer;\n    this.start = start;\n    this.end = end;\n  }\n  /**\n   * Merges two `SourceLocation`s from location providers, given they are\n   * provided in order of appearance.\n   * - Returns the first one's location if only the first is provided.\n   * - Returns a merged range of the first and the last if both are provided\n   *   and their lexers match.\n   * - Otherwise, returns null.\n   */\n\n\n  static range(first, second) {\n    if (!second) {\n      return first && first.loc;\n    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {\n      return null;\n    } else {\n      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);\n    }\n  }\n\n}\n\n/**\n * Interface required to break circular dependency between Token, Lexer, and\n * ParseError.\n */\n\n/**\n * The resulting token returned from `lex`.\n *\n * It consists of the token text plus some position information.\n * The position information is essentially a range in an input string,\n * but instead of referencing the bare input string, we refer to the lexer.\n * That way it is possible to attach extra metadata to the input string,\n * like for example a file name or similar.\n *\n * The position information is optional, so it is OK to construct synthetic\n * tokens if appropriate. Not providing available position information may\n * lead to degraded error reporting, though.\n */\nclass Token {\n  // don't expand the token\n  // used in \\noexpand\n  constructor(text, // the text of this token\n  loc) {\n    this.text = void 0;\n    this.loc = void 0;\n    this.noexpand = void 0;\n    this.treatAsRelax = void 0;\n    this.text = text;\n    this.loc = loc;\n  }\n  /**\n   * Given a pair of tokens (this and endToken), compute a `Token` encompassing\n   * the whole input range enclosed by these two.\n   */\n\n\n  range(endToken, // last token of the range, inclusive\n  text // the text of the newly constructed token\n  ) {\n    return new Token(text, SourceLocation.range(this, endToken));\n  }\n\n}\n\n/**\n * This is the ParseError class, which is the main error thrown by KaTeX\n * functions when something has gone wrong. This is used to distinguish internal\n * errors from errors in the expression that the user provided.\n *\n * If possible, a caller should provide a Token or ParseNode with information\n * about where in the source string the problem occurred.\n */\nclass ParseError {\n  // Error position based on passed-in Token or ParseNode.\n  constructor(message, // The error message\n  token // An object providing position information\n  ) {\n    this.position = void 0;\n    var error = \"KaTeX parse error: \" + message;\n    var start;\n    var loc = token && token.loc;\n\n    if (loc && loc.start <= loc.end) {\n      // If we have the input and a position, make the error a bit fancier\n      // Get the input\n      var input = loc.lexer.input; // Prepend some information\n\n      start = loc.start;\n      var end = loc.end;\n\n      if (start === input.length) {\n        error += \" at end of input: \";\n      } else {\n        error += \" at position \" + (start + 1) + \": \";\n      } // Underline token in question using combining underscores\n\n\n      var underlined = input.slice(start, end).replace(/[^]/g, \"$&\\u0332\"); // Extract some context from the input and add it to the error\n\n      var left;\n\n      if (start > 15) {\n        left = \"…\" + input.slice(start - 15, start);\n      } else {\n        left = input.slice(0, start);\n      }\n\n      var right;\n\n      if (end + 15 < input.length) {\n        right = input.slice(end, end + 15) + \"…\";\n      } else {\n        right = input.slice(end);\n      }\n\n      error += left + underlined + right;\n    } // Some hackery to make ParseError a prototype of Error\n    // See http://stackoverflow.com/a/8460753\n\n\n    var self = new Error(error);\n    self.name = \"ParseError\"; // $FlowFixMe\n\n    self.__proto__ = ParseError.prototype; // $FlowFixMe\n\n    self.position = start;\n    return self;\n  }\n\n} // $FlowFixMe More hackery\n\n\nParseError.prototype.__proto__ = Error.prototype;\n\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\n/**\n * Return whether an element is contained in a list\n */\nvar contains = function contains(list, elem) {\n  return list.indexOf(elem) !== -1;\n};\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\n\n\nvar deflt = function deflt(setting, defaultIfUndefined) {\n  return setting === undefined ? defaultIfUndefined : setting;\n}; // hyphenate and escape adapted from Facebook's React under Apache 2 license\n\n\nvar uppercase = /([A-Z])/g;\n\nvar hyphenate = function hyphenate(str) {\n  return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nvar ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\nvar ESCAPE_REGEX = /[&><\"']/g;\n/**\n * Escapes text to prevent scripting attacks.\n */\n\nfunction escape(text) {\n  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\n\n\nvar getBaseElem = function getBaseElem(group) {\n  if (group.type === \"ordgroup\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"font\") {\n    return getBaseElem(group.body);\n  } else {\n    return group;\n  }\n};\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\n\n\nvar isCharacterBox = function isCharacterBox(group) {\n  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters\n\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"atom\";\n};\n\nvar assert = function assert(value) {\n  if (!value) {\n    throw new Error('Expected non-null, but got ' + String(value));\n  }\n\n  return value;\n};\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative).\n */\n\nvar protocolFromUrl = function protocolFromUrl(url) {\n  var protocol = /^\\s*([^\\\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);\n  return protocol != null ? protocol[1] : \"_relative\";\n};\nvar utils = {\n  contains,\n  deflt,\n  escape,\n  hyphenate,\n  getBaseElem,\n  isCharacterBox,\n  protocolFromUrl\n};\n\n/* eslint no-console:0 */\n// TODO: automatically generate documentation\n// TODO: check all properties on Settings exist\n// TODO: check the type of a property on Settings matches\nvar SETTINGS_SCHEMA = {\n  displayMode: {\n    type: \"boolean\",\n    description: \"Render math in display mode, which puts the math in \" + \"display style (so \\\\int and \\\\sum are large, for example), and \" + \"centers the math on the page on its own line.\",\n    cli: \"-d, --display-mode\"\n  },\n  output: {\n    type: {\n      enum: [\"htmlAndMathml\", \"html\", \"mathml\"]\n    },\n    description: \"Determines the markup language of the output.\",\n    cli: \"-F, --format <type>\"\n  },\n  leqno: {\n    type: \"boolean\",\n    description: \"Render display math in leqno style (left-justified tags).\"\n  },\n  fleqn: {\n    type: \"boolean\",\n    description: \"Render display math flush left.\"\n  },\n  throwOnError: {\n    type: \"boolean\",\n    default: true,\n    cli: \"-t, --no-throw-on-error\",\n    cliDescription: \"Render errors (in the color given by --error-color) ins\" + \"tead of throwing a ParseError exception when encountering an error.\"\n  },\n  errorColor: {\n    type: \"string\",\n    default: \"#cc0000\",\n    cli: \"-c, --error-color <color>\",\n    cliDescription: \"A color string given in the format 'rgb' or 'rrggbb' \" + \"(no #). This option determines the color of errors rendered by the \" + \"-t option.\",\n    cliProcessor: color => \"#\" + color\n  },\n  macros: {\n    type: \"object\",\n    cli: \"-m, --macro <def>\",\n    cliDescription: \"Define custom macro of the form '\\\\foo:expansion' (use \" + \"multiple -m arguments for multiple macros).\",\n    cliDefault: [],\n    cliProcessor: (def, defs) => {\n      defs.push(def);\n      return defs;\n    }\n  },\n  minRuleThickness: {\n    type: \"number\",\n    description: \"Specifies a minimum thickness, in ems, for fraction lines,\" + \" `\\\\sqrt` top lines, `{array}` vertical lines, `\\\\hline`, \" + \"`\\\\hdashline`, `\\\\underline`, `\\\\overline`, and the borders of \" + \"`\\\\fbox`, `\\\\boxed`, and `\\\\fcolorbox`.\",\n    processor: t => Math.max(0, t),\n    cli: \"--min-rule-thickness <size>\",\n    cliProcessor: parseFloat\n  },\n  colorIsTextColor: {\n    type: \"boolean\",\n    description: \"Makes \\\\color behave like LaTeX's 2-argument \\\\textcolor, \" + \"instead of LaTeX's one-argument \\\\color mode change.\",\n    cli: \"-b, --color-is-text-color\"\n  },\n  strict: {\n    type: [{\n      enum: [\"warn\", \"ignore\", \"error\"]\n    }, \"boolean\", \"function\"],\n    description: \"Turn on strict / LaTeX faithfulness mode, which throws an \" + \"error if the input uses features that are not supported by LaTeX.\",\n    cli: \"-S, --strict\",\n    cliDefault: false\n  },\n  trust: {\n    type: [\"boolean\", \"function\"],\n    description: \"Trust the input, enabling all HTML features such as \\\\url.\",\n    cli: \"-T, --trust\"\n  },\n  maxSize: {\n    type: \"number\",\n    default: Infinity,\n    description: \"If non-zero, all user-specified sizes, e.g. in \" + \"\\\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, \" + \"elements and spaces can be arbitrarily large\",\n    processor: s => Math.max(0, s),\n    cli: \"-s, --max-size <n>\",\n    cliProcessor: parseInt\n  },\n  maxExpand: {\n    type: \"number\",\n    default: 1000,\n    description: \"Limit the number of macro expansions to the specified \" + \"number, to prevent e.g. infinite macro loops. If set to Infinity, \" + \"the macro expander will try to fully expand as in LaTeX.\",\n    processor: n => Math.max(0, n),\n    cli: \"-e, --max-expand <n>\",\n    cliProcessor: n => n === \"Infinity\" ? Infinity : parseInt(n)\n  },\n  globalGroup: {\n    type: \"boolean\",\n    cli: false\n  }\n};\n\nfunction getDefaultValue(schema) {\n  if (schema.default) {\n    return schema.default;\n  }\n\n  var type = schema.type;\n  var defaultType = Array.isArray(type) ? type[0] : type;\n\n  if (typeof defaultType !== 'string') {\n    return defaultType.enum[0];\n  }\n\n  switch (defaultType) {\n    case 'boolean':\n      return false;\n\n    case 'string':\n      return '';\n\n    case 'number':\n      return 0;\n\n    case 'object':\n      return {};\n  }\n}\n/**\n * The main Settings object\n *\n * The current options stored are:\n *  - displayMode: Whether the expression should be typeset as inline math\n *                 (false, the default), meaning that the math starts in\n *                 \\textstyle and is placed in an inline-block); or as display\n *                 math (true), meaning that the math starts in \\displaystyle\n *                 and is placed in a block with vertical margin.\n */\n\n\nclass Settings {\n  constructor(options) {\n    this.displayMode = void 0;\n    this.output = void 0;\n    this.leqno = void 0;\n    this.fleqn = void 0;\n    this.throwOnError = void 0;\n    this.errorColor = void 0;\n    this.macros = void 0;\n    this.minRuleThickness = void 0;\n    this.colorIsTextColor = void 0;\n    this.strict = void 0;\n    this.trust = void 0;\n    this.maxSize = void 0;\n    this.maxExpand = void 0;\n    this.globalGroup = void 0;\n    // allow null options\n    options = options || {};\n\n    for (var prop in SETTINGS_SCHEMA) {\n      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {\n        // $FlowFixMe\n        var schema = SETTINGS_SCHEMA[prop]; // TODO: validate options\n        // $FlowFixMe\n\n        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);\n      }\n    }\n  }\n  /**\n   * Report nonstrict (non-LaTeX-compatible) input.\n   * Can safely not be called if `this.strict` is false in JavaScript.\n   */\n\n\n  reportNonstrict(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      strict = strict(errorCode, errorMsg, token);\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return;\n    } else if (strict === true || strict === \"error\") {\n      throw new ParseError(\"LaTeX-incompatible input and strict mode is set to 'error': \" + (errorMsg + \" [\" + errorCode + \"]\"), token);\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n    }\n  }\n  /**\n   * Check whether to apply strict (LaTeX-adhering) behavior for unusual\n   * input (like `\\\\`).  Unlike `nonstrict`, will not throw an error;\n   * instead, \"error\" translates to a return value of `true`, while \"ignore\"\n   * translates to a return value of `false`.  May still print a warning:\n   * \"warn\" prints a warning and returns `false`.\n   * This is for the second category of `errorCode`s listed in the README.\n   */\n\n\n  useStrictBehavior(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      // But catch any exceptions thrown by function, treating them\n      // like \"error\".\n      try {\n        strict = strict(errorCode, errorMsg, token);\n      } catch (error) {\n        strict = \"error\";\n      }\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return false;\n    } else if (strict === true || strict === \"error\") {\n      return true;\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    }\n  }\n  /**\n   * Check whether to test potentially dangerous input, and return\n   * `true` (trusted) or `false` (untrusted).  The sole argument `context`\n   * should be an object with `command` field specifying the relevant LaTeX\n   * command (as a string starting with `\\`), and any other arguments, etc.\n   * If `context` has a `url` field, a `protocol` field will automatically\n   * get added by this function (changing the specified object).\n   */\n\n\n  isTrusted(context) {\n    if (context.url && !context.protocol) {\n      context.protocol = utils.protocolFromUrl(context.url);\n    }\n\n    var trust = typeof this.trust === \"function\" ? this.trust(context) : this.trust;\n    return Boolean(trust);\n  }\n\n}\n\n/**\n * This file contains information and classes for the various kinds of styles\n * used in TeX. It provides a generic `Style` class, which holds information\n * about a specific style. It then provides instances of all the different kinds\n * of styles possible, and provides functions to move between them and get\n * information about them.\n */\n\n/**\n * The main style class. Contains a unique id for the style, a size (which is\n * the same for cramped and uncramped version of a style), and a cramped flag.\n */\nclass Style {\n  constructor(id, size, cramped) {\n    this.id = void 0;\n    this.size = void 0;\n    this.cramped = void 0;\n    this.id = id;\n    this.size = size;\n    this.cramped = cramped;\n  }\n  /**\n   * Get the style of a superscript given a base in the current style.\n   */\n\n\n  sup() {\n    return styles[sup[this.id]];\n  }\n  /**\n   * Get the style of a subscript given a base in the current style.\n   */\n\n\n  sub() {\n    return styles[sub[this.id]];\n  }\n  /**\n   * Get the style of a fraction numerator given the fraction in the current\n   * style.\n   */\n\n\n  fracNum() {\n    return styles[fracNum[this.id]];\n  }\n  /**\n   * Get the style of a fraction denominator given the fraction in the current\n   * style.\n   */\n\n\n  fracDen() {\n    return styles[fracDen[this.id]];\n  }\n  /**\n   * Get the cramped version of a style (in particular, cramping a cramped style\n   * doesn't change the style).\n   */\n\n\n  cramp() {\n    return styles[cramp[this.id]];\n  }\n  /**\n   * Get a text or display version of this style.\n   */\n\n\n  text() {\n    return styles[text$1[this.id]];\n  }\n  /**\n   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)\n   */\n\n\n  isTight() {\n    return this.size >= 2;\n  }\n\n} // Export an interface for type checking, but don't expose the implementation.\n// This way, no more styles can be generated.\n\n\n// IDs of the different styles\nvar D = 0;\nvar Dc = 1;\nvar T = 2;\nvar Tc = 3;\nvar S = 4;\nvar Sc = 5;\nvar SS = 6;\nvar SSc = 7; // Instances of the different styles\n\nvar styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another\n\nvar sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];\nvar sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];\nvar fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];\nvar text$1 = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.\n\nvar Style$1 = {\n  DISPLAY: styles[D],\n  TEXT: styles[T],\n  SCRIPT: styles[S],\n  SCRIPTSCRIPT: styles[SS]\n};\n\n/*\n * This file defines the Unicode scripts and script families that we\n * support. To add new scripts or families, just add a new entry to the\n * scriptData array below. Adding scripts to the scriptData array allows\n * characters from that script to appear in \\text{} environments.\n */\n\n/**\n * Each script or script family has a name and an array of blocks.\n * Each block is an array of two numbers which specify the start and\n * end points (inclusive) of a block of Unicode codepoints.\n */\n\n/**\n * Unicode block data for the families of scripts we support in \\text{}.\n * Scripts only need to appear here if they do not have font metrics.\n */\nvar scriptData = [{\n  // Latin characters beyond the Latin-1 characters we have metrics for.\n  // Needed for Czech, Hungarian and Turkish text, for example.\n  name: 'latin',\n  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B\n  [0x0300, 0x036f] // Combining Diacritical marks\n  ]\n}, {\n  // The Cyrillic script used by Russian and related languages.\n  // A Cyrillic subset used to be supported as explicitly defined\n  // symbols in symbols.js\n  name: 'cyrillic',\n  blocks: [[0x0400, 0x04ff]]\n}, {\n  // Armenian\n  name: 'armenian',\n  blocks: [[0x0530, 0x058F]]\n}, {\n  // The Brahmic scripts of South and Southeast Asia\n  // Devanagari (0900–097F)\n  // Bengali (0980–09FF)\n  // Gurmukhi (0A00–0A7F)\n  // Gujarati (0A80–0AFF)\n  // Oriya (0B00–0B7F)\n  // Tamil (0B80–0BFF)\n  // Telugu (0C00–0C7F)\n  // Kannada (0C80–0CFF)\n  // Malayalam (0D00–0D7F)\n  // Sinhala (0D80–0DFF)\n  // Thai (0E00–0E7F)\n  // Lao (0E80–0EFF)\n  // Tibetan (0F00–0FFF)\n  // Myanmar (1000–109F)\n  name: 'brahmic',\n  blocks: [[0x0900, 0x109F]]\n}, {\n  name: 'georgian',\n  blocks: [[0x10A0, 0x10ff]]\n}, {\n  // Chinese and Japanese.\n  // The \"k\" in cjk is for Korean, but we've separated Korean out\n  name: \"cjk\",\n  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana\n  [0x4E00, 0x9FAF], // CJK ideograms\n  [0xFF00, 0xFF60] // Fullwidth punctuation\n  // TODO: add halfwidth Katakana and Romanji glyphs\n  ]\n}, {\n  // Korean\n  name: 'hangul',\n  blocks: [[0xAC00, 0xD7AF]]\n}];\n/**\n * Given a codepoint, return the name of the script or script family\n * it is from, or null if it is not part of a known block\n */\n\nfunction scriptFromCodepoint(codepoint) {\n  for (var i = 0; i < scriptData.length; i++) {\n    var script = scriptData[i];\n\n    for (var _i = 0; _i < script.blocks.length; _i++) {\n      var block = script.blocks[_i];\n\n      if (codepoint >= block[0] && codepoint <= block[1]) {\n        return script.name;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * A flattened version of all the supported blocks in a single array.\n * This is an optimization to make supportedCodepoint() fast.\n */\n\nvar allBlocks = [];\nscriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));\n/**\n * Given a codepoint, return true if it falls within one of the\n * scripts or script families defined above and false otherwise.\n *\n * Micro benchmarks shows that this is faster than\n * /[\\u3000-\\u30FF\\u4E00-\\u9FAF\\uFF00-\\uFF60\\uAC00-\\uD7AF\\u0900-\\u109F]/.test()\n * in Firefox, Chrome and Node.\n */\n\nfunction supportedCodepoint(codepoint) {\n  for (var i = 0; i < allBlocks.length; i += 2) {\n    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * This file provides support to domTree.js and delimiter.js.\n * It's a storehouse of path geometry for SVG images.\n */\n// In all paths below, the viewBox-to-em scale is 1000:1.\nvar hLinePad = 80; // padding above a sqrt viniculum. Prevents image cropping.\n// The viniculum of a \\sqrt can be made thicker by a KaTeX rendering option.\n// Think of variable extraViniculum as two detours in the SVG path.\n// The detour begins at the lower left of the area labeled extraViniculum below.\n// The detour proceeds one extraViniculum distance up and slightly to the right,\n// displacing the radiused corner between surd and viniculum. The radius is\n// traversed as usual, then the detour resumes. It goes right, to the end of\n// the very long viniculumn, then down one extraViniculum distance,\n// after which it resumes regular path geometry for the radical.\n\n/*                                                  viniculum\n                                                   /\n         /▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒←extraViniculum\n        / █████████████████████←0.04em (40 unit) std viniculum thickness\n       / /\n      / /\n     / /\\\n    / / surd\n*/\n\nvar sqrtMain = function sqrtMain(extraViniculum, hLinePad) {\n  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main\n  return \"M95,\" + (622 + extraViniculum + hLinePad) + \"\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl\" + extraViniculum / 2.075 + \" -\" + extraViniculum + \"\\nc5.3,-9.3,12,-14,20,-14\\nH400000v\" + (40 + extraViniculum) + \"H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM\" + (834 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize1 = function sqrtSize1(extraViniculum, hLinePad) {\n  // size1 is from glyph U221A in the font KaTeX_Size1-Regular\n  return \"M263,\" + (601 + extraViniculum + hLinePad) + \"c0.7,0,18,39.7,52,119\\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\\nc340,-704.7,510.7,-1060.3,512,-1067\\nl\" + extraViniculum / 2.084 + \" -\" + extraViniculum + \"\\nc4.7,-7.3,11,-11,19,-11\\nH40000v\" + (40 + extraViniculum) + \"H1012.3\\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\\nM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize2 = function sqrtSize2(extraViniculum, hLinePad) {\n  // size2 is from glyph U221A in the font KaTeX_Size2-Regular\n  return \"M983 \" + (10 + extraViniculum + hLinePad) + \"\\nl\" + extraViniculum / 3.13 + \" -\" + extraViniculum + \"\\nc4,-6.7,10,-10,18,-10 H400000v\" + (40 + extraViniculum) + \"\\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\\nM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize3 = function sqrtSize3(extraViniculum, hLinePad) {\n  // size3 is from glyph U221A in the font KaTeX_Size3-Regular\n  return \"M424,\" + (2398 + extraViniculum + hLinePad) + \"\\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\\nl\" + extraViniculum / 4.223 + \" -\" + extraViniculum + \"c4,-6.7,10,-10,18,-10 H400000\\nv\" + (40 + extraViniculum) + \"H1014.6\\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\\nc-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2z M\" + (1001 + extraViniculum) + \" \" + hLinePad + \"\\nh400000v\" + (40 + extraViniculum) + \"h-400000z\";\n};\n\nvar sqrtSize4 = function sqrtSize4(extraViniculum, hLinePad) {\n  // size4 is from glyph U221A in the font KaTeX_Size4-Regular\n  return \"M473,\" + (2713 + extraViniculum + hLinePad) + \"\\nc339.3,-1799.3,509.3,-2700,510,-2702 l\" + extraViniculum / 5.298 + \" -\" + extraViniculum + \"\\nc3.3,-7.3,9.3,-11,18,-11 H400000v\" + (40 + extraViniculum) + \"H1017.7\\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\\n606zM\" + (1001 + extraViniculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraViniculum) + \"H1017.7z\";\n};\n\nvar phasePath = function phasePath(y) {\n  var x = y / 2; // x coordinate at top of angle\n\n  return \"M400000 \" + y + \" H0 L\" + x + \" 0 l65 45 L145 \" + (y - 80) + \" H400000z\";\n};\n\nvar sqrtTall = function sqrtTall(extraViniculum, hLinePad, viewBoxHeight) {\n  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular\n  // One path edge has a variable length. It runs vertically from the viniculumn\n  // to a point near (14 units) the bottom of the surd. The viniculum\n  // is normally 40 units thick. So the length of the line in question is:\n  var vertSegment = viewBoxHeight - 54 - hLinePad - extraViniculum;\n  return \"M702 \" + (extraViniculum + hLinePad) + \"H400000\" + (40 + extraViniculum) + \"\\nH742v\" + vertSegment + \"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\\n219 661 l218 661zM702 \" + hLinePad + \"H400000v\" + (40 + extraViniculum) + \"H742z\";\n};\n\nvar sqrtPath = function sqrtPath(size, extraViniculum, viewBoxHeight) {\n  extraViniculum = 1000 * extraViniculum; // Convert from document ems to viewBox.\n\n  var path = \"\";\n\n  switch (size) {\n    case \"sqrtMain\":\n      path = sqrtMain(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize1\":\n      path = sqrtSize1(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize2\":\n      path = sqrtSize2(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize3\":\n      path = sqrtSize3(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtSize4\":\n      path = sqrtSize4(extraViniculum, hLinePad);\n      break;\n\n    case \"sqrtTall\":\n      path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);\n  }\n\n  return path;\n};\nvar innerPath = function innerPath(name, height) {\n  // The inner part of stretchy tall delimiters\n  switch (name) {\n    case \"\\u239c\":\n      return \"M291 0 H417 V\" + height + \" H291z M291 0 H417 V\" + height + \" H291z\";\n\n    case \"\\u2223\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\";\n\n    case \"\\u2225\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\" + (\"M367 0 H410 V\" + height + \" H367z M367 0 H410 V\" + height + \" H367z\");\n\n    case \"\\u239f\":\n      return \"M457 0 H583 V\" + height + \" H457z M457 0 H583 V\" + height + \" H457z\";\n\n    case \"\\u23a2\":\n      return \"M319 0 H403 V\" + height + \" H319z M319 0 H403 V\" + height + \" H319z\";\n\n    case \"\\u23a5\":\n      return \"M263 0 H347 V\" + height + \" H263z M263 0 H347 V\" + height + \" H263z\";\n\n    case \"\\u23aa\":\n      return \"M384 0 H504 V\" + height + \" H384z M384 0 H504 V\" + height + \" H384z\";\n\n    case \"\\u23d0\":\n      return \"M312 0 H355 V\" + height + \" H312z M312 0 H355 V\" + height + \" H312z\";\n\n    case \"\\u2016\":\n      return \"M257 0 H300 V\" + height + \" H257z M257 0 H300 V\" + height + \" H257z\" + (\"M478 0 H521 V\" + height + \" H478z M478 0 H521 V\" + height + \" H478z\");\n\n    default:\n      return \"\";\n  }\n};\nvar path = {\n  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main\n  doubleleftarrow: \"M262 157\\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\\nm8 0v40h399730v-40zm0 194v40h399730v-40z\",\n  // doublerightarrow is from glyph U+21D2 in font KaTeX Main\n  doublerightarrow: \"M399738 392l\\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z\",\n  // leftarrow is from glyph U+2190 in font KaTeX Main\n  leftarrow: \"M400000 241H110l3-3c68.7-52.7 113.7-120\\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\\n l-3-3h399890zM100 241v40h399900v-40z\",\n  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular\n  leftbrace: \"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z\",\n  leftbraceunder: \"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\",\n  // overgroup is from the MnSymbol package (public domain)\n  leftgroup: \"M400000 80\\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\\n 435 0h399565z\",\n  leftgroupunder: \"M400000 262\\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\\n 435 219h399565z\",\n  // Harpoons are from glyph U+21BD in font KaTeX Main\n  leftharpoon: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z\",\n  leftharpoonplus: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\\nm0 0v40h400000v-40z\",\n  leftharpoondown: \"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z\",\n  leftharpoondownplus: \"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z\",\n  // hook is from glyph U+21A9 in font KaTeX Main\n  lefthook: \"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\\n 71.5 23h399859zM103 281v-40h399897v40z\",\n  leftlinesegment: \"M40 281 V428 H0 V94 H40 V241 H400000 v40z\\nM40 281 V428 H0 V94 H40 V241 H400000 v40z\",\n  leftmapsto: \"M40 281 V448H0V74H40V241H400000v40z\\nM40 281 V448H0V74H40V241H400000v40z\",\n  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular\n  leftToFrom: \"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z\",\n  longequal: \"M0 50 h400000 v40H0z m0 194h40000v40H0z\\nM0 50 h400000 v40H0z m0 194h40000v40H0z\",\n  midbrace: \"M200428 334\\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z\",\n  midbraceunder: \"M199572 214\\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\",\n  oiintSize1: \"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z\",\n  oiintSize2: \"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\\nc0 110 84 276 504 276s502.4-166 502.4-276z\",\n  oiiintSize1: \"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z\",\n  oiiintSize2: \"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z\",\n  rightarrow: \"M0 241v40h399891c-47.3 35.3-84 78-110 128\\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n 151.7 139 205zm0 0v40h399900v-40z\",\n  rightbrace: \"M400000 542l\\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z\",\n  rightbraceunder: \"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\",\n  rightgroup: \"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\\n 3-1 3-3v-38c-76-158-257-219-435-219H0z\",\n  rightgroupunder: \"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z\",\n  rightharpoon: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\\n 69.2 92 94.5zm0 0v40h399900v-40z\",\n  rightharpoonplus: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z\",\n  rightharpoondown: \"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z\",\n  rightharpoondownplus: \"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\\nm0-194v40h400000v-40zm0 0v40h400000v-40z\",\n  righthook: \"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z\",\n  rightlinesegment: \"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z\",\n  rightToFrom: \"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z\",\n  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular\n  twoheadleftarrow: \"M0 167c68 40\\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z\",\n  twoheadrightarrow: \"M400000 167\\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z\",\n  // tilde1 is a modified version of a glyph from the MnSymbol package\n  tilde1: \"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\\n-68.267.847-113-73.952-191-73.952z\",\n  // ditto tilde2, tilde3, & tilde4\n  tilde2: \"M344 55.266c-142 0-300.638 81.316-311.5 86.418\\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z\",\n  tilde3: \"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\\n -338 0-409-156.573-744-156.573z\",\n  tilde4: \"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\\n -175.236-744-175.236z\",\n  // vec is from glyph U+20D7 in font KaTeX Main\n  vec: \"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\\nc-16-25.333-24-45-24-59z\",\n  // widehat1 is a modified version of a glyph from the MnSymbol package\n  widehat1: \"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\",\n  // ditto widehat2, widehat3, & widehat4\n  widehat2: \"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat3: \"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat4: \"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  // widecheck paths are all inverted versions of widehat\n  widecheck1: \"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z\",\n  widecheck2: \"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck3: \"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck4: \"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  // The next ten paths support reaction arrows from the mhchem package.\n  // Arrows for \\ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX\n  // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main\n  baraboveleftarrow: \"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z\",\n  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main\n  rightarrowabovebar: \"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z\",\n  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.\n  // Ref from mhchem.sty: \\rlap{\\raisebox{-.22ex}{$\\kern0.5em\n  baraboveshortleftharpoon: \"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z\",\n  rightharpoonaboveshortbar: \"M0,241 l0,40c399126,0,399993,0,399993,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z\",\n  shortbaraboveleftharpoon: \"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z\",\n  shortrightharpoonabovebar: \"M53,241l0,40c398570,0,399437,0,399437,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z\"\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. It only contains\n * children and doesn't have any DOM node properties.\n */\nclass DocumentFragment {\n  // HtmlDomNode\n  // Never used; needed for satisfying interface.\n  constructor(children) {\n    this.children = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.children = children;\n    this.classes = [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /** Convert the fragment into a node. */\n\n\n  toNode() {\n    var frag = document.createDocumentFragment();\n\n    for (var i = 0; i < this.children.length; i++) {\n      frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n  }\n  /** Convert the fragment into HTML markup. */\n\n\n  toMarkup() {\n    var markup = \"\"; // Simply concatenate the markup for the children together.\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText. Applies to\n   * MathDomNode's only.\n   */\n\n\n  toText() {\n    // To avoid this, we would subclass documentFragment separately for\n    // MathML, but polyfills for subclassing is expensive per PR 1469.\n    // $FlowFixMe: Only works for ChildType = MathDomNode.\n    var toText = child => child.toText();\n\n    return this.children.map(toText).join(\"\");\n  }\n\n}\n\n// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.\nvar fontMetricsData = {\n  \"AMS-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68889, 0, 0, 0.72222],\n    \"66\": [0, 0.68889, 0, 0, 0.66667],\n    \"67\": [0, 0.68889, 0, 0, 0.72222],\n    \"68\": [0, 0.68889, 0, 0, 0.72222],\n    \"69\": [0, 0.68889, 0, 0, 0.66667],\n    \"70\": [0, 0.68889, 0, 0, 0.61111],\n    \"71\": [0, 0.68889, 0, 0, 0.77778],\n    \"72\": [0, 0.68889, 0, 0, 0.77778],\n    \"73\": [0, 0.68889, 0, 0, 0.38889],\n    \"74\": [0.16667, 0.68889, 0, 0, 0.5],\n    \"75\": [0, 0.68889, 0, 0, 0.77778],\n    \"76\": [0, 0.68889, 0, 0, 0.66667],\n    \"77\": [0, 0.68889, 0, 0, 0.94445],\n    \"78\": [0, 0.68889, 0, 0, 0.72222],\n    \"79\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"80\": [0, 0.68889, 0, 0, 0.61111],\n    \"81\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"82\": [0, 0.68889, 0, 0, 0.72222],\n    \"83\": [0, 0.68889, 0, 0, 0.55556],\n    \"84\": [0, 0.68889, 0, 0, 0.66667],\n    \"85\": [0, 0.68889, 0, 0, 0.72222],\n    \"86\": [0, 0.68889, 0, 0, 0.72222],\n    \"87\": [0, 0.68889, 0, 0, 1.0],\n    \"88\": [0, 0.68889, 0, 0, 0.72222],\n    \"89\": [0, 0.68889, 0, 0, 0.72222],\n    \"90\": [0, 0.68889, 0, 0, 0.66667],\n    \"107\": [0, 0.68889, 0, 0, 0.55556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"165\": [0, 0.675, 0.025, 0, 0.75],\n    \"174\": [0.15559, 0.69224, 0, 0, 0.94666],\n    \"240\": [0, 0.68889, 0, 0, 0.55556],\n    \"295\": [0, 0.68889, 0, 0, 0.54028],\n    \"710\": [0, 0.825, 0, 0, 2.33334],\n    \"732\": [0, 0.9, 0, 0, 2.33334],\n    \"770\": [0, 0.825, 0, 0, 2.33334],\n    \"771\": [0, 0.9, 0, 0, 2.33334],\n    \"989\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"1008\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"8245\": [0, 0.54986, 0, 0, 0.275],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8487\": [0, 0.68889, 0, 0, 0.72222],\n    \"8498\": [0, 0.68889, 0, 0, 0.55556],\n    \"8502\": [0, 0.68889, 0, 0, 0.66667],\n    \"8503\": [0, 0.68889, 0, 0, 0.44445],\n    \"8504\": [0, 0.68889, 0, 0, 0.66667],\n    \"8513\": [0, 0.68889, 0, 0, 0.63889],\n    \"8592\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8594\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8602\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8603\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8606\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8608\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8610\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8611\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8619\": [0, 0.54986, 0, 0, 1.0],\n    \"8620\": [0, 0.54986, 0, 0, 1.0],\n    \"8621\": [-0.13313, 0.37788, 0, 0, 1.38889],\n    \"8622\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8624\": [0, 0.69224, 0, 0, 0.5],\n    \"8625\": [0, 0.69224, 0, 0, 0.5],\n    \"8630\": [0, 0.43056, 0, 0, 1.0],\n    \"8631\": [0, 0.43056, 0, 0, 1.0],\n    \"8634\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8635\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8638\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8639\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8642\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8643\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8644\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8646\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8647\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8648\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8649\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8650\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8651\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8652\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8653\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8654\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8655\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8666\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8667\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8669\": [-0.13313, 0.37788, 0, 0, 1.0],\n    \"8672\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8674\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8705\": [0, 0.825, 0, 0, 0.5],\n    \"8708\": [0, 0.68889, 0, 0, 0.55556],\n    \"8709\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8717\": [0, 0.43056, 0, 0, 0.42917],\n    \"8722\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8724\": [0.08198, 0.69224, 0, 0, 0.77778],\n    \"8726\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8733\": [0, 0.69224, 0, 0, 0.77778],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8737\": [0, 0.69224, 0, 0, 0.72222],\n    \"8738\": [0.03517, 0.52239, 0, 0, 0.72222],\n    \"8739\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"8740\": [0.25142, 0.74111, 0, 0, 0.27778],\n    \"8741\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"8742\": [0.25142, 0.74111, 0, 0, 0.5],\n    \"8756\": [0, 0.69224, 0, 0, 0.66667],\n    \"8757\": [0, 0.69224, 0, 0, 0.66667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8765\": [-0.13313, 0.37788, 0, 0, 0.77778],\n    \"8769\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8770\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8774\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8778\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8782\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8783\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8785\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8786\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8787\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8790\": [0, 0.69224, 0, 0, 0.77778],\n    \"8791\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8796\": [0.08198, 0.91667, 0, 0, 0.77778],\n    \"8806\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8807\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8808\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8809\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8812\": [0.25583, 0.75583, 0, 0, 0.5],\n    \"8814\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8815\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8816\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8817\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8818\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8819\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8822\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8823\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8828\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8829\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8830\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8831\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8832\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8833\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8840\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8841\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8842\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8843\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8847\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8848\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8858\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8859\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8861\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8862\": [0, 0.675, 0, 0, 0.77778],\n    \"8863\": [0, 0.675, 0, 0, 0.77778],\n    \"8864\": [0, 0.675, 0, 0, 0.77778],\n    \"8865\": [0, 0.675, 0, 0, 0.77778],\n    \"8872\": [0, 0.69224, 0, 0, 0.61111],\n    \"8873\": [0, 0.69224, 0, 0, 0.72222],\n    \"8874\": [0, 0.69224, 0, 0, 0.88889],\n    \"8876\": [0, 0.68889, 0, 0, 0.61111],\n    \"8877\": [0, 0.68889, 0, 0, 0.61111],\n    \"8878\": [0, 0.68889, 0, 0, 0.72222],\n    \"8879\": [0, 0.68889, 0, 0, 0.72222],\n    \"8882\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8883\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8884\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8885\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8888\": [0, 0.54986, 0, 0, 1.11111],\n    \"8890\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"8891\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8892\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8901\": [0, 0.54986, 0, 0, 0.27778],\n    \"8903\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8905\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8906\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8907\": [0, 0.69224, 0, 0, 0.77778],\n    \"8908\": [0, 0.69224, 0, 0, 0.77778],\n    \"8909\": [-0.03598, 0.46402, 0, 0, 0.77778],\n    \"8910\": [0, 0.54986, 0, 0, 0.76042],\n    \"8911\": [0, 0.54986, 0, 0, 0.76042],\n    \"8912\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8913\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8914\": [0, 0.54986, 0, 0, 0.66667],\n    \"8915\": [0, 0.54986, 0, 0, 0.66667],\n    \"8916\": [0, 0.69224, 0, 0, 0.66667],\n    \"8918\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8919\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8920\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8921\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8922\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8923\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8926\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8927\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8928\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8929\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8934\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8935\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8936\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8937\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8938\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8939\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8940\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8941\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8994\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"8995\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"9416\": [0.15559, 0.69224, 0, 0, 0.90222],\n    \"9484\": [0, 0.69224, 0, 0, 0.5],\n    \"9488\": [0, 0.69224, 0, 0, 0.5],\n    \"9492\": [0, 0.37788, 0, 0, 0.5],\n    \"9496\": [0, 0.37788, 0, 0, 0.5],\n    \"9585\": [0.19444, 0.68889, 0, 0, 0.88889],\n    \"9586\": [0.19444, 0.74111, 0, 0, 0.88889],\n    \"9632\": [0, 0.675, 0, 0, 0.77778],\n    \"9633\": [0, 0.675, 0, 0, 0.77778],\n    \"9650\": [0, 0.54986, 0, 0, 0.72222],\n    \"9651\": [0, 0.54986, 0, 0, 0.72222],\n    \"9654\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9660\": [0, 0.54986, 0, 0, 0.72222],\n    \"9661\": [0, 0.54986, 0, 0, 0.72222],\n    \"9664\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9674\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"9733\": [0.19444, 0.69224, 0, 0, 0.94445],\n    \"10003\": [0, 0.69224, 0, 0, 0.83334],\n    \"10016\": [0, 0.69224, 0, 0, 0.83334],\n    \"10731\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"10846\": [0.19444, 0.75583, 0, 0, 0.61111],\n    \"10877\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10878\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10885\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10886\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10887\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10888\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10889\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10890\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10891\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10892\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10901\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10902\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10933\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10934\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10935\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10936\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10937\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10938\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10949\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10950\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10955\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"10956\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"57350\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"57351\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"57352\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"57353\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"57356\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57357\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57358\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57359\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57360\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57361\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57366\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57367\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57368\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57369\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57370\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57371\": [0.13597, 0.63597, 0, 0, 0.77778]\n  },\n  \"Caligraphic-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68333, 0, 0.19445, 0.79847],\n    \"66\": [0, 0.68333, 0.03041, 0.13889, 0.65681],\n    \"67\": [0, 0.68333, 0.05834, 0.13889, 0.52653],\n    \"68\": [0, 0.68333, 0.02778, 0.08334, 0.77139],\n    \"69\": [0, 0.68333, 0.08944, 0.11111, 0.52778],\n    \"70\": [0, 0.68333, 0.09931, 0.11111, 0.71875],\n    \"71\": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],\n    \"72\": [0, 0.68333, 0.00965, 0.11111, 0.84452],\n    \"73\": [0, 0.68333, 0.07382, 0, 0.54452],\n    \"74\": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],\n    \"75\": [0, 0.68333, 0.01445, 0.05556, 0.76195],\n    \"76\": [0, 0.68333, 0, 0.13889, 0.68972],\n    \"77\": [0, 0.68333, 0, 0.13889, 1.2009],\n    \"78\": [0, 0.68333, 0.14736, 0.08334, 0.82049],\n    \"79\": [0, 0.68333, 0.02778, 0.11111, 0.79611],\n    \"80\": [0, 0.68333, 0.08222, 0.08334, 0.69556],\n    \"81\": [0.09722, 0.68333, 0, 0.11111, 0.81667],\n    \"82\": [0, 0.68333, 0, 0.08334, 0.8475],\n    \"83\": [0, 0.68333, 0.075, 0.13889, 0.60556],\n    \"84\": [0, 0.68333, 0.25417, 0, 0.54464],\n    \"85\": [0, 0.68333, 0.09931, 0.08334, 0.62583],\n    \"86\": [0, 0.68333, 0.08222, 0, 0.61278],\n    \"87\": [0, 0.68333, 0.08222, 0.08334, 0.98778],\n    \"88\": [0, 0.68333, 0.14643, 0.13889, 0.7133],\n    \"89\": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],\n    \"90\": [0, 0.68333, 0.07944, 0.13889, 0.72473],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Fraktur-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69141, 0, 0, 0.29574],\n    \"34\": [0, 0.69141, 0, 0, 0.21471],\n    \"38\": [0, 0.69141, 0, 0, 0.73786],\n    \"39\": [0, 0.69141, 0, 0, 0.21201],\n    \"40\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"41\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"42\": [0, 0.62119, 0, 0, 0.27764],\n    \"43\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"44\": [0, 0.10803, 0, 0, 0.27764],\n    \"45\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"46\": [0, 0.10803, 0, 0, 0.27764],\n    \"47\": [0.24982, 0.74947, 0, 0, 0.50181],\n    \"48\": [0, 0.47534, 0, 0, 0.50181],\n    \"49\": [0, 0.47534, 0, 0, 0.50181],\n    \"50\": [0, 0.47534, 0, 0, 0.50181],\n    \"51\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"52\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"53\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"54\": [0, 0.69141, 0, 0, 0.50181],\n    \"55\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"56\": [0, 0.69141, 0, 0, 0.50181],\n    \"57\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"58\": [0, 0.47534, 0, 0, 0.21606],\n    \"59\": [0.12604, 0.47534, 0, 0, 0.21606],\n    \"61\": [-0.13099, 0.36866, 0, 0, 0.75623],\n    \"63\": [0, 0.69141, 0, 0, 0.36245],\n    \"65\": [0, 0.69141, 0, 0, 0.7176],\n    \"66\": [0, 0.69141, 0, 0, 0.88397],\n    \"67\": [0, 0.69141, 0, 0, 0.61254],\n    \"68\": [0, 0.69141, 0, 0, 0.83158],\n    \"69\": [0, 0.69141, 0, 0, 0.66278],\n    \"70\": [0.12604, 0.69141, 0, 0, 0.61119],\n    \"71\": [0, 0.69141, 0, 0, 0.78539],\n    \"72\": [0.06302, 0.69141, 0, 0, 0.7203],\n    \"73\": [0, 0.69141, 0, 0, 0.55448],\n    \"74\": [0.12604, 0.69141, 0, 0, 0.55231],\n    \"75\": [0, 0.69141, 0, 0, 0.66845],\n    \"76\": [0, 0.69141, 0, 0, 0.66602],\n    \"77\": [0, 0.69141, 0, 0, 1.04953],\n    \"78\": [0, 0.69141, 0, 0, 0.83212],\n    \"79\": [0, 0.69141, 0, 0, 0.82699],\n    \"80\": [0.18906, 0.69141, 0, 0, 0.82753],\n    \"81\": [0.03781, 0.69141, 0, 0, 0.82699],\n    \"82\": [0, 0.69141, 0, 0, 0.82807],\n    \"83\": [0, 0.69141, 0, 0, 0.82861],\n    \"84\": [0, 0.69141, 0, 0, 0.66899],\n    \"85\": [0, 0.69141, 0, 0, 0.64576],\n    \"86\": [0, 0.69141, 0, 0, 0.83131],\n    \"87\": [0, 0.69141, 0, 0, 1.04602],\n    \"88\": [0, 0.69141, 0, 0, 0.71922],\n    \"89\": [0.18906, 0.69141, 0, 0, 0.83293],\n    \"90\": [0.12604, 0.69141, 0, 0, 0.60201],\n    \"91\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"93\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"94\": [0, 0.69141, 0, 0, 0.49965],\n    \"97\": [0, 0.47534, 0, 0, 0.50046],\n    \"98\": [0, 0.69141, 0, 0, 0.51315],\n    \"99\": [0, 0.47534, 0, 0, 0.38946],\n    \"100\": [0, 0.62119, 0, 0, 0.49857],\n    \"101\": [0, 0.47534, 0, 0, 0.40053],\n    \"102\": [0.18906, 0.69141, 0, 0, 0.32626],\n    \"103\": [0.18906, 0.47534, 0, 0, 0.5037],\n    \"104\": [0.18906, 0.69141, 0, 0, 0.52126],\n    \"105\": [0, 0.69141, 0, 0, 0.27899],\n    \"106\": [0, 0.69141, 0, 0, 0.28088],\n    \"107\": [0, 0.69141, 0, 0, 0.38946],\n    \"108\": [0, 0.69141, 0, 0, 0.27953],\n    \"109\": [0, 0.47534, 0, 0, 0.76676],\n    \"110\": [0, 0.47534, 0, 0, 0.52666],\n    \"111\": [0, 0.47534, 0, 0, 0.48885],\n    \"112\": [0.18906, 0.52396, 0, 0, 0.50046],\n    \"113\": [0.18906, 0.47534, 0, 0, 0.48912],\n    \"114\": [0, 0.47534, 0, 0, 0.38919],\n    \"115\": [0, 0.47534, 0, 0, 0.44266],\n    \"116\": [0, 0.62119, 0, 0, 0.33301],\n    \"117\": [0, 0.47534, 0, 0, 0.5172],\n    \"118\": [0, 0.52396, 0, 0, 0.5118],\n    \"119\": [0, 0.52396, 0, 0, 0.77351],\n    \"120\": [0.18906, 0.47534, 0, 0, 0.38865],\n    \"121\": [0.18906, 0.47534, 0, 0, 0.49884],\n    \"122\": [0.18906, 0.47534, 0, 0, 0.39054],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"8216\": [0, 0.69141, 0, 0, 0.21471],\n    \"8217\": [0, 0.69141, 0, 0, 0.21471],\n    \"58112\": [0, 0.62119, 0, 0, 0.49749],\n    \"58113\": [0, 0.62119, 0, 0, 0.4983],\n    \"58114\": [0.18906, 0.69141, 0, 0, 0.33328],\n    \"58115\": [0.18906, 0.69141, 0, 0, 0.32923],\n    \"58116\": [0.18906, 0.47534, 0, 0, 0.50343],\n    \"58117\": [0, 0.69141, 0, 0, 0.33301],\n    \"58118\": [0, 0.62119, 0, 0, 0.33409],\n    \"58119\": [0, 0.47534, 0, 0, 0.50073]\n  },\n  \"Main-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.35],\n    \"34\": [0, 0.69444, 0, 0, 0.60278],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.95833],\n    \"36\": [0.05556, 0.75, 0, 0, 0.575],\n    \"37\": [0.05556, 0.75, 0, 0, 0.95833],\n    \"38\": [0, 0.69444, 0, 0, 0.89444],\n    \"39\": [0, 0.69444, 0, 0, 0.31944],\n    \"40\": [0.25, 0.75, 0, 0, 0.44722],\n    \"41\": [0.25, 0.75, 0, 0, 0.44722],\n    \"42\": [0, 0.75, 0, 0, 0.575],\n    \"43\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"44\": [0.19444, 0.15556, 0, 0, 0.31944],\n    \"45\": [0, 0.44444, 0, 0, 0.38333],\n    \"46\": [0, 0.15556, 0, 0, 0.31944],\n    \"47\": [0.25, 0.75, 0, 0, 0.575],\n    \"48\": [0, 0.64444, 0, 0, 0.575],\n    \"49\": [0, 0.64444, 0, 0, 0.575],\n    \"50\": [0, 0.64444, 0, 0, 0.575],\n    \"51\": [0, 0.64444, 0, 0, 0.575],\n    \"52\": [0, 0.64444, 0, 0, 0.575],\n    \"53\": [0, 0.64444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0, 0.64444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0, 0.64444, 0, 0, 0.575],\n    \"58\": [0, 0.44444, 0, 0, 0.31944],\n    \"59\": [0.19444, 0.44444, 0, 0, 0.31944],\n    \"60\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"61\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"62\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"63\": [0, 0.69444, 0, 0, 0.54305],\n    \"64\": [0, 0.69444, 0, 0, 0.89444],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0, 0, 0.81805],\n    \"67\": [0, 0.68611, 0, 0, 0.83055],\n    \"68\": [0, 0.68611, 0, 0, 0.88194],\n    \"69\": [0, 0.68611, 0, 0, 0.75555],\n    \"70\": [0, 0.68611, 0, 0, 0.72361],\n    \"71\": [0, 0.68611, 0, 0, 0.90416],\n    \"72\": [0, 0.68611, 0, 0, 0.9],\n    \"73\": [0, 0.68611, 0, 0, 0.43611],\n    \"74\": [0, 0.68611, 0, 0, 0.59444],\n    \"75\": [0, 0.68611, 0, 0, 0.90138],\n    \"76\": [0, 0.68611, 0, 0, 0.69166],\n    \"77\": [0, 0.68611, 0, 0, 1.09166],\n    \"78\": [0, 0.68611, 0, 0, 0.9],\n    \"79\": [0, 0.68611, 0, 0, 0.86388],\n    \"80\": [0, 0.68611, 0, 0, 0.78611],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86388],\n    \"82\": [0, 0.68611, 0, 0, 0.8625],\n    \"83\": [0, 0.68611, 0, 0, 0.63889],\n    \"84\": [0, 0.68611, 0, 0, 0.8],\n    \"85\": [0, 0.68611, 0, 0, 0.88472],\n    \"86\": [0, 0.68611, 0.01597, 0, 0.86944],\n    \"87\": [0, 0.68611, 0.01597, 0, 1.18888],\n    \"88\": [0, 0.68611, 0, 0, 0.86944],\n    \"89\": [0, 0.68611, 0.02875, 0, 0.86944],\n    \"90\": [0, 0.68611, 0, 0, 0.70277],\n    \"91\": [0.25, 0.75, 0, 0, 0.31944],\n    \"92\": [0.25, 0.75, 0, 0, 0.575],\n    \"93\": [0.25, 0.75, 0, 0, 0.31944],\n    \"94\": [0, 0.69444, 0, 0, 0.575],\n    \"95\": [0.31, 0.13444, 0.03194, 0, 0.575],\n    \"97\": [0, 0.44444, 0, 0, 0.55902],\n    \"98\": [0, 0.69444, 0, 0, 0.63889],\n    \"99\": [0, 0.44444, 0, 0, 0.51111],\n    \"100\": [0, 0.69444, 0, 0, 0.63889],\n    \"101\": [0, 0.44444, 0, 0, 0.52708],\n    \"102\": [0, 0.69444, 0.10903, 0, 0.35139],\n    \"103\": [0.19444, 0.44444, 0.01597, 0, 0.575],\n    \"104\": [0, 0.69444, 0, 0, 0.63889],\n    \"105\": [0, 0.69444, 0, 0, 0.31944],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.35139],\n    \"107\": [0, 0.69444, 0, 0, 0.60694],\n    \"108\": [0, 0.69444, 0, 0, 0.31944],\n    \"109\": [0, 0.44444, 0, 0, 0.95833],\n    \"110\": [0, 0.44444, 0, 0, 0.63889],\n    \"111\": [0, 0.44444, 0, 0, 0.575],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.63889],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.60694],\n    \"114\": [0, 0.44444, 0, 0, 0.47361],\n    \"115\": [0, 0.44444, 0, 0, 0.45361],\n    \"116\": [0, 0.63492, 0, 0, 0.44722],\n    \"117\": [0, 0.44444, 0, 0, 0.63889],\n    \"118\": [0, 0.44444, 0.01597, 0, 0.60694],\n    \"119\": [0, 0.44444, 0.01597, 0, 0.83055],\n    \"120\": [0, 0.44444, 0, 0, 0.60694],\n    \"121\": [0.19444, 0.44444, 0.01597, 0, 0.60694],\n    \"122\": [0, 0.44444, 0, 0, 0.51111],\n    \"123\": [0.25, 0.75, 0, 0, 0.575],\n    \"124\": [0.25, 0.75, 0, 0, 0.31944],\n    \"125\": [0.25, 0.75, 0, 0, 0.575],\n    \"126\": [0.35, 0.34444, 0, 0, 0.575],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.86853],\n    \"168\": [0, 0.69444, 0, 0, 0.575],\n    \"172\": [0, 0.44444, 0, 0, 0.76666],\n    \"176\": [0, 0.69444, 0, 0, 0.86944],\n    \"177\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"184\": [0.17014, 0, 0, 0, 0.51111],\n    \"198\": [0, 0.68611, 0, 0, 1.04166],\n    \"215\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"216\": [0.04861, 0.73472, 0, 0, 0.89444],\n    \"223\": [0, 0.69444, 0, 0, 0.59722],\n    \"230\": [0, 0.44444, 0, 0, 0.83055],\n    \"247\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"248\": [0.09722, 0.54167, 0, 0, 0.575],\n    \"305\": [0, 0.44444, 0, 0, 0.31944],\n    \"338\": [0, 0.68611, 0, 0, 1.16944],\n    \"339\": [0, 0.44444, 0, 0, 0.89444],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.35139],\n    \"710\": [0, 0.69444, 0, 0, 0.575],\n    \"711\": [0, 0.63194, 0, 0, 0.575],\n    \"713\": [0, 0.59611, 0, 0, 0.575],\n    \"714\": [0, 0.69444, 0, 0, 0.575],\n    \"715\": [0, 0.69444, 0, 0, 0.575],\n    \"728\": [0, 0.69444, 0, 0, 0.575],\n    \"729\": [0, 0.69444, 0, 0, 0.31944],\n    \"730\": [0, 0.69444, 0, 0, 0.86944],\n    \"732\": [0, 0.69444, 0, 0, 0.575],\n    \"733\": [0, 0.69444, 0, 0, 0.575],\n    \"915\": [0, 0.68611, 0, 0, 0.69166],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0, 0, 0.89444],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0, 0, 0.76666],\n    \"928\": [0, 0.68611, 0, 0, 0.9],\n    \"931\": [0, 0.68611, 0, 0, 0.83055],\n    \"933\": [0, 0.68611, 0, 0, 0.89444],\n    \"934\": [0, 0.68611, 0, 0, 0.83055],\n    \"936\": [0, 0.68611, 0, 0, 0.89444],\n    \"937\": [0, 0.68611, 0, 0, 0.83055],\n    \"8211\": [0, 0.44444, 0.03194, 0, 0.575],\n    \"8212\": [0, 0.44444, 0.03194, 0, 1.14999],\n    \"8216\": [0, 0.69444, 0, 0, 0.31944],\n    \"8217\": [0, 0.69444, 0, 0, 0.31944],\n    \"8220\": [0, 0.69444, 0, 0, 0.60278],\n    \"8221\": [0, 0.69444, 0, 0, 0.60278],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8242\": [0, 0.55556, 0, 0, 0.34444],\n    \"8407\": [0, 0.72444, 0.15486, 0, 0.575],\n    \"8463\": [0, 0.69444, 0, 0, 0.66759],\n    \"8465\": [0, 0.69444, 0, 0, 0.83055],\n    \"8467\": [0, 0.69444, 0, 0, 0.47361],\n    \"8472\": [0.19444, 0.44444, 0, 0, 0.74027],\n    \"8476\": [0, 0.69444, 0, 0, 0.83055],\n    \"8501\": [0, 0.69444, 0, 0, 0.70277],\n    \"8592\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8594\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8596\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8597\": [0.25, 0.75, 0, 0, 0.575],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8636\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8637\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8640\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8641\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8656\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8658\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8660\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8661\": [0.25, 0.75, 0, 0, 0.70277],\n    \"8704\": [0, 0.69444, 0, 0, 0.63889],\n    \"8706\": [0, 0.69444, 0.06389, 0, 0.62847],\n    \"8707\": [0, 0.69444, 0, 0, 0.63889],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.575],\n    \"8711\": [0, 0.68611, 0, 0, 0.95833],\n    \"8712\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8715\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8722\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8723\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8725\": [0.25, 0.75, 0, 0, 0.575],\n    \"8726\": [0.25, 0.75, 0, 0, 0.575],\n    \"8727\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8728\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8729\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8730\": [0.18, 0.82, 0, 0, 0.95833],\n    \"8733\": [0, 0.44444, 0, 0, 0.89444],\n    \"8734\": [0, 0.44444, 0, 0, 1.14999],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.31944],\n    \"8741\": [0.25, 0.75, 0, 0, 0.575],\n    \"8743\": [0, 0.55556, 0, 0, 0.76666],\n    \"8744\": [0, 0.55556, 0, 0, 0.76666],\n    \"8745\": [0, 0.55556, 0, 0, 0.76666],\n    \"8746\": [0, 0.55556, 0, 0, 0.76666],\n    \"8747\": [0.19444, 0.69444, 0.12778, 0, 0.56875],\n    \"8764\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.31944],\n    \"8771\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8773\": [0.027, 0.638, 0, 0, 0.894],\n    \"8776\": [0.02444, 0.52444, 0, 0, 0.89444],\n    \"8781\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8801\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8804\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8805\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8810\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8811\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8826\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8827\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8834\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8835\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8838\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8839\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8846\": [0, 0.55556, 0, 0, 0.76666],\n    \"8849\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8850\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8851\": [0, 0.55556, 0, 0, 0.76666],\n    \"8852\": [0, 0.55556, 0, 0, 0.76666],\n    \"8853\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8854\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8855\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8856\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8857\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8866\": [0, 0.69444, 0, 0, 0.70277],\n    \"8867\": [0, 0.69444, 0, 0, 0.70277],\n    \"8868\": [0, 0.69444, 0, 0, 0.89444],\n    \"8869\": [0, 0.69444, 0, 0, 0.89444],\n    \"8900\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8901\": [-0.02639, 0.47361, 0, 0, 0.31944],\n    \"8902\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8968\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8969\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8970\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8971\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8994\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"8995\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"9651\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9657\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9661\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9667\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9837\": [0, 0.75, 0, 0, 0.44722],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"10216\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10217\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10815\": [0, 0.68611, 0, 0, 0.9],\n    \"10927\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"10928\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Main-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.11417, 0, 0.38611],\n    \"34\": [0, 0.69444, 0.07939, 0, 0.62055],\n    \"35\": [0.19444, 0.69444, 0.06833, 0, 0.94444],\n    \"37\": [0.05556, 0.75, 0.12861, 0, 0.94444],\n    \"38\": [0, 0.69444, 0.08528, 0, 0.88555],\n    \"39\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"40\": [0.25, 0.75, 0.15806, 0, 0.47333],\n    \"41\": [0.25, 0.75, 0.03306, 0, 0.47333],\n    \"42\": [0, 0.75, 0.14333, 0, 0.59111],\n    \"43\": [0.10333, 0.60333, 0.03306, 0, 0.88555],\n    \"44\": [0.19444, 0.14722, 0, 0, 0.35555],\n    \"45\": [0, 0.44444, 0.02611, 0, 0.41444],\n    \"46\": [0, 0.14722, 0, 0, 0.35555],\n    \"47\": [0.25, 0.75, 0.15806, 0, 0.59111],\n    \"48\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"49\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"50\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"51\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"52\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"53\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"54\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"55\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"56\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"57\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"58\": [0, 0.44444, 0.06695, 0, 0.35555],\n    \"59\": [0.19444, 0.44444, 0.06695, 0, 0.35555],\n    \"61\": [-0.10889, 0.39111, 0.06833, 0, 0.88555],\n    \"63\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"64\": [0, 0.69444, 0.09208, 0, 0.88555],\n    \"65\": [0, 0.68611, 0, 0, 0.86555],\n    \"66\": [0, 0.68611, 0.0992, 0, 0.81666],\n    \"67\": [0, 0.68611, 0.14208, 0, 0.82666],\n    \"68\": [0, 0.68611, 0.09062, 0, 0.87555],\n    \"69\": [0, 0.68611, 0.11431, 0, 0.75666],\n    \"70\": [0, 0.68611, 0.12903, 0, 0.72722],\n    \"71\": [0, 0.68611, 0.07347, 0, 0.89527],\n    \"72\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"73\": [0, 0.68611, 0.15681, 0, 0.47166],\n    \"74\": [0, 0.68611, 0.145, 0, 0.61055],\n    \"75\": [0, 0.68611, 0.14208, 0, 0.89499],\n    \"76\": [0, 0.68611, 0, 0, 0.69777],\n    \"77\": [0, 0.68611, 0.17208, 0, 1.07277],\n    \"78\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"79\": [0, 0.68611, 0.09062, 0, 0.85499],\n    \"80\": [0, 0.68611, 0.0992, 0, 0.78721],\n    \"81\": [0.19444, 0.68611, 0.09062, 0, 0.85499],\n    \"82\": [0, 0.68611, 0.02559, 0, 0.85944],\n    \"83\": [0, 0.68611, 0.11264, 0, 0.64999],\n    \"84\": [0, 0.68611, 0.12903, 0, 0.7961],\n    \"85\": [0, 0.68611, 0.17208, 0, 0.88083],\n    \"86\": [0, 0.68611, 0.18625, 0, 0.86555],\n    \"87\": [0, 0.68611, 0.18625, 0, 1.15999],\n    \"88\": [0, 0.68611, 0.15681, 0, 0.86555],\n    \"89\": [0, 0.68611, 0.19803, 0, 0.86555],\n    \"90\": [0, 0.68611, 0.14208, 0, 0.70888],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.35611],\n    \"93\": [0.25, 0.75, 0.09972, 0, 0.35611],\n    \"94\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"95\": [0.31, 0.13444, 0.09811, 0, 0.59111],\n    \"97\": [0, 0.44444, 0.09426, 0, 0.59111],\n    \"98\": [0, 0.69444, 0.07861, 0, 0.53222],\n    \"99\": [0, 0.44444, 0.05222, 0, 0.53222],\n    \"100\": [0, 0.69444, 0.10861, 0, 0.59111],\n    \"101\": [0, 0.44444, 0.085, 0, 0.53222],\n    \"102\": [0.19444, 0.69444, 0.21778, 0, 0.4],\n    \"103\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"104\": [0, 0.69444, 0.09426, 0, 0.59111],\n    \"105\": [0, 0.69326, 0.11387, 0, 0.35555],\n    \"106\": [0.19444, 0.69326, 0.1672, 0, 0.35555],\n    \"107\": [0, 0.69444, 0.11111, 0, 0.53222],\n    \"108\": [0, 0.69444, 0.10861, 0, 0.29666],\n    \"109\": [0, 0.44444, 0.09426, 0, 0.94444],\n    \"110\": [0, 0.44444, 0.09426, 0, 0.64999],\n    \"111\": [0, 0.44444, 0.07861, 0, 0.59111],\n    \"112\": [0.19444, 0.44444, 0.07861, 0, 0.59111],\n    \"113\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"114\": [0, 0.44444, 0.11111, 0, 0.50167],\n    \"115\": [0, 0.44444, 0.08167, 0, 0.48694],\n    \"116\": [0, 0.63492, 0.09639, 0, 0.385],\n    \"117\": [0, 0.44444, 0.09426, 0, 0.62055],\n    \"118\": [0, 0.44444, 0.11111, 0, 0.53222],\n    \"119\": [0, 0.44444, 0.11111, 0, 0.76777],\n    \"120\": [0, 0.44444, 0.12583, 0, 0.56055],\n    \"121\": [0.19444, 0.44444, 0.105, 0, 0.56166],\n    \"122\": [0, 0.44444, 0.13889, 0, 0.49055],\n    \"126\": [0.35, 0.34444, 0.11472, 0, 0.59111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0.11473, 0, 0.59111],\n    \"176\": [0, 0.69444, 0, 0, 0.94888],\n    \"184\": [0.17014, 0, 0, 0, 0.53222],\n    \"198\": [0, 0.68611, 0.11431, 0, 1.02277],\n    \"216\": [0.04861, 0.73472, 0.09062, 0, 0.88555],\n    \"223\": [0.19444, 0.69444, 0.09736, 0, 0.665],\n    \"230\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"248\": [0.09722, 0.54167, 0.09458, 0, 0.59111],\n    \"305\": [0, 0.44444, 0.09426, 0, 0.35555],\n    \"338\": [0, 0.68611, 0.11431, 0, 1.14054],\n    \"339\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"567\": [0.19444, 0.44444, 0.04611, 0, 0.385],\n    \"710\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"711\": [0, 0.63194, 0.08271, 0, 0.59111],\n    \"713\": [0, 0.59444, 0.10444, 0, 0.59111],\n    \"714\": [0, 0.69444, 0.08528, 0, 0.59111],\n    \"715\": [0, 0.69444, 0, 0, 0.59111],\n    \"728\": [0, 0.69444, 0.10333, 0, 0.59111],\n    \"729\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"730\": [0, 0.69444, 0, 0, 0.94888],\n    \"732\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"733\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"915\": [0, 0.68611, 0.12903, 0, 0.69777],\n    \"916\": [0, 0.68611, 0, 0, 0.94444],\n    \"920\": [0, 0.68611, 0.09062, 0, 0.88555],\n    \"923\": [0, 0.68611, 0, 0, 0.80666],\n    \"926\": [0, 0.68611, 0.15092, 0, 0.76777],\n    \"928\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"931\": [0, 0.68611, 0.11431, 0, 0.82666],\n    \"933\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"934\": [0, 0.68611, 0.05632, 0, 0.82666],\n    \"936\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"937\": [0, 0.68611, 0.0992, 0, 0.82666],\n    \"8211\": [0, 0.44444, 0.09811, 0, 0.59111],\n    \"8212\": [0, 0.44444, 0.09811, 0, 1.18221],\n    \"8216\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8217\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8220\": [0, 0.69444, 0.16772, 0, 0.62055],\n    \"8221\": [0, 0.69444, 0.07939, 0, 0.62055]\n  },\n  \"Main-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"34\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"35\": [0.19444, 0.69444, 0.06616, 0, 0.81777],\n    \"37\": [0.05556, 0.75, 0.13639, 0, 0.81777],\n    \"38\": [0, 0.69444, 0.09694, 0, 0.76666],\n    \"39\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"40\": [0.25, 0.75, 0.16194, 0, 0.40889],\n    \"41\": [0.25, 0.75, 0.03694, 0, 0.40889],\n    \"42\": [0, 0.75, 0.14917, 0, 0.51111],\n    \"43\": [0.05667, 0.56167, 0.03694, 0, 0.76666],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.30667],\n    \"45\": [0, 0.43056, 0.02826, 0, 0.35778],\n    \"46\": [0, 0.10556, 0, 0, 0.30667],\n    \"47\": [0.25, 0.75, 0.16194, 0, 0.51111],\n    \"48\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"49\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"50\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"51\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"52\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"53\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"54\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"55\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"56\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"57\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"58\": [0, 0.43056, 0.0582, 0, 0.30667],\n    \"59\": [0.19444, 0.43056, 0.0582, 0, 0.30667],\n    \"61\": [-0.13313, 0.36687, 0.06616, 0, 0.76666],\n    \"63\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"64\": [0, 0.69444, 0.09597, 0, 0.76666],\n    \"65\": [0, 0.68333, 0, 0, 0.74333],\n    \"66\": [0, 0.68333, 0.10257, 0, 0.70389],\n    \"67\": [0, 0.68333, 0.14528, 0, 0.71555],\n    \"68\": [0, 0.68333, 0.09403, 0, 0.755],\n    \"69\": [0, 0.68333, 0.12028, 0, 0.67833],\n    \"70\": [0, 0.68333, 0.13305, 0, 0.65277],\n    \"71\": [0, 0.68333, 0.08722, 0, 0.77361],\n    \"72\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"73\": [0, 0.68333, 0.15806, 0, 0.38555],\n    \"74\": [0, 0.68333, 0.14028, 0, 0.525],\n    \"75\": [0, 0.68333, 0.14528, 0, 0.76888],\n    \"76\": [0, 0.68333, 0, 0, 0.62722],\n    \"77\": [0, 0.68333, 0.16389, 0, 0.89666],\n    \"78\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"79\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"80\": [0, 0.68333, 0.10257, 0, 0.67833],\n    \"81\": [0.19444, 0.68333, 0.09403, 0, 0.76666],\n    \"82\": [0, 0.68333, 0.03868, 0, 0.72944],\n    \"83\": [0, 0.68333, 0.11972, 0, 0.56222],\n    \"84\": [0, 0.68333, 0.13305, 0, 0.71555],\n    \"85\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"86\": [0, 0.68333, 0.18361, 0, 0.74333],\n    \"87\": [0, 0.68333, 0.18361, 0, 0.99888],\n    \"88\": [0, 0.68333, 0.15806, 0, 0.74333],\n    \"89\": [0, 0.68333, 0.19383, 0, 0.74333],\n    \"90\": [0, 0.68333, 0.14528, 0, 0.61333],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.30667],\n    \"93\": [0.25, 0.75, 0.10528, 0, 0.30667],\n    \"94\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"95\": [0.31, 0.12056, 0.09208, 0, 0.51111],\n    \"97\": [0, 0.43056, 0.07671, 0, 0.51111],\n    \"98\": [0, 0.69444, 0.06312, 0, 0.46],\n    \"99\": [0, 0.43056, 0.05653, 0, 0.46],\n    \"100\": [0, 0.69444, 0.10333, 0, 0.51111],\n    \"101\": [0, 0.43056, 0.07514, 0, 0.46],\n    \"102\": [0.19444, 0.69444, 0.21194, 0, 0.30667],\n    \"103\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"104\": [0, 0.69444, 0.07671, 0, 0.51111],\n    \"105\": [0, 0.65536, 0.1019, 0, 0.30667],\n    \"106\": [0.19444, 0.65536, 0.14467, 0, 0.30667],\n    \"107\": [0, 0.69444, 0.10764, 0, 0.46],\n    \"108\": [0, 0.69444, 0.10333, 0, 0.25555],\n    \"109\": [0, 0.43056, 0.07671, 0, 0.81777],\n    \"110\": [0, 0.43056, 0.07671, 0, 0.56222],\n    \"111\": [0, 0.43056, 0.06312, 0, 0.51111],\n    \"112\": [0.19444, 0.43056, 0.06312, 0, 0.51111],\n    \"113\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"114\": [0, 0.43056, 0.10764, 0, 0.42166],\n    \"115\": [0, 0.43056, 0.08208, 0, 0.40889],\n    \"116\": [0, 0.61508, 0.09486, 0, 0.33222],\n    \"117\": [0, 0.43056, 0.07671, 0, 0.53666],\n    \"118\": [0, 0.43056, 0.10764, 0, 0.46],\n    \"119\": [0, 0.43056, 0.10764, 0, 0.66444],\n    \"120\": [0, 0.43056, 0.12042, 0, 0.46389],\n    \"121\": [0.19444, 0.43056, 0.08847, 0, 0.48555],\n    \"122\": [0, 0.43056, 0.12292, 0, 0.40889],\n    \"126\": [0.35, 0.31786, 0.11585, 0, 0.51111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.66786, 0.10474, 0, 0.51111],\n    \"176\": [0, 0.69444, 0, 0, 0.83129],\n    \"184\": [0.17014, 0, 0, 0, 0.46],\n    \"198\": [0, 0.68333, 0.12028, 0, 0.88277],\n    \"216\": [0.04861, 0.73194, 0.09403, 0, 0.76666],\n    \"223\": [0.19444, 0.69444, 0.10514, 0, 0.53666],\n    \"230\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"248\": [0.09722, 0.52778, 0.09194, 0, 0.51111],\n    \"338\": [0, 0.68333, 0.12028, 0, 0.98499],\n    \"339\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"710\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"711\": [0, 0.62847, 0.08295, 0, 0.51111],\n    \"713\": [0, 0.56167, 0.10333, 0, 0.51111],\n    \"714\": [0, 0.69444, 0.09694, 0, 0.51111],\n    \"715\": [0, 0.69444, 0, 0, 0.51111],\n    \"728\": [0, 0.69444, 0.10806, 0, 0.51111],\n    \"729\": [0, 0.66786, 0.11752, 0, 0.30667],\n    \"730\": [0, 0.69444, 0, 0, 0.83129],\n    \"732\": [0, 0.66786, 0.11585, 0, 0.51111],\n    \"733\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"915\": [0, 0.68333, 0.13305, 0, 0.62722],\n    \"916\": [0, 0.68333, 0, 0, 0.81777],\n    \"920\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"923\": [0, 0.68333, 0, 0, 0.69222],\n    \"926\": [0, 0.68333, 0.15294, 0, 0.66444],\n    \"928\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"931\": [0, 0.68333, 0.12028, 0, 0.71555],\n    \"933\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"934\": [0, 0.68333, 0.05986, 0, 0.71555],\n    \"936\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"937\": [0, 0.68333, 0.10257, 0, 0.71555],\n    \"8211\": [0, 0.43056, 0.09208, 0, 0.51111],\n    \"8212\": [0, 0.43056, 0.09208, 0, 1.02222],\n    \"8216\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8217\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8220\": [0, 0.69444, 0.1685, 0, 0.51444],\n    \"8221\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028]\n  },\n  \"Main-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.27778],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.77778],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.27778],\n    \"45\": [0, 0.43056, 0, 0, 0.33333],\n    \"46\": [0, 0.10556, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.64444, 0, 0, 0.5],\n    \"49\": [0, 0.64444, 0, 0, 0.5],\n    \"50\": [0, 0.64444, 0, 0, 0.5],\n    \"51\": [0, 0.64444, 0, 0, 0.5],\n    \"52\": [0, 0.64444, 0, 0, 0.5],\n    \"53\": [0, 0.64444, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0, 0.64444, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0, 0.64444, 0, 0, 0.5],\n    \"58\": [0, 0.43056, 0, 0, 0.27778],\n    \"59\": [0.19444, 0.43056, 0, 0, 0.27778],\n    \"60\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"61\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"62\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.77778],\n    \"65\": [0, 0.68333, 0, 0, 0.75],\n    \"66\": [0, 0.68333, 0, 0, 0.70834],\n    \"67\": [0, 0.68333, 0, 0, 0.72222],\n    \"68\": [0, 0.68333, 0, 0, 0.76389],\n    \"69\": [0, 0.68333, 0, 0, 0.68056],\n    \"70\": [0, 0.68333, 0, 0, 0.65278],\n    \"71\": [0, 0.68333, 0, 0, 0.78472],\n    \"72\": [0, 0.68333, 0, 0, 0.75],\n    \"73\": [0, 0.68333, 0, 0, 0.36111],\n    \"74\": [0, 0.68333, 0, 0, 0.51389],\n    \"75\": [0, 0.68333, 0, 0, 0.77778],\n    \"76\": [0, 0.68333, 0, 0, 0.625],\n    \"77\": [0, 0.68333, 0, 0, 0.91667],\n    \"78\": [0, 0.68333, 0, 0, 0.75],\n    \"79\": [0, 0.68333, 0, 0, 0.77778],\n    \"80\": [0, 0.68333, 0, 0, 0.68056],\n    \"81\": [0.19444, 0.68333, 0, 0, 0.77778],\n    \"82\": [0, 0.68333, 0, 0, 0.73611],\n    \"83\": [0, 0.68333, 0, 0, 0.55556],\n    \"84\": [0, 0.68333, 0, 0, 0.72222],\n    \"85\": [0, 0.68333, 0, 0, 0.75],\n    \"86\": [0, 0.68333, 0.01389, 0, 0.75],\n    \"87\": [0, 0.68333, 0.01389, 0, 1.02778],\n    \"88\": [0, 0.68333, 0, 0, 0.75],\n    \"89\": [0, 0.68333, 0.025, 0, 0.75],\n    \"90\": [0, 0.68333, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.27778],\n    \"92\": [0.25, 0.75, 0, 0, 0.5],\n    \"93\": [0.25, 0.75, 0, 0, 0.27778],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.31, 0.12056, 0.02778, 0, 0.5],\n    \"97\": [0, 0.43056, 0, 0, 0.5],\n    \"98\": [0, 0.69444, 0, 0, 0.55556],\n    \"99\": [0, 0.43056, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.55556],\n    \"101\": [0, 0.43056, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.07778, 0, 0.30556],\n    \"103\": [0.19444, 0.43056, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.55556],\n    \"105\": [0, 0.66786, 0, 0, 0.27778],\n    \"106\": [0.19444, 0.66786, 0, 0, 0.30556],\n    \"107\": [0, 0.69444, 0, 0, 0.52778],\n    \"108\": [0, 0.69444, 0, 0, 0.27778],\n    \"109\": [0, 0.43056, 0, 0, 0.83334],\n    \"110\": [0, 0.43056, 0, 0, 0.55556],\n    \"111\": [0, 0.43056, 0, 0, 0.5],\n    \"112\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"113\": [0.19444, 0.43056, 0, 0, 0.52778],\n    \"114\": [0, 0.43056, 0, 0, 0.39167],\n    \"115\": [0, 0.43056, 0, 0, 0.39445],\n    \"116\": [0, 0.61508, 0, 0, 0.38889],\n    \"117\": [0, 0.43056, 0, 0, 0.55556],\n    \"118\": [0, 0.43056, 0.01389, 0, 0.52778],\n    \"119\": [0, 0.43056, 0.01389, 0, 0.72222],\n    \"120\": [0, 0.43056, 0, 0, 0.52778],\n    \"121\": [0.19444, 0.43056, 0.01389, 0, 0.52778],\n    \"122\": [0, 0.43056, 0, 0, 0.44445],\n    \"123\": [0.25, 0.75, 0, 0, 0.5],\n    \"124\": [0.25, 0.75, 0, 0, 0.27778],\n    \"125\": [0.25, 0.75, 0, 0, 0.5],\n    \"126\": [0.35, 0.31786, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.76909],\n    \"167\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"168\": [0, 0.66786, 0, 0, 0.5],\n    \"172\": [0, 0.43056, 0, 0, 0.66667],\n    \"176\": [0, 0.69444, 0, 0, 0.75],\n    \"177\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"182\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"198\": [0, 0.68333, 0, 0, 0.90278],\n    \"215\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"216\": [0.04861, 0.73194, 0, 0, 0.77778],\n    \"223\": [0, 0.69444, 0, 0, 0.5],\n    \"230\": [0, 0.43056, 0, 0, 0.72222],\n    \"247\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"248\": [0.09722, 0.52778, 0, 0, 0.5],\n    \"305\": [0, 0.43056, 0, 0, 0.27778],\n    \"338\": [0, 0.68333, 0, 0, 1.01389],\n    \"339\": [0, 0.43056, 0, 0, 0.77778],\n    \"567\": [0.19444, 0.43056, 0, 0, 0.30556],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.62847, 0, 0, 0.5],\n    \"713\": [0, 0.56778, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.66786, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.75],\n    \"732\": [0, 0.66786, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.68333, 0, 0, 0.625],\n    \"916\": [0, 0.68333, 0, 0, 0.83334],\n    \"920\": [0, 0.68333, 0, 0, 0.77778],\n    \"923\": [0, 0.68333, 0, 0, 0.69445],\n    \"926\": [0, 0.68333, 0, 0, 0.66667],\n    \"928\": [0, 0.68333, 0, 0, 0.75],\n    \"931\": [0, 0.68333, 0, 0, 0.72222],\n    \"933\": [0, 0.68333, 0, 0, 0.77778],\n    \"934\": [0, 0.68333, 0, 0, 0.72222],\n    \"936\": [0, 0.68333, 0, 0, 0.77778],\n    \"937\": [0, 0.68333, 0, 0, 0.72222],\n    \"8211\": [0, 0.43056, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.43056, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8230\": [0, 0.123, 0, 0, 1.172],\n    \"8242\": [0, 0.55556, 0, 0, 0.275],\n    \"8407\": [0, 0.71444, 0.15382, 0, 0.5],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8465\": [0, 0.69444, 0, 0, 0.72222],\n    \"8467\": [0, 0.69444, 0, 0.11111, 0.41667],\n    \"8472\": [0.19444, 0.43056, 0, 0.11111, 0.63646],\n    \"8476\": [0, 0.69444, 0, 0, 0.72222],\n    \"8501\": [0, 0.69444, 0, 0, 0.61111],\n    \"8592\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8594\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8596\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8597\": [0.25, 0.75, 0, 0, 0.5],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8614\": [0.011, 0.511, 0, 0, 1.0],\n    \"8617\": [0.011, 0.511, 0, 0, 1.126],\n    \"8618\": [0.011, 0.511, 0, 0, 1.126],\n    \"8636\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8637\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8640\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8641\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8652\": [0.011, 0.671, 0, 0, 1.0],\n    \"8656\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8658\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8660\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8661\": [0.25, 0.75, 0, 0, 0.61111],\n    \"8704\": [0, 0.69444, 0, 0, 0.55556],\n    \"8706\": [0, 0.69444, 0.05556, 0.08334, 0.5309],\n    \"8707\": [0, 0.69444, 0, 0, 0.55556],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.5],\n    \"8711\": [0, 0.68333, 0, 0, 0.83334],\n    \"8712\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8715\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8722\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8723\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8725\": [0.25, 0.75, 0, 0, 0.5],\n    \"8726\": [0.25, 0.75, 0, 0, 0.5],\n    \"8727\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8728\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8729\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8730\": [0.2, 0.8, 0, 0, 0.83334],\n    \"8733\": [0, 0.43056, 0, 0, 0.77778],\n    \"8734\": [0, 0.43056, 0, 0, 1.0],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.27778],\n    \"8741\": [0.25, 0.75, 0, 0, 0.5],\n    \"8743\": [0, 0.55556, 0, 0, 0.66667],\n    \"8744\": [0, 0.55556, 0, 0, 0.66667],\n    \"8745\": [0, 0.55556, 0, 0, 0.66667],\n    \"8746\": [0, 0.55556, 0, 0, 0.66667],\n    \"8747\": [0.19444, 0.69444, 0.11111, 0, 0.41667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.27778],\n    \"8771\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8773\": [-0.022, 0.589, 0, 0, 0.778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8781\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8784\": [-0.133, 0.673, 0, 0, 0.778],\n    \"8801\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8804\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8805\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8810\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8811\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8826\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8827\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8834\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8835\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8838\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8839\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8846\": [0, 0.55556, 0, 0, 0.66667],\n    \"8849\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8850\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8851\": [0, 0.55556, 0, 0, 0.66667],\n    \"8852\": [0, 0.55556, 0, 0, 0.66667],\n    \"8853\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8854\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8855\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8856\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8857\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8866\": [0, 0.69444, 0, 0, 0.61111],\n    \"8867\": [0, 0.69444, 0, 0, 0.61111],\n    \"8868\": [0, 0.69444, 0, 0, 0.77778],\n    \"8869\": [0, 0.69444, 0, 0, 0.77778],\n    \"8872\": [0.249, 0.75, 0, 0, 0.867],\n    \"8900\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8901\": [-0.05555, 0.44445, 0, 0, 0.27778],\n    \"8902\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8904\": [0.005, 0.505, 0, 0, 0.9],\n    \"8942\": [0.03, 0.903, 0, 0, 0.278],\n    \"8943\": [-0.19, 0.313, 0, 0, 1.172],\n    \"8945\": [-0.1, 0.823, 0, 0, 1.282],\n    \"8968\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8969\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8970\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8971\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8994\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"8995\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"9136\": [0.244, 0.744, 0, 0, 0.412],\n    \"9137\": [0.244, 0.745, 0, 0, 0.412],\n    \"9651\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9657\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9661\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9667\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9837\": [0, 0.75, 0, 0, 0.38889],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"10216\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10217\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10222\": [0.244, 0.744, 0, 0, 0.412],\n    \"10223\": [0.244, 0.745, 0, 0, 0.412],\n    \"10229\": [0.011, 0.511, 0, 0, 1.609],\n    \"10230\": [0.011, 0.511, 0, 0, 1.638],\n    \"10231\": [0.011, 0.511, 0, 0, 1.859],\n    \"10232\": [0.024, 0.525, 0, 0, 1.609],\n    \"10233\": [0.024, 0.525, 0, 0, 1.638],\n    \"10234\": [0.024, 0.525, 0, 0, 1.858],\n    \"10236\": [0.011, 0.511, 0, 0, 1.638],\n    \"10815\": [0, 0.68333, 0, 0, 0.75],\n    \"10927\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10928\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Math-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.44444, 0, 0, 0.575],\n    \"49\": [0, 0.44444, 0, 0, 0.575],\n    \"50\": [0, 0.44444, 0, 0, 0.575],\n    \"51\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"52\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"53\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0.04835, 0, 0.8664],\n    \"67\": [0, 0.68611, 0.06979, 0, 0.81694],\n    \"68\": [0, 0.68611, 0.03194, 0, 0.93812],\n    \"69\": [0, 0.68611, 0.05451, 0, 0.81007],\n    \"70\": [0, 0.68611, 0.15972, 0, 0.68889],\n    \"71\": [0, 0.68611, 0, 0, 0.88673],\n    \"72\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"73\": [0, 0.68611, 0.07778, 0, 0.51111],\n    \"74\": [0, 0.68611, 0.10069, 0, 0.63125],\n    \"75\": [0, 0.68611, 0.06979, 0, 0.97118],\n    \"76\": [0, 0.68611, 0, 0, 0.75555],\n    \"77\": [0, 0.68611, 0.11424, 0, 1.14201],\n    \"78\": [0, 0.68611, 0.11424, 0, 0.95034],\n    \"79\": [0, 0.68611, 0.03194, 0, 0.83666],\n    \"80\": [0, 0.68611, 0.15972, 0, 0.72309],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86861],\n    \"82\": [0, 0.68611, 0.00421, 0, 0.87235],\n    \"83\": [0, 0.68611, 0.05382, 0, 0.69271],\n    \"84\": [0, 0.68611, 0.15972, 0, 0.63663],\n    \"85\": [0, 0.68611, 0.11424, 0, 0.80027],\n    \"86\": [0, 0.68611, 0.25555, 0, 0.67778],\n    \"87\": [0, 0.68611, 0.15972, 0, 1.09305],\n    \"88\": [0, 0.68611, 0.07778, 0, 0.94722],\n    \"89\": [0, 0.68611, 0.25555, 0, 0.67458],\n    \"90\": [0, 0.68611, 0.06979, 0, 0.77257],\n    \"97\": [0, 0.44444, 0, 0, 0.63287],\n    \"98\": [0, 0.69444, 0, 0, 0.52083],\n    \"99\": [0, 0.44444, 0, 0, 0.51342],\n    \"100\": [0, 0.69444, 0, 0, 0.60972],\n    \"101\": [0, 0.44444, 0, 0, 0.55361],\n    \"102\": [0.19444, 0.69444, 0.11042, 0, 0.56806],\n    \"103\": [0.19444, 0.44444, 0.03704, 0, 0.5449],\n    \"104\": [0, 0.69444, 0, 0, 0.66759],\n    \"105\": [0, 0.69326, 0, 0, 0.4048],\n    \"106\": [0.19444, 0.69326, 0.0622, 0, 0.47083],\n    \"107\": [0, 0.69444, 0.01852, 0, 0.6037],\n    \"108\": [0, 0.69444, 0.0088, 0, 0.34815],\n    \"109\": [0, 0.44444, 0, 0, 1.0324],\n    \"110\": [0, 0.44444, 0, 0, 0.71296],\n    \"111\": [0, 0.44444, 0, 0, 0.58472],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.60092],\n    \"113\": [0.19444, 0.44444, 0.03704, 0, 0.54213],\n    \"114\": [0, 0.44444, 0.03194, 0, 0.5287],\n    \"115\": [0, 0.44444, 0, 0, 0.53125],\n    \"116\": [0, 0.63492, 0, 0, 0.41528],\n    \"117\": [0, 0.44444, 0, 0, 0.68102],\n    \"118\": [0, 0.44444, 0.03704, 0, 0.56666],\n    \"119\": [0, 0.44444, 0.02778, 0, 0.83148],\n    \"120\": [0, 0.44444, 0, 0, 0.65903],\n    \"121\": [0.19444, 0.44444, 0.03704, 0, 0.59028],\n    \"122\": [0, 0.44444, 0.04213, 0, 0.55509],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68611, 0.15972, 0, 0.65694],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0.03194, 0, 0.86722],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0.07458, 0, 0.84125],\n    \"928\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"931\": [0, 0.68611, 0.05451, 0, 0.88507],\n    \"933\": [0, 0.68611, 0.15972, 0, 0.67083],\n    \"934\": [0, 0.68611, 0, 0, 0.76666],\n    \"936\": [0, 0.68611, 0.11653, 0, 0.71402],\n    \"937\": [0, 0.68611, 0.04835, 0, 0.8789],\n    \"945\": [0, 0.44444, 0, 0, 0.76064],\n    \"946\": [0.19444, 0.69444, 0.03403, 0, 0.65972],\n    \"947\": [0.19444, 0.44444, 0.06389, 0, 0.59003],\n    \"948\": [0, 0.69444, 0.03819, 0, 0.52222],\n    \"949\": [0, 0.44444, 0, 0, 0.52882],\n    \"950\": [0.19444, 0.69444, 0.06215, 0, 0.50833],\n    \"951\": [0.19444, 0.44444, 0.03704, 0, 0.6],\n    \"952\": [0, 0.69444, 0.03194, 0, 0.5618],\n    \"953\": [0, 0.44444, 0, 0, 0.41204],\n    \"954\": [0, 0.44444, 0, 0, 0.66759],\n    \"955\": [0, 0.69444, 0, 0, 0.67083],\n    \"956\": [0.19444, 0.44444, 0, 0, 0.70787],\n    \"957\": [0, 0.44444, 0.06898, 0, 0.57685],\n    \"958\": [0.19444, 0.69444, 0.03021, 0, 0.50833],\n    \"959\": [0, 0.44444, 0, 0, 0.58472],\n    \"960\": [0, 0.44444, 0.03704, 0, 0.68241],\n    \"961\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"962\": [0.09722, 0.44444, 0.07917, 0, 0.42361],\n    \"963\": [0, 0.44444, 0.03704, 0, 0.68588],\n    \"964\": [0, 0.44444, 0.13472, 0, 0.52083],\n    \"965\": [0, 0.44444, 0.03704, 0, 0.63055],\n    \"966\": [0.19444, 0.44444, 0, 0, 0.74722],\n    \"967\": [0.19444, 0.44444, 0, 0, 0.71805],\n    \"968\": [0.19444, 0.69444, 0.03704, 0, 0.75833],\n    \"969\": [0, 0.44444, 0.03704, 0, 0.71782],\n    \"977\": [0, 0.69444, 0, 0, 0.69155],\n    \"981\": [0.19444, 0.69444, 0, 0, 0.7125],\n    \"982\": [0, 0.44444, 0.03194, 0, 0.975],\n    \"1009\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"1013\": [0, 0.44444, 0, 0, 0.48333],\n    \"57649\": [0, 0.44444, 0, 0, 0.39352],\n    \"57911\": [0.19444, 0.44444, 0, 0, 0.43889]\n  },\n  \"Math-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.43056, 0, 0, 0.5],\n    \"49\": [0, 0.43056, 0, 0, 0.5],\n    \"50\": [0, 0.43056, 0, 0, 0.5],\n    \"51\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"52\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"53\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059],\n    \"57649\": [0, 0.43056, 0, 0.02778, 0.32246],\n    \"57911\": [0.19444, 0.43056, 0, 0.08334, 0.38403]\n  },\n  \"SansSerif-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.36667],\n    \"34\": [0, 0.69444, 0, 0, 0.55834],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.91667],\n    \"36\": [0.05556, 0.75, 0, 0, 0.55],\n    \"37\": [0.05556, 0.75, 0, 0, 1.02912],\n    \"38\": [0, 0.69444, 0, 0, 0.83056],\n    \"39\": [0, 0.69444, 0, 0, 0.30556],\n    \"40\": [0.25, 0.75, 0, 0, 0.42778],\n    \"41\": [0.25, 0.75, 0, 0, 0.42778],\n    \"42\": [0, 0.75, 0, 0, 0.55],\n    \"43\": [0.11667, 0.61667, 0, 0, 0.85556],\n    \"44\": [0.10556, 0.13056, 0, 0, 0.30556],\n    \"45\": [0, 0.45833, 0, 0, 0.36667],\n    \"46\": [0, 0.13056, 0, 0, 0.30556],\n    \"47\": [0.25, 0.75, 0, 0, 0.55],\n    \"48\": [0, 0.69444, 0, 0, 0.55],\n    \"49\": [0, 0.69444, 0, 0, 0.55],\n    \"50\": [0, 0.69444, 0, 0, 0.55],\n    \"51\": [0, 0.69444, 0, 0, 0.55],\n    \"52\": [0, 0.69444, 0, 0, 0.55],\n    \"53\": [0, 0.69444, 0, 0, 0.55],\n    \"54\": [0, 0.69444, 0, 0, 0.55],\n    \"55\": [0, 0.69444, 0, 0, 0.55],\n    \"56\": [0, 0.69444, 0, 0, 0.55],\n    \"57\": [0, 0.69444, 0, 0, 0.55],\n    \"58\": [0, 0.45833, 0, 0, 0.30556],\n    \"59\": [0.10556, 0.45833, 0, 0, 0.30556],\n    \"61\": [-0.09375, 0.40625, 0, 0, 0.85556],\n    \"63\": [0, 0.69444, 0, 0, 0.51945],\n    \"64\": [0, 0.69444, 0, 0, 0.73334],\n    \"65\": [0, 0.69444, 0, 0, 0.73334],\n    \"66\": [0, 0.69444, 0, 0, 0.73334],\n    \"67\": [0, 0.69444, 0, 0, 0.70278],\n    \"68\": [0, 0.69444, 0, 0, 0.79445],\n    \"69\": [0, 0.69444, 0, 0, 0.64167],\n    \"70\": [0, 0.69444, 0, 0, 0.61111],\n    \"71\": [0, 0.69444, 0, 0, 0.73334],\n    \"72\": [0, 0.69444, 0, 0, 0.79445],\n    \"73\": [0, 0.69444, 0, 0, 0.33056],\n    \"74\": [0, 0.69444, 0, 0, 0.51945],\n    \"75\": [0, 0.69444, 0, 0, 0.76389],\n    \"76\": [0, 0.69444, 0, 0, 0.58056],\n    \"77\": [0, 0.69444, 0, 0, 0.97778],\n    \"78\": [0, 0.69444, 0, 0, 0.79445],\n    \"79\": [0, 0.69444, 0, 0, 0.79445],\n    \"80\": [0, 0.69444, 0, 0, 0.70278],\n    \"81\": [0.10556, 0.69444, 0, 0, 0.79445],\n    \"82\": [0, 0.69444, 0, 0, 0.70278],\n    \"83\": [0, 0.69444, 0, 0, 0.61111],\n    \"84\": [0, 0.69444, 0, 0, 0.73334],\n    \"85\": [0, 0.69444, 0, 0, 0.76389],\n    \"86\": [0, 0.69444, 0.01528, 0, 0.73334],\n    \"87\": [0, 0.69444, 0.01528, 0, 1.03889],\n    \"88\": [0, 0.69444, 0, 0, 0.73334],\n    \"89\": [0, 0.69444, 0.0275, 0, 0.73334],\n    \"90\": [0, 0.69444, 0, 0, 0.67223],\n    \"91\": [0.25, 0.75, 0, 0, 0.34306],\n    \"93\": [0.25, 0.75, 0, 0, 0.34306],\n    \"94\": [0, 0.69444, 0, 0, 0.55],\n    \"95\": [0.35, 0.10833, 0.03056, 0, 0.55],\n    \"97\": [0, 0.45833, 0, 0, 0.525],\n    \"98\": [0, 0.69444, 0, 0, 0.56111],\n    \"99\": [0, 0.45833, 0, 0, 0.48889],\n    \"100\": [0, 0.69444, 0, 0, 0.56111],\n    \"101\": [0, 0.45833, 0, 0, 0.51111],\n    \"102\": [0, 0.69444, 0.07639, 0, 0.33611],\n    \"103\": [0.19444, 0.45833, 0.01528, 0, 0.55],\n    \"104\": [0, 0.69444, 0, 0, 0.56111],\n    \"105\": [0, 0.69444, 0, 0, 0.25556],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.28611],\n    \"107\": [0, 0.69444, 0, 0, 0.53056],\n    \"108\": [0, 0.69444, 0, 0, 0.25556],\n    \"109\": [0, 0.45833, 0, 0, 0.86667],\n    \"110\": [0, 0.45833, 0, 0, 0.56111],\n    \"111\": [0, 0.45833, 0, 0, 0.55],\n    \"112\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"113\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"114\": [0, 0.45833, 0.01528, 0, 0.37222],\n    \"115\": [0, 0.45833, 0, 0, 0.42167],\n    \"116\": [0, 0.58929, 0, 0, 0.40417],\n    \"117\": [0, 0.45833, 0, 0, 0.56111],\n    \"118\": [0, 0.45833, 0.01528, 0, 0.5],\n    \"119\": [0, 0.45833, 0.01528, 0, 0.74445],\n    \"120\": [0, 0.45833, 0, 0, 0.5],\n    \"121\": [0.19444, 0.45833, 0.01528, 0, 0.5],\n    \"122\": [0, 0.45833, 0, 0, 0.47639],\n    \"126\": [0.35, 0.34444, 0, 0, 0.55],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0, 0, 0.55],\n    \"176\": [0, 0.69444, 0, 0, 0.73334],\n    \"180\": [0, 0.69444, 0, 0, 0.55],\n    \"184\": [0.17014, 0, 0, 0, 0.48889],\n    \"305\": [0, 0.45833, 0, 0, 0.25556],\n    \"567\": [0.19444, 0.45833, 0, 0, 0.28611],\n    \"710\": [0, 0.69444, 0, 0, 0.55],\n    \"711\": [0, 0.63542, 0, 0, 0.55],\n    \"713\": [0, 0.63778, 0, 0, 0.55],\n    \"728\": [0, 0.69444, 0, 0, 0.55],\n    \"729\": [0, 0.69444, 0, 0, 0.30556],\n    \"730\": [0, 0.69444, 0, 0, 0.73334],\n    \"732\": [0, 0.69444, 0, 0, 0.55],\n    \"733\": [0, 0.69444, 0, 0, 0.55],\n    \"915\": [0, 0.69444, 0, 0, 0.58056],\n    \"916\": [0, 0.69444, 0, 0, 0.91667],\n    \"920\": [0, 0.69444, 0, 0, 0.85556],\n    \"923\": [0, 0.69444, 0, 0, 0.67223],\n    \"926\": [0, 0.69444, 0, 0, 0.73334],\n    \"928\": [0, 0.69444, 0, 0, 0.79445],\n    \"931\": [0, 0.69444, 0, 0, 0.79445],\n    \"933\": [0, 0.69444, 0, 0, 0.85556],\n    \"934\": [0, 0.69444, 0, 0, 0.79445],\n    \"936\": [0, 0.69444, 0, 0, 0.85556],\n    \"937\": [0, 0.69444, 0, 0, 0.79445],\n    \"8211\": [0, 0.45833, 0.03056, 0, 0.55],\n    \"8212\": [0, 0.45833, 0.03056, 0, 1.10001],\n    \"8216\": [0, 0.69444, 0, 0, 0.30556],\n    \"8217\": [0, 0.69444, 0, 0, 0.30556],\n    \"8220\": [0, 0.69444, 0, 0, 0.55834],\n    \"8221\": [0, 0.69444, 0, 0, 0.55834]\n  },\n  \"SansSerif-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.05733, 0, 0.31945],\n    \"34\": [0, 0.69444, 0.00316, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0.05087, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0.11156, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0.03126, 0, 0.83334],\n    \"38\": [0, 0.69444, 0.03058, 0, 0.75834],\n    \"39\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0.13164, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0.02536, 0, 0.38889],\n    \"42\": [0, 0.75, 0.11775, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0.02536, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0.01946, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0.13164, 0, 0.5],\n    \"48\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"49\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"50\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"51\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"52\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"53\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"54\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"55\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"56\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"57\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"58\": [0, 0.44444, 0.02502, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0.02502, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0.05087, 0, 0.77778],\n    \"63\": [0, 0.69444, 0.11809, 0, 0.47222],\n    \"64\": [0, 0.69444, 0.07555, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0.08293, 0, 0.66667],\n    \"67\": [0, 0.69444, 0.11983, 0, 0.63889],\n    \"68\": [0, 0.69444, 0.07555, 0, 0.72223],\n    \"69\": [0, 0.69444, 0.11983, 0, 0.59722],\n    \"70\": [0, 0.69444, 0.13372, 0, 0.56945],\n    \"71\": [0, 0.69444, 0.11983, 0, 0.66667],\n    \"72\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"73\": [0, 0.69444, 0.13372, 0, 0.27778],\n    \"74\": [0, 0.69444, 0.08094, 0, 0.47222],\n    \"75\": [0, 0.69444, 0.11983, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0.08094, 0, 0.875],\n    \"78\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"79\": [0, 0.69444, 0.07555, 0, 0.73611],\n    \"80\": [0, 0.69444, 0.08293, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0.07555, 0, 0.73611],\n    \"82\": [0, 0.69444, 0.08293, 0, 0.64584],\n    \"83\": [0, 0.69444, 0.09205, 0, 0.55556],\n    \"84\": [0, 0.69444, 0.13372, 0, 0.68056],\n    \"85\": [0, 0.69444, 0.08094, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.1615, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.1615, 0, 0.94445],\n    \"88\": [0, 0.69444, 0.13372, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.17261, 0, 0.66667],\n    \"90\": [0, 0.69444, 0.11983, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0.15942, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0.08719, 0, 0.28889],\n    \"94\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.08616, 0, 0.5],\n    \"97\": [0, 0.44444, 0.00981, 0, 0.48056],\n    \"98\": [0, 0.69444, 0.03057, 0, 0.51667],\n    \"99\": [0, 0.44444, 0.08336, 0, 0.44445],\n    \"100\": [0, 0.69444, 0.09483, 0, 0.51667],\n    \"101\": [0, 0.44444, 0.06778, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.21705, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.10836, 0, 0.5],\n    \"104\": [0, 0.69444, 0.01778, 0, 0.51667],\n    \"105\": [0, 0.67937, 0.09718, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0.09162, 0, 0.26667],\n    \"107\": [0, 0.69444, 0.08336, 0, 0.48889],\n    \"108\": [0, 0.69444, 0.09483, 0, 0.23889],\n    \"109\": [0, 0.44444, 0.01778, 0, 0.79445],\n    \"110\": [0, 0.44444, 0.01778, 0, 0.51667],\n    \"111\": [0, 0.44444, 0.06613, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0.0389, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0.04169, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.10836, 0, 0.34167],\n    \"115\": [0, 0.44444, 0.0778, 0, 0.38333],\n    \"116\": [0, 0.57143, 0.07225, 0, 0.36111],\n    \"117\": [0, 0.44444, 0.04169, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.10836, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.10836, 0, 0.68334],\n    \"120\": [0, 0.44444, 0.09169, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.10836, 0, 0.46111],\n    \"122\": [0, 0.44444, 0.08752, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0.08826, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0.06385, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.73752],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0.04169, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0.04169, 0, 0.26667],\n    \"710\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"711\": [0, 0.63194, 0.08432, 0, 0.5],\n    \"713\": [0, 0.60889, 0.08776, 0, 0.5],\n    \"714\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0.09483, 0, 0.5],\n    \"729\": [0, 0.67937, 0.07774, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.73752],\n    \"732\": [0, 0.67659, 0.08826, 0, 0.5],\n    \"733\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"915\": [0, 0.69444, 0.13372, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0.07555, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0.12816, 0, 0.66667],\n    \"928\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"931\": [0, 0.69444, 0.11983, 0, 0.72222],\n    \"933\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"934\": [0, 0.69444, 0.04603, 0, 0.72222],\n    \"936\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"937\": [0, 0.69444, 0.08293, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.08616, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.08616, 0, 1.0],\n    \"8216\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0.14205, 0, 0.5],\n    \"8221\": [0, 0.69444, 0.00316, 0, 0.5]\n  },\n  \"SansSerif-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.31945],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.75834],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.65556, 0, 0, 0.5],\n    \"49\": [0, 0.65556, 0, 0, 0.5],\n    \"50\": [0, 0.65556, 0, 0, 0.5],\n    \"51\": [0, 0.65556, 0, 0, 0.5],\n    \"52\": [0, 0.65556, 0, 0, 0.5],\n    \"53\": [0, 0.65556, 0, 0, 0.5],\n    \"54\": [0, 0.65556, 0, 0, 0.5],\n    \"55\": [0, 0.65556, 0, 0, 0.5],\n    \"56\": [0, 0.65556, 0, 0, 0.5],\n    \"57\": [0, 0.65556, 0, 0, 0.5],\n    \"58\": [0, 0.44444, 0, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0, 0, 0.66667],\n    \"67\": [0, 0.69444, 0, 0, 0.63889],\n    \"68\": [0, 0.69444, 0, 0, 0.72223],\n    \"69\": [0, 0.69444, 0, 0, 0.59722],\n    \"70\": [0, 0.69444, 0, 0, 0.56945],\n    \"71\": [0, 0.69444, 0, 0, 0.66667],\n    \"72\": [0, 0.69444, 0, 0, 0.70834],\n    \"73\": [0, 0.69444, 0, 0, 0.27778],\n    \"74\": [0, 0.69444, 0, 0, 0.47222],\n    \"75\": [0, 0.69444, 0, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0, 0, 0.875],\n    \"78\": [0, 0.69444, 0, 0, 0.70834],\n    \"79\": [0, 0.69444, 0, 0, 0.73611],\n    \"80\": [0, 0.69444, 0, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0, 0, 0.73611],\n    \"82\": [0, 0.69444, 0, 0, 0.64584],\n    \"83\": [0, 0.69444, 0, 0, 0.55556],\n    \"84\": [0, 0.69444, 0, 0, 0.68056],\n    \"85\": [0, 0.69444, 0, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.01389, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.01389, 0, 0.94445],\n    \"88\": [0, 0.69444, 0, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.025, 0, 0.66667],\n    \"90\": [0, 0.69444, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0, 0, 0.28889],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.02778, 0, 0.5],\n    \"97\": [0, 0.44444, 0, 0, 0.48056],\n    \"98\": [0, 0.69444, 0, 0, 0.51667],\n    \"99\": [0, 0.44444, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.51667],\n    \"101\": [0, 0.44444, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.06944, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.51667],\n    \"105\": [0, 0.67937, 0, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0, 0, 0.26667],\n    \"107\": [0, 0.69444, 0, 0, 0.48889],\n    \"108\": [0, 0.69444, 0, 0, 0.23889],\n    \"109\": [0, 0.44444, 0, 0, 0.79445],\n    \"110\": [0, 0.44444, 0, 0, 0.51667],\n    \"111\": [0, 0.44444, 0, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.01389, 0, 0.34167],\n    \"115\": [0, 0.44444, 0, 0, 0.38333],\n    \"116\": [0, 0.57143, 0, 0, 0.36111],\n    \"117\": [0, 0.44444, 0, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.01389, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.01389, 0, 0.68334],\n    \"120\": [0, 0.44444, 0, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.01389, 0, 0.46111],\n    \"122\": [0, 0.44444, 0, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.66667],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.26667],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.63194, 0, 0, 0.5],\n    \"713\": [0, 0.60889, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.67937, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.66667],\n    \"732\": [0, 0.67659, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.69444, 0, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0, 0, 0.66667],\n    \"928\": [0, 0.69444, 0, 0, 0.70834],\n    \"931\": [0, 0.69444, 0, 0, 0.72222],\n    \"933\": [0, 0.69444, 0, 0, 0.77778],\n    \"934\": [0, 0.69444, 0, 0, 0.72222],\n    \"936\": [0, 0.69444, 0, 0, 0.77778],\n    \"937\": [0, 0.69444, 0, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5]\n  },\n  \"Script-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.7, 0.22925, 0, 0.80253],\n    \"66\": [0, 0.7, 0.04087, 0, 0.90757],\n    \"67\": [0, 0.7, 0.1689, 0, 0.66619],\n    \"68\": [0, 0.7, 0.09371, 0, 0.77443],\n    \"69\": [0, 0.7, 0.18583, 0, 0.56162],\n    \"70\": [0, 0.7, 0.13634, 0, 0.89544],\n    \"71\": [0, 0.7, 0.17322, 0, 0.60961],\n    \"72\": [0, 0.7, 0.29694, 0, 0.96919],\n    \"73\": [0, 0.7, 0.19189, 0, 0.80907],\n    \"74\": [0.27778, 0.7, 0.19189, 0, 1.05159],\n    \"75\": [0, 0.7, 0.31259, 0, 0.91364],\n    \"76\": [0, 0.7, 0.19189, 0, 0.87373],\n    \"77\": [0, 0.7, 0.15981, 0, 1.08031],\n    \"78\": [0, 0.7, 0.3525, 0, 0.9015],\n    \"79\": [0, 0.7, 0.08078, 0, 0.73787],\n    \"80\": [0, 0.7, 0.08078, 0, 1.01262],\n    \"81\": [0, 0.7, 0.03305, 0, 0.88282],\n    \"82\": [0, 0.7, 0.06259, 0, 0.85],\n    \"83\": [0, 0.7, 0.19189, 0, 0.86767],\n    \"84\": [0, 0.7, 0.29087, 0, 0.74697],\n    \"85\": [0, 0.7, 0.25815, 0, 0.79996],\n    \"86\": [0, 0.7, 0.27523, 0, 0.62204],\n    \"87\": [0, 0.7, 0.27523, 0, 0.80532],\n    \"88\": [0, 0.7, 0.26006, 0, 0.94445],\n    \"89\": [0, 0.7, 0.2939, 0, 0.70961],\n    \"90\": [0, 0.7, 0.24037, 0, 0.8212],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Size1-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"41\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"47\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"91\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"92\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"93\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"123\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"125\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.72222, 0, 0, 0.55556],\n    \"732\": [0, 0.72222, 0, 0, 0.55556],\n    \"770\": [0, 0.72222, 0, 0, 0.55556],\n    \"771\": [0, 0.72222, 0, 0, 0.55556],\n    \"8214\": [-0.00099, 0.601, 0, 0, 0.77778],\n    \"8593\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8595\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8657\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8659\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8719\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8720\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8721\": [0.25001, 0.75, 0, 0, 1.05556],\n    \"8730\": [0.35001, 0.85, 0, 0, 1.0],\n    \"8739\": [-0.00599, 0.606, 0, 0, 0.33333],\n    \"8741\": [-0.00599, 0.606, 0, 0, 0.55556],\n    \"8747\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8748\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8749\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8750\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8896\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8897\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8898\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8899\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8968\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8969\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8970\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8971\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"9168\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"10216\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10217\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10752\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10753\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10754\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10756\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"10758\": [0.25001, 0.75, 0, 0, 0.83334]\n  },\n  \"Size2-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"41\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"47\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"91\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"92\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"93\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"123\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"125\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.0],\n    \"732\": [0, 0.75, 0, 0, 1.0],\n    \"770\": [0, 0.75, 0, 0, 1.0],\n    \"771\": [0, 0.75, 0, 0, 1.0],\n    \"8719\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8720\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8721\": [0.55001, 1.05, 0, 0, 1.44445],\n    \"8730\": [0.65002, 1.15, 0, 0, 1.0],\n    \"8747\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8748\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8749\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8750\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8896\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8897\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8898\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8899\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8968\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8969\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8970\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8971\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"10216\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10217\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10752\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10753\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10754\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10756\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"10758\": [0.55001, 1.05, 0, 0, 1.11111]\n  },\n  \"Size3-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"41\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"47\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"91\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"92\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"93\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"123\": [0.95003, 1.45, 0, 0, 0.75],\n    \"125\": [0.95003, 1.45, 0, 0, 0.75],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.44445],\n    \"732\": [0, 0.75, 0, 0, 1.44445],\n    \"770\": [0, 0.75, 0, 0, 1.44445],\n    \"771\": [0, 0.75, 0, 0, 1.44445],\n    \"8730\": [0.95003, 1.45, 0, 0, 1.0],\n    \"8968\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8969\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8970\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8971\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"10216\": [0.95003, 1.45, 0, 0, 0.75],\n    \"10217\": [0.95003, 1.45, 0, 0, 0.75]\n  },\n  \"Size4-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"41\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"47\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"91\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"92\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"93\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"123\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"125\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.825, 0, 0, 1.8889],\n    \"732\": [0, 0.825, 0, 0, 1.8889],\n    \"770\": [0, 0.825, 0, 0, 1.8889],\n    \"771\": [0, 0.825, 0, 0, 1.8889],\n    \"8730\": [1.25003, 1.75, 0, 0, 1.0],\n    \"8968\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8969\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8970\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8971\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"9115\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9116\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9117\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9118\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9119\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9120\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9121\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9122\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9123\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9124\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9125\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9126\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9127\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9128\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9129\": [0.90001, 0, 0, 0, 0.88889],\n    \"9130\": [0, 0.3, 0, 0, 0.88889],\n    \"9131\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9132\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9133\": [0.90001, 0, 0, 0, 0.88889],\n    \"9143\": [0.88502, 0.915, 0, 0, 1.05556],\n    \"10216\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"10217\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"57344\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57345\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57680\": [0, 0.12, 0, 0, 0.45],\n    \"57681\": [0, 0.12, 0, 0, 0.45],\n    \"57682\": [0, 0.12, 0, 0, 0.45],\n    \"57683\": [0, 0.12, 0, 0, 0.45]\n  },\n  \"Typewriter-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.525],\n    \"33\": [0, 0.61111, 0, 0, 0.525],\n    \"34\": [0, 0.61111, 0, 0, 0.525],\n    \"35\": [0, 0.61111, 0, 0, 0.525],\n    \"36\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"37\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"38\": [0, 0.61111, 0, 0, 0.525],\n    \"39\": [0, 0.61111, 0, 0, 0.525],\n    \"40\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"41\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"42\": [0, 0.52083, 0, 0, 0.525],\n    \"43\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"44\": [0.13889, 0.125, 0, 0, 0.525],\n    \"45\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"46\": [0, 0.125, 0, 0, 0.525],\n    \"47\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"48\": [0, 0.61111, 0, 0, 0.525],\n    \"49\": [0, 0.61111, 0, 0, 0.525],\n    \"50\": [0, 0.61111, 0, 0, 0.525],\n    \"51\": [0, 0.61111, 0, 0, 0.525],\n    \"52\": [0, 0.61111, 0, 0, 0.525],\n    \"53\": [0, 0.61111, 0, 0, 0.525],\n    \"54\": [0, 0.61111, 0, 0, 0.525],\n    \"55\": [0, 0.61111, 0, 0, 0.525],\n    \"56\": [0, 0.61111, 0, 0, 0.525],\n    \"57\": [0, 0.61111, 0, 0, 0.525],\n    \"58\": [0, 0.43056, 0, 0, 0.525],\n    \"59\": [0.13889, 0.43056, 0, 0, 0.525],\n    \"60\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"61\": [-0.19549, 0.41562, 0, 0, 0.525],\n    \"62\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"63\": [0, 0.61111, 0, 0, 0.525],\n    \"64\": [0, 0.61111, 0, 0, 0.525],\n    \"65\": [0, 0.61111, 0, 0, 0.525],\n    \"66\": [0, 0.61111, 0, 0, 0.525],\n    \"67\": [0, 0.61111, 0, 0, 0.525],\n    \"68\": [0, 0.61111, 0, 0, 0.525],\n    \"69\": [0, 0.61111, 0, 0, 0.525],\n    \"70\": [0, 0.61111, 0, 0, 0.525],\n    \"71\": [0, 0.61111, 0, 0, 0.525],\n    \"72\": [0, 0.61111, 0, 0, 0.525],\n    \"73\": [0, 0.61111, 0, 0, 0.525],\n    \"74\": [0, 0.61111, 0, 0, 0.525],\n    \"75\": [0, 0.61111, 0, 0, 0.525],\n    \"76\": [0, 0.61111, 0, 0, 0.525],\n    \"77\": [0, 0.61111, 0, 0, 0.525],\n    \"78\": [0, 0.61111, 0, 0, 0.525],\n    \"79\": [0, 0.61111, 0, 0, 0.525],\n    \"80\": [0, 0.61111, 0, 0, 0.525],\n    \"81\": [0.13889, 0.61111, 0, 0, 0.525],\n    \"82\": [0, 0.61111, 0, 0, 0.525],\n    \"83\": [0, 0.61111, 0, 0, 0.525],\n    \"84\": [0, 0.61111, 0, 0, 0.525],\n    \"85\": [0, 0.61111, 0, 0, 0.525],\n    \"86\": [0, 0.61111, 0, 0, 0.525],\n    \"87\": [0, 0.61111, 0, 0, 0.525],\n    \"88\": [0, 0.61111, 0, 0, 0.525],\n    \"89\": [0, 0.61111, 0, 0, 0.525],\n    \"90\": [0, 0.61111, 0, 0, 0.525],\n    \"91\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"92\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"93\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"94\": [0, 0.61111, 0, 0, 0.525],\n    \"95\": [0.09514, 0, 0, 0, 0.525],\n    \"96\": [0, 0.61111, 0, 0, 0.525],\n    \"97\": [0, 0.43056, 0, 0, 0.525],\n    \"98\": [0, 0.61111, 0, 0, 0.525],\n    \"99\": [0, 0.43056, 0, 0, 0.525],\n    \"100\": [0, 0.61111, 0, 0, 0.525],\n    \"101\": [0, 0.43056, 0, 0, 0.525],\n    \"102\": [0, 0.61111, 0, 0, 0.525],\n    \"103\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"104\": [0, 0.61111, 0, 0, 0.525],\n    \"105\": [0, 0.61111, 0, 0, 0.525],\n    \"106\": [0.22222, 0.61111, 0, 0, 0.525],\n    \"107\": [0, 0.61111, 0, 0, 0.525],\n    \"108\": [0, 0.61111, 0, 0, 0.525],\n    \"109\": [0, 0.43056, 0, 0, 0.525],\n    \"110\": [0, 0.43056, 0, 0, 0.525],\n    \"111\": [0, 0.43056, 0, 0, 0.525],\n    \"112\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"113\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"114\": [0, 0.43056, 0, 0, 0.525],\n    \"115\": [0, 0.43056, 0, 0, 0.525],\n    \"116\": [0, 0.55358, 0, 0, 0.525],\n    \"117\": [0, 0.43056, 0, 0, 0.525],\n    \"118\": [0, 0.43056, 0, 0, 0.525],\n    \"119\": [0, 0.43056, 0, 0, 0.525],\n    \"120\": [0, 0.43056, 0, 0, 0.525],\n    \"121\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"122\": [0, 0.43056, 0, 0, 0.525],\n    \"123\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"124\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"125\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"126\": [0, 0.61111, 0, 0, 0.525],\n    \"127\": [0, 0.61111, 0, 0, 0.525],\n    \"160\": [0, 0, 0, 0, 0.525],\n    \"176\": [0, 0.61111, 0, 0, 0.525],\n    \"184\": [0.19445, 0, 0, 0, 0.525],\n    \"305\": [0, 0.43056, 0, 0, 0.525],\n    \"567\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"711\": [0, 0.56597, 0, 0, 0.525],\n    \"713\": [0, 0.56555, 0, 0, 0.525],\n    \"714\": [0, 0.61111, 0, 0, 0.525],\n    \"715\": [0, 0.61111, 0, 0, 0.525],\n    \"728\": [0, 0.61111, 0, 0, 0.525],\n    \"730\": [0, 0.61111, 0, 0, 0.525],\n    \"770\": [0, 0.61111, 0, 0, 0.525],\n    \"771\": [0, 0.61111, 0, 0, 0.525],\n    \"776\": [0, 0.61111, 0, 0, 0.525],\n    \"915\": [0, 0.61111, 0, 0, 0.525],\n    \"916\": [0, 0.61111, 0, 0, 0.525],\n    \"920\": [0, 0.61111, 0, 0, 0.525],\n    \"923\": [0, 0.61111, 0, 0, 0.525],\n    \"926\": [0, 0.61111, 0, 0, 0.525],\n    \"928\": [0, 0.61111, 0, 0, 0.525],\n    \"931\": [0, 0.61111, 0, 0, 0.525],\n    \"933\": [0, 0.61111, 0, 0, 0.525],\n    \"934\": [0, 0.61111, 0, 0, 0.525],\n    \"936\": [0, 0.61111, 0, 0, 0.525],\n    \"937\": [0, 0.61111, 0, 0, 0.525],\n    \"8216\": [0, 0.61111, 0, 0, 0.525],\n    \"8217\": [0, 0.61111, 0, 0, 0.525],\n    \"8242\": [0, 0.61111, 0, 0, 0.525],\n    \"9251\": [0.11111, 0.21944, 0, 0, 0.525]\n  }\n};\n\n/**\n * This file contains metrics regarding fonts and individual symbols. The sigma\n * and xi variables, as well as the metricMap map contain data extracted from\n * TeX, TeX font metrics, and the TTF files. These data are then exposed via the\n * `metrics` variable and the getCharacterMetrics function.\n */\n// In TeX, there are actually three sets of dimensions, one for each of\n// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:\n// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are\n// provided in the the arrays below, in that order.\n//\n// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.\n// This was determined by running the following script:\n//\n//     latex -interaction=nonstopmode \\\n//     '\\documentclass{article}\\usepackage{amsmath}\\begin{document}' \\\n//     '$a$ \\expandafter\\show\\the\\textfont2' \\\n//     '\\expandafter\\show\\the\\scriptfont2' \\\n//     '\\expandafter\\show\\the\\scriptscriptfont2' \\\n//     '\\stop'\n//\n// The metrics themselves were retreived using the following commands:\n//\n//     tftopl cmsy10\n//     tftopl cmsy7\n//     tftopl cmsy5\n//\n// The output of each of these commands is quite lengthy.  The only part we\n// care about is the FONTDIMEN section. Each value is measured in EMs.\nvar sigmasAndXis = {\n  slant: [0.250, 0.250, 0.250],\n  // sigma1\n  space: [0.000, 0.000, 0.000],\n  // sigma2\n  stretch: [0.000, 0.000, 0.000],\n  // sigma3\n  shrink: [0.000, 0.000, 0.000],\n  // sigma4\n  xHeight: [0.431, 0.431, 0.431],\n  // sigma5\n  quad: [1.000, 1.171, 1.472],\n  // sigma6\n  extraSpace: [0.000, 0.000, 0.000],\n  // sigma7\n  num1: [0.677, 0.732, 0.925],\n  // sigma8\n  num2: [0.394, 0.384, 0.387],\n  // sigma9\n  num3: [0.444, 0.471, 0.504],\n  // sigma10\n  denom1: [0.686, 0.752, 1.025],\n  // sigma11\n  denom2: [0.345, 0.344, 0.532],\n  // sigma12\n  sup1: [0.413, 0.503, 0.504],\n  // sigma13\n  sup2: [0.363, 0.431, 0.404],\n  // sigma14\n  sup3: [0.289, 0.286, 0.294],\n  // sigma15\n  sub1: [0.150, 0.143, 0.200],\n  // sigma16\n  sub2: [0.247, 0.286, 0.400],\n  // sigma17\n  supDrop: [0.386, 0.353, 0.494],\n  // sigma18\n  subDrop: [0.050, 0.071, 0.100],\n  // sigma19\n  delim1: [2.390, 1.700, 1.980],\n  // sigma20\n  delim2: [1.010, 1.157, 1.420],\n  // sigma21\n  axisHeight: [0.250, 0.250, 0.250],\n  // sigma22\n  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;\n  // they correspond to the font parameters of the extension fonts (family 3).\n  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to\n  // match cmex7, we'd use cmex7.tfm values for script and scriptscript\n  // values.\n  defaultRuleThickness: [0.04, 0.049, 0.049],\n  // xi8; cmex7: 0.049\n  bigOpSpacing1: [0.111, 0.111, 0.111],\n  // xi9\n  bigOpSpacing2: [0.166, 0.166, 0.166],\n  // xi10\n  bigOpSpacing3: [0.2, 0.2, 0.2],\n  // xi11\n  bigOpSpacing4: [0.6, 0.611, 0.611],\n  // xi12; cmex7: 0.611\n  bigOpSpacing5: [0.1, 0.143, 0.143],\n  // xi13; cmex7: 0.143\n  // The \\sqrt rule width is taken from the height of the surd character.\n  // Since we use the same font at all sizes, this thickness doesn't scale.\n  sqrtRuleThickness: [0.04, 0.04, 0.04],\n  // This value determines how large a pt is, for metrics which are defined\n  // in terms of pts.\n  // This value is also used in katex.less; if you change it make sure the\n  // values match.\n  ptPerEm: [10.0, 10.0, 10.0],\n  // The space between adjacent `|` columns in an array definition. From\n  // `\\showthe\\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.\n  doubleRuleSep: [0.2, 0.2, 0.2],\n  // The width of separator lines in {array} environments. From\n  // `\\showthe\\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.\n  arrayRuleWidth: [0.04, 0.04, 0.04],\n  // Two values from LaTeX source2e:\n  fboxsep: [0.3, 0.3, 0.3],\n  //        3 pt / ptPerEm\n  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm\n\n}; // This map contains a mapping from font name and character code to character\n// should have Latin-1 and Cyrillic characters, but may not depending on the\n// operating system.  The metrics do not account for extra height from the\n// accents.  In the case of Cyrillic characters which have both ascenders and\n// descenders we prefer approximations with ascenders, primarily to prevent\n// the fraction bar or root line from intersecting the glyph.\n// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.\n\nvar extraCharacterMap = {\n  // Latin-1\n  'Å': 'A',\n  'Ð': 'D',\n  'Þ': 'o',\n  'å': 'a',\n  'ð': 'd',\n  'þ': 'o',\n  // Cyrillic\n  'А': 'A',\n  'Б': 'B',\n  'В': 'B',\n  'Г': 'F',\n  'Д': 'A',\n  'Е': 'E',\n  'Ж': 'K',\n  'З': '3',\n  'И': 'N',\n  'Й': 'N',\n  'К': 'K',\n  'Л': 'N',\n  'М': 'M',\n  'Н': 'H',\n  'О': 'O',\n  'П': 'N',\n  'Р': 'P',\n  'С': 'C',\n  'Т': 'T',\n  'У': 'y',\n  'Ф': 'O',\n  'Х': 'X',\n  'Ц': 'U',\n  'Ч': 'h',\n  'Ш': 'W',\n  'Щ': 'W',\n  'Ъ': 'B',\n  'Ы': 'X',\n  'Ь': 'B',\n  'Э': '3',\n  'Ю': 'X',\n  'Я': 'R',\n  'а': 'a',\n  'б': 'b',\n  'в': 'a',\n  'г': 'r',\n  'д': 'y',\n  'е': 'e',\n  'ж': 'm',\n  'з': 'e',\n  'и': 'n',\n  'й': 'n',\n  'к': 'n',\n  'л': 'n',\n  'м': 'm',\n  'н': 'n',\n  'о': 'o',\n  'п': 'n',\n  'р': 'p',\n  'с': 'c',\n  'т': 'o',\n  'у': 'y',\n  'ф': 'b',\n  'х': 'x',\n  'ц': 'n',\n  'ч': 'n',\n  'ш': 'w',\n  'щ': 'w',\n  'ъ': 'a',\n  'ы': 'm',\n  'ь': 'a',\n  'э': 'e',\n  'ю': 'm',\n  'я': 'r'\n};\n\n/**\n * This function adds new font metrics to default metricMap\n * It can also override existing metrics\n */\nfunction setFontMetrics(fontName, metrics) {\n  fontMetricsData[fontName] = metrics;\n}\n/**\n * This function is a convenience function for looking up information in the\n * metricMap table. It takes a character as a string, and a font.\n *\n * Note: the `width` property may be undefined if fontMetricsData.js wasn't\n * built using `Make extended_metrics`.\n */\n\nfunction getCharacterMetrics(character, font, mode) {\n  if (!fontMetricsData[font]) {\n    throw new Error(\"Font metrics not found for font: \" + font + \".\");\n  }\n\n  var ch = character.charCodeAt(0);\n  var metrics = fontMetricsData[font][ch];\n\n  if (!metrics && character[0] in extraCharacterMap) {\n    ch = extraCharacterMap[character[0]].charCodeAt(0);\n    metrics = fontMetricsData[font][ch];\n  }\n\n  if (!metrics && mode === 'text') {\n    // We don't typically have font metrics for Asian scripts.\n    // But since we support them in text mode, we need to return\n    // some sort of metrics.\n    // So if the character is in a script we support but we\n    // don't have metrics for it, just use the metrics for\n    // the Latin capital letter M. This is close enough because\n    // we (currently) only care about the height of the glpyh\n    // not its width.\n    if (supportedCodepoint(ch)) {\n      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'\n    }\n  }\n\n  if (metrics) {\n    return {\n      depth: metrics[0],\n      height: metrics[1],\n      italic: metrics[2],\n      skew: metrics[3],\n      width: metrics[4]\n    };\n  }\n}\nvar fontMetricsBySizeIndex = {};\n/**\n * Get the font metrics for a given size.\n */\n\nfunction getGlobalMetrics(size) {\n  var sizeIndex;\n\n  if (size >= 5) {\n    sizeIndex = 0;\n  } else if (size >= 3) {\n    sizeIndex = 1;\n  } else {\n    sizeIndex = 2;\n  }\n\n  if (!fontMetricsBySizeIndex[sizeIndex]) {\n    var metrics = fontMetricsBySizeIndex[sizeIndex] = {\n      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18\n    };\n\n    for (var key in sigmasAndXis) {\n      if (sigmasAndXis.hasOwnProperty(key)) {\n        metrics[key] = sigmasAndXis[key][sizeIndex];\n      }\n    }\n  }\n\n  return fontMetricsBySizeIndex[sizeIndex];\n}\n\n/**\n * This file contains information about the options that the Parser carries\n * around with it while parsing. Data is held in an `Options` object, and when\n * recursing, a new `Options` object can be created with the `.with*` and\n * `.reset` functions.\n */\nvar sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].\n// The size mappings are taken from TeX with \\normalsize=10pt.\n[1, 1, 1], // size1: [5, 5, 5]              \\tiny\n[2, 1, 1], // size2: [6, 5, 5]\n[3, 1, 1], // size3: [7, 5, 5]              \\scriptsize\n[4, 2, 1], // size4: [8, 6, 5]              \\footnotesize\n[5, 2, 1], // size5: [9, 6, 5]              \\small\n[6, 3, 1], // size6: [10, 7, 5]             \\normalsize\n[7, 4, 2], // size7: [12, 8, 6]             \\large\n[8, 6, 3], // size8: [14.4, 10, 7]          \\Large\n[9, 7, 6], // size9: [17.28, 12, 10]        \\LARGE\n[10, 8, 7], // size10: [20.74, 14.4, 12]     \\huge\n[11, 10, 9] // size11: [24.88, 20.74, 17.28] \\HUGE\n];\nvar sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if\n// you change size indexes, change that function.\n0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];\n\nvar sizeAtStyle = function sizeAtStyle(size, style) {\n  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];\n}; // In these types, \"\" (empty string) means \"no change\".\n\n\n/**\n * This is the main options class. It contains the current style, size, color,\n * and font.\n *\n * Options objects should not be modified. To create a new Options with\n * different properties, call a `.having*` method.\n */\nclass Options {\n  // A font family applies to a group of fonts (i.e. SansSerif), while a font\n  // represents a specific font (i.e. SansSerif Bold).\n  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm\n\n  /**\n   * The base size index.\n   */\n  constructor(data) {\n    this.style = void 0;\n    this.color = void 0;\n    this.size = void 0;\n    this.textSize = void 0;\n    this.phantom = void 0;\n    this.font = void 0;\n    this.fontFamily = void 0;\n    this.fontWeight = void 0;\n    this.fontShape = void 0;\n    this.sizeMultiplier = void 0;\n    this.maxSize = void 0;\n    this.minRuleThickness = void 0;\n    this._fontMetrics = void 0;\n    this.style = data.style;\n    this.color = data.color;\n    this.size = data.size || Options.BASESIZE;\n    this.textSize = data.textSize || this.size;\n    this.phantom = !!data.phantom;\n    this.font = data.font || \"\";\n    this.fontFamily = data.fontFamily || \"\";\n    this.fontWeight = data.fontWeight || '';\n    this.fontShape = data.fontShape || '';\n    this.sizeMultiplier = sizeMultipliers[this.size - 1];\n    this.maxSize = data.maxSize;\n    this.minRuleThickness = data.minRuleThickness;\n    this._fontMetrics = undefined;\n  }\n  /**\n   * Returns a new options object with the same properties as \"this\".  Properties\n   * from \"extension\" will be copied to the new options object.\n   */\n\n\n  extend(extension) {\n    var data = {\n      style: this.style,\n      size: this.size,\n      textSize: this.textSize,\n      color: this.color,\n      phantom: this.phantom,\n      font: this.font,\n      fontFamily: this.fontFamily,\n      fontWeight: this.fontWeight,\n      fontShape: this.fontShape,\n      maxSize: this.maxSize,\n      minRuleThickness: this.minRuleThickness\n    };\n\n    for (var key in extension) {\n      if (extension.hasOwnProperty(key)) {\n        data[key] = extension[key];\n      }\n    }\n\n    return new Options(data);\n  }\n  /**\n   * Return an options object with the given style. If `this.style === style`,\n   * returns `this`.\n   */\n\n\n  havingStyle(style) {\n    if (this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: sizeAtStyle(this.textSize, style)\n      });\n    }\n  }\n  /**\n   * Return an options object with a cramped version of the current style. If\n   * the current style is cramped, returns `this`.\n   */\n\n\n  havingCrampedStyle() {\n    return this.havingStyle(this.style.cramp());\n  }\n  /**\n   * Return an options object with the given size and in at least `\\textstyle`.\n   * Returns `this` if appropriate.\n   */\n\n\n  havingSize(size) {\n    if (this.size === size && this.textSize === size) {\n      return this;\n    } else {\n      return this.extend({\n        style: this.style.text(),\n        size: size,\n        textSize: size,\n        sizeMultiplier: sizeMultipliers[size - 1]\n      });\n    }\n  }\n  /**\n   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,\n   * changes to at least `\\textstyle`.\n   */\n\n\n  havingBaseStyle(style) {\n    style = style || this.style.text();\n    var wantSize = sizeAtStyle(Options.BASESIZE, style);\n\n    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: wantSize\n      });\n    }\n  }\n  /**\n   * Remove the effect of sizing changes such as \\Huge.\n   * Keep the effect of the current style, such as \\scriptstyle.\n   */\n\n\n  havingBaseSizing() {\n    var size;\n\n    switch (this.style.id) {\n      case 4:\n      case 5:\n        size = 3; // normalsize in scriptstyle\n\n        break;\n\n      case 6:\n      case 7:\n        size = 1; // normalsize in scriptscriptstyle\n\n        break;\n\n      default:\n        size = 6;\n      // normalsize in textstyle or displaystyle\n    }\n\n    return this.extend({\n      style: this.style.text(),\n      size: size\n    });\n  }\n  /**\n   * Create a new options object with the given color.\n   */\n\n\n  withColor(color) {\n    return this.extend({\n      color: color\n    });\n  }\n  /**\n   * Create a new options object with \"phantom\" set to true.\n   */\n\n\n  withPhantom() {\n    return this.extend({\n      phantom: true\n    });\n  }\n  /**\n   * Creates a new options object with the given math font or old text font.\n   * @type {[type]}\n   */\n\n\n  withFont(font) {\n    return this.extend({\n      font\n    });\n  }\n  /**\n   * Create a new options objects with the given fontFamily.\n   */\n\n\n  withTextFontFamily(fontFamily) {\n    return this.extend({\n      fontFamily,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontWeight(fontWeight) {\n    return this.extend({\n      fontWeight,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontShape(fontShape) {\n    return this.extend({\n      fontShape,\n      font: \"\"\n    });\n  }\n  /**\n   * Return the CSS sizing classes required to switch from enclosing options\n   * `oldOptions` to `this`. Returns an array of classes.\n   */\n\n\n  sizingClasses(oldOptions) {\n    if (oldOptions.size !== this.size) {\n      return [\"sizing\", \"reset-size\" + oldOptions.size, \"size\" + this.size];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the CSS sizing classes required to switch to the base size. Like\n   * `this.havingSize(BASESIZE).sizingClasses(this)`.\n   */\n\n\n  baseSizingClasses() {\n    if (this.size !== Options.BASESIZE) {\n      return [\"sizing\", \"reset-size\" + this.size, \"size\" + Options.BASESIZE];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the font metrics for this size.\n   */\n\n\n  fontMetrics() {\n    if (!this._fontMetrics) {\n      this._fontMetrics = getGlobalMetrics(this.size);\n    }\n\n    return this._fontMetrics;\n  }\n  /**\n   * Gets the CSS color of the current options object\n   */\n\n\n  getColor() {\n    if (this.phantom) {\n      return \"transparent\";\n    } else {\n      return this.color;\n    }\n  }\n\n}\n\nOptions.BASESIZE = 6;\n\n/**\n * This file does conversion between units.  In particular, it provides\n * calculateSize to convert other units into ems.\n */\n// Thus, multiplying a length by this number converts the length from units\n// into pts.  Dividing the result by ptPerEm gives the number of ems\n// *assuming* a font size of ptPerEm (normal size, normal style).\n\nvar ptPerUnit = {\n  // https://en.wikibooks.org/wiki/LaTeX/Lengths and\n  // https://tex.stackexchange.com/a/8263\n  \"pt\": 1,\n  // TeX point\n  \"mm\": 7227 / 2540,\n  // millimeter\n  \"cm\": 7227 / 254,\n  // centimeter\n  \"in\": 72.27,\n  // inch\n  \"bp\": 803 / 800,\n  // big (PostScript) points\n  \"pc\": 12,\n  // pica\n  \"dd\": 1238 / 1157,\n  // didot\n  \"cc\": 14856 / 1157,\n  // cicero (12 didot)\n  \"nd\": 685 / 642,\n  // new didot\n  \"nc\": 1370 / 107,\n  // new cicero (12 new didot)\n  \"sp\": 1 / 65536,\n  // scaled point (TeX's internal smallest unit)\n  // https://tex.stackexchange.com/a/41371\n  \"px\": 803 / 800 // \\pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX\n\n}; // Dictionary of relative units, for fast validity testing.\n\nvar relativeUnit = {\n  \"ex\": true,\n  \"em\": true,\n  \"mu\": true\n};\n\n/**\n * Determine whether the specified unit (either a string defining the unit\n * or a \"size\" parse node containing a unit field) is valid.\n */\nvar validUnit = function validUnit(unit) {\n  if (typeof unit !== \"string\") {\n    unit = unit.unit;\n  }\n\n  return unit in ptPerUnit || unit in relativeUnit || unit === \"ex\";\n};\n/*\n * Convert a \"size\" parse node (with numeric \"number\" and string \"unit\" fields,\n * as parsed by functions.js argType \"size\") into a CSS em value for the\n * current style/scale.  `options` gives the current options.\n */\n\nvar calculateSize = function calculateSize(sizeValue, options) {\n  var scale;\n\n  if (sizeValue.unit in ptPerUnit) {\n    // Absolute units\n    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt\n    / options.fontMetrics().ptPerEm // Convert pt to CSS em\n    / options.sizeMultiplier; // Unscale to make absolute units\n  } else if (sizeValue.unit === \"mu\") {\n    // `mu` units scale with scriptstyle/scriptscriptstyle.\n    scale = options.fontMetrics().cssEmPerMu;\n  } else {\n    // Other relative units always refer to the *textstyle* font\n    // in the current size.\n    var unitOptions;\n\n    if (options.style.isTight()) {\n      // isTight() means current style is script/scriptscript.\n      unitOptions = options.havingStyle(options.style.text());\n    } else {\n      unitOptions = options;\n    } // TODO: In TeX these units are relative to the quad of the current\n    // *text* font, e.g. cmr10. KaTeX instead uses values from the\n    // comparably-sized *Computer Modern symbol* font. At 10pt, these\n    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;\n    // cmr5=1.361133, cmsy5=1.472241. Consider $\\scriptsize a\\kern1emb$.\n    // TeX \\showlists shows a kern of 1.13889 * fontsize;\n    // KaTeX shows a kern of 1.171 * fontsize.\n\n\n    if (sizeValue.unit === \"ex\") {\n      scale = unitOptions.fontMetrics().xHeight;\n    } else if (sizeValue.unit === \"em\") {\n      scale = unitOptions.fontMetrics().quad;\n    } else {\n      throw new ParseError(\"Invalid unit: '\" + sizeValue.unit + \"'\");\n    }\n\n    if (unitOptions !== options) {\n      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;\n    }\n  }\n\n  return Math.min(sizeValue.number * scale, options.maxSize);\n};\n/**\n * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See\n * https://github.com/KaTeX/KaTeX/pull/2460.\n */\n\nvar makeEm = function makeEm(n) {\n  return +n.toFixed(4) + \"em\";\n};\n\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nvar createClass = function createClass(classes) {\n  return classes.filter(cls => cls).join(\" \");\n};\n\nvar initNode = function initNode(classes, options, style) {\n  this.classes = classes || [];\n  this.attributes = {};\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = style || {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      this.style.color = color;\n    }\n  }\n};\n/**\n * Convert into an HTML node\n */\n\n\nvar toNode = function toNode(tagName) {\n  var node = document.createElement(tagName); // Apply the class\n\n  node.className = createClass(this.classes); // Apply inline styles\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      // $FlowFixMe Flow doesn't seem to understand span.style's type.\n      node.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * Convert into an HTML markup string\n */\n\n\nvar toMarkup = function toMarkup(tagName) {\n  var markup = \"<\" + tagName; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n  }\n\n  var styles = \"\"; // Add the styles, after hyphenation\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + tagName + \">\";\n  return markup;\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nclass Span {\n  constructor(classes, children, options, style) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options, style);\n    this.children = children || [];\n  }\n  /**\n   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n   * all browsers support attributes the same, and having too many custom\n   * attributes is probably bad.\n   */\n\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"span\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"span\");\n  }\n\n}\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\n\nclass Anchor {\n  constructor(href, classes, children, options) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options);\n    this.children = children || [];\n    this.setAttribute('href', href);\n  }\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"a\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"a\");\n  }\n\n}\n/**\n * This node represents an image embed (<img>) element.\n */\n\nclass Img {\n  constructor(src, alt, style) {\n    this.src = void 0;\n    this.alt = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.alt = alt;\n    this.src = src;\n    this.classes = [\"mord\"];\n    this.style = style;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    var node = document.createElement(\"img\");\n    node.src = this.src;\n    node.alt = this.alt;\n    node.className = \"mord\"; // Apply inline styles\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        // $FlowFixMe\n        node.style[style] = this.style[style];\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<img  src='\" + this.src + \" 'alt='\" + this.alt + \"' \"; // Add the styles, after hyphenation\n\n    var styles = \"\";\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    markup += \"'/>\";\n    return markup;\n  }\n\n}\nvar iCombinations = {\n  'î': '\\u0131\\u0302',\n  'ï': '\\u0131\\u0308',\n  'í': '\\u0131\\u0301',\n  // 'ī': '\\u0131\\u0304', // enable when we add Extended Latin\n  'ì': '\\u0131\\u0300'\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nclass SymbolNode {\n  constructor(text, height, depth, italic, skew, width, classes, style) {\n    this.text = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.italic = void 0;\n    this.skew = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.classes = void 0;\n    this.style = void 0;\n    this.text = text;\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.width = width || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we\n    // can specify which fonts to use.  This allows us to render these\n    // characters with a serif font in situations where the browser would\n    // either default to a sans serif or render a placeholder character.\n    // We use CSS class names like cjk_fallback, hangul_fallback and\n    // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n    // script names\n\n    var script = scriptFromCodepoint(this.text.charCodeAt(0));\n\n    if (script) {\n      this.classes.push(script + \"_fallback\");\n    }\n\n    if (/[îïíì]/.test(this.text)) {\n      // add ī when we add Extended Latin\n      this.text = iCombinations[this.text];\n    }\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /**\n   * Creates a text node or span from a symbol node. Note that a span is only\n   * created if it is needed.\n   */\n\n\n  toNode() {\n    var node = document.createTextNode(this.text);\n    var span = null;\n\n    if (this.italic > 0) {\n      span = document.createElement(\"span\");\n      span.style.marginRight = makeEm(this.italic);\n    }\n\n    if (this.classes.length > 0) {\n      span = span || document.createElement(\"span\");\n      span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        span = span || document.createElement(\"span\"); // $FlowFixMe Flow doesn't seem to understand span.style's type.\n\n        span.style[style] = this.style[style];\n      }\n    }\n\n    if (span) {\n      span.appendChild(node);\n      return span;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * Creates markup for a symbol node.\n   */\n\n\n  toMarkup() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n      needsSpan = true;\n      markup += \" class=\\\"\";\n      markup += utils.escape(createClass(this.classes));\n      markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n      styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      needsSpan = true;\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.text);\n\n    if (needsSpan) {\n      markup += \">\";\n      markup += escaped;\n      markup += \"</span>\";\n      return markup;\n    } else {\n      return escaped;\n    }\n  }\n\n}\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\n\nclass SvgNode {\n  constructor(children, attributes) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.children = children || [];\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"svg\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"; // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"='\" + this.attributes[attr] + \"'\";\n      }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</svg>\";\n    return markup;\n  }\n\n}\nclass PathNode {\n  constructor(pathName, alternate) {\n    this.pathName = void 0;\n    this.alternate = void 0;\n    this.pathName = pathName;\n    this.alternate = alternate; // Used only for \\sqrt, \\phase, & tall delims\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"path\");\n\n    if (this.alternate) {\n      node.setAttribute(\"d\", this.alternate);\n    } else {\n      node.setAttribute(\"d\", path[this.pathName]);\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    if (this.alternate) {\n      return \"<path d='\" + this.alternate + \"'/>\";\n    } else {\n      return \"<path d='\" + path[this.pathName] + \"'/>\";\n    }\n  }\n\n}\nclass LineNode {\n  constructor(attributes) {\n    this.attributes = void 0;\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"line\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<line\";\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"='\" + this.attributes[attr] + \"'\";\n      }\n    }\n\n    markup += \"/>\";\n    return markup;\n  }\n\n}\nfunction assertSymbolDomNode(group) {\n  if (group instanceof SymbolNode) {\n    return group;\n  } else {\n    throw new Error(\"Expected symbolNode but got \" + String(group) + \".\");\n  }\n}\nfunction assertSpan(group) {\n  if (group instanceof Span) {\n    return group;\n  } else {\n    throw new Error(\"Expected span<HtmlDomNode> but got \" + String(group) + \".\");\n  }\n}\n\n/**\n * This file holds a list of all no-argument functions and single-character\n * symbols (like 'a' or ';').\n *\n * For each of the symbols, there are three properties they can have:\n * - font (required): the font to be used for this symbol. Either \"main\" (the\n     normal font), or \"ams\" (the ams fonts).\n * - group (required): the ParseNode group type the symbol should have (i.e.\n     \"textord\", \"mathord\", etc).\n     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types\n * - replace: the character that this symbol or function should be\n *   replaced with (i.e. \"\\phi\" has a replace value of \"\\u03d5\", the phi\n *   character in the main font).\n *\n * The outermost map in the table indicates what mode the symbols should be\n * accepted in (e.g. \"math\" or \"text\").\n */\n// Some of these have a \"-token\" suffix since these are also used as `ParseNode`\n// types for raw text tokens, and we want to avoid conflicts with higher-level\n// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by\n// looking up the `symbols` map.\nvar ATOMS = {\n  \"bin\": 1,\n  \"close\": 1,\n  \"inner\": 1,\n  \"open\": 1,\n  \"punct\": 1,\n  \"rel\": 1\n};\nvar NON_ATOMS = {\n  \"accent-token\": 1,\n  \"mathord\": 1,\n  \"op-token\": 1,\n  \"spacing\": 1,\n  \"textord\": 1\n};\nvar symbols = {\n  \"math\": {},\n  \"text\": {}\n};\n/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */\n\nfunction defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {\n  symbols[mode][name] = {\n    font,\n    group,\n    replace\n  };\n\n  if (acceptUnicodeChar && replace) {\n    symbols[mode][replace] = symbols[mode][name];\n  }\n} // Some abbreviations for commonly used strings.\n// This helps minify the code, and also spotting typos using jshint.\n// modes:\n\nvar math = \"math\";\nvar text = \"text\"; // fonts:\n\nvar main = \"main\";\nvar ams = \"ams\"; // groups:\n\nvar accent = \"accent-token\";\nvar bin = \"bin\";\nvar close = \"close\";\nvar inner = \"inner\";\nvar mathord = \"mathord\";\nvar op = \"op-token\";\nvar open = \"open\";\nvar punct = \"punct\";\nvar rel = \"rel\";\nvar spacing = \"spacing\";\nvar textord = \"textord\"; // Now comes the symbol table\n// Relation Symbols\n\ndefineSymbol(math, main, rel, \"\\u2261\", \"\\\\equiv\", true);\ndefineSymbol(math, main, rel, \"\\u227a\", \"\\\\prec\", true);\ndefineSymbol(math, main, rel, \"\\u227b\", \"\\\\succ\", true);\ndefineSymbol(math, main, rel, \"\\u223c\", \"\\\\sim\", true);\ndefineSymbol(math, main, rel, \"\\u22a5\", \"\\\\perp\");\ndefineSymbol(math, main, rel, \"\\u2aaf\", \"\\\\preceq\", true);\ndefineSymbol(math, main, rel, \"\\u2ab0\", \"\\\\succeq\", true);\ndefineSymbol(math, main, rel, \"\\u2243\", \"\\\\simeq\", true);\ndefineSymbol(math, main, rel, \"\\u2223\", \"\\\\mid\", true);\ndefineSymbol(math, main, rel, \"\\u226a\", \"\\\\ll\", true);\ndefineSymbol(math, main, rel, \"\\u226b\", \"\\\\gg\", true);\ndefineSymbol(math, main, rel, \"\\u224d\", \"\\\\asymp\", true);\ndefineSymbol(math, main, rel, \"\\u2225\", \"\\\\parallel\");\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\bowtie\", true);\ndefineSymbol(math, main, rel, \"\\u2323\", \"\\\\smile\", true);\ndefineSymbol(math, main, rel, \"\\u2291\", \"\\\\sqsubseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2292\", \"\\\\sqsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2250\", \"\\\\doteq\", true);\ndefineSymbol(math, main, rel, \"\\u2322\", \"\\\\frown\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\ni\", true);\ndefineSymbol(math, main, rel, \"\\u221d\", \"\\\\propto\", true);\ndefineSymbol(math, main, rel, \"\\u22a2\", \"\\\\vdash\", true);\ndefineSymbol(math, main, rel, \"\\u22a3\", \"\\\\dashv\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\owns\"); // Punctuation\n\ndefineSymbol(math, main, punct, \"\\u002e\", \"\\\\ldotp\");\ndefineSymbol(math, main, punct, \"\\u22c5\", \"\\\\cdotp\"); // Misc Symbols\n\ndefineSymbol(math, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(text, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(math, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(text, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(math, main, textord, \"\\u2135\", \"\\\\aleph\", true);\ndefineSymbol(math, main, textord, \"\\u2200\", \"\\\\forall\", true);\ndefineSymbol(math, main, textord, \"\\u210f\", \"\\\\hbar\", true);\ndefineSymbol(math, main, textord, \"\\u2203\", \"\\\\exists\", true);\ndefineSymbol(math, main, textord, \"\\u2207\", \"\\\\nabla\", true);\ndefineSymbol(math, main, textord, \"\\u266d\", \"\\\\flat\", true);\ndefineSymbol(math, main, textord, \"\\u2113\", \"\\\\ell\", true);\ndefineSymbol(math, main, textord, \"\\u266e\", \"\\\\natural\", true);\ndefineSymbol(math, main, textord, \"\\u2663\", \"\\\\clubsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2118\", \"\\\\wp\", true);\ndefineSymbol(math, main, textord, \"\\u266f\", \"\\\\sharp\", true);\ndefineSymbol(math, main, textord, \"\\u2662\", \"\\\\diamondsuit\", true);\ndefineSymbol(math, main, textord, \"\\u211c\", \"\\\\Re\", true);\ndefineSymbol(math, main, textord, \"\\u2661\", \"\\\\heartsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2111\", \"\\\\Im\", true);\ndefineSymbol(math, main, textord, \"\\u2660\", \"\\\\spadesuit\", true);\ndefineSymbol(math, main, textord, \"\\u00a7\", \"\\\\S\", true);\ndefineSymbol(text, main, textord, \"\\u00a7\", \"\\\\S\");\ndefineSymbol(math, main, textord, \"\\u00b6\", \"\\\\P\", true);\ndefineSymbol(text, main, textord, \"\\u00b6\", \"\\\\P\"); // Math and Text\n\ndefineSymbol(math, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\textdagger\");\ndefineSymbol(math, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\textdaggerdbl\"); // Large Delimiters\n\ndefineSymbol(math, main, close, \"\\u23b1\", \"\\\\rmoustache\", true);\ndefineSymbol(math, main, open, \"\\u23b0\", \"\\\\lmoustache\", true);\ndefineSymbol(math, main, close, \"\\u27ef\", \"\\\\rgroup\", true);\ndefineSymbol(math, main, open, \"\\u27ee\", \"\\\\lgroup\", true); // Binary Operators\n\ndefineSymbol(math, main, bin, \"\\u2213\", \"\\\\mp\", true);\ndefineSymbol(math, main, bin, \"\\u2296\", \"\\\\ominus\", true);\ndefineSymbol(math, main, bin, \"\\u228e\", \"\\\\uplus\", true);\ndefineSymbol(math, main, bin, \"\\u2293\", \"\\\\sqcap\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"\\\\ast\");\ndefineSymbol(math, main, bin, \"\\u2294\", \"\\\\sqcup\", true);\ndefineSymbol(math, main, bin, \"\\u25ef\", \"\\\\bigcirc\", true);\ndefineSymbol(math, main, bin, \"\\u2219\", \"\\\\bullet\", true);\ndefineSymbol(math, main, bin, \"\\u2021\", \"\\\\ddagger\");\ndefineSymbol(math, main, bin, \"\\u2240\", \"\\\\wr\", true);\ndefineSymbol(math, main, bin, \"\\u2a3f\", \"\\\\amalg\");\ndefineSymbol(math, main, bin, \"\\u0026\", \"\\\\And\"); // from amsmath\n// Arrow Symbols\n\ndefineSymbol(math, main, rel, \"\\u27f5\", \"\\\\longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d0\", \"\\\\Leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f8\", \"\\\\Longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f6\", \"\\\\longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d2\", \"\\\\Rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f9\", \"\\\\Longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2194\", \"\\\\leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f7\", \"\\\\longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d4\", \"\\\\Leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27fa\", \"\\\\Longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a6\", \"\\\\mapsto\", true);\ndefineSymbol(math, main, rel, \"\\u27fc\", \"\\\\longmapsto\", true);\ndefineSymbol(math, main, rel, \"\\u2197\", \"\\\\nearrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a9\", \"\\\\hookleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21aa\", \"\\\\hookrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2198\", \"\\\\searrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bc\", \"\\\\leftharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u21c0\", \"\\\\rightharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u2199\", \"\\\\swarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bd\", \"\\\\leftharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u21c1\", \"\\\\rightharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u2196\", \"\\\\nwarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21cc\", \"\\\\rightleftharpoons\", true); // AMS Negated Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u226e\", \"\\\\nless\", true); // Symbol names preceeded by \"@\" each have a corresponding macro.\n\ndefineSymbol(math, ams, rel, \"\\ue010\", \"\\\\@nleqslant\");\ndefineSymbol(math, ams, rel, \"\\ue011\", \"\\\\@nleqq\");\ndefineSymbol(math, ams, rel, \"\\u2a87\", \"\\\\lneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2268\", \"\\\\lneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00c\", \"\\\\@lvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e6\", \"\\\\lnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a89\", \"\\\\lnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2280\", \"\\\\nprec\", true); // unicode-math maps \\u22e0 to \\npreccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e0\", \"\\\\npreceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e8\", \"\\\\precnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab9\", \"\\\\precnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2241\", \"\\\\nsim\", true);\ndefineSymbol(math, ams, rel, \"\\ue006\", \"\\\\@nshortmid\");\ndefineSymbol(math, ams, rel, \"\\u2224\", \"\\\\nmid\", true);\ndefineSymbol(math, ams, rel, \"\\u22ac\", \"\\\\nvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ad\", \"\\\\nvDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ea\", \"\\\\ntriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22ec\", \"\\\\ntrianglelefteq\", true);\ndefineSymbol(math, ams, rel, \"\\u228a\", \"\\\\subsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01a\", \"\\\\@varsubsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acb\", \"\\\\subsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue017\", \"\\\\@varsubsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u226f\", \"\\\\ngtr\", true);\ndefineSymbol(math, ams, rel, \"\\ue00f\", \"\\\\@ngeqslant\");\ndefineSymbol(math, ams, rel, \"\\ue00e\", \"\\\\@ngeqq\");\ndefineSymbol(math, ams, rel, \"\\u2a88\", \"\\\\gneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2269\", \"\\\\gneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00d\", \"\\\\@gvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e7\", \"\\\\gnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8a\", \"\\\\gnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2281\", \"\\\\nsucc\", true); // unicode-math maps \\u22e1 to \\nsucccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e1\", \"\\\\nsucceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e9\", \"\\\\succnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2aba\", \"\\\\succnapprox\", true); // unicode-math maps \\u2246 to \\simneqq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u2246\", \"\\\\ncong\", true);\ndefineSymbol(math, ams, rel, \"\\ue007\", \"\\\\@nshortparallel\");\ndefineSymbol(math, ams, rel, \"\\u2226\", \"\\\\nparallel\", true);\ndefineSymbol(math, ams, rel, \"\\u22af\", \"\\\\nVDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22eb\", \"\\\\ntriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22ed\", \"\\\\ntrianglerighteq\", true);\ndefineSymbol(math, ams, rel, \"\\ue018\", \"\\\\@nsupseteqq\");\ndefineSymbol(math, ams, rel, \"\\u228b\", \"\\\\supsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01b\", \"\\\\@varsupsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acc\", \"\\\\supsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue019\", \"\\\\@varsupsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u22ae\", \"\\\\nVdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab5\", \"\\\\precneqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab6\", \"\\\\succneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue016\", \"\\\\@nsubseteqq\");\ndefineSymbol(math, ams, bin, \"\\u22b4\", \"\\\\unlhd\");\ndefineSymbol(math, ams, bin, \"\\u22b5\", \"\\\\unrhd\"); // AMS Negated Arrows\n\ndefineSymbol(math, ams, rel, \"\\u219a\", \"\\\\nleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219b\", \"\\\\nrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cd\", \"\\\\nLeftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cf\", \"\\\\nRightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ae\", \"\\\\nleftrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ce\", \"\\\\nLeftrightarrow\", true); // AMS Misc\n\ndefineSymbol(math, ams, rel, \"\\u25b3\", \"\\\\vartriangle\");\ndefineSymbol(math, ams, textord, \"\\u210f\", \"\\\\hslash\");\ndefineSymbol(math, ams, textord, \"\\u25bd\", \"\\\\triangledown\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\lozenge\");\ndefineSymbol(math, ams, textord, \"\\u24c8\", \"\\\\circledS\");\ndefineSymbol(math, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(text, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(math, ams, textord, \"\\u2221\", \"\\\\measuredangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2204\", \"\\\\nexists\");\ndefineSymbol(math, ams, textord, \"\\u2127\", \"\\\\mho\");\ndefineSymbol(math, ams, textord, \"\\u2132\", \"\\\\Finv\", true);\ndefineSymbol(math, ams, textord, \"\\u2141\", \"\\\\Game\", true);\ndefineSymbol(math, ams, textord, \"\\u2035\", \"\\\\backprime\");\ndefineSymbol(math, ams, textord, \"\\u25b2\", \"\\\\blacktriangle\");\ndefineSymbol(math, ams, textord, \"\\u25bc\", \"\\\\blacktriangledown\");\ndefineSymbol(math, ams, textord, \"\\u25a0\", \"\\\\blacksquare\");\ndefineSymbol(math, ams, textord, \"\\u29eb\", \"\\\\blacklozenge\");\ndefineSymbol(math, ams, textord, \"\\u2605\", \"\\\\bigstar\");\ndefineSymbol(math, ams, textord, \"\\u2222\", \"\\\\sphericalangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2201\", \"\\\\complement\", true); // unicode-math maps U+F0 to \\matheth. We map to AMS function \\eth\n\ndefineSymbol(math, ams, textord, \"\\u00f0\", \"\\\\eth\", true);\ndefineSymbol(text, main, textord, \"\\u00f0\", \"\\u00f0\");\ndefineSymbol(math, ams, textord, \"\\u2571\", \"\\\\diagup\");\ndefineSymbol(math, ams, textord, \"\\u2572\", \"\\\\diagdown\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\square\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\Box\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\Diamond\"); // unicode-math maps U+A5 to \\mathyen. We map to AMS function \\yen\n\ndefineSymbol(math, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(text, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(math, ams, textord, \"\\u2713\", \"\\\\checkmark\", true);\ndefineSymbol(text, ams, textord, \"\\u2713\", \"\\\\checkmark\"); // AMS Hebrew\n\ndefineSymbol(math, ams, textord, \"\\u2136\", \"\\\\beth\", true);\ndefineSymbol(math, ams, textord, \"\\u2138\", \"\\\\daleth\", true);\ndefineSymbol(math, ams, textord, \"\\u2137\", \"\\\\gimel\", true); // AMS Greek\n\ndefineSymbol(math, ams, textord, \"\\u03dd\", \"\\\\digamma\", true);\ndefineSymbol(math, ams, textord, \"\\u03f0\", \"\\\\varkappa\"); // AMS Delimiters\n\ndefineSymbol(math, ams, open, \"\\u250c\", \"\\\\@ulcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2510\", \"\\\\@urcorner\", true);\ndefineSymbol(math, ams, open, \"\\u2514\", \"\\\\@llcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2518\", \"\\\\@lrcorner\", true); // AMS Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u2266\", \"\\\\leqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7d\", \"\\\\leqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a95\", \"\\\\eqslantless\", true);\ndefineSymbol(math, ams, rel, \"\\u2272\", \"\\\\lesssim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a85\", \"\\\\lessapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u224a\", \"\\\\approxeq\", true);\ndefineSymbol(math, ams, bin, \"\\u22d6\", \"\\\\lessdot\");\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\lll\", true);\ndefineSymbol(math, ams, rel, \"\\u2276\", \"\\\\lessgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u22da\", \"\\\\lesseqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8b\", \"\\\\lesseqqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\doteqdot\");\ndefineSymbol(math, ams, rel, \"\\u2253\", \"\\\\risingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u2252\", \"\\\\fallingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u223d\", \"\\\\backsim\", true);\ndefineSymbol(math, ams, rel, \"\\u22cd\", \"\\\\backsimeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ac5\", \"\\\\subseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d0\", \"\\\\Subset\", true);\ndefineSymbol(math, ams, rel, \"\\u228f\", \"\\\\sqsubset\", true);\ndefineSymbol(math, ams, rel, \"\\u227c\", \"\\\\preccurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22de\", \"\\\\curlyeqprec\", true);\ndefineSymbol(math, ams, rel, \"\\u227e\", \"\\\\precsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab7\", \"\\\\precapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b2\", \"\\\\vartriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22b4\", \"\\\\trianglelefteq\");\ndefineSymbol(math, ams, rel, \"\\u22a8\", \"\\\\vDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22aa\", \"\\\\Vvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2323\", \"\\\\smallsmile\");\ndefineSymbol(math, ams, rel, \"\\u2322\", \"\\\\smallfrown\");\ndefineSymbol(math, ams, rel, \"\\u224f\", \"\\\\bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u224e\", \"\\\\Bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2267\", \"\\\\geqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7e\", \"\\\\geqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a96\", \"\\\\eqslantgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2273\", \"\\\\gtrsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a86\", \"\\\\gtrapprox\", true);\ndefineSymbol(math, ams, bin, \"\\u22d7\", \"\\\\gtrdot\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\ggg\", true);\ndefineSymbol(math, ams, rel, \"\\u2277\", \"\\\\gtrless\", true);\ndefineSymbol(math, ams, rel, \"\\u22db\", \"\\\\gtreqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8c\", \"\\\\gtreqqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2256\", \"\\\\eqcirc\", true);\ndefineSymbol(math, ams, rel, \"\\u2257\", \"\\\\circeq\", true);\ndefineSymbol(math, ams, rel, \"\\u225c\", \"\\\\triangleq\", true);\ndefineSymbol(math, ams, rel, \"\\u223c\", \"\\\\thicksim\");\ndefineSymbol(math, ams, rel, \"\\u2248\", \"\\\\thickapprox\");\ndefineSymbol(math, ams, rel, \"\\u2ac6\", \"\\\\supseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d1\", \"\\\\Supset\", true);\ndefineSymbol(math, ams, rel, \"\\u2290\", \"\\\\sqsupset\", true);\ndefineSymbol(math, ams, rel, \"\\u227d\", \"\\\\succcurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22df\", \"\\\\curlyeqsucc\", true);\ndefineSymbol(math, ams, rel, \"\\u227f\", \"\\\\succsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab8\", \"\\\\succapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b3\", \"\\\\vartriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22b5\", \"\\\\trianglerighteq\");\ndefineSymbol(math, ams, rel, \"\\u22a9\", \"\\\\Vdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2223\", \"\\\\shortmid\");\ndefineSymbol(math, ams, rel, \"\\u2225\", \"\\\\shortparallel\");\ndefineSymbol(math, ams, rel, \"\\u226c\", \"\\\\between\", true);\ndefineSymbol(math, ams, rel, \"\\u22d4\", \"\\\\pitchfork\", true);\ndefineSymbol(math, ams, rel, \"\\u221d\", \"\\\\varpropto\");\ndefineSymbol(math, ams, rel, \"\\u25c0\", \"\\\\blacktriangleleft\"); // unicode-math says that \\therefore is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2234\", \"\\\\therefore\", true);\ndefineSymbol(math, ams, rel, \"\\u220d\", \"\\\\backepsilon\");\ndefineSymbol(math, ams, rel, \"\\u25b6\", \"\\\\blacktriangleright\"); // unicode-math says that \\because is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2235\", \"\\\\because\", true);\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\llless\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\gggtr\");\ndefineSymbol(math, ams, bin, \"\\u22b2\", \"\\\\lhd\");\ndefineSymbol(math, ams, bin, \"\\u22b3\", \"\\\\rhd\");\ndefineSymbol(math, ams, rel, \"\\u2242\", \"\\\\eqsim\", true);\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\Join\");\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\Doteq\", true); // AMS Binary Operators\n\ndefineSymbol(math, ams, bin, \"\\u2214\", \"\\\\dotplus\", true);\ndefineSymbol(math, ams, bin, \"\\u2216\", \"\\\\smallsetminus\");\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\Cap\", true);\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\Cup\", true);\ndefineSymbol(math, ams, bin, \"\\u2a5e\", \"\\\\doublebarwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u229f\", \"\\\\boxminus\", true);\ndefineSymbol(math, ams, bin, \"\\u229e\", \"\\\\boxplus\", true);\ndefineSymbol(math, ams, bin, \"\\u22c7\", \"\\\\divideontimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22c9\", \"\\\\ltimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22ca\", \"\\\\rtimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cb\", \"\\\\leftthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cc\", \"\\\\rightthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cf\", \"\\\\curlywedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22ce\", \"\\\\curlyvee\", true);\ndefineSymbol(math, ams, bin, \"\\u229d\", \"\\\\circleddash\", true);\ndefineSymbol(math, ams, bin, \"\\u229b\", \"\\\\circledast\", true);\ndefineSymbol(math, ams, bin, \"\\u22c5\", \"\\\\centerdot\");\ndefineSymbol(math, ams, bin, \"\\u22ba\", \"\\\\intercal\", true);\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\doublecap\");\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\doublecup\");\ndefineSymbol(math, ams, bin, \"\\u22a0\", \"\\\\boxtimes\", true); // AMS Arrows\n// Note: unicode-math maps \\u21e2 to their own function \\rightdasharrow.\n// We'll map it to AMS function \\dashrightarrow. It produces the same atom.\n\ndefineSymbol(math, ams, rel, \"\\u21e2\", \"\\\\dashrightarrow\", true); // unicode-math maps \\u21e0 to \\leftdasharrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21e0\", \"\\\\dashleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c7\", \"\\\\leftleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c6\", \"\\\\leftrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21da\", \"\\\\Lleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219e\", \"\\\\twoheadleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a2\", \"\\\\leftarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ab\", \"\\\\looparrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21cb\", \"\\\\leftrightharpoons\", true);\ndefineSymbol(math, ams, rel, \"\\u21b6\", \"\\\\curvearrowleft\", true); // unicode-math maps \\u21ba to \\acwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21ba\", \"\\\\circlearrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21b0\", \"\\\\Lsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21c8\", \"\\\\upuparrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21bf\", \"\\\\upharpoonleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21c3\", \"\\\\downharpoonleft\", true);\ndefineSymbol(math, main, rel, \"\\u22b6\", \"\\\\origof\", true); // not in font\n\ndefineSymbol(math, main, rel, \"\\u22b7\", \"\\\\imageof\", true); // not in font\n\ndefineSymbol(math, ams, rel, \"\\u22b8\", \"\\\\multimap\", true);\ndefineSymbol(math, ams, rel, \"\\u21ad\", \"\\\\leftrightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c9\", \"\\\\rightrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c4\", \"\\\\rightleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21a0\", \"\\\\twoheadrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a3\", \"\\\\rightarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ac\", \"\\\\looparrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b7\", \"\\\\curvearrowright\", true); // unicode-math maps \\u21bb to \\cwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21bb\", \"\\\\circlearrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b1\", \"\\\\Rsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21ca\", \"\\\\downdownarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\upharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21c2\", \"\\\\downharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\rightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\leadsto\");\ndefineSymbol(math, ams, rel, \"\\u21db\", \"\\\\Rrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\restriction\");\ndefineSymbol(math, main, textord, \"\\u2018\", \"`\");\ndefineSymbol(math, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\textdollar\");\ndefineSymbol(math, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(text, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(math, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\textunderscore\");\ndefineSymbol(math, main, textord, \"\\u2220\", \"\\\\angle\", true);\ndefineSymbol(math, main, textord, \"\\u221e\", \"\\\\infty\", true);\ndefineSymbol(math, main, textord, \"\\u2032\", \"\\\\prime\");\ndefineSymbol(math, main, textord, \"\\u25b3\", \"\\\\triangle\");\ndefineSymbol(math, main, textord, \"\\u0393\", \"\\\\Gamma\", true);\ndefineSymbol(math, main, textord, \"\\u0394\", \"\\\\Delta\", true);\ndefineSymbol(math, main, textord, \"\\u0398\", \"\\\\Theta\", true);\ndefineSymbol(math, main, textord, \"\\u039b\", \"\\\\Lambda\", true);\ndefineSymbol(math, main, textord, \"\\u039e\", \"\\\\Xi\", true);\ndefineSymbol(math, main, textord, \"\\u03a0\", \"\\\\Pi\", true);\ndefineSymbol(math, main, textord, \"\\u03a3\", \"\\\\Sigma\", true);\ndefineSymbol(math, main, textord, \"\\u03a5\", \"\\\\Upsilon\", true);\ndefineSymbol(math, main, textord, \"\\u03a6\", \"\\\\Phi\", true);\ndefineSymbol(math, main, textord, \"\\u03a8\", \"\\\\Psi\", true);\ndefineSymbol(math, main, textord, \"\\u03a9\", \"\\\\Omega\", true);\ndefineSymbol(math, main, textord, \"A\", \"\\u0391\");\ndefineSymbol(math, main, textord, \"B\", \"\\u0392\");\ndefineSymbol(math, main, textord, \"E\", \"\\u0395\");\ndefineSymbol(math, main, textord, \"Z\", \"\\u0396\");\ndefineSymbol(math, main, textord, \"H\", \"\\u0397\");\ndefineSymbol(math, main, textord, \"I\", \"\\u0399\");\ndefineSymbol(math, main, textord, \"K\", \"\\u039A\");\ndefineSymbol(math, main, textord, \"M\", \"\\u039C\");\ndefineSymbol(math, main, textord, \"N\", \"\\u039D\");\ndefineSymbol(math, main, textord, \"O\", \"\\u039F\");\ndefineSymbol(math, main, textord, \"P\", \"\\u03A1\");\ndefineSymbol(math, main, textord, \"T\", \"\\u03A4\");\ndefineSymbol(math, main, textord, \"X\", \"\\u03A7\");\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\neg\", true);\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\lnot\");\ndefineSymbol(math, main, textord, \"\\u22a4\", \"\\\\top\");\ndefineSymbol(math, main, textord, \"\\u22a5\", \"\\\\bot\");\ndefineSymbol(math, main, textord, \"\\u2205\", \"\\\\emptyset\");\ndefineSymbol(math, ams, textord, \"\\u2205\", \"\\\\varnothing\");\ndefineSymbol(math, main, mathord, \"\\u03b1\", \"\\\\alpha\", true);\ndefineSymbol(math, main, mathord, \"\\u03b2\", \"\\\\beta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b3\", \"\\\\gamma\", true);\ndefineSymbol(math, main, mathord, \"\\u03b4\", \"\\\\delta\", true);\ndefineSymbol(math, main, mathord, \"\\u03f5\", \"\\\\epsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03b6\", \"\\\\zeta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b7\", \"\\\\eta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b8\", \"\\\\theta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b9\", \"\\\\iota\", true);\ndefineSymbol(math, main, mathord, \"\\u03ba\", \"\\\\kappa\", true);\ndefineSymbol(math, main, mathord, \"\\u03bb\", \"\\\\lambda\", true);\ndefineSymbol(math, main, mathord, \"\\u03bc\", \"\\\\mu\", true);\ndefineSymbol(math, main, mathord, \"\\u03bd\", \"\\\\nu\", true);\ndefineSymbol(math, main, mathord, \"\\u03be\", \"\\\\xi\", true);\ndefineSymbol(math, main, mathord, \"\\u03bf\", \"\\\\omicron\", true);\ndefineSymbol(math, main, mathord, \"\\u03c0\", \"\\\\pi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c1\", \"\\\\rho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c3\", \"\\\\sigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c4\", \"\\\\tau\", true);\ndefineSymbol(math, main, mathord, \"\\u03c5\", \"\\\\upsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d5\", \"\\\\phi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c7\", \"\\\\chi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c8\", \"\\\\psi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c9\", \"\\\\omega\", true);\ndefineSymbol(math, main, mathord, \"\\u03b5\", \"\\\\varepsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d1\", \"\\\\vartheta\", true);\ndefineSymbol(math, main, mathord, \"\\u03d6\", \"\\\\varpi\", true);\ndefineSymbol(math, main, mathord, \"\\u03f1\", \"\\\\varrho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c2\", \"\\\\varsigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c6\", \"\\\\varphi\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"*\", true);\ndefineSymbol(math, main, bin, \"+\", \"+\");\ndefineSymbol(math, main, bin, \"\\u2212\", \"-\", true);\ndefineSymbol(math, main, bin, \"\\u22c5\", \"\\\\cdot\", true);\ndefineSymbol(math, main, bin, \"\\u2218\", \"\\\\circ\", true);\ndefineSymbol(math, main, bin, \"\\u00f7\", \"\\\\div\", true);\ndefineSymbol(math, main, bin, \"\\u00b1\", \"\\\\pm\", true);\ndefineSymbol(math, main, bin, \"\\u00d7\", \"\\\\times\", true);\ndefineSymbol(math, main, bin, \"\\u2229\", \"\\\\cap\", true);\ndefineSymbol(math, main, bin, \"\\u222a\", \"\\\\cup\", true);\ndefineSymbol(math, main, bin, \"\\u2216\", \"\\\\setminus\", true);\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\land\");\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\lor\");\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\wedge\", true);\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\vee\", true);\ndefineSymbol(math, main, textord, \"\\u221a\", \"\\\\surd\");\ndefineSymbol(math, main, open, \"\\u27e8\", \"\\\\langle\", true);\ndefineSymbol(math, main, open, \"\\u2223\", \"\\\\lvert\");\ndefineSymbol(math, main, open, \"\\u2225\", \"\\\\lVert\");\ndefineSymbol(math, main, close, \"?\", \"?\");\ndefineSymbol(math, main, close, \"!\", \"!\");\ndefineSymbol(math, main, close, \"\\u27e9\", \"\\\\rangle\", true);\ndefineSymbol(math, main, close, \"\\u2223\", \"\\\\rvert\");\ndefineSymbol(math, main, close, \"\\u2225\", \"\\\\rVert\");\ndefineSymbol(math, main, rel, \"=\", \"=\");\ndefineSymbol(math, main, rel, \":\", \":\");\ndefineSymbol(math, main, rel, \"\\u2248\", \"\\\\approx\", true);\ndefineSymbol(math, main, rel, \"\\u2245\", \"\\\\cong\", true);\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\ge\");\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\geq\", true);\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\gets\");\ndefineSymbol(math, main, rel, \">\", \"\\\\gt\", true);\ndefineSymbol(math, main, rel, \"\\u2208\", \"\\\\in\", true);\ndefineSymbol(math, main, rel, \"\\ue020\", \"\\\\@not\");\ndefineSymbol(math, main, rel, \"\\u2282\", \"\\\\subset\", true);\ndefineSymbol(math, main, rel, \"\\u2283\", \"\\\\supset\", true);\ndefineSymbol(math, main, rel, \"\\u2286\", \"\\\\subseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2287\", \"\\\\supseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2288\", \"\\\\nsubseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2289\", \"\\\\nsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u22a8\", \"\\\\models\");\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\le\");\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\leq\", true);\ndefineSymbol(math, main, rel, \"<\", \"\\\\lt\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\to\");\ndefineSymbol(math, ams, rel, \"\\u2271\", \"\\\\ngeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2270\", \"\\\\nleq\", true);\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\space\"); // Ref: LaTeX Source 2e: \\DeclareRobustCommand{\\nobreakspace}{%\n\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \" \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\space\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(math, main, spacing, null, \"\\\\nobreak\");\ndefineSymbol(math, main, spacing, null, \"\\\\allowbreak\");\ndefineSymbol(math, main, punct, \",\", \",\");\ndefineSymbol(math, main, punct, \";\", \";\");\ndefineSymbol(math, ams, bin, \"\\u22bc\", \"\\\\barwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22bb\", \"\\\\veebar\", true);\ndefineSymbol(math, main, bin, \"\\u2299\", \"\\\\odot\", true);\ndefineSymbol(math, main, bin, \"\\u2295\", \"\\\\oplus\", true);\ndefineSymbol(math, main, bin, \"\\u2297\", \"\\\\otimes\", true);\ndefineSymbol(math, main, textord, \"\\u2202\", \"\\\\partial\", true);\ndefineSymbol(math, main, bin, \"\\u2298\", \"\\\\oslash\", true);\ndefineSymbol(math, ams, bin, \"\\u229a\", \"\\\\circledcirc\", true);\ndefineSymbol(math, ams, bin, \"\\u22a1\", \"\\\\boxdot\", true);\ndefineSymbol(math, main, bin, \"\\u25b3\", \"\\\\bigtriangleup\");\ndefineSymbol(math, main, bin, \"\\u25bd\", \"\\\\bigtriangledown\");\ndefineSymbol(math, main, bin, \"\\u2020\", \"\\\\dagger\");\ndefineSymbol(math, main, bin, \"\\u22c4\", \"\\\\diamond\");\ndefineSymbol(math, main, bin, \"\\u22c6\", \"\\\\star\");\ndefineSymbol(math, main, bin, \"\\u25c3\", \"\\\\triangleleft\");\ndefineSymbol(math, main, bin, \"\\u25b9\", \"\\\\triangleright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\textbraceleft\");\ndefineSymbol(math, main, close, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\textbraceright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\lbrace\");\ndefineSymbol(math, main, close, \"}\", \"\\\\rbrace\");\ndefineSymbol(math, main, open, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(text, main, textord, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(math, main, close, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(text, main, textord, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(math, main, open, \"(\", \"\\\\lparen\", true);\ndefineSymbol(math, main, close, \")\", \"\\\\rparen\", true);\ndefineSymbol(text, main, textord, \"<\", \"\\\\textless\", true); // in T1 fontenc\n\ndefineSymbol(text, main, textord, \">\", \"\\\\textgreater\", true); // in T1 fontenc\n\ndefineSymbol(math, main, open, \"\\u230a\", \"\\\\lfloor\", true);\ndefineSymbol(math, main, close, \"\\u230b\", \"\\\\rfloor\", true);\ndefineSymbol(math, main, open, \"\\u2308\", \"\\\\lceil\", true);\ndefineSymbol(math, main, close, \"\\u2309\", \"\\\\rceil\", true);\ndefineSymbol(math, main, textord, \"\\\\\", \"\\\\backslash\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"|\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"\\\\vert\");\ndefineSymbol(text, main, textord, \"|\", \"\\\\textbar\", true); // in T1 fontenc\n\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\|\");\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\Vert\");\ndefineSymbol(text, main, textord, \"\\u2225\", \"\\\\textbardbl\");\ndefineSymbol(text, main, textord, \"~\", \"\\\\textasciitilde\");\ndefineSymbol(text, main, textord, \"\\\\\", \"\\\\textbackslash\");\ndefineSymbol(text, main, textord, \"^\", \"\\\\textasciicircum\");\ndefineSymbol(math, main, rel, \"\\u2191\", \"\\\\uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d1\", \"\\\\Uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u2193\", \"\\\\downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d3\", \"\\\\Downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2195\", \"\\\\updownarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d5\", \"\\\\Updownarrow\", true);\ndefineSymbol(math, main, op, \"\\u2210\", \"\\\\coprod\");\ndefineSymbol(math, main, op, \"\\u22c1\", \"\\\\bigvee\");\ndefineSymbol(math, main, op, \"\\u22c0\", \"\\\\bigwedge\");\ndefineSymbol(math, main, op, \"\\u2a04\", \"\\\\biguplus\");\ndefineSymbol(math, main, op, \"\\u22c2\", \"\\\\bigcap\");\ndefineSymbol(math, main, op, \"\\u22c3\", \"\\\\bigcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\int\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\intop\");\ndefineSymbol(math, main, op, \"\\u222c\", \"\\\\iint\");\ndefineSymbol(math, main, op, \"\\u222d\", \"\\\\iiint\");\ndefineSymbol(math, main, op, \"\\u220f\", \"\\\\prod\");\ndefineSymbol(math, main, op, \"\\u2211\", \"\\\\sum\");\ndefineSymbol(math, main, op, \"\\u2a02\", \"\\\\bigotimes\");\ndefineSymbol(math, main, op, \"\\u2a01\", \"\\\\bigoplus\");\ndefineSymbol(math, main, op, \"\\u2a00\", \"\\\\bigodot\");\ndefineSymbol(math, main, op, \"\\u222e\", \"\\\\oint\");\ndefineSymbol(math, main, op, \"\\u222f\", \"\\\\oiint\");\ndefineSymbol(math, main, op, \"\\u2230\", \"\\\\oiiint\");\ndefineSymbol(math, main, op, \"\\u2a06\", \"\\\\bigsqcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\smallint\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\textellipsis\");\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\mathellipsis\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u22ef\", \"\\\\@cdots\", true);\ndefineSymbol(math, main, inner, \"\\u22f1\", \"\\\\ddots\", true);\ndefineSymbol(math, main, textord, \"\\u22ee\", \"\\\\varvdots\"); // \\vdots is a macro\n\ndefineSymbol(math, main, accent, \"\\u02ca\", \"\\\\acute\");\ndefineSymbol(math, main, accent, \"\\u02cb\", \"\\\\grave\");\ndefineSymbol(math, main, accent, \"\\u00a8\", \"\\\\ddot\");\ndefineSymbol(math, main, accent, \"\\u007e\", \"\\\\tilde\");\ndefineSymbol(math, main, accent, \"\\u02c9\", \"\\\\bar\");\ndefineSymbol(math, main, accent, \"\\u02d8\", \"\\\\breve\");\ndefineSymbol(math, main, accent, \"\\u02c7\", \"\\\\check\");\ndefineSymbol(math, main, accent, \"\\u005e\", \"\\\\hat\");\ndefineSymbol(math, main, accent, \"\\u20d7\", \"\\\\vec\");\ndefineSymbol(math, main, accent, \"\\u02d9\", \"\\\\dot\");\ndefineSymbol(math, main, accent, \"\\u02da\", \"\\\\mathring\"); // \\imath and \\jmath should be invariant to \\mathrm, \\mathbf, etc., so use PUA\n\ndefineSymbol(math, main, mathord, \"\\ue131\", \"\\\\@imath\");\ndefineSymbol(math, main, mathord, \"\\ue237\", \"\\\\@jmath\");\ndefineSymbol(math, main, textord, \"\\u0131\", \"\\u0131\");\ndefineSymbol(math, main, textord, \"\\u0237\", \"\\u0237\");\ndefineSymbol(text, main, textord, \"\\u0131\", \"\\\\i\", true);\ndefineSymbol(text, main, textord, \"\\u0237\", \"\\\\j\", true);\ndefineSymbol(text, main, textord, \"\\u00df\", \"\\\\ss\", true);\ndefineSymbol(text, main, textord, \"\\u00e6\", \"\\\\ae\", true);\ndefineSymbol(text, main, textord, \"\\u0153\", \"\\\\oe\", true);\ndefineSymbol(text, main, textord, \"\\u00f8\", \"\\\\o\", true);\ndefineSymbol(text, main, textord, \"\\u00c6\", \"\\\\AE\", true);\ndefineSymbol(text, main, textord, \"\\u0152\", \"\\\\OE\", true);\ndefineSymbol(text, main, textord, \"\\u00d8\", \"\\\\O\", true);\ndefineSymbol(text, main, accent, \"\\u02ca\", \"\\\\'\"); // acute\n\ndefineSymbol(text, main, accent, \"\\u02cb\", \"\\\\`\"); // grave\n\ndefineSymbol(text, main, accent, \"\\u02c6\", \"\\\\^\"); // circumflex\n\ndefineSymbol(text, main, accent, \"\\u02dc\", \"\\\\~\"); // tilde\n\ndefineSymbol(text, main, accent, \"\\u02c9\", \"\\\\=\"); // macron\n\ndefineSymbol(text, main, accent, \"\\u02d8\", \"\\\\u\"); // breve\n\ndefineSymbol(text, main, accent, \"\\u02d9\", \"\\\\.\"); // dot above\n\ndefineSymbol(text, main, accent, \"\\u00b8\", \"\\\\c\"); // cedilla\n\ndefineSymbol(text, main, accent, \"\\u02da\", \"\\\\r\"); // ring above\n\ndefineSymbol(text, main, accent, \"\\u02c7\", \"\\\\v\"); // caron\n\ndefineSymbol(text, main, accent, \"\\u00a8\", '\\\\\"'); // diaresis\n\ndefineSymbol(text, main, accent, \"\\u02dd\", \"\\\\H\"); // double acute\n\ndefineSymbol(text, main, accent, \"\\u25ef\", \"\\\\textcircled\"); // \\bigcirc glyph\n// These ligatures are detected and created in Parser.js's `formLigatures`.\n\nvar ligatures = {\n  \"--\": true,\n  \"---\": true,\n  \"``\": true,\n  \"''\": true\n};\ndefineSymbol(text, main, textord, \"\\u2013\", \"--\", true);\ndefineSymbol(text, main, textord, \"\\u2013\", \"\\\\textendash\");\ndefineSymbol(text, main, textord, \"\\u2014\", \"---\", true);\ndefineSymbol(text, main, textord, \"\\u2014\", \"\\\\textemdash\");\ndefineSymbol(text, main, textord, \"\\u2018\", \"`\", true);\ndefineSymbol(text, main, textord, \"\\u2018\", \"\\\\textquoteleft\");\ndefineSymbol(text, main, textord, \"\\u2019\", \"'\", true);\ndefineSymbol(text, main, textord, \"\\u2019\", \"\\\\textquoteright\");\ndefineSymbol(text, main, textord, \"\\u201c\", \"``\", true);\ndefineSymbol(text, main, textord, \"\\u201c\", \"\\\\textquotedblleft\");\ndefineSymbol(text, main, textord, \"\\u201d\", \"''\", true);\ndefineSymbol(text, main, textord, \"\\u201d\", \"\\\\textquotedblright\"); //  \\degree from gensymb package\n\ndefineSymbol(math, main, textord, \"\\u00b0\", \"\\\\degree\", true);\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\degree\"); // \\textdegree from inputenc package\n\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\textdegree\", true); // TODO: In LaTeX, \\pounds can generate a different character in text and math\n// mode, but among our fonts, only Main-Regular defines this character \"163\".\n\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\mathsterling\", true);\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\textsterling\", true);\ndefineSymbol(math, ams, textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(text, ams, textord, \"\\u2720\", \"\\\\maltese\"); // There are lots of symbols which are the same, so we add them in afterwards.\n// All of these are textords in math mode\n\nvar mathTextSymbols = \"0123456789/@.\\\"\";\n\nfor (var i = 0; i < mathTextSymbols.length; i++) {\n  var ch = mathTextSymbols.charAt(i);\n  defineSymbol(math, main, textord, ch, ch);\n} // All of these are textords in text mode\n\n\nvar textSymbols = \"0123456789!@*()-=+\\\";:?/.,\";\n\nfor (var _i = 0; _i < textSymbols.length; _i++) {\n  var _ch = textSymbols.charAt(_i);\n\n  defineSymbol(text, main, textord, _ch, _ch);\n} // All of these are textords in text mode, and mathords in math mode\n\n\nvar letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfor (var _i2 = 0; _i2 < letters.length; _i2++) {\n  var _ch2 = letters.charAt(_i2);\n\n  defineSymbol(math, main, mathord, _ch2, _ch2);\n  defineSymbol(text, main, textord, _ch2, _ch2);\n} // Blackboard bold and script letters in Unicode range\n\n\ndefineSymbol(math, ams, textord, \"C\", \"\\u2102\"); // blackboard bold\n\ndefineSymbol(text, ams, textord, \"C\", \"\\u2102\");\ndefineSymbol(math, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(text, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(math, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(text, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(math, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(text, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(math, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(text, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(math, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(text, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(math, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(text, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(math, main, mathord, \"h\", \"\\u210E\"); // italic h, Planck constant\n\ndefineSymbol(text, main, mathord, \"h\", \"\\u210E\"); // The next loop loads wide (surrogate pair) characters.\n// We support some letters in the Unicode range U+1D400 to U+1D7FF,\n// Mathematical Alphanumeric Symbols.\n// Some editors do not deal well with wide characters. So don't write the\n// string into this file. Instead, create the string from the surrogate pair.\n\nvar wideChar = \"\";\n\nfor (var _i3 = 0; _i3 < letters.length; _i3++) {\n  var _ch3 = letters.charAt(_i3); // The hex numbers in the next line are a surrogate pair.\n  // 0xD835 is the high surrogate for all letters in the range we support.\n  // 0xDC00 is the low surrogate for bold A.\n\n\n  wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3); // A-Z a-z bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3); // A-Z a-z italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3); // A-Z a-z bold italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3); // A-Z a-z Fractur\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3); // A-Z a-z sans-serif\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3); // A-Z a-z sans bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3); // A-Z a-z sans italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3); // A-Z a-z monospace\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n\n  if (_i3 < 26) {\n    // KaTeX fonts have only capital letters for blackboard bold and script.\n    // See exception for k below.\n    wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3); // A-Z double struck\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n    wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3); // A-Z script\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n  } // TODO: Add bold script when it is supported by a KaTeX font.\n\n} // \"k\" is the only double struck lower case letter in the KaTeX fonts.\n\n\nwideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck\n\ndefineSymbol(math, main, mathord, \"k\", wideChar);\ndefineSymbol(text, main, textord, \"k\", wideChar); // Next, some wide character numerals\n\nfor (var _i4 = 0; _i4 < 10; _i4++) {\n  var _ch4 = _i4.toString();\n\n  wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4); // 0-9 bold\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4); // 0-9 sans serif\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4); // 0-9 bold sans\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4); // 0-9 monospace\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n} // We add these Latin-1 letters as symbols for backwards-compatibility,\n// but they are not actually in the font, nor are they supported by the\n// Unicode accent mechanism, so they fall back to Times font and look ugly.\n// TODO(edemaine): Fix this.\n\n\nvar extraLatin = \"\\u00d0\\u00de\\u00fe\";\n\nfor (var _i5 = 0; _i5 < extraLatin.length; _i5++) {\n  var _ch5 = extraLatin.charAt(_i5);\n\n  defineSymbol(math, main, mathord, _ch5, _ch5);\n  defineSymbol(text, main, textord, _ch5, _ch5);\n}\n\n/**\n * This file provides support for Unicode range U+1D400 to U+1D7FF,\n * Mathematical Alphanumeric Symbols.\n *\n * Function wideCharacterFont takes a wide character as input and returns\n * the font information necessary to render it properly.\n */\n/**\n * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf\n * That document sorts characters into groups by font type, say bold or italic.\n *\n * In the arrays below, each subarray consists three elements:\n *      * The CSS class of that group when in math mode.\n *      * The CSS class of that group when in text mode.\n *      * The font name, so that KaTeX can get font metrics.\n */\n\nvar wideLatinLetterData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // A-Z bold upright\n[\"mathbf\", \"textbf\", \"Main-Bold\"], // a-z bold upright\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // A-Z italic\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // a-z italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // A-Z bold italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // a-z bold italic\n// Map fancy A-Z letters to script, not calligraphic.\n// This aligns with unicode-math and math fonts (except Cambria Math).\n[\"mathscr\", \"textscr\", \"Script-Regular\"], // A-Z script\n[\"\", \"\", \"\"], // a-z script.  No font\n[\"\", \"\", \"\"], // A-Z bold script. No font\n[\"\", \"\", \"\"], // a-z bold script. No font\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // A-Z Fraktur\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // a-z Fraktur\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // A-Z double-struck\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // k double-struck\n[\"\", \"\", \"\"], // A-Z bold Fraktur No font metrics\n[\"\", \"\", \"\"], // a-z bold Fraktur.   No font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // A-Z sans-serif\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // a-z sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // A-Z bold sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // a-z bold sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // A-Z italic sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // a-z italic sans-serif\n[\"\", \"\", \"\"], // A-Z bold italic sans. No font\n[\"\", \"\", \"\"], // a-z bold italic sans. No font\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"], // A-Z monospace\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // a-z monospace\n];\nvar wideNumeralData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // 0-9 bold\n[\"\", \"\", \"\"], // 0-9 double-struck. No KaTeX font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // 0-9 sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // 0-9 bold sans-serif\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // 0-9 monospace\n];\nvar wideCharacterFont = function wideCharacterFont(wideChar, mode) {\n  // IE doesn't support codePointAt(). So work with the surrogate pair.\n  var H = wideChar.charCodeAt(0); // high surrogate\n\n  var L = wideChar.charCodeAt(1); // low surrogate\n\n  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;\n  var j = mode === \"math\" ? 0 : 1; // column index for CSS class.\n\n  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {\n    // wideLatinLetterData contains exactly 26 chars on each row.\n    // So we can calculate the relevant row. No traverse necessary.\n    var i = Math.floor((codePoint - 0x1D400) / 26);\n    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];\n  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {\n    // Numerals, ten per row.\n    var _i = Math.floor((codePoint - 0x1D7CE) / 10);\n\n    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];\n  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {\n    // dotless i or j\n    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];\n  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {\n    // Greek letters. Not supported, yet.\n    return [\"\", \"\"];\n  } else {\n    // We don't support any wide characters outside 1D400–1D7FF.\n    throw new ParseError(\"Unsupported character: \" + wideChar);\n  }\n};\n\n/* eslint no-console:0 */\n\n/**\n * Looks up the given symbol in fontMetrics, after applying any symbol\n * replacements defined in symbol.js\n */\nvar lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.\nfontName, mode) {\n  // Replace the value with its replaced value from symbol.js\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  return {\n    value: value,\n    metrics: getCharacterMetrics(value, fontName, mode)\n  };\n};\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n * TODO(#953): Make `options` mandatory and always pass it in.\n */\n\n\nvar makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {\n  var lookup = lookupSymbol(value, fontName, mode);\n  var metrics = lookup.metrics;\n  value = lookup.value;\n  var symbolNode;\n\n  if (metrics) {\n    var italic = metrics.italic;\n\n    if (mode === \"text\" || options && options.font === \"mathit\") {\n      italic = 0;\n    }\n\n    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics \" + (\"for '\" + value + \"' in style '\" + fontName + \"' and mode '\" + mode + \"'\"));\n    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    symbolNode.maxFontSize = options.sizeMultiplier;\n\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      symbolNode.style.color = color;\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nvar mathsym = function mathsym(value, mode, options, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text, as well as a special case for boldsymbol because it\n  // can be used for bold + and -\n  if (options.font === \"boldsymbol\" && lookupSymbol(value, \"Main-Bold\", mode).metrics) {\n    return makeSymbol(value, \"Main-Bold\", mode, options, classes.concat([\"mathbf\"]));\n  } else if (value === \"\\\\\" || symbols[mode][value].font === \"main\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Determines which of the two font names (Main-Bold and Math-BoldItalic) and\n * corresponding style tags (mathbf or boldsymbol) to use for font \"boldsymbol\",\n * depending on the symbol.  Use this function instead of fontMap for font\n * \"boldsymbol\".\n */\n\n\nvar boldsymbol = function boldsymbol(value, mode, options, classes, type) {\n  if (type !== \"textord\" && lookupSymbol(value, \"Math-BoldItalic\", mode).metrics) {\n    return {\n      fontName: \"Math-BoldItalic\",\n      fontClass: \"boldsymbol\"\n    };\n  } else {\n    // Some glyphs do not exist in Math-BoldItalic so we need to use\n    // Main-Bold instead.\n    return {\n      fontName: \"Main-Bold\",\n      fontClass: \"mathbf\"\n    };\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nvar makeOrd = function makeOrd(group, options, type) {\n  var mode = group.mode;\n  var text = group.text;\n  var classes = [\"mord\"]; // Math mode or Old font (i.e. \\rm)\n\n  var isFont = mode === \"math\" || mode === \"text\" && options.font;\n  var fontOrFamily = isFont ? options.font : options.fontFamily;\n\n  if (text.charCodeAt(0) === 0xD835) {\n    // surrogate pairs get special treatment\n    var [wideFontName, wideFontClass] = wideCharacterFont(text, mode);\n    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));\n  } else if (fontOrFamily) {\n    var fontName;\n    var fontClasses;\n\n    if (fontOrFamily === \"boldsymbol\") {\n      var fontData = boldsymbol(text, mode, options, classes, type);\n      fontName = fontData.fontName;\n      fontClasses = [fontData.fontClass];\n    } else if (isFont) {\n      fontName = fontMap[fontOrFamily].fontName;\n      fontClasses = [fontOrFamily];\n    } else {\n      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);\n      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];\n    }\n\n    if (lookupSymbol(text, fontName, mode).metrics) {\n      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));\n    } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === \"Typewriter\") {\n      // Deconstruct ligatures in monospace fonts (\\texttt, \\tt).\n      var parts = [];\n\n      for (var i = 0; i < text.length; i++) {\n        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));\n      }\n\n      return makeFragment(parts);\n    }\n  } // Makes a symbol in the default font for mathords and textords.\n\n\n  if (type === \"mathord\") {\n    return makeSymbol(text, \"Math-Italic\", mode, options, classes.concat([\"mathnormal\"]));\n  } else if (type === \"textord\") {\n    var font = symbols[mode][text] && symbols[mode][text].font;\n\n    if (font === \"ams\") {\n      var _fontName = retrieveTextFontName(\"amsrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName, mode, options, classes.concat(\"amsrm\", options.fontWeight, options.fontShape));\n    } else if (font === \"main\" || !font) {\n      var _fontName2 = retrieveTextFontName(\"textrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));\n    } else {\n      // fonts added by plugins\n      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class\n\n\n      return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));\n    }\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in makeOrd\");\n  }\n};\n/**\n * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,\n * and styles.\n */\n\n\nvar canCombine = (prev, next) => {\n  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {\n    return false;\n  } // If prev and next both are just \"mbin\"s or \"mord\"s we don't combine them\n  // so that the proper spacing can be preserved.\n\n\n  if (prev.classes.length === 1) {\n    var cls = prev.classes[0];\n\n    if (cls === \"mbin\" || cls === \"mord\") {\n      return false;\n    }\n  }\n\n  for (var style in prev.style) {\n    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  for (var _style in next.style) {\n    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Combine consecutive domTree.symbolNodes into a single symbolNode.\n * Note: this function mutates the argument.\n */\n\n\nvar tryCombineChars = chars => {\n  for (var i = 0; i < chars.length - 1; i++) {\n    var prev = chars[i];\n    var next = chars[i + 1];\n\n    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {\n      prev.text += next.text;\n      prev.height = Math.max(prev.height, next.height);\n      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use\n      // it to add padding to the right of the span created from\n      // the combined characters.\n\n      prev.italic = next.italic;\n      chars.splice(i + 1, 1);\n      i--;\n    }\n  }\n\n  return chars;\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nvar sizeElementFromChildren = function sizeElementFromChildren(elem) {\n  var height = 0;\n  var depth = 0;\n  var maxFontSize = 0;\n\n  for (var i = 0; i < elem.children.length; i++) {\n    var child = elem.children[i];\n\n    if (child.height > height) {\n      height = child.height;\n    }\n\n    if (child.depth > depth) {\n      depth = child.depth;\n    }\n\n    if (child.maxFontSize > maxFontSize) {\n      maxFontSize = child.maxFontSize;\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO(#953): Ensure that `options` is always provided (currently some call\n * sites don't pass it) and make the type below mandatory.\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nvar makeSpan$2 = function makeSpan(classes, children, options, style) {\n  var span = new Span(classes, children, options, style);\n  sizeElementFromChildren(span);\n  return span;\n}; // SVG one is simpler -- doesn't require height, depth, max-font setting.\n// This is also a separate method for typesafety.\n\n\nvar makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);\n\nvar makeLineSpan = function makeLineSpan(className, options, thickness) {\n  var line = makeSpan$2([className], [], options);\n  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n  line.style.borderBottomWidth = makeEm(line.height);\n  line.maxFontSize = 1.0;\n  return line;\n};\n/**\n * Makes an anchor with the given href, list of classes, list of children,\n * and options.\n */\n\n\nvar makeAnchor = function makeAnchor(href, classes, children, options) {\n  var anchor = new Anchor(href, classes, children, options);\n  sizeElementFromChildren(anchor);\n  return anchor;\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nvar makeFragment = function makeFragment(children) {\n  var fragment = new DocumentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Wraps group in a span if it's a document fragment, allowing to apply classes\n * and styles\n */\n\n\nvar wrapFragment = function wrapFragment(group, options) {\n  if (group instanceof DocumentFragment) {\n    return makeSpan$2([], [group], options);\n  }\n\n  return group;\n}; // These are exact object types to catch typos in the names of the optional fields.\n\n\n// Computes the updated `children` list and the overall depth.\n//\n// This helper function for makeVList makes it easier to enforce type safety by\n// allowing early exits (returns) in the logic.\nvar getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {\n  if (params.positionType === \"individualShift\") {\n    var oldChildren = params.children;\n    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be\n    // shifted to the correct specified shift\n\n    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n\n    var currPos = _depth;\n\n    for (var i = 1; i < oldChildren.length; i++) {\n      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size\n      });\n      children.push(oldChildren[i]);\n    }\n\n    return {\n      children,\n      depth: _depth\n    };\n  }\n\n  var depth;\n\n  if (params.positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    var bottom = params.positionData;\n\n    for (var _i = 0; _i < params.children.length; _i++) {\n      var child = params.children[_i];\n      bottom -= child.type === \"kern\" ? child.size : child.elem.height + child.elem.depth;\n    }\n\n    depth = bottom;\n  } else if (params.positionType === \"bottom\") {\n    depth = -params.positionData;\n  } else {\n    var firstChild = params.children[0];\n\n    if (firstChild.type !== \"elem\") {\n      throw new Error('First child must have type \"elem\".');\n    }\n\n    if (params.positionType === \"shift\") {\n      depth = -firstChild.elem.depth - params.positionData;\n    } else if (params.positionType === \"firstBaseline\") {\n      depth = -firstChild.elem.depth;\n    } else {\n      throw new Error(\"Invalid positionType \" + params.positionType + \".\");\n    }\n  }\n\n  return {\n    children: params.children,\n    depth\n  };\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * See VListParam documentation above.\n */\n\n\nvar makeVList = function makeVList(params, options) {\n  var {\n    children,\n    depth\n  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to\n  // each item, where it will determine the item's baseline. Since it has\n  // `overflow:hidden`, the strut's top edge will sit on the item's line box's\n  // top edge and the strut's bottom edge will sit on the item's baseline,\n  // with no additional line-height spacing. This allows the item baseline to\n  // be positioned precisely without worrying about font ascent and\n  // line-height.\n\n  var pstrutSize = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child.type === \"elem\") {\n      var elem = child.elem;\n      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);\n    }\n  }\n\n  pstrutSize += 2;\n  var pstrut = makeSpan$2([\"pstrut\"], []);\n  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets\n\n  var realChildren = [];\n  var minPos = depth;\n  var maxPos = depth;\n  var currPos = depth;\n\n  for (var _i2 = 0; _i2 < children.length; _i2++) {\n    var _child = children[_i2];\n\n    if (_child.type === \"kern\") {\n      currPos += _child.size;\n    } else {\n      var _elem = _child.elem;\n      var classes = _child.wrapperClasses || [];\n      var style = _child.wrapperStyle || {};\n      var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);\n      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);\n\n      if (_child.marginLeft) {\n        childWrap.style.marginLeft = _child.marginLeft;\n      }\n\n      if (_child.marginRight) {\n        childWrap.style.marginRight = _child.marginRight;\n      }\n\n      realChildren.push(childWrap);\n      currPos += _elem.height + _elem.depth;\n    }\n\n    minPos = Math.min(minPos, currPos);\n    maxPos = Math.max(maxPos, currPos);\n  } // The vlist contents go in a table-cell with `vertical-align:bottom`.\n  // This cell's bottom edge will determine the containing table's baseline\n  // without overly expanding the containing line-box.\n\n\n  var vlist = makeSpan$2([\"vlist\"], realChildren);\n  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.\n\n  var rows;\n\n  if (minPos < 0) {\n    // We will define depth in an empty span with display: table-cell.\n    // It should render with the height that we define. But Chrome, in\n    // contenteditable mode only, treats that span as if it contains some\n    // text content. And that min-height over-rides our desired height.\n    // So we put another empty span inside the depth strut span.\n    var emptySpan = makeSpan$2([], []);\n    var depthStrut = makeSpan$2([\"vlist\"], [emptySpan]);\n    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it\n    // puts the bottom of the *second* row on the baseline.\n\n    var topStrut = makeSpan$2([\"vlist-s\"], [new SymbolNode(\"\\u200b\")]);\n    rows = [makeSpan$2([\"vlist-r\"], [vlist, topStrut]), makeSpan$2([\"vlist-r\"], [depthStrut])];\n  } else {\n    rows = [makeSpan$2([\"vlist-r\"], [vlist])];\n  }\n\n  var vtable = makeSpan$2([\"vlist-t\"], rows);\n\n  if (rows.length === 2) {\n    vtable.classes.push(\"vlist-t2\");\n  }\n\n  vtable.height = maxPos;\n  vtable.depth = -minPos;\n  return vtable;\n}; // Glue is a concept from TeX which is a flexible space between elements in\n// either a vertical or horizontal list. In KaTeX, at least for now, it's\n// static space between elements in a horizontal layout.\n\n\nvar makeGlue = (measurement, options) => {\n  // Make an empty span for the space\n  var rule = makeSpan$2([\"mspace\"], [], options);\n  var size = calculateSize(measurement, options);\n  rule.style.marginRight = makeEm(size);\n  return rule;\n}; // Takes font options, and returns the appropriate fontLookup name\n\n\nvar retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {\n  var baseFontName = \"\";\n\n  switch (fontFamily) {\n    case \"amsrm\":\n      baseFontName = \"AMS\";\n      break;\n\n    case \"textrm\":\n      baseFontName = \"Main\";\n      break;\n\n    case \"textsf\":\n      baseFontName = \"SansSerif\";\n      break;\n\n    case \"texttt\":\n      baseFontName = \"Typewriter\";\n      break;\n\n    default:\n      baseFontName = fontFamily;\n    // use fonts added by a plugin\n  }\n\n  var fontStylesName;\n\n  if (fontWeight === \"textbf\" && fontShape === \"textit\") {\n    fontStylesName = \"BoldItalic\";\n  } else if (fontWeight === \"textbf\") {\n    fontStylesName = \"Bold\";\n  } else if (fontWeight === \"textit\") {\n    fontStylesName = \"Italic\";\n  } else {\n    fontStylesName = \"Regular\";\n  }\n\n  return baseFontName + \"-\" + fontStylesName;\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\n\nvar fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathnormal\": {\n    variant: \"italic\",\n    fontName: \"Math-Italic\"\n  },\n  // \"boldsymbol\" is missing because they require the use of multiple fonts:\n  // Math-BoldItalic and Main-Bold.  This is handled by a special case in\n  // makeOrd which ends up calling boldsymbol.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nvar svgData = {\n  //   path, width, height\n  vec: [\"vec\", 0.471, 0.714],\n  // values from the font glyph\n  oiintSize1: [\"oiintSize1\", 0.957, 0.499],\n  // oval to overlay the integrand\n  oiintSize2: [\"oiintSize2\", 1.472, 0.659],\n  oiiintSize1: [\"oiiintSize1\", 1.304, 0.499],\n  oiiintSize2: [\"oiiintSize2\", 1.98, 0.659]\n};\n\nvar staticSvg = function staticSvg(value, options) {\n  // Create a span with inline SVG for the element.\n  var [pathName, width, height] = svgData[value];\n  var path = new PathNode(pathName);\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + 1000 * height,\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = makeSvgSpan([\"overlay\"], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return span;\n};\n\nvar buildCommon = {\n  fontMap,\n  makeSymbol,\n  mathsym,\n  makeSpan: makeSpan$2,\n  makeSvgSpan,\n  makeLineSpan,\n  makeAnchor,\n  makeFragment,\n  wrapFragment,\n  makeVList,\n  makeOrd,\n  makeGlue,\n  staticSvg,\n  svgData,\n  tryCombineChars\n};\n\n/**\n * Describes spaces between different classes of atoms.\n */\nvar thinspace = {\n  number: 3,\n  unit: \"mu\"\n};\nvar mediumspace = {\n  number: 4,\n  unit: \"mu\"\n};\nvar thickspace = {\n  number: 5,\n  unit: \"mu\"\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n\n// Spacing relationships for display and text styles\nvar spacings = {\n  mord: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mbin: {\n    mord: mediumspace,\n    mop: mediumspace,\n    mopen: mediumspace,\n    minner: mediumspace\n  },\n  mrel: {\n    mord: thickspace,\n    mop: thickspace,\n    mopen: thickspace,\n    minner: thickspace\n  },\n  mopen: {},\n  mclose: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mpunct: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mclose: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  },\n  minner: {\n    mord: thinspace,\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  }\n}; // Spacing relationships for script and scriptscript styles\n\nvar tightSpacings = {\n  mord: {\n    mop: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace\n  },\n  mbin: {},\n  mrel: {},\n  mopen: {},\n  mclose: {\n    mop: thinspace\n  },\n  mpunct: {},\n  minner: {\n    mop: thinspace\n  }\n};\n\n/** Context provided to function handlers for error messages. */\n// Note: reverse the order of the return type union will cause a flow error.\n// See https://github.com/facebook/flow/issues/3663.\n// More general version of `HtmlBuilder` for nodes (e.g. \\sum, accent types)\n// whose presence impacts super/subscripting. In this case, ParseNode<\"supsub\">\n// delegates its HTML building to the HtmlBuilder corresponding to these nodes.\n\n/**\n * Final function spec for use at parse time.\n * This is almost identical to `FunctionPropSpec`, except it\n * 1. includes the function handler, and\n * 2. requires all arguments except argTypes.\n * It is generated by `defineFunction()` below.\n */\n\n/**\n * All registered functions.\n * `functions.js` just exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary.\n */\nvar _functions = {};\n/**\n * All HTML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _htmlGroupBuilders = {};\n/**\n * All MathML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _mathmlGroupBuilders = {};\nfunction defineFunction(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of functions\n  var data = {\n    type,\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    allowedInArgument: !!props.allowedInArgument,\n    allowedInText: !!props.allowedInText,\n    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    primitive: !!props.primitive,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    _functions[names[i]] = data;\n  }\n\n  if (type) {\n    if (htmlBuilder) {\n      _htmlGroupBuilders[type] = htmlBuilder;\n    }\n\n    if (mathmlBuilder) {\n      _mathmlGroupBuilders[type] = mathmlBuilder;\n    }\n  }\n}\n/**\n * Use this to register only the HTML and MathML builders for a function (e.g.\n * if the function's ParseNode is generated in Parser.js rather than via a\n * stand-alone handler provided to `defineFunction`).\n */\n\nfunction defineFunctionBuilders(_ref2) {\n  var {\n    type,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref2;\n  defineFunction({\n    type,\n    names: [],\n    props: {\n      numArgs: 0\n    },\n\n    handler() {\n      throw new Error('Should never be called.');\n    },\n\n    htmlBuilder,\n    mathmlBuilder\n  });\n}\nvar normalizeArgument = function normalizeArgument(arg) {\n  return arg.type === \"ordgroup\" && arg.body.length === 1 ? arg.body[0] : arg;\n}; // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\nvar ordargument = function ordargument(arg) {\n  return arg.type === \"ordgroup\" ? arg.body : [arg];\n};\n\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupBuilders functions\n * are called, to produce a final HTML tree.\n */\nvar makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)\n// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,\n// and the text before Rule 19.\n\nvar binLeftCanceller = [\"leftmost\", \"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"];\nvar binRightCanceller = [\"rightmost\", \"mrel\", \"mclose\", \"mpunct\"];\nvar styleMap$1 = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\nvar DomEnum = {\n  mord: \"mord\",\n  mop: \"mop\",\n  mbin: \"mbin\",\n  mrel: \"mrel\",\n  mopen: \"mopen\",\n  mclose: \"mclose\",\n  mpunct: \"mpunct\",\n  minner: \"minner\"\n};\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. documentFragments are flattened into their contents, so the\n * returned list contains no fragments. `isRealGroup` is true if `expression`\n * is a real group (no atoms will be added on either side), as opposed to\n * a partial group (e.g. one created by \\color). `surrounding` is an array\n * consisting type of nodes that will be added to the left and right.\n */\nvar buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {\n  if (surrounding === void 0) {\n    surrounding = [null, null];\n  }\n\n  // Parse expressions into `groups`.\n  var groups = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    var output = buildGroup$1(expression[i], options);\n\n    if (output instanceof DocumentFragment) {\n      var children = output.children;\n      groups.push(...children);\n    } else {\n      groups.push(output);\n    }\n  } // Combine consecutive domTree.symbolNodes into a single symbolNode.\n\n\n  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings\n  // to avoid processing groups multiple times.\n\n  if (!isRealGroup) {\n    return groups;\n  }\n\n  var glueOptions = options;\n\n  if (expression.length === 1) {\n    var node = expression[0];\n\n    if (node.type === \"sizing\") {\n      glueOptions = options.havingSize(node.size);\n    } else if (node.type === \"styling\") {\n      glueOptions = options.havingStyle(styleMap$1[node.style]);\n    }\n  } // Dummy spans for determining spacings between surrounding atoms.\n  // If `expression` has no atoms on the left or right, class \"leftmost\"\n  // or \"rightmost\", respectively, is used to indicate it.\n\n\n  var dummyPrev = makeSpan$1([surrounding[0] || \"leftmost\"], [], options);\n  var dummyNext = makeSpan$1([surrounding[1] || \"rightmost\"], [], options); // TODO: These code assumes that a node's math class is the first element\n  // of its `classes` array. A later cleanup should ensure this, for\n  // instance by changing the signature of `makeSpan`.\n  // Before determining what spaces to insert, perform bin cancellation.\n  // Binary operators change to ordinary symbols in some contexts.\n\n  var isRoot = isRealGroup === \"root\";\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = prev.classes[0];\n    var type = node.classes[0];\n\n    if (prevType === \"mbin\" && utils.contains(binRightCanceller, type)) {\n      prev.classes[0] = \"mord\";\n    } else if (type === \"mbin\" && utils.contains(binLeftCanceller, prevType)) {\n      node.classes[0] = \"mord\";\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = getTypeOfDomTree(prev);\n    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.\n\n    var space = prevType && type ? node.hasClass(\"mtight\") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;\n\n    if (space) {\n      // Insert glue (spacing) after the `prev`.\n      return buildCommon.makeGlue(space, glueOptions);\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  return groups;\n}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and\n// previous node as arguments, optionally returning a node to insert after the\n// previous node. `prev` is an object with the previous node and `insertAfter`\n// function to insert after it. `next` is a node that will be added to the right.\n// Used for bin cancellation and inserting spacings.\n\nvar traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {\n  if (next) {\n    // temporarily append the right node, if exists\n    nodes.push(next);\n  }\n\n  var i = 0;\n\n  for (; i < nodes.length; i++) {\n    var node = nodes[i];\n    var partialGroup = checkPartialGroup(node);\n\n    if (partialGroup) {\n      // Recursive DFS\n      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array\n      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);\n      continue;\n    } // Ignore explicit spaces (e.g., \\;, \\,) when determining what implicit\n    // spacing should go between atoms of different classes\n\n\n    var nonspace = !node.hasClass(\"mspace\");\n\n    if (nonspace) {\n      var result = callback(node, prev.node);\n\n      if (result) {\n        if (prev.insertAfter) {\n          prev.insertAfter(result);\n        } else {\n          // insert at front\n          nodes.unshift(result);\n          i++;\n        }\n      }\n    }\n\n    if (nonspace) {\n      prev.node = node;\n    } else if (isRoot && node.hasClass(\"newline\")) {\n      prev.node = makeSpan$1([\"leftmost\"]); // treat like beginning of line\n    }\n\n    prev.insertAfter = (index => n => {\n      nodes.splice(index + 1, 0, n);\n      i++;\n    })(i);\n  }\n\n  if (next) {\n    nodes.pop();\n  }\n}; // Check if given node is a partial group, i.e., does not affect spacing around.\n\n\nvar checkPartialGroup = function checkPartialGroup(node) {\n  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass(\"enclosing\")) {\n    return node;\n  }\n\n  return null;\n}; // Return the outermost node of a domTree.\n\n\nvar getOutermostNode = function getOutermostNode(node, side) {\n  var partialGroup = checkPartialGroup(node);\n\n  if (partialGroup) {\n    var children = partialGroup.children;\n\n    if (children.length) {\n      if (side === \"right\") {\n        return getOutermostNode(children[children.length - 1], \"right\");\n      } else if (side === \"left\") {\n        return getOutermostNode(children[0], \"left\");\n      }\n    }\n  }\n\n  return node;\n}; // Return math atom class (mclass) of a domTree.\n// If `side` is given, it will get the type of the outermost node at given side.\n\n\nvar getTypeOfDomTree = function getTypeOfDomTree(node, side) {\n  if (!node) {\n    return null;\n  }\n\n  if (side) {\n    node = getOutermostNode(node, side);\n  } // This makes a lot of assumptions as to where the type of atom\n  // appears.  We should do a better job of enforcing this.\n\n\n  return DomEnum[node.classes[0]] || null;\n};\nvar makeNullDelimiter = function makeNullDelimiter(options, classes) {\n  var moreClasses = [\"nulldelimiter\"].concat(options.baseSizingClasses());\n  return makeSpan$1(classes.concat(moreClasses));\n};\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\n\nvar buildGroup$1 = function buildGroup(group, options, baseOptions) {\n  if (!group) {\n    return makeSpan$1();\n  }\n\n  if (_htmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account\n    // for that size difference.\n\n    if (baseOptions && options.size !== baseOptions.size) {\n      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);\n      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    return groupNode;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)\n * into an unbreakable HTML node of class .base, with proper struts to\n * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to\n * make up the entire expression as a sequence of unbreakable units.\n */\n\nfunction buildHTMLUnbreakable(children, options) {\n  // Compute height and depth of this chunk.\n  var body = makeSpan$1([\"base\"], children, options); // Add strut, which ensures that the top of the HTML element falls at\n  // the height of the expression, and the bottom of the HTML element\n  // falls at the depth of the expression.\n\n  var strut = makeSpan$1([\"strut\"]);\n  strut.style.height = makeEm(body.height + body.depth);\n\n  if (body.depth) {\n    strut.style.verticalAlign = makeEm(-body.depth);\n  }\n\n  body.children.unshift(strut);\n  return body;\n}\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\n\n\nfunction buildHTML(tree, options) {\n  // Strip off outer tag wrapper for processing below.\n  var tag = null;\n\n  if (tree.length === 1 && tree[0].type === \"tag\") {\n    tag = tree[0].tag;\n    tree = tree[0].body;\n  } // Build the expression contained in the tree\n\n\n  var expression = buildExpression$1(tree, options, \"root\");\n  var eqnNum;\n\n  if (expression.length === 2 && expression[1].hasClass(\"tag\")) {\n    // An environment with automatic equation numbers, e.g. {gather}.\n    eqnNum = expression.pop();\n  }\n\n  var children = []; // Create one base node for each chunk between potential line breaks.\n  // The TeXBook [p.173] says \"A formula will be broken only after a\n  // relation symbol like $=$ or $<$ or $\\rightarrow$, or after a binary\n  // operation symbol like $+$ or $-$ or $\\times$, where the relation or\n  // binary operation is on the ``outer level'' of the formula (i.e., not\n  // enclosed in {...} and not part of an \\over construction).\"\n\n  var parts = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    parts.push(expression[i]);\n\n    if (expression[i].hasClass(\"mbin\") || expression[i].hasClass(\"mrel\") || expression[i].hasClass(\"allowbreak\")) {\n      // Put any post-operator glue on same line as operator.\n      // Watch for \\nobreak along the way, and stop at \\newline.\n      var nobreak = false;\n\n      while (i < expression.length - 1 && expression[i + 1].hasClass(\"mspace\") && !expression[i + 1].hasClass(\"newline\")) {\n        i++;\n        parts.push(expression[i]);\n\n        if (expression[i].hasClass(\"nobreak\")) {\n          nobreak = true;\n        }\n      } // Don't allow break if \\nobreak among the post-operator glue.\n\n\n      if (!nobreak) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      }\n    } else if (expression[i].hasClass(\"newline\")) {\n      // Write the line except the newline\n      parts.pop();\n\n      if (parts.length > 0) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      } // Put the newline at the top level\n\n\n      children.push(expression[i]);\n    }\n  }\n\n  if (parts.length > 0) {\n    children.push(buildHTMLUnbreakable(parts, options));\n  } // Now, if there was a tag, build it too and append it as a final child.\n\n\n  var tagChild;\n\n  if (tag) {\n    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));\n    tagChild.classes = [\"tag\"];\n    children.push(tagChild);\n  } else if (eqnNum) {\n    children.push(eqnNum);\n  }\n\n  var htmlNode = makeSpan$1([\"katex-html\"], children);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\"); // Adjust the strut of the tag to be the maximum height of all children\n  // (the height of the enclosing htmlNode) for proper vertical alignment.\n\n  if (tagChild) {\n    var strut = tagChild.children[0];\n    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);\n\n    if (htmlNode.depth) {\n      strut.style.verticalAlign = makeEm(-htmlNode.depth);\n    }\n  }\n\n  return htmlNode;\n}\n\n/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\nfunction newDocumentFragment(children) {\n  return new DocumentFragment(children);\n}\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\nclass MathNode {\n  constructor(type, children, classes) {\n    this.type = void 0;\n    this.attributes = void 0;\n    this.children = void 0;\n    this.classes = void 0;\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n    this.classes = classes || [];\n  }\n  /**\n   * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n   * semantic content, so this is used heavily.\n   */\n\n\n  setAttribute(name, value) {\n    this.attributes[name] = value;\n  }\n  /**\n   * Gets an attribute on a MathML node.\n   */\n\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    if (this.classes.length > 0) {\n      node.className = createClass(this.classes);\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    var markup = \"<\" + this.type; // Add the attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\";\n        markup += utils.escape(this.attributes[attr]);\n        markup += \"\\\"\";\n      }\n    }\n\n    if (this.classes.length > 0) {\n      markup += \" class =\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText, but escaped.\n   */\n\n\n  toText() {\n    return this.children.map(child => child.toText()).join(\"\");\n  }\n\n}\n/**\n * This node represents a piece of text.\n */\n\nclass TextNode {\n  constructor(text) {\n    this.text = void 0;\n    this.text = text;\n  }\n  /**\n   * Converts the text node into a DOM text node.\n   */\n\n\n  toNode() {\n    return document.createTextNode(this.text);\n  }\n  /**\n   * Converts the text node into escaped HTML markup\n   * (representing the text itself).\n   */\n\n\n  toMarkup() {\n    return utils.escape(this.toText());\n  }\n  /**\n   * Converts the text node into a string\n   * (representing the text iteself).\n   */\n\n\n  toText() {\n    return this.text;\n  }\n\n}\n/**\n * This node represents a space, but may render as <mspace.../> or as text,\n * depending on the width.\n */\n\nclass SpaceNode {\n  /**\n   * Create a Space node with width given in CSS ems.\n   */\n  constructor(width) {\n    this.width = void 0;\n    this.character = void 0;\n    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html\n    // for a table of space-like characters.  We use Unicode\n    // representations instead of &LongNames; as it's not clear how to\n    // make the latter via document.createTextNode.\n\n    if (width >= 0.05555 && width <= 0.05556) {\n      this.character = \"\\u200a\"; // &VeryThinSpace;\n    } else if (width >= 0.1666 && width <= 0.1667) {\n      this.character = \"\\u2009\"; // &ThinSpace;\n    } else if (width >= 0.2222 && width <= 0.2223) {\n      this.character = \"\\u2005\"; // &MediumSpace;\n    } else if (width >= 0.2777 && width <= 0.2778) {\n      this.character = \"\\u2005\\u200a\"; // &ThickSpace;\n    } else if (width >= -0.05556 && width <= -0.05555) {\n      this.character = \"\\u200a\\u2063\"; // &NegativeVeryThinSpace;\n    } else if (width >= -0.1667 && width <= -0.1666) {\n      this.character = \"\\u2009\\u2063\"; // &NegativeThinSpace;\n    } else if (width >= -0.2223 && width <= -0.2222) {\n      this.character = \"\\u205f\\u2063\"; // &NegativeMediumSpace;\n    } else if (width >= -0.2778 && width <= -0.2777) {\n      this.character = \"\\u2005\\u2063\"; // &NegativeThickSpace;\n    } else {\n      this.character = null;\n    }\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    if (this.character) {\n      return document.createTextNode(this.character);\n    } else {\n      var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"mspace\");\n      node.setAttribute(\"width\", makeEm(this.width));\n      return node;\n    }\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    if (this.character) {\n      return \"<mtext>\" + this.character + \"</mtext>\";\n    } else {\n      return \"<mspace width=\\\"\" + makeEm(this.width) + \"\\\"/>\";\n    }\n  }\n  /**\n   * Converts the math node into a string, similar to innerText.\n   */\n\n\n  toText() {\n    if (this.character) {\n      return this.character;\n    } else {\n      return \" \";\n    }\n  }\n\n}\n\nvar mathMLTree = {\n  MathNode,\n  TextNode,\n  SpaceNode,\n  newDocumentFragment\n};\n\n/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function makeText(text, mode, options) {\n  if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === \"tt\" || options.font && options.font.substr(4, 2) === \"tt\"))) {\n    text = symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Wrap the given array of nodes in an <mrow> node if needed, i.e.,\n * unless the array has length 1.  Always returns a single node.\n */\n\nvar makeRow = function makeRow(body) {\n  if (body.length === 1) {\n    return body[0];\n  } else {\n    return new mathMLTree.MathNode(\"mrow\", body);\n  }\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\nvar getVariant = function getVariant(group, options) {\n  // Handle \\text... font specifiers as best we can.\n  // MathML has a limited list of allowable mathvariant specifiers; see\n  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt\n  if (options.fontFamily === \"texttt\") {\n    return \"monospace\";\n  } else if (options.fontFamily === \"textsf\") {\n    if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n      return \"sans-serif-bold-italic\";\n    } else if (options.fontShape === \"textit\") {\n      return \"sans-serif-italic\";\n    } else if (options.fontWeight === \"textbf\") {\n      return \"bold-sans-serif\";\n    } else {\n      return \"sans-serif\";\n    }\n  } else if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n    return \"bold-italic\";\n  } else if (options.fontShape === \"textit\") {\n    return \"italic\";\n  } else if (options.fontWeight === \"textbf\") {\n    return \"bold\";\n  }\n\n  var font = options.font;\n\n  if (!font || font === \"mathnormal\") {\n    return null;\n  }\n\n  var mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  } else if (font === \"boldsymbol\") {\n    return group.type === \"textord\" ? \"bold\" : \"bold-italic\";\n  } else if (font === \"mathbf\") {\n    return \"bold\";\n  } else if (font === \"mathbb\") {\n    return \"double-struck\";\n  } else if (font === \"mathfrak\") {\n    return \"fraktur\";\n  } else if (font === \"mathscr\" || font === \"mathcal\") {\n    // MathML makes no distinction between script and caligrahpic\n    return \"script\";\n  } else if (font === \"mathsf\") {\n    return \"sans-serif\";\n  } else if (font === \"mathtt\") {\n    return \"monospace\";\n  }\n\n  var text = group.text;\n\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], text)) {\n    return null;\n  }\n\n  if (symbols[mode][text] && symbols[mode][text].replace) {\n    text = symbols[mode][text].replace;\n  }\n\n  var fontName = buildCommon.fontMap[font].fontName;\n\n  if (getCharacterMetrics(text, fontName, mode)) {\n    return buildCommon.fontMap[font].variant;\n  }\n\n  return null;\n};\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes.  Also combine consecutive <mtext> outputs into a single\n * <mtext> tag.\n */\n\nvar buildExpression = function buildExpression(expression, options, isOrdgroup) {\n  if (expression.length === 1) {\n    var group = buildGroup(expression[0], options);\n\n    if (isOrdgroup && group instanceof MathNode && group.type === \"mo\") {\n      // When TeX writers want to suppress spacing on an operator,\n      // they often put the operator by itself inside braces.\n      group.setAttribute(\"lspace\", \"0em\");\n      group.setAttribute(\"rspace\", \"0em\");\n    }\n\n    return [group];\n  }\n\n  var groups = [];\n  var lastGroup;\n\n  for (var i = 0; i < expression.length; i++) {\n    var _group = buildGroup(expression[i], options);\n\n    if (_group instanceof MathNode && lastGroup instanceof MathNode) {\n      // Concatenate adjacent <mtext>s\n      if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate adjacent <mn>s\n      } else if (_group.type === 'mn' && lastGroup.type === 'mn') {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>\n      } else if (_group.type === 'mi' && _group.children.length === 1 && lastGroup.type === 'mn') {\n        var child = _group.children[0];\n\n        if (child instanceof TextNode && child.text === '.') {\n          lastGroup.children.push(..._group.children);\n          continue;\n        }\n      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {\n        var lastChild = lastGroup.children[0];\n\n        if (lastChild instanceof TextNode && lastChild.text === '\\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {\n          var _child = _group.children[0];\n\n          if (_child instanceof TextNode && _child.text.length > 0) {\n            // Overlay with combining character long solidus\n            _child.text = _child.text.slice(0, 1) + \"\\u0338\" + _child.text.slice(1);\n            groups.pop();\n          }\n        }\n      }\n    }\n\n    groups.push(_group);\n    lastGroup = _group;\n  }\n\n  return groups;\n};\n/**\n * Equivalent to buildExpression, but wraps the elements in an <mrow>\n * if there's more than one.  Returns a single node instead of an array.\n */\n\nvar buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {\n  return makeRow(buildExpression(expression, options, isOrdgroup));\n};\n/**\n * Takes a group from the parser and calls the appropriate groupBuilders function\n * on it to produce a MathML node.\n */\n\nvar buildGroup = function buildGroup(group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (_mathmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe\n\n    return result;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\nfunction buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {\n  var expression = buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes\n  // and add spacing nodes. This is necessary only adjacent to math operators\n  // like \\sin or \\lim or to subsup elements that contain math operators.\n  // MathML takes care of the other spacing issues.\n  // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly, unless it's a single <mrow> or <mtable>.\n\n  var wrapper;\n\n  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains([\"mrow\", \"mtable\"], expression[0].type)) {\n    wrapper = expression[0];\n  } else {\n    wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n  } // Build a TeX annotation of the source\n\n\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]);\n  math.setAttribute(\"xmlns\", \"http://www.w3.org/1998/Math/MathML\");\n\n  if (isDisplayMode) {\n    math.setAttribute(\"display\", \"block\");\n  } // You can't style <math> nodes, so we wrap the node in a span.\n  // NOTE: The span class is not typed to have <math> nodes as children, and\n  // we don't want to make the children type more generic since the children\n  // of span are expected to have more fields in `buildHtml` contexts.\n\n\n  var wrapperClass = forMathmlOnly ? \"katex\" : \"katex-mathml\"; // $FlowFixMe\n\n  return buildCommon.makeSpan([wrapperClass], [math]);\n}\n\nvar optionsFromSettings = function optionsFromSettings(settings) {\n  return new Options({\n    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,\n    maxSize: settings.maxSize,\n    minRuleThickness: settings.minRuleThickness\n  });\n};\n\nvar displayWrap = function displayWrap(node, settings) {\n  if (settings.displayMode) {\n    var classes = [\"katex-display\"];\n\n    if (settings.leqno) {\n      classes.push(\"leqno\");\n    }\n\n    if (settings.fleqn) {\n      classes.push(\"fleqn\");\n    }\n\n    node = buildCommon.makeSpan(classes, [node]);\n  }\n\n  return node;\n};\n\nvar buildTree = function buildTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var katexNode;\n\n  if (settings.output === \"mathml\") {\n    return buildMathML(tree, expression, options, settings.displayMode, true);\n  } else if (settings.output === \"html\") {\n    var htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  } else {\n    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);\n\n    var _htmlNode = buildHTML(tree, options);\n\n    katexNode = buildCommon.makeSpan([\"katex\"], [mathMLNode, _htmlNode]);\n  }\n\n  return displayWrap(katexNode, settings);\n};\nvar buildHTMLTree = function buildHTMLTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var htmlNode = buildHTML(tree, options);\n  var katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  return displayWrap(katexNode, settings);\n};\n\n/**\n * This file provides support to buildMathML.js and buildHTML.js\n * for stretchy wide elements rendered from SVG files\n * and other CSS trickery.\n */\nvar stretchyCodePoint = {\n  widehat: \"^\",\n  widecheck: \"ˇ\",\n  widetilde: \"~\",\n  utilde: \"~\",\n  overleftarrow: \"\\u2190\",\n  underleftarrow: \"\\u2190\",\n  xleftarrow: \"\\u2190\",\n  overrightarrow: \"\\u2192\",\n  underrightarrow: \"\\u2192\",\n  xrightarrow: \"\\u2192\",\n  underbrace: \"\\u23df\",\n  overbrace: \"\\u23de\",\n  overgroup: \"\\u23e0\",\n  undergroup: \"\\u23e1\",\n  overleftrightarrow: \"\\u2194\",\n  underleftrightarrow: \"\\u2194\",\n  xleftrightarrow: \"\\u2194\",\n  Overrightarrow: \"\\u21d2\",\n  xRightarrow: \"\\u21d2\",\n  overleftharpoon: \"\\u21bc\",\n  xleftharpoonup: \"\\u21bc\",\n  overrightharpoon: \"\\u21c0\",\n  xrightharpoonup: \"\\u21c0\",\n  xLeftarrow: \"\\u21d0\",\n  xLeftrightarrow: \"\\u21d4\",\n  xhookleftarrow: \"\\u21a9\",\n  xhookrightarrow: \"\\u21aa\",\n  xmapsto: \"\\u21a6\",\n  xrightharpoondown: \"\\u21c1\",\n  xleftharpoondown: \"\\u21bd\",\n  xrightleftharpoons: \"\\u21cc\",\n  xleftrightharpoons: \"\\u21cb\",\n  xtwoheadleftarrow: \"\\u219e\",\n  xtwoheadrightarrow: \"\\u21a0\",\n  xlongequal: \"=\",\n  xtofrom: \"\\u21c4\",\n  xrightleftarrows: \"\\u21c4\",\n  xrightequilibrium: \"\\u21cc\",\n  // Not a perfect match.\n  xleftequilibrium: \"\\u21cb\",\n  // None better available.\n  \"\\\\cdrightarrow\": \"\\u2192\",\n  \"\\\\cdleftarrow\": \"\\u2190\",\n  \"\\\\cdlongequal\": \"=\"\n};\n\nvar mathMLnode = function mathMLnode(label) {\n  var node = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\\\/, '')])]);\n  node.setAttribute(\"stretchy\", \"true\");\n  return node;\n}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.\n// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)\n// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)\n// Licensed under the SIL Open Font License, Version 1.1.\n// See \\nhttp://scripts.sil.org/OFL\n// Very Long SVGs\n//    Many of the KaTeX stretchy wide elements use a long SVG image and an\n//    overflow: hidden tactic to achieve a stretchy image while avoiding\n//    distortion of arrowheads or brace corners.\n//    The SVG typically contains a very long (400 em) arrow.\n//    The SVG is in a container span that has overflow: hidden, so the span\n//    acts like a window that exposes only part of the  SVG.\n//    The SVG always has a longer, thinner aspect ratio than the container span.\n//    After the SVG fills 100% of the height of the container span,\n//    there is a long arrow shaft left over. That left-over shaft is not shown.\n//    Instead, it is sliced off because the span's CSS has overflow: hidden.\n//    Thus, the reader sees an arrow that matches the subject matter width\n//    without distortion.\n//    Some functions, such as \\cancel, need to vary their aspect ratio. These\n//    functions do not get the overflow SVG treatment.\n// Second Brush Stroke\n//    Low resolution monitors struggle to display images in fine detail.\n//    So browsers apply anti-aliasing. A long straight arrow shaft therefore\n//    will sometimes appear as if it has a blurred edge.\n//    To mitigate this, these SVG files contain a second \"brush-stroke\" on the\n//    arrow shafts. That is, a second long thin rectangular SVG path has been\n//    written directly on top of each arrow shaft. This reinforcement causes\n//    some of the screen pixels to display as black instead of the anti-aliased\n//    gray pixel that a  single path would generate. So we get arrow shafts\n//    whose edges appear to be sharper.\n// In the katexImagesData object just below, the dimensions all\n// correspond to path geometry inside the relevant SVG.\n// For example, \\overrightarrow uses the same arrowhead as glyph U+2192\n// from the KaTeX Main font. The scaling factor is 1000.\n// That is, inside the font, that arrowhead is 522 units tall, which\n// corresponds to 0.522 em inside the document.\n\n\nvar katexImagesData = {\n  //   path(s), minWidth, height, align\n  overrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  overleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  underrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  underleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  xrightarrow: [[\"rightarrow\"], 1.469, 522, \"xMaxYMin\"],\n  \"\\\\cdrightarrow\": [[\"rightarrow\"], 3.0, 522, \"xMaxYMin\"],\n  // CD minwwidth2.5pc\n  xleftarrow: [[\"leftarrow\"], 1.469, 522, \"xMinYMin\"],\n  \"\\\\cdleftarrow\": [[\"leftarrow\"], 3.0, 522, \"xMinYMin\"],\n  Overrightarrow: [[\"doublerightarrow\"], 0.888, 560, \"xMaxYMin\"],\n  xRightarrow: [[\"doublerightarrow\"], 1.526, 560, \"xMaxYMin\"],\n  xLeftarrow: [[\"doubleleftarrow\"], 1.526, 560, \"xMinYMin\"],\n  overleftharpoon: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoonup: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoondown: [[\"leftharpoondown\"], 0.888, 522, \"xMinYMin\"],\n  overrightharpoon: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoonup: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoondown: [[\"rightharpoondown\"], 0.888, 522, \"xMaxYMin\"],\n  xlongequal: [[\"longequal\"], 0.888, 334, \"xMinYMin\"],\n  \"\\\\cdlongequal\": [[\"longequal\"], 3.0, 334, \"xMinYMin\"],\n  xtwoheadleftarrow: [[\"twoheadleftarrow\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadrightarrow: [[\"twoheadrightarrow\"], 0.888, 334, \"xMaxYMin\"],\n  overleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  overbrace: [[\"leftbrace\", \"midbrace\", \"rightbrace\"], 1.6, 548],\n  underbrace: [[\"leftbraceunder\", \"midbraceunder\", \"rightbraceunder\"], 1.6, 548],\n  underleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  xleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 1.75, 522],\n  xLeftrightarrow: [[\"doubleleftarrow\", \"doublerightarrow\"], 1.75, 560],\n  xrightleftharpoons: [[\"leftharpoondownplus\", \"rightharpoonplus\"], 1.75, 716],\n  xleftrightharpoons: [[\"leftharpoonplus\", \"rightharpoondownplus\"], 1.75, 716],\n  xhookleftarrow: [[\"leftarrow\", \"righthook\"], 1.08, 522],\n  xhookrightarrow: [[\"lefthook\", \"rightarrow\"], 1.08, 522],\n  overlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  underlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  overgroup: [[\"leftgroup\", \"rightgroup\"], 0.888, 342],\n  undergroup: [[\"leftgroupunder\", \"rightgroupunder\"], 0.888, 342],\n  xmapsto: [[\"leftmapsto\", \"rightarrow\"], 1.5, 522],\n  xtofrom: [[\"leftToFrom\", \"rightToFrom\"], 1.75, 528],\n  // The next three arrows are from the mhchem package.\n  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the\n  // document as \\xrightarrow or \\xrightleftharpoons. Those have\n  // min-length = 1.75em, so we set min-length on these next three to match.\n  xrightleftarrows: [[\"baraboveleftarrow\", \"rightarrowabovebar\"], 1.75, 901],\n  xrightequilibrium: [[\"baraboveshortleftharpoon\", \"rightharpoonaboveshortbar\"], 1.75, 716],\n  xleftequilibrium: [[\"shortbaraboveleftharpoon\", \"shortrightharpoonabovebar\"], 1.75, 716]\n};\n\nvar groupLength = function groupLength(arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.body.length;\n  } else {\n    return 1;\n  }\n};\n\nvar svgSpan = function svgSpan(group, options) {\n  // Create a span with inline SVG for the element.\n  function buildSvgSpan_() {\n    var viewBoxWidth = 400000; // default\n\n    var label = group.label.substr(1);\n\n    if (utils.contains([\"widehat\", \"widecheck\", \"widetilde\", \"utilde\"], label)) {\n      // Each type in the `if` statement corresponds to one of the ParseNode\n      // types below. This narrowing is required to access `grp.base`.\n      // $FlowFixMe\n      var grp = group; // There are four SVG images available for each function.\n      // Choose a taller image when there are more characters.\n\n      var numChars = groupLength(grp.base);\n      var viewBoxHeight;\n      var pathName;\n\n      var _height;\n\n      if (numChars > 5) {\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxHeight = 420;\n          viewBoxWidth = 2364;\n          _height = 0.42;\n          pathName = label + \"4\";\n        } else {\n          viewBoxHeight = 312;\n          viewBoxWidth = 2340;\n          _height = 0.34;\n          pathName = \"tilde4\";\n        }\n      } else {\n        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];\n\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];\n          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];\n          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];\n          pathName = label + imgIndex;\n        } else {\n          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];\n          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];\n          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];\n          pathName = \"tilde\" + imgIndex;\n        }\n      }\n\n      var path = new PathNode(pathName);\n      var svgNode = new SvgNode([path], {\n        \"width\": \"100%\",\n        \"height\": makeEm(_height),\n        \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n        \"preserveAspectRatio\": \"none\"\n      });\n      return {\n        span: buildCommon.makeSvgSpan([], [svgNode], options),\n        minWidth: 0,\n        height: _height\n      };\n    } else {\n      var spans = [];\n      var data = katexImagesData[label];\n      var [paths, _minWidth, _viewBoxHeight] = data;\n\n      var _height2 = _viewBoxHeight / 1000;\n\n      var numSvgChildren = paths.length;\n      var widthClasses;\n      var aligns;\n\n      if (numSvgChildren === 1) {\n        // $FlowFixMe: All these cases must be of the 4-tuple type.\n        var align1 = data[3];\n        widthClasses = [\"hide-tail\"];\n        aligns = [align1];\n      } else if (numSvgChildren === 2) {\n        widthClasses = [\"halfarrow-left\", \"halfarrow-right\"];\n        aligns = [\"xMinYMin\", \"xMaxYMin\"];\n      } else if (numSvgChildren === 3) {\n        widthClasses = [\"brace-left\", \"brace-center\", \"brace-right\"];\n        aligns = [\"xMinYMin\", \"xMidYMin\", \"xMaxYMin\"];\n      } else {\n        throw new Error(\"Correct katexImagesData or update code here to support\\n                    \" + numSvgChildren + \" children.\");\n      }\n\n      for (var i = 0; i < numSvgChildren; i++) {\n        var _path = new PathNode(paths[i]);\n\n        var _svgNode = new SvgNode([_path], {\n          \"width\": \"400em\",\n          \"height\": makeEm(_height2),\n          \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + _viewBoxHeight,\n          \"preserveAspectRatio\": aligns[i] + \" slice\"\n        });\n\n        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);\n\n        if (numSvgChildren === 1) {\n          return {\n            span: _span,\n            minWidth: _minWidth,\n            height: _height2\n          };\n        } else {\n          _span.style.height = makeEm(_height2);\n          spans.push(_span);\n        }\n      }\n\n      return {\n        span: buildCommon.makeSpan([\"stretchy\"], spans, options),\n        minWidth: _minWidth,\n        height: _height2\n      };\n    }\n  } // buildSvgSpan_()\n\n\n  var {\n    span,\n    minWidth,\n    height\n  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.\n  // Any adjustments relative to the baseline must be done in buildHTML.\n\n  span.height = height;\n  span.style.height = makeEm(height);\n\n  if (minWidth > 0) {\n    span.style.minWidth = makeEm(minWidth);\n  }\n\n  return span;\n};\n\nvar encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {\n  // Return an image span for \\cancel, \\bcancel, \\xcancel, \\fbox, or \\angl\n  var img;\n  var totalHeight = inner.height + inner.depth + topPad + bottomPad;\n\n  if (/fbox|color|angl/.test(label)) {\n    img = buildCommon.makeSpan([\"stretchy\", label], [], options);\n\n    if (label === \"fbox\") {\n      var color = options.color && options.getColor();\n\n      if (color) {\n        img.style.borderColor = color;\n      }\n    }\n  } else {\n    // \\cancel, \\bcancel, or \\xcancel\n    // Since \\cancel's SVG is inline and it omits the viewBox attribute,\n    // its stroke-width will not vary with span area.\n    var lines = [];\n\n    if (/^[bx]cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"0\",\n        \"x2\": \"100%\",\n        \"y2\": \"100%\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    if (/^x?cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"100%\",\n        \"x2\": \"100%\",\n        \"y2\": \"0\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    var svgNode = new SvgNode(lines, {\n      \"width\": \"100%\",\n      \"height\": makeEm(totalHeight)\n    });\n    img = buildCommon.makeSvgSpan([], [svgNode], options);\n  }\n\n  img.height = totalHeight;\n  img.style.height = makeEm(totalHeight);\n  return img;\n};\n\nvar stretchy = {\n  encloseSpan,\n  mathMLnode,\n  svgSpan\n};\n\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\nfunction assertNodeType(node, type) {\n  if (!node || node.type !== type) {\n    throw new Error(\"Expected node of type \" + type + \", but got \" + (node ? \"node of type \" + node.type : String(node)));\n  } // $FlowFixMe, >=0.125\n\n\n  return node;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction assertSymbolNodeType(node) {\n  var typedNode = checkSymbolNodeType(node);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of symbol group type, but got \" + (node ? \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkSymbolNodeType(node) {\n  if (node && (node.type === \"atom\" || NON_ATOMS.hasOwnProperty(node.type))) {\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"accent\", but\n// also \"supsub\" since an accent can affect super/subscripting.\nvar htmlBuilder$a = (grp, options) => {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  var base;\n  var group;\n  var supSubGroup;\n\n  if (grp && grp.type === \"supsub\") {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n    // The real accent group is the base of the supsub group\n    group = assertNodeType(grp.base, \"accent\"); // The character box is the base of the accent group\n\n    base = group.base; // Stick the character box into the base of the supsub group\n\n    grp.base = base; // Rerender the supsub group with its new base, and store that\n    // result.\n\n    supSubGroup = assertSpan(buildGroup$1(grp, options)); // reset original base\n\n    grp.base = group;\n  } else {\n    group = assertNodeType(grp, \"accent\");\n    base = group.base;\n  } // Build the base group\n\n\n  var body = buildGroup$1(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?\n\n  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n\n  var skew = 0;\n\n  if (mustShift) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it\n\n    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.\n\n    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  }\n\n  var accentBelow = group.label === \"\\\\c\"; // calculate the amount of space between the body and the accent\n\n  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent\n\n  var accentBody;\n\n  if (!group.isStretchy) {\n    var accent;\n    var width;\n\n    if (group.label === \"\\\\vec\") {\n      // Before version 0.9, \\vec used the combining font glyph U+20D7.\n      // But browsers, especially Safari, are not consistent in how they\n      // render combining characters when not preceded by a character.\n      // So now we use an SVG.\n      // If Safari reforms, we should consider reverting to the glyph.\n      accent = buildCommon.staticSvg(\"vec\", options);\n      width = buildCommon.svgData.vec[1];\n    } else {\n      accent = buildCommon.makeOrd({\n        mode: group.mode,\n        text: group.label\n      }, options, \"textord\");\n      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to\n      // shift the accent over to a place we don't want.\n\n      accent.italic = 0;\n      width = accent.width;\n\n      if (accentBelow) {\n        clearance += accent.depth;\n      }\n    }\n\n    accentBody = buildCommon.makeSpan([\"accent-body\"], [accent]); // \"Full\" accents expand the width of the resulting symbol to be\n    // at least the width of the accent, and overlap directly onto the\n    // character without any vertical offset.\n\n    var accentFull = group.label === \"\\\\textcircled\";\n\n    if (accentFull) {\n      accentBody.classes.push('accent-full');\n      clearance = body.height;\n    } // Shift the accent over by the skew.\n\n\n    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`\n    // so that the accent doesn't contribute to the bounding box.\n    // We need to shift the character by its width (effectively half\n    // its width) to compensate.\n\n    if (!accentFull) {\n      left -= width / 2;\n    }\n\n    accentBody.style.left = makeEm(left); // \\textcircled uses the \\bigcirc glyph, so it needs some\n    // vertical adjustment to match LaTeX.\n\n    if (group.label === \"\\\\textcircled\") {\n      accentBody.style.top = \".2em\";\n    }\n\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: -clearance\n      }, {\n        type: \"elem\",\n        elem: accentBody\n      }]\n    }, options);\n  } else {\n    accentBody = stretchy.svgSpan(group, options);\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"],\n        wrapperStyle: skew > 0 ? {\n          width: \"calc(100% - \" + makeEm(2 * skew) + \")\",\n          marginLeft: makeEm(2 * skew)\n        } : undefined\n      }]\n    }, options);\n  }\n\n  var accentWrap = buildCommon.makeSpan([\"mord\", \"accent\"], [accentBody], options);\n\n  if (supSubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n\n    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.\n\n    supSubGroup.classes[0] = \"mord\";\n    return supSubGroup;\n  } else {\n    return accentWrap;\n  }\n};\n\nvar mathmlBuilder$9 = (group, options) => {\n  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode(\"mo\", [makeText(group.label, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\nvar NON_STRETCHY_ACCENT_REGEX = new RegExp([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\"].map(accent => \"\\\\\" + accent).join(\"|\")); // Accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\", \"\\\\widecheck\", \"\\\\widehat\", \"\\\\widetilde\", \"\\\\overrightarrow\", \"\\\\overleftarrow\", \"\\\\Overrightarrow\", \"\\\\overleftrightarrow\", \"\\\\overgroup\", \"\\\\overlinesegment\", \"\\\\overleftharpoon\", \"\\\\overrightharpoon\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (context, args) => {\n    var base = normalizeArgument(args[0]);\n    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);\n    var isShifty = !isStretchy || context.funcName === \"\\\\widehat\" || context.funcName === \"\\\\widetilde\" || context.funcName === \"\\\\widecheck\";\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: isStretchy,\n      isShifty: isShifty,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n}); // Text-mode accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\'\", \"\\\\`\", \"\\\\^\", \"\\\\~\", \"\\\\=\", \"\\\\u\", \"\\\\.\", '\\\\\"', \"\\\\c\", \"\\\\r\", \"\\\\H\", \"\\\\v\", \"\\\\textcircled\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    allowedInMath: true,\n    // unless in strict mode\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var base = args[0];\n    var mode = context.parser.mode;\n\n    if (mode === \"math\") {\n      context.parser.settings.reportNonstrict(\"mathVsTextAccents\", \"LaTeX's accent \" + context.funcName + \" works only in text mode\");\n      mode = \"text\";\n    }\n\n    return {\n      type: \"accent\",\n      mode: mode,\n      label: context.funcName,\n      isStretchy: false,\n      isShifty: true,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"accentUnder\",\n  names: [\"\\\\underleftarrow\", \"\\\\underrightarrow\", \"\\\\underleftrightarrow\", \"\\\\undergroup\", \"\\\\underlinesegment\", \"\\\\utilde\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var base = args[0];\n    return {\n      type: \"accentUnder\",\n      mode: parser.mode,\n      label: funcName,\n      base: base\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // Treat under accents much like underlines.\n    var innerGroup = buildGroup$1(group.base, options);\n    var accentBody = stretchy.svgSpan(group, options);\n    var kern = group.label === \"\\\\utilde\" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns\n\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: kern\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"accentunder\"], [vlist], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var accentNode = stretchy.mathMLnode(group.label);\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.base, options), accentNode]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n\n// Helper function\nvar paddedNode = group => {\n  var node = new mathMLTree.MathNode(\"mpadded\", group ? [group] : []);\n  node.setAttribute(\"width\", \"+0.6em\");\n  node.setAttribute(\"lspace\", \"0.3em\");\n  return node;\n}; // Stretchy arrows with an optional argument\n\n\ndefineFunction({\n  type: \"xArrow\",\n  names: [\"\\\\xleftarrow\", \"\\\\xrightarrow\", \"\\\\xLeftarrow\", \"\\\\xRightarrow\", \"\\\\xleftrightarrow\", \"\\\\xLeftrightarrow\", \"\\\\xhookleftarrow\", \"\\\\xhookrightarrow\", \"\\\\xmapsto\", \"\\\\xrightharpoondown\", \"\\\\xrightharpoonup\", \"\\\\xleftharpoondown\", \"\\\\xleftharpoonup\", \"\\\\xrightleftharpoons\", \"\\\\xleftrightharpoons\", \"\\\\xlongequal\", \"\\\\xtwoheadrightarrow\", \"\\\\xtwoheadleftarrow\", \"\\\\xtofrom\", // The next 3 functions are here to support the mhchem extension.\n  // Direct use of these functions is discouraged and may break someday.\n  \"\\\\xrightleftarrows\", \"\\\\xrightequilibrium\", \"\\\\xleftequilibrium\", // The next 3 functions are here only to support the {CD} environment.\n  \"\\\\\\\\cdrightarrow\", \"\\\\\\\\cdleftarrow\", \"\\\\\\\\cdlongequal\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"xArrow\",\n      mode: parser.mode,\n      label: funcName,\n      body: args[0],\n      below: optArgs[0]\n    };\n  },\n\n  // Flow is unable to correctly infer the type of `group`, even though it's\n  // unamibiguously determined from the passed-in `type` above.\n  htmlBuilder(group, options) {\n    var style = options.style; // Build the argument groups in the appropriate style.\n    // Ref: amsmath.dtx:   \\hbox{$\\scriptstyle\\mkern#3mu{#6}\\mkern#4mu$}%\n    // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n    var newOptions = options.havingStyle(style.sup());\n    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);\n    var arrowPrefix = group.label.slice(0, 2) === \"\\\\x\" ? \"x\" : \"cd\";\n    upperGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    var lowerGroup;\n\n    if (group.below) {\n      // Build the lower group\n      newOptions = options.havingStyle(style.sub());\n      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);\n      lowerGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    }\n\n    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.\n    // The point we want on the math axis is at 0.5 * arrowBody.height.\n\n    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\\if0#2\\else\\mkern#2mu\\fi\n\n    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu\n\n    if (upperGroup.depth > 0.25 || group.label === \"\\\\xleftequilibrium\") {\n      upperShift -= upperGroup.depth; // shift up if depth encroaches\n    } // Generate the vlist\n\n\n    var vlist;\n\n    if (lowerGroup) {\n      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }, {\n          type: \"elem\",\n          elem: lowerGroup,\n          shift: lowerShift\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }]\n      }, options);\n    } // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n    return buildCommon.makeSpan([\"mrel\", \"x-arrow\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var arrowNode = stretchy.mathMLnode(group.label);\n    arrowNode.setAttribute(\"minsize\", group.label.charAt(0) === \"x\" ? \"1.75em\" : \"3.0em\");\n    var node;\n\n    if (group.body) {\n      var upperNode = paddedNode(buildGroup(group.body, options));\n\n      if (group.below) {\n        var lowerNode = paddedNode(buildGroup(group.below, options));\n        node = new mathMLTree.MathNode(\"munderover\", [arrowNode, lowerNode, upperNode]);\n      } else {\n        node = new mathMLTree.MathNode(\"mover\", [arrowNode, upperNode]);\n      }\n    } else if (group.below) {\n      var _lowerNode = paddedNode(buildGroup(group.below, options));\n\n      node = new mathMLTree.MathNode(\"munder\", [arrowNode, _lowerNode]);\n    } else {\n      // This should never happen.\n      // Parser.js throws an error if there is no argument.\n      node = paddedNode();\n      node = new mathMLTree.MathNode(\"mover\", [arrowNode, node]);\n    }\n\n    return node;\n  }\n\n});\n\nvar cdArrowFunctionName = {\n  \">\": \"\\\\\\\\cdrightarrow\",\n  \"<\": \"\\\\\\\\cdleftarrow\",\n  \"=\": \"\\\\\\\\cdlongequal\",\n  \"A\": \"\\\\uparrow\",\n  \"V\": \"\\\\downarrow\",\n  \"|\": \"\\\\Vert\",\n  \".\": \"no arrow\"\n};\n\nvar newCell = () => {\n  // Create an empty cell, to be filled below with parse nodes.\n  // The parseTree from this module must be constructed like the\n  // one created by parseArray(), so an empty CD cell must\n  // be a ParseNode<\"styling\">. And CD is always displaystyle.\n  // So these values are fixed and flow can do implicit typing.\n  return {\n    type: \"styling\",\n    body: [],\n    mode: \"math\",\n    style: \"display\"\n  };\n};\n\nvar isStartOfArrow = node => {\n  return node.type === \"textord\" && node.text === \"@\";\n};\n\nvar isLabelEnd = (node, endChar) => {\n  return (node.type === \"mathord\" || node.type === \"atom\") && node.text === endChar;\n};\n\nfunction cdArrow(arrowChar, labels, parser) {\n  // Return a parse tree of an arrow and its labels.\n  // This acts in a way similar to a macro expansion.\n  var funcName = cdArrowFunctionName[arrowChar];\n\n  switch (funcName) {\n    case \"\\\\\\\\cdrightarrow\":\n    case \"\\\\\\\\cdleftarrow\":\n      return parser.callFunction(funcName, [labels[0]], [labels[1]]);\n\n    case \"\\\\uparrow\":\n    case \"\\\\downarrow\":\n      {\n        var leftLabel = parser.callFunction(\"\\\\\\\\cdleft\", [labels[0]], []);\n        var bareArrow = {\n          type: \"atom\",\n          text: funcName,\n          mode: \"math\",\n          family: \"rel\"\n        };\n        var sizedArrow = parser.callFunction(\"\\\\Big\", [bareArrow], []);\n        var rightLabel = parser.callFunction(\"\\\\\\\\cdright\", [labels[1]], []);\n        var arrowGroup = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: [leftLabel, sizedArrow, rightLabel]\n        };\n        return parser.callFunction(\"\\\\\\\\cdparent\", [arrowGroup], []);\n      }\n\n    case \"\\\\\\\\cdlongequal\":\n      return parser.callFunction(\"\\\\\\\\cdlongequal\", [], []);\n\n    case \"\\\\Vert\":\n      {\n        var arrow = {\n          type: \"textord\",\n          text: \"\\\\Vert\",\n          mode: \"math\"\n        };\n        return parser.callFunction(\"\\\\Big\", [arrow], []);\n      }\n\n    default:\n      return {\n        type: \"textord\",\n        text: \" \",\n        mode: \"math\"\n      };\n  }\n}\n\nfunction parseCD(parser) {\n  // Get the array's parse nodes with \\\\ temporarily mapped to \\cr.\n  var parsedRows = [];\n  parser.gullet.beginGroup();\n  parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  parser.gullet.beginGroup();\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Get the parse nodes for the next row.\n    parsedRows.push(parser.parseExpression(false, \"\\\\\\\\\"));\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    var next = parser.fetch().text;\n\n    if (next === \"&\" || next === \"\\\\\\\\\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      if (parsedRows[parsedRows.length - 1].length === 0) {\n        parsedRows.pop(); // final row ended in \\\\\n      }\n\n      break;\n    } else {\n      throw new ParseError(\"Expected \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  }\n\n  var row = [];\n  var body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.\n\n  for (var i = 0; i < parsedRows.length; i++) {\n    // Start a new row.\n    var rowNodes = parsedRows[i]; // Create the first cell.\n\n    var cell = newCell();\n\n    for (var j = 0; j < rowNodes.length; j++) {\n      if (!isStartOfArrow(rowNodes[j])) {\n        // If a parseNode is not an arrow, it goes into a cell.\n        cell.body.push(rowNodes[j]);\n      } else {\n        // Parse node j is an \"@\", the start of an arrow.\n        // Before starting on the arrow, push the cell into `row`.\n        row.push(cell); // Now collect parseNodes into an arrow.\n        // The character after \"@\" defines the arrow type.\n\n        j += 1;\n        var arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.\n\n        var labels = new Array(2);\n        labels[0] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        };\n        labels[1] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        }; // Process the arrow.\n\n        if (\"=|.\".indexOf(arrowChar) > -1) ; else if (\"<>AV\".indexOf(arrowChar) > -1) {\n          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take\n          // two optional labels. E.g. the right-point arrow syntax is\n          // really:  @>{optional label}>{optional label}>\n          // Collect parseNodes into labels.\n          for (var labelNum = 0; labelNum < 2; labelNum++) {\n            var inLabel = true;\n\n            for (var k = j + 1; k < rowNodes.length; k++) {\n              if (isLabelEnd(rowNodes[k], arrowChar)) {\n                inLabel = false;\n                j = k;\n                break;\n              }\n\n              if (isStartOfArrow(rowNodes[k])) {\n                throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[k]);\n              }\n\n              labels[labelNum].body.push(rowNodes[k]);\n            }\n\n            if (inLabel) {\n              // isLabelEnd never returned a true.\n              throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[j]);\n            }\n          }\n        } else {\n          throw new ParseError(\"Expected one of \\\"<>AV=|.\\\" after @\", rowNodes[j]);\n        } // Now join the arrow to its labels.\n\n\n        var arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<\"styling\">.\n        // This is done to match parseArray() behavior.\n\n        var wrappedArrow = {\n          type: \"styling\",\n          body: [arrow],\n          mode: \"math\",\n          style: \"display\" // CD is always displaystyle.\n\n        };\n        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that\n        // is not an arrow gets collected into a cell. So create an empty\n        // cell now. It will collect upcoming parseNodes.\n\n        cell = newCell();\n      }\n    }\n\n    if (i % 2 === 0) {\n      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell\n      // The last cell is not yet pushed into `row`, so:\n      row.push(cell);\n    } else {\n      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow\n      // Remove the empty cell that was placed at the beginning of `row`.\n      row.shift();\n    }\n\n    row = [];\n    body.push(row);\n  } // End row group\n\n\n  parser.gullet.endGroup(); // End array group defining \\\\\n\n  parser.gullet.endGroup(); // define column separation.\n\n  var cols = new Array(body[0].length).fill({\n    type: \"align\",\n    align: \"c\",\n    pregap: 0.25,\n    // CD package sets \\enskip between columns.\n    postgap: 0.25 // So pre and post each get half an \\enskip, i.e. 0.25em.\n\n  });\n  return {\n    type: \"array\",\n    mode: \"math\",\n    body,\n    arraystretch: 1,\n    addJot: true,\n    rowGaps: [null],\n    cols,\n    colSeparationType: \"CD\",\n    hLinesBeforeRow: new Array(body.length + 1).fill([])\n  };\n} // The functions below are not available for general use.\n// They are here only for internal use by the {CD} environment in placing labels\n// next to vertical arrows.\n// We don't need any such functions for horizontal arrows because we can reuse\n// the functionality that already exists for extensible arrows.\n\ndefineFunction({\n  type: \"cdlabel\",\n  names: [\"\\\\\\\\cdleft\", \"\\\\\\\\cdright\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"cdlabel\",\n      mode: parser.mode,\n      side: funcName.slice(4),\n      label: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = options.havingStyle(options.style.sup());\n    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);\n    label.classes.push(\"cd-label-\" + group.side);\n    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set\n    // by the arrow height, not by the label.\n\n    label.height = 0;\n    label.depth = 0;\n    return label;\n  },\n\n  mathmlBuilder(group, options) {\n    var label = new mathMLTree.MathNode(\"mrow\", [buildGroup(group.label, options)]);\n    label = new mathMLTree.MathNode(\"mpadded\", [label]);\n    label.setAttribute(\"width\", \"0\");\n\n    if (group.side === \"left\") {\n      label.setAttribute(\"lspace\", \"-1width\");\n    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,\n    // But we don't know the height or depth of the label.\n\n\n    label.setAttribute(\"voffset\", \"0.7em\");\n    label = new mathMLTree.MathNode(\"mstyle\", [label]);\n    label.setAttribute(\"displaystyle\", \"false\");\n    label.setAttribute(\"scriptlevel\", \"1\");\n    return label;\n  }\n\n});\ndefineFunction({\n  type: \"cdlabelparent\",\n  names: [\"\\\\\\\\cdparent\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"cdlabelparent\",\n      mode: parser.mode,\n      fragment: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Wrap the vertical arrow and its labels.\n    // The parent gets position: relative. The child gets position: absolute.\n    // So CSS can locate the label correctly.\n    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);\n    parent.classes.push(\"cd-vert-arrow\");\n    return parent;\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", [buildGroup(group.fragment, options)]);\n  }\n\n});\n\n// {123} and converts into symbol with code 123.  It is used by the *macro*\n// \\char defined in macros.js.\n\ndefineFunction({\n  type: \"textord\",\n  names: [\"\\\\@char\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var arg = assertNodeType(args[0], \"ordgroup\");\n    var group = arg.body;\n    var number = \"\";\n\n    for (var i = 0; i < group.length; i++) {\n      var node = assertNodeType(group[i], \"textord\");\n      number += node.text;\n    }\n\n    var code = parseInt(number);\n    var text;\n\n    if (isNaN(code)) {\n      throw new ParseError(\"\\\\@char has non-numeric argument \" + number); // If we drop IE support, the following code could be replaced with\n      // text = String.fromCodePoint(code)\n    } else if (code < 0 || code >= 0x10ffff) {\n      throw new ParseError(\"\\\\@char with invalid code point \" + number);\n    } else if (code <= 0xffff) {\n      text = String.fromCharCode(code);\n    } else {\n      // Astral code point; split into surrogate halves\n      code -= 0x10000;\n      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);\n    }\n\n    return {\n      type: \"textord\",\n      mode: parser.mode,\n      text: text\n    };\n  }\n\n});\n\nvar htmlBuilder$9 = (group, options) => {\n  var elements = buildExpression$1(group.body, options.withColor(group.color), false); // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n\n  return buildCommon.makeFragment(elements);\n};\n\nvar mathmlBuilder$8 = (group, options) => {\n  var inner = buildExpression(group.body, options.withColor(group.color));\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.color);\n  return node;\n};\n\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\textcolor\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"original\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body: ordargument(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\color\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    argTypes: [\"color\"]\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser,\n      breakOnTokenText\n    } = _ref2;\n    var color = assertNodeType(args[0], \"color-token\").color; // Set macro \\current@color in current namespace to store the current\n    // color, mimicking the behavior of color.sty.\n    // This is currently used just to correctly color a \\right\n    // that follows a \\color command.\n\n    parser.gullet.macros.set(\"\\\\current@color\", color); // Parse out the implicit body that should be colored.\n\n    var body = parser.parseExpression(true, breakOnTokenText);\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\n\n// Row breaks within tabular environments, and line breaks at top level\n\ndefineFunction({\n  type: \"cr\",\n  names: [\"\\\\\\\\\"],\n  props: {\n    numArgs: 0,\n    numOptionalArgs: 1,\n    argTypes: [\"size\"],\n    allowedInText: true\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var size = optArgs[0];\n    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior(\"newLineInDisplayMode\", \"In LaTeX, \\\\\\\\ or \\\\newline \" + \"does nothing in display mode\");\n    return {\n      type: \"cr\",\n      mode: parser.mode,\n      newLine,\n      size: size && assertNodeType(size, \"size\").value\n    };\n  },\n\n  // The following builders are called only at the top level,\n  // not within tabular/array environments.\n  htmlBuilder(group, options) {\n    var span = buildCommon.makeSpan([\"mspace\"], [], options);\n\n    if (group.newLine) {\n      span.classes.push(\"newline\");\n\n      if (group.size) {\n        span.style.marginTop = makeEm(calculateSize(group.size, options));\n      }\n    }\n\n    return span;\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mspace\");\n\n    if (group.newLine) {\n      node.setAttribute(\"linebreak\", \"newline\");\n\n      if (group.size) {\n        node.setAttribute(\"height\", makeEm(calculateSize(group.size, options)));\n      }\n    }\n\n    return node;\n  }\n\n});\n\nvar globalMap = {\n  \"\\\\global\": \"\\\\global\",\n  \"\\\\long\": \"\\\\\\\\globallong\",\n  \"\\\\\\\\globallong\": \"\\\\\\\\globallong\",\n  \"\\\\def\": \"\\\\gdef\",\n  \"\\\\gdef\": \"\\\\gdef\",\n  \"\\\\edef\": \"\\\\xdef\",\n  \"\\\\xdef\": \"\\\\xdef\",\n  \"\\\\let\": \"\\\\\\\\globallet\",\n  \"\\\\futurelet\": \"\\\\\\\\globalfuture\"\n};\n\nvar checkControlSequence = tok => {\n  var name = tok.text;\n\n  if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n    throw new ParseError(\"Expected a control sequence\", tok);\n  }\n\n  return name;\n};\n\nvar getRHS = parser => {\n  var tok = parser.gullet.popToken();\n\n  if (tok.text === \"=\") {\n    // consume optional equals\n    tok = parser.gullet.popToken();\n\n    if (tok.text === \" \") {\n      // consume one optional space\n      tok = parser.gullet.popToken();\n    }\n  }\n\n  return tok;\n};\n\nvar letCommand = (parser, name, tok, global) => {\n  var macro = parser.gullet.macros.get(tok.text);\n\n  if (macro == null) {\n    // don't expand it later even if a macro with the same name is defined\n    // e.g., \\let\\foo=\\frac \\def\\frac{\\relax} \\frac12\n    tok.noexpand = true;\n    macro = {\n      tokens: [tok],\n      numArgs: 0,\n      // reproduce the same behavior in expansion\n      unexpandable: !parser.gullet.isExpandable(tok.text)\n    };\n  }\n\n  parser.gullet.macros.set(name, macro, global);\n}; // <assignment> -> <non-macro assignment>|<macro assignment>\n// <non-macro assignment> -> <simple assignment>|\\global<non-macro assignment>\n// <macro assignment> -> <definition>|<prefix><macro assignment>\n// <prefix> -> \\global|\\long|\\outer\n\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\global\", \"\\\\long\", \"\\\\\\\\globallong\" // can’t be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    parser.consumeSpaces();\n    var token = parser.fetch();\n\n    if (globalMap[token.text]) {\n      // KaTeX doesn't have \\par, so ignore \\long\n      if (funcName === \"\\\\global\" || funcName === \"\\\\\\\\globallong\") {\n        token.text = globalMap[token.text];\n      }\n\n      return assertNodeType(parser.parseFunction(), \"internal\");\n    }\n\n    throw new ParseError(\"Invalid token after macro prefix\", token);\n  }\n\n}); // Basic support for macro definitions: \\def, \\gdef, \\edef, \\xdef\n// <definition> -> <def><control sequence><definition text>\n// <def> -> \\def|\\gdef|\\edef|\\xdef\n// <definition text> -> <parameter text><left brace><balanced text><right brace>\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\def\", \"\\\\gdef\", \"\\\\edef\", \"\\\\xdef\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref2) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var tok = parser.gullet.popToken();\n    var name = tok.text;\n\n    if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n      throw new ParseError(\"Expected a control sequence\", tok);\n    }\n\n    var numArgs = 0;\n    var insert;\n    var delimiters = [[]]; // <parameter text> contains no braces\n\n    while (parser.gullet.future().text !== \"{\") {\n      tok = parser.gullet.popToken();\n\n      if (tok.text === \"#\") {\n        // If the very last character of the <parameter text> is #, so that\n        // this # is immediately followed by {, TeX will behave as if the {\n        // had been inserted at the right end of both the parameter text\n        // and the replacement text.\n        if (parser.gullet.future().text === \"{\") {\n          insert = parser.gullet.future();\n          delimiters[numArgs].push(\"{\");\n          break;\n        } // A parameter, the first appearance of # must be followed by 1,\n        // the next by 2, and so on; up to nine #’s are allowed\n\n\n        tok = parser.gullet.popToken();\n\n        if (!/^[1-9]$/.test(tok.text)) {\n          throw new ParseError(\"Invalid argument number \\\"\" + tok.text + \"\\\"\");\n        }\n\n        if (parseInt(tok.text) !== numArgs + 1) {\n          throw new ParseError(\"Argument number \\\"\" + tok.text + \"\\\" out of order\");\n        }\n\n        numArgs++;\n        delimiters.push([]);\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Expected a macro definition\");\n      } else {\n        delimiters[numArgs].push(tok.text);\n      }\n    } // replacement text, enclosed in '{' and '}' and properly nested\n\n\n    var {\n      tokens\n    } = parser.gullet.consumeArg();\n\n    if (insert) {\n      tokens.unshift(insert);\n    }\n\n    if (funcName === \"\\\\edef\" || funcName === \"\\\\xdef\") {\n      tokens = parser.gullet.expandTokens(tokens);\n      tokens.reverse(); // to fit in with stack order\n    } // Final arg is the expansion of the macro\n\n\n    parser.gullet.macros.set(name, {\n      tokens,\n      numArgs,\n      delimiters\n    }, funcName === globalMap[funcName]);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // <simple assignment> -> <let assignment>\n// <let assignment> -> \\futurelet<control sequence><token><token>\n//     | \\let<control sequence><equals><one optional space><token>\n// <equals> -> <optional spaces>|<optional spaces>=\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\let\", \"\\\\\\\\globallet\" // can’t be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var name = checkControlSequence(parser.gullet.popToken());\n    parser.gullet.consumeSpaces();\n    var tok = getRHS(parser);\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globallet\");\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\futurelet\", \"\\\\\\\\globalfuture\" // can’t be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var name = checkControlSequence(parser.gullet.popToken());\n    var middle = parser.gullet.popToken();\n    var tok = parser.gullet.popToken();\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globalfuture\");\n    parser.gullet.pushToken(tok);\n    parser.gullet.pushToken(middle);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function getMetrics(symbol, font, mode) {\n  var replace = symbols.math[symbol] && symbols.math[symbol].replace;\n  var metrics = getCharacterMetrics(replace || symbol, font, mode);\n\n  if (!metrics) {\n    throw new Error(\"Unsupported symbol \" + symbol + \" and font size \" + font + \".\");\n  }\n\n  return metrics;\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nvar styleWrap = function styleWrap(delim, toStyle, options, classes) {\n  var newOptions = options.havingBaseStyle(toStyle);\n  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);\n  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;\n  span.height *= delimSizeMultiplier;\n  span.depth *= delimSizeMultiplier;\n  span.maxFontSize = newOptions.sizeMultiplier;\n  return span;\n};\n\nvar centerSpan = function centerSpan(span, options, style) {\n  var newOptions = options.havingBaseStyle(style);\n  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;\n  span.classes.push(\"delimcenter\");\n  span.style.top = makeEm(shift);\n  span.height -= shift;\n  span.depth += shift;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nvar makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  var span = styleWrap(text, style, options, classes);\n\n  if (center) {\n    centerSpan(span, options, style);\n  }\n\n  return span;\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nvar mathrmSize = function mathrmSize(value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nvar makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {\n  var inner = mathrmSize(delim, size, mode, options);\n  var span = styleWrap(buildCommon.makeSpan([\"delimsizing\", \"size\" + size], [inner], options), Style$1.TEXT, options, classes);\n\n  if (center) {\n    centerSpan(span, options, Style$1.TEXT);\n  }\n\n  return span;\n};\n/**\n * Make a span from a font glyph with the given offset and in the given font.\n * This is used in makeStackedDelim to make the stacking pieces for the delimiter.\n */\n\n\nvar makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {\n  var sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else\n    /* if (font === \"Size4-Regular\") */\n    {\n      sizeClass = \"delim-size4\";\n    }\n\n  var corner = buildCommon.makeSpan([\"delimsizinginner\", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: corner\n  };\n};\n\nvar makeInner = function makeInner(ch, height, options) {\n  // Create a span with inline SVG for the inner part of a tall stacked delimiter.\n  var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];\n  var path = new PathNode(\"inner\", innerPath(ch, Math.round(1000 * height)));\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + Math.round(1000 * height),\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = buildCommon.makeSvgSpan([], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return {\n    type: \"elem\",\n    elem: span\n  };\n}; // Helpers for makeStackedDelim\n\n\nvar lapInEms = 0.008;\nvar lap = {\n  type: \"kern\",\n  size: -1 * lapInEms\n};\nvar verts = [\"|\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\vert\"];\nvar doubleVerts = [\"\\\\|\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\Vert\"];\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\nvar makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  var font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (utils.contains(verts, delim)) {\n    repeat = \"\\u2223\";\n  } else if (utils.contains(doubleVerts, delim)) {\n    repeat = \"\\u2225\";\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lfloor\" || delim === \"\\u230a\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lceil\" || delim === \"\\u2308\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rfloor\" || delim === \"\\u230b\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rceil\" || delim === \"\\u2309\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"(\" || delim === \"\\\\lparen\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n  } else if (delim === \")\" || delim === \"\\\\rparen\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\" || delim === \"\\u27ee\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\" || delim === \"\\u27ef\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\" || delim === \"\\u23b0\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\" || delim === \"\\u23b1\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  var topMetrics = getMetrics(top, font, mode);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = getMetrics(repeat, font, mode);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = getMetrics(bottom, font, mode);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n\n  if (middle !== null) {\n    var middleMetrics = getMetrics(middle, font, mode);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calcuate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols\n\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  var axisHeight = options.fontMetrics().axisHeight;\n\n  if (center) {\n    axisHeight *= options.sizeMultiplier;\n  } // Calculate the depth\n\n\n  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the pieces of the stacked delimiter\n\n  var stack = []; // Add the bottom symbol\n\n  stack.push(makeGlyphSpan(bottom, font, mode));\n  stack.push(lap); // overlap\n\n  if (middle === null) {\n    // The middle section will be an SVG. Make it an extra 0.016em tall.\n    // We'll overlap by 0.008em at top and bottom.\n    var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;\n    stack.push(makeInner(repeat, innerHeight, options));\n  } else {\n    // When there is a middle bit, we need the middle part and two repeated\n    // sections\n    var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;\n\n    stack.push(makeInner(repeat, _innerHeight, options)); // Now insert the middle of the brace.\n\n    stack.push(lap);\n    stack.push(makeGlyphSpan(middle, font, mode));\n    stack.push(lap);\n    stack.push(makeInner(repeat, _innerHeight, options));\n  } // Add the top symbol\n\n\n  stack.push(lap);\n  stack.push(makeGlyphSpan(top, font, mode)); // Finally, build the vlist\n\n  var newOptions = options.havingBaseStyle(Style$1.TEXT);\n  var inner = buildCommon.makeVList({\n    positionType: \"bottom\",\n    positionData: depth,\n    children: stack\n  }, newOptions);\n  return styleWrap(buildCommon.makeSpan([\"delimsizing\", \"mult\"], [inner], newOptions), Style$1.TEXT, options, classes);\n}; // All surds have 0.08em padding above the viniculum inside the SVG.\n// That keeps browser span height rounding error from pinching the line.\n\n\nvar vbPad = 80; // padding above the surd, measured inside the viewBox.\n\nvar emPad = 0.08; // padding, in ems, measured in the document.\n\nvar sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {\n  var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);\n  var pathNode = new PathNode(sqrtName, path);\n  var svg = new SvgNode([pathNode], {\n    // Note: 1000:1 ratio of viewBox to document em width.\n    \"width\": \"400em\",\n    \"height\": makeEm(height),\n    \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n    \"preserveAspectRatio\": \"xMinYMin slice\"\n  });\n  return buildCommon.makeSvgSpan([\"hide-tail\"], [svg], options);\n};\n/**\n * Make a sqrt image of the given height,\n */\n\n\nvar makeSqrtImage = function makeSqrtImage(height, options) {\n  // Define a newOptions that removes the effect of size changes such as \\Huge.\n  // We don't pick different a height surd for \\Huge. For it, we scale up.\n  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.\n\n  var delim = traverseSequence(\"\\\\surd\", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);\n  var sizeMultiplier = newOptions.sizeMultiplier; // default\n  // The standard sqrt SVGs each have a 0.04em thick viniculum.\n  // If Settings.minRuleThickness is larger than that, we add extraViniculum.\n\n  var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.\n\n  var span;\n  var spanHeight = 0;\n  var texHeight = 0;\n  var viewBoxHeight = 0;\n  var advanceWidth; // We create viewBoxes with 80 units of \"padding\" above each surd.\n  // Then browser rounding error on the parent span height will not\n  // encroach on the ink of the viniculum. But that padding is not\n  // included in the TeX-like `height` used for calculation of\n  // vertical alignment. So texHeight = span.height < span.style.height.\n\n  if (delim.type === \"small\") {\n    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.\n    // 1000 unit normal glyph height.\n    viewBoxHeight = 1000 + 1000 * extraViniculum + vbPad;\n\n    if (height < 1.0) {\n      sizeMultiplier = 1.0; // mimic a \\textfont radical\n    } else if (height < 1.4) {\n      sizeMultiplier = 0.7; // mimic a \\scriptfont radical\n    }\n\n    spanHeight = (1.0 + extraViniculum + emPad) / sizeMultiplier;\n    texHeight = (1.00 + extraViniculum) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtMain\", spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"0.853em\";\n    advanceWidth = 0.833 / sizeMultiplier; // from the font.\n  } else if (delim.type === \"large\") {\n    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.\n    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];\n    texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;\n    spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtSize\" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"1.02em\";\n    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.\n  } else {\n    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.\n    // We'll use a single SVG to accomplish the same thing.\n    spanHeight = height + extraViniculum + emPad;\n    texHeight = height + extraViniculum;\n    viewBoxHeight = Math.floor(1000 * height + extraViniculum) + vbPad;\n    span = sqrtSvg(\"sqrtTall\", spanHeight, viewBoxHeight, extraViniculum, options);\n    span.style.minWidth = \"0.742em\";\n    advanceWidth = 1.056;\n  }\n\n  span.height = texHeight;\n  span.style.height = makeEm(spanHeight);\n  return {\n    span,\n    advanceWidth,\n    // Calculate the actual line width.\n    // This actually should depend on the chosen font -- e.g. \\boldmath\n    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and\n    // have thicker rules.\n    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier\n  };\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nvar stackLargeDelimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"\\\\surd\"]; // delimiters that always stack\n\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\"]; // and delimiters that never stack\n\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nvar makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n * TODO(#963) Use more specific font family return type once that is introduced.\n */\n\nvar delimTypeToFont = function delimTypeToFont(type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  } else {\n    throw new Error(\"Add support for delim type '\" + type.type + \"' here.\");\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nvar traverseSequence = function traverseSequence(delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), \"math\");\n    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      var newOptions = options.havingBaseStyle(sequence[i].style);\n      heightDepth *= newOptions.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nvar makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  var sequence;\n\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.\n  // Depending on the sequence element we decided on, call the\n  // appropriate function.\n\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else\n    /* if (delimType.type === \"stack\") */\n    {\n      return makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nvar makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\nvar delimiter = {\n  sqrtImage: makeSqrtImage,\n  sizedDelim: makeSizedDelim,\n  sizeToMaxHeight: sizeToMaxHeight,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n};\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"<\", \">\", \"\\\\langle\", \"\\u27e8\", \"\\\\rangle\", \"\\u27e9\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\n\n// Delimiter functions\nfunction checkDelimiter(delim, context) {\n  var symDelim = checkSymbolNodeType(delim);\n\n  if (symDelim && utils.contains(delimiters, symDelim.text)) {\n    return symDelim;\n  } else if (symDelim) {\n    throw new ParseError(\"Invalid delimiter '\" + symDelim.text + \"' after '\" + context.funcName + \"'\", delim);\n  } else {\n    throw new ParseError(\"Invalid delimiter type '\" + delim.type + \"'\", delim);\n  }\n}\n\ndefineFunction({\n  type: \"delimsizing\",\n  names: [\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    return {\n      type: \"delimsizing\",\n      mode: context.parser.mode,\n      size: delimiterSizes[context.funcName].size,\n      mclass: delimiterSizes[context.funcName].mclass,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    if (group.delim === \".\") {\n      // Empty delimiters still count as elements, even though they don't\n      // show anything.\n      return buildCommon.makeSpan([group.mclass]);\n    } // Use delimiter.sizedDelim to generate the delimiter.\n\n\n    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);\n  },\n  mathmlBuilder: group => {\n    var children = [];\n\n    if (group.delim !== \".\") {\n      children.push(makeText(group.delim, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      // Only some of the delimsizing functions act as fences, and they\n      // return \"mopen\" or \"mclose\" mclass.\n      node.setAttribute(\"fence\", \"true\");\n    } else {\n      // Explicitly disable fencing if it's not a fence, to override the\n      // defaults.\n      node.setAttribute(\"fence\", \"false\");\n    }\n\n    node.setAttribute(\"stretchy\", \"true\");\n    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);\n    node.setAttribute(\"minsize\", size);\n    node.setAttribute(\"maxsize\", size);\n    return node;\n  }\n});\n\nfunction assertParsed(group) {\n  if (!group.body) {\n    throw new Error(\"Bug: The leftright ParseNode wasn't fully parsed.\");\n  }\n}\n\ndefineFunction({\n  type: \"leftright-right\",\n  names: [\"\\\\right\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    // \\left case below triggers parsing of \\right in\n    //   `const right = parser.parseFunction();`\n    // uses this return value.\n    var color = context.parser.gullet.macros.get(\"\\\\current@color\");\n\n    if (color && typeof color !== \"string\") {\n      throw new ParseError(\"\\\\current@color set to non-string in \\\\right\");\n    }\n\n    return {\n      type: \"leftright-right\",\n      mode: context.parser.mode,\n      delim: checkDelimiter(args[0], context).text,\n      color // undefined if not set via \\color\n\n    };\n  }\n});\ndefineFunction({\n  type: \"leftright\",\n  names: [\"\\\\left\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    var parser = context.parser; // Parse out the implicit body\n\n    ++parser.leftrightDepth; // parseExpression stops before '\\\\right'\n\n    var body = parser.parseExpression(false);\n    --parser.leftrightDepth; // Check the next token\n\n    parser.expect(\"\\\\right\", false);\n    var right = assertNodeType(parser.parseFunction(), \"leftright-right\");\n    return {\n      type: \"leftright\",\n      mode: parser.mode,\n      body,\n      left: delim.text,\n      right: right.delim,\n      rightColor: right.color\n    };\n  },\n  htmlBuilder: (group, options) => {\n    assertParsed(group); // Build the inner expression\n\n    var inner = buildExpression$1(group.body, options, true, [\"mopen\", \"mclose\"]);\n    var innerHeight = 0;\n    var innerDepth = 0;\n    var hadMiddle = false; // Calculate its height and depth\n\n    for (var i = 0; i < inner.length; i++) {\n      // Property `isMiddle` not defined on `span`. See comment in\n      // \"middle\"'s htmlBuilder.\n      // $FlowFixMe\n      if (inner[i].isMiddle) {\n        hadMiddle = true;\n      } else {\n        innerHeight = Math.max(inner[i].height, innerHeight);\n        innerDepth = Math.max(inner[i].depth, innerDepth);\n      }\n    } // The size of delimiters is the same, regardless of what style we are\n    // in. Thus, to correctly calculate the size of delimiter we need around\n    // a group, we scale down the inner size based on the size.\n\n\n    innerHeight *= options.sizeMultiplier;\n    innerDepth *= options.sizeMultiplier;\n    var leftDelim;\n\n    if (group.left === \".\") {\n      // Empty delimiters in \\left and \\right make null delimiter spaces.\n      leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n    } else {\n      // Otherwise, use leftRightDelim to generate the correct sized\n      // delimiter.\n      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, [\"mopen\"]);\n    } // Add it to the beginning of the expression\n\n\n    inner.unshift(leftDelim); // Handle middle delimiters\n\n    if (hadMiddle) {\n      for (var _i = 1; _i < inner.length; _i++) {\n        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in\n        // \"middle\"'s htmlBuilder.\n        // $FlowFixMe\n\n        var isMiddle = middleDelim.isMiddle;\n\n        if (isMiddle) {\n          // Apply the options that were active when \\middle was called\n          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);\n        }\n      }\n    }\n\n    var rightDelim; // Same for the right delimiter, but using color specified by \\color\n\n    if (group.right === \".\") {\n      rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n    } else {\n      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;\n      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, [\"mclose\"]);\n    } // Add it to the end of the expression.\n\n\n    inner.push(rightDelim);\n    return buildCommon.makeSpan([\"minner\"], inner, options);\n  },\n  mathmlBuilder: (group, options) => {\n    assertParsed(group);\n    var inner = buildExpression(group.body, options);\n\n    if (group.left !== \".\") {\n      var leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.left, group.mode)]);\n      leftNode.setAttribute(\"fence\", \"true\");\n      inner.unshift(leftNode);\n    }\n\n    if (group.right !== \".\") {\n      var rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.right, group.mode)]);\n      rightNode.setAttribute(\"fence\", \"true\");\n\n      if (group.rightColor) {\n        rightNode.setAttribute(\"mathcolor\", group.rightColor);\n      }\n\n      inner.push(rightNode);\n    }\n\n    return makeRow(inner);\n  }\n});\ndefineFunction({\n  type: \"middle\",\n  names: [\"\\\\middle\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n\n    if (!context.parser.leftrightDepth) {\n      throw new ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n      type: \"middle\",\n      mode: context.parser.mode,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var middleDelim;\n\n    if (group.delim === \".\") {\n      middleDelim = makeNullDelimiter(options, []);\n    } else {\n      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);\n      var isMiddle = {\n        delim: group.delim,\n        options\n      }; // Property `isMiddle` not defined on `span`. It is only used in\n      // this file above.\n      // TODO: Fix this violation of the `span` type and possibly rename\n      // things since `isMiddle` sounds like a boolean, but is a struct.\n      // $FlowFixMe\n\n      middleDelim.isMiddle = isMiddle;\n    }\n\n    return middleDelim;\n  },\n  mathmlBuilder: (group, options) => {\n    // A Firefox \\middle will strech a character vertically only if it\n    // is in the fence part of the operator dictionary at:\n    // https://www.w3.org/TR/MathML3/appendixc.html.\n    // So we need to avoid U+2223 and use plain \"|\" instead.\n    var textNode = group.delim === \"\\\\vert\" || group.delim === \"|\" ? makeText(\"|\", \"text\") : makeText(group.delim, group.mode);\n    var middleNode = new mathMLTree.MathNode(\"mo\", [textNode]);\n    middleNode.setAttribute(\"fence\", \"true\"); // MathML gives 5/18em spacing to each <mo> element.\n    // \\middle should get delimiter spacing instead.\n\n    middleNode.setAttribute(\"lspace\", \"0.05em\");\n    middleNode.setAttribute(\"rspace\", \"0.05em\");\n    return middleNode;\n  }\n});\n\nvar htmlBuilder$8 = (group, options) => {\n  // \\cancel, \\bcancel, \\xcancel, \\sout, \\fbox, \\colorbox, \\fcolorbox, \\phase\n  // Some groups can return document fragments.  Handle those by wrapping\n  // them in a span.\n  var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);\n  var label = group.label.substr(1);\n  var scale = options.sizeMultiplier;\n  var img;\n  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different\n  // depending on whether the subject is wider than it is tall, or vice versa.\n  // We don't know the width of a group, so as a proxy, we test if\n  // the subject is a single character. This captures most of the\n  // subjects that should get the \"tall\" treatment.\n\n  var isSingleChar = utils.isCharacterBox(group.body);\n\n  if (label === \"sout\") {\n    img = buildCommon.makeSpan([\"stretchy\", \"sout\"]);\n    img.height = options.fontMetrics().defaultRuleThickness / scale;\n    imgShift = -0.5 * options.fontMetrics().xHeight;\n  } else if (label === \"phase\") {\n    // Set a couple of dimensions from the steinmetz package.\n    var lineWeight = calculateSize({\n      number: 0.6,\n      unit: \"pt\"\n    }, options);\n    var clearance = calculateSize({\n      number: 0.35,\n      unit: \"ex\"\n    }, options); // Prevent size changes like \\Huge from affecting line thickness\n\n    var newOptions = options.havingBaseSizing();\n    scale = scale / newOptions.sizeMultiplier;\n    var angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.\n\n    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG\n\n    var viewBoxHeight = Math.floor(1000 * angleHeight * scale);\n    var path = phasePath(viewBoxHeight);\n    var svgNode = new SvgNode([new PathNode(\"phase\", path)], {\n      \"width\": \"400em\",\n      \"height\": makeEm(viewBoxHeight / 1000),\n      \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n      \"preserveAspectRatio\": \"xMinYMin slice\"\n    }); // Wrap it in a span with overflow: hidden.\n\n    img = buildCommon.makeSvgSpan([\"hide-tail\"], [svgNode], options);\n    img.style.height = makeEm(angleHeight);\n    imgShift = inner.depth + lineWeight + clearance;\n  } else {\n    // Add horizontal padding\n    if (/cancel/.test(label)) {\n      if (!isSingleChar) {\n        inner.classes.push(\"cancel-pad\");\n      }\n    } else if (label === \"angl\") {\n      inner.classes.push(\"anglpad\");\n    } else {\n      inner.classes.push(\"boxpad\");\n    } // Add vertical padding\n\n\n    var topPad = 0;\n    var bottomPad = 0;\n    var ruleThickness = 0; // ref: cancel package: \\advance\\totalheight2\\p@ % \"+2\"\n\n    if (/box/.test(label)) {\n      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default\n      options.minRuleThickness // User override.\n      );\n      topPad = options.fontMetrics().fboxsep + (label === \"colorbox\" ? 0 : ruleThickness);\n      bottomPad = topPad;\n    } else if (label === \"angl\") {\n      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n      topPad = 4 * ruleThickness; // gap = 3 × line, plus the line itself.\n\n      bottomPad = Math.max(0, 0.25 - inner.depth);\n    } else {\n      topPad = isSingleChar ? 0.2 : 0;\n      bottomPad = topPad;\n    }\n\n    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);\n\n    if (/fbox|boxed|fcolorbox/.test(label)) {\n      img.style.borderStyle = \"solid\";\n      img.style.borderWidth = makeEm(ruleThickness);\n    } else if (label === \"angl\" && ruleThickness !== 0.049) {\n      img.style.borderTopWidth = makeEm(ruleThickness);\n      img.style.borderRightWidth = makeEm(ruleThickness);\n    }\n\n    imgShift = inner.depth + bottomPad;\n\n    if (group.backgroundColor) {\n      img.style.backgroundColor = group.backgroundColor;\n\n      if (group.borderColor) {\n        img.style.borderColor = group.borderColor;\n      }\n    }\n  }\n\n  var vlist;\n\n  if (group.backgroundColor) {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Put the color background behind inner;\n      {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift\n      }, {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }]\n    }, options);\n  } else {\n    var classes = /cancel|phase/.test(label) ? [\"svg-align\"] : [];\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Write the \\cancel stroke on top of inner.\n      {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }, {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift,\n        wrapperClasses: classes\n      }]\n    }, options);\n  }\n\n  if (/cancel/.test(label)) {\n    // The cancel package documentation says that cancel lines add their height\n    // to the expression, but tests show that isn't how it actually works.\n    vlist.height = inner.height;\n    vlist.depth = inner.depth;\n  }\n\n  if (/cancel/.test(label) && !isSingleChar) {\n    // cancel does not create horiz space for its line extension.\n    return buildCommon.makeSpan([\"mord\", \"cancel-lap\"], [vlist], options);\n  } else {\n    return buildCommon.makeSpan([\"mord\"], [vlist], options);\n  }\n};\n\nvar mathmlBuilder$7 = (group, options) => {\n  var fboxsep = 0;\n  var node = new mathMLTree.MathNode(group.label.indexOf(\"colorbox\") > -1 ? \"mpadded\" : \"menclose\", [buildGroup(group.body, options)]);\n\n  switch (group.label) {\n    case \"\\\\cancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike\");\n      break;\n\n    case \"\\\\bcancel\":\n      node.setAttribute(\"notation\", \"downdiagonalstrike\");\n      break;\n\n    case \"\\\\phase\":\n      node.setAttribute(\"notation\", \"phasorangle\");\n      break;\n\n    case \"\\\\sout\":\n      node.setAttribute(\"notation\", \"horizontalstrike\");\n      break;\n\n    case \"\\\\fbox\":\n      node.setAttribute(\"notation\", \"box\");\n      break;\n\n    case \"\\\\angl\":\n      node.setAttribute(\"notation\", \"actuarial\");\n      break;\n\n    case \"\\\\fcolorbox\":\n    case \"\\\\colorbox\":\n      // <menclose> doesn't have a good notation option. So use <mpadded>\n      // instead. Set some attributes that come included with <menclose>.\n      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;\n      node.setAttribute(\"width\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"height\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"lspace\", fboxsep + \"pt\"); //\n\n      node.setAttribute(\"voffset\", fboxsep + \"pt\");\n\n      if (group.label === \"\\\\fcolorbox\") {\n        var thk = Math.max(options.fontMetrics().fboxrule, // default\n        options.minRuleThickness // user override\n        );\n        node.setAttribute(\"style\", \"border: \" + thk + \"em solid \" + String(group.borderColor));\n      }\n\n      break;\n\n    case \"\\\\xcancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike downdiagonalstrike\");\n      break;\n  }\n\n  if (group.backgroundColor) {\n    node.setAttribute(\"mathbackground\", group.backgroundColor);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\colorbox\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"text\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fcolorbox\"],\n  props: {\n    numArgs: 3,\n    allowedInText: true,\n    argTypes: [\"color\", \"color\", \"text\"]\n  },\n\n  handler(_ref2, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var borderColor = assertNodeType(args[0], \"color-token\").color;\n    var backgroundColor = assertNodeType(args[1], \"color-token\").color;\n    var body = args[2];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor,\n      borderColor,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser\n    } = _ref3;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\fbox\",\n      body: args[0]\n    };\n  }\n\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\cancel\", \"\\\\bcancel\", \"\\\\xcancel\", \"\\\\sout\", \"\\\\phase\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var body = args[0];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\angl\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: false\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser\n    } = _ref5;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\angl\",\n      body: args[0]\n    };\n  }\n\n});\n\n/**\n * All registered environments.\n * `environments.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `environments.js`.\n */\nvar _environments = {};\nfunction defineEnvironment(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of environments.\n  var data = {\n    type,\n    numArgs: props.numArgs || 0,\n    allowedInText: false,\n    numOptionalArgs: 0,\n    handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    // TODO: The value type of _environments should be a type union of all\n    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is\n    // an existential type.\n    _environments[names[i]] = data;\n  }\n\n  if (htmlBuilder) {\n    _htmlGroupBuilders[type] = htmlBuilder;\n  }\n\n  if (mathmlBuilder) {\n    _mathmlGroupBuilders[type] = mathmlBuilder;\n  }\n}\n\n/**\n * All registered global/built-in macros.\n * `macros.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `macros.js`.\n */\nvar _macros = {}; // This function might one day accept an additional argument and do more things.\n\nfunction defineMacro(name, body) {\n  _macros[name] = body;\n}\n\n// Helper functions\nfunction getHLines(parser) {\n  // Return an array. The array length = number of hlines.\n  // Each element in the array tells if the line is dashed.\n  var hlineInfo = [];\n  parser.consumeSpaces();\n  var nxt = parser.fetch().text;\n\n  while (nxt === \"\\\\hline\" || nxt === \"\\\\hdashline\") {\n    parser.consume();\n    hlineInfo.push(nxt === \"\\\\hdashline\");\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  return hlineInfo;\n}\n\nvar validateAmsEnvironmentContext = context => {\n  var settings = context.parser.settings;\n\n  if (!settings.displayMode) {\n    throw new ParseError(\"{\" + context.envName + \"} can be used only in\" + \" display mode.\");\n  }\n}; // autoTag (an argument to parseArray) can be one of three values:\n// * undefined: Regular (not-top-level) array; no tags on each row\n// * true: Automatic equation numbering, overridable by \\tag\n// * false: Tags allowed on each row, but no automatic numbering\n// This function *doesn't* work with the \"split\" environment name.\n\n\nfunction getAutoTag(name) {\n  if (name.indexOf(\"ed\") === -1) {\n    return name.indexOf(\"*\") === -1;\n  } // return undefined;\n\n}\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.  If given an optional argument style\n * (\"text\", \"display\", etc.), then each cell is cast into that style.\n */\n\n\nfunction parseArray(parser, _ref, style) {\n  var {\n    hskipBeforeAndAfter,\n    addJot,\n    cols,\n    arraystretch,\n    colSeparationType,\n    autoTag,\n    singleRow,\n    emptySingleRow,\n    maxNumCols,\n    leqno\n  } = _ref;\n  parser.gullet.beginGroup();\n\n  if (!singleRow) {\n    // \\cr is equivalent to \\\\ without the optional size argument (see below)\n    // TODO: provide helpful error when \\cr is used outside array environment\n    parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  } // Get current arraystretch if it's not set by the environment\n\n\n  if (!arraystretch) {\n    var stretch = parser.gullet.expandMacroAsText(\"\\\\arraystretch\");\n\n    if (stretch == null) {\n      // Default \\arraystretch from lttab.dtx\n      arraystretch = 1;\n    } else {\n      arraystretch = parseFloat(stretch);\n\n      if (!arraystretch || arraystretch < 0) {\n        throw new ParseError(\"Invalid \\\\arraystretch: \" + stretch);\n      }\n    }\n  } // Start group for first cell\n\n\n  parser.gullet.beginGroup();\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  var hLinesBeforeRow = [];\n  var tags = autoTag != null ? [] : undefined; // amsmath uses \\global\\@eqnswtrue and \\global\\@eqnswfalse to represent\n  // whether this row should have an equation number.  Simulate this with\n  // a \\@eqnsw macro set to 1 or 0.\n\n  function beginRow() {\n    if (autoTag) {\n      parser.gullet.macros.set(\"\\\\@eqnsw\", \"1\", true);\n    }\n  }\n\n  function endRow() {\n    if (tags) {\n      if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n        tags.push(parser.subparse([new Token(\"\\\\df@tag\")]));\n        parser.gullet.macros.set(\"\\\\df@tag\", undefined, true);\n      } else {\n        tags.push(Boolean(autoTag) && parser.gullet.macros.get(\"\\\\@eqnsw\") === \"1\");\n      }\n    }\n  }\n\n  beginRow(); // Test for \\hline at the top of the array.\n\n  hLinesBeforeRow.push(getHLines(parser));\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Parse each cell in its own group (namespace)\n    var cell = parser.parseExpression(false, singleRow ? \"\\\\end\" : \"\\\\\\\\\");\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    cell = {\n      type: \"ordgroup\",\n      mode: parser.mode,\n      body: cell\n    };\n\n    if (style) {\n      cell = {\n        type: \"styling\",\n        mode: parser.mode,\n        style,\n        body: [cell]\n      };\n    }\n\n    row.push(cell);\n    var next = parser.fetch().text;\n\n    if (next === \"&\") {\n      if (maxNumCols && row.length === maxNumCols) {\n        if (singleRow || colSeparationType) {\n          // {equation} or {split}\n          throw new ParseError(\"Too many tab characters: &\", parser.nextToken);\n        } else {\n          // {array} environment\n          parser.settings.reportNonstrict(\"textEnv\", \"Too few columns \" + \"specified in the {array} column argument.\");\n        }\n      }\n\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      endRow(); // Arrays terminate newlines with `\\crcr` which consumes a `\\cr` if\n      // the last line is empty.  However, AMS environments keep the\n      // empty row if it's the only one.\n      // NOTE: Currently, `cell` is the last item added into `row`.\n\n      if (row.length === 1 && cell.type === \"styling\" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {\n        body.pop();\n      }\n\n      if (hLinesBeforeRow.length < body.length + 1) {\n        hLinesBeforeRow.push([]);\n      }\n\n      break;\n    } else if (next === \"\\\\\\\\\") {\n      parser.consume();\n      var size = void 0; // \\def\\Let@{\\let\\\\\\math@cr}\n      // \\def\\math@cr{...\\math@cr@}\n      // \\def\\math@cr@{\\new@ifnextchar[\\math@cr@@{\\math@cr@@[\\z@]}}\n      // \\def\\math@cr@@[#1]{...\\math@cr@@@...}\n      // \\def\\math@cr@@@{\\cr}\n\n      if (parser.gullet.future().text !== \" \") {\n        size = parser.parseSizeGroup(true);\n      }\n\n      rowGaps.push(size ? size.value : null);\n      endRow(); // check for \\hline(s) following the row separator\n\n      hLinesBeforeRow.push(getHLines(parser));\n      row = [];\n      body.push(row);\n      beginRow();\n    } else {\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  } // End cell group\n\n\n  parser.gullet.endGroup(); // End array group defining \\cr\n\n  parser.gullet.endGroup();\n  return {\n    type: \"array\",\n    mode: parser.mode,\n    addJot,\n    arraystretch,\n    body,\n    cols,\n    rowGaps,\n    hskipBeforeAndAfter,\n    hLinesBeforeRow,\n    colSeparationType,\n    tags,\n    leqno\n  };\n} // Decides on a style for cells in an array according to whether the given\n// environment name starts with the letter 'd'.\n\n\nfunction dCellStyle(envName) {\n  if (envName.substr(0, 1) === \"d\") {\n    return \"display\";\n  } else {\n    return \"text\";\n  }\n}\n\nvar htmlBuilder$7 = function htmlBuilder(group, options) {\n  var r;\n  var c;\n  var nr = group.body.length;\n  var hLinesBeforeRow = group.hLinesBeforeRow;\n  var nc = 0;\n  var body = new Array(nr);\n  var hlines = [];\n  var ruleThickness = Math.max( // From LaTeX \\showthe\\arrayrulewidth. Equals 0.04 em.\n  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.\n  ); // Horizontal spacing\n\n  var pt = 1 / options.fontMetrics().ptPerEm;\n  var arraycolsep = 5 * pt; // default value, i.e. \\arraycolsep in article.cls\n\n  if (group.colSeparationType && group.colSeparationType === \"small\") {\n    // We're in a {smallmatrix}. Default column space is \\thickspace,\n    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.\n    // But that needs adjustment because LaTeX applies \\scriptstyle to the\n    // entire array, including the colspace, but this function applies\n    // \\scriptstyle only inside each element.\n    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;\n    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);\n  } // Vertical spacing\n\n\n  var baselineskip = group.colSeparationType === \"CD\" ? calculateSize({\n    number: 3,\n    unit: \"ex\"\n  }, options) : 12 * pt; // see size10.clo\n  // Default \\jot from ltmath.dtx\n  // TODO(edemaine): allow overriding \\jot via \\setlength (#687)\n\n  var jot = 3 * pt;\n  var arrayskip = group.arraystretch * baselineskip;\n  var arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n\n  var arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  var totalHeight = 0; // Set a position for \\hline(s) at the top of the array, if any.\n\n  function setHLinePos(hlinesInGap) {\n    for (var i = 0; i < hlinesInGap.length; ++i) {\n      if (i > 0) {\n        totalHeight += 0.25;\n      }\n\n      hlines.push({\n        pos: totalHeight,\n        isDashed: hlinesInGap[i]\n      });\n    }\n  }\n\n  setHLinePos(hLinesBeforeRow[0]);\n\n  for (r = 0; r < group.body.length; ++r) {\n    var inrow = group.body[r];\n    var height = arstrutHeight; // \\@array adds an \\@arstrut\n\n    var depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n\n    var outrow = new Array(inrow.length);\n\n    for (c = 0; c < inrow.length; ++c) {\n      var elt = buildGroup$1(inrow[c], options);\n\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n\n      if (height < elt.height) {\n        height = elt.height;\n      }\n\n      outrow[c] = elt;\n    }\n\n    var rowGap = group.rowGaps[r];\n    var gap = 0;\n\n    if (rowGap) {\n      gap = calculateSize(rowGap, options);\n\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n\n        gap = 0;\n      }\n    } // In AMS multiline environments such as aligned and gathered, rows\n    // correspond to lines that have additional \\jot added to the\n    // \\baselineskip via \\openup.\n\n\n    if (group.addJot) {\n      depth += jot;\n    }\n\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n\n    body[r] = outrow; // Set a position for \\hline(s), if any.\n\n    setHLinePos(hLinesBeforeRow[r + 1]);\n  }\n\n  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;\n  var colDescriptions = group.cols || [];\n  var cols = [];\n  var colSep;\n  var colDescrNum;\n  var tagSpans = [];\n\n  if (group.tags && group.tags.some(tag => tag)) {\n    // An environment with manual tags and/or automatic equation numbers.\n    // Create node(s), the latter of which trigger CSS counter increment.\n    for (r = 0; r < nr; ++r) {\n      var rw = body[r];\n      var shift = rw.pos - offset;\n      var tag = group.tags[r];\n      var tagSpan = void 0;\n\n      if (tag === true) {\n        // automatic numbering\n        tagSpan = buildCommon.makeSpan([\"eqn-num\"], [], options);\n      } else if (tag === false) {\n        // \\nonumber/\\notag or starred environment\n        tagSpan = buildCommon.makeSpan([], [], options);\n      } else {\n        // manual \\tag\n        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);\n      }\n\n      tagSpan.depth = rw.depth;\n      tagSpan.height = rw.height;\n      tagSpans.push({\n        type: \"elem\",\n        elem: tagSpan,\n        shift\n      });\n    }\n  }\n\n  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    var colDescr = colDescriptions[colDescrNum] || {};\n    var firstSeparator = true;\n\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);\n        cols.push(colSep);\n      }\n\n      if (colDescr.separator === \"|\" || colDescr.separator === \":\") {\n        var lineType = colDescr.separator === \"|\" ? \"solid\" : \"dashed\";\n        var separator = buildCommon.makeSpan([\"vertical-separator\"], [], options);\n        separator.style.height = makeEm(totalHeight);\n        separator.style.borderRightWidth = makeEm(ruleThickness);\n        separator.style.borderRightStyle = lineType;\n        separator.style.margin = \"0 \" + makeEm(-ruleThickness / 2);\n\n        var _shift = totalHeight - offset;\n\n        if (_shift) {\n          separator.style.verticalAlign = makeEm(-_shift);\n        }\n\n        cols.push(separator);\n      } else {\n        throw new ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n\n    if (c >= nc) {\n      continue;\n    }\n\n    var sepwidth = void 0;\n\n    if (c > 0 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n\n    var col = [];\n\n    for (r = 0; r < nr; ++r) {\n      var row = body[r];\n      var elem = row[c];\n\n      if (!elem) {\n        continue;\n      }\n\n      var _shift2 = row.pos - offset;\n\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: _shift2\n      });\n    }\n\n    col = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: col\n    }, options);\n    col = buildCommon.makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n\n    if (c < nc - 1 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n  }\n\n  body = buildCommon.makeSpan([\"mtable\"], cols); // Add \\hline(s), if any.\n\n  if (hlines.length > 0) {\n    var line = buildCommon.makeLineSpan(\"hline\", options, ruleThickness);\n    var dashes = buildCommon.makeLineSpan(\"hdashline\", options, ruleThickness);\n    var vListElems = [{\n      type: \"elem\",\n      elem: body,\n      shift: 0\n    }];\n\n    while (hlines.length > 0) {\n      var hline = hlines.pop();\n      var lineShift = hline.pos - offset;\n\n      if (hline.isDashed) {\n        vListElems.push({\n          type: \"elem\",\n          elem: dashes,\n          shift: lineShift\n        });\n      } else {\n        vListElems.push({\n          type: \"elem\",\n          elem: line,\n          shift: lineShift\n        });\n      }\n    }\n\n    body = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: vListElems\n    }, options);\n  }\n\n  if (tagSpans.length === 0) {\n    return buildCommon.makeSpan([\"mord\"], [body], options);\n  } else {\n    var eqnNumCol = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: tagSpans\n    }, options);\n    eqnNumCol = buildCommon.makeSpan([\"tag\"], [eqnNumCol], options);\n    return buildCommon.makeFragment([body, eqnNumCol]);\n  }\n};\n\nvar alignMap = {\n  c: \"center \",\n  l: \"left \",\n  r: \"right \"\n};\n\nvar mathmlBuilder$6 = function mathmlBuilder(group, options) {\n  var tbl = [];\n  var glue = new mathMLTree.MathNode(\"mtd\", [], [\"mtr-glue\"]);\n  var tag = new mathMLTree.MathNode(\"mtd\", [], [\"mml-eqn-num\"]);\n\n  for (var i = 0; i < group.body.length; i++) {\n    var rw = group.body[i];\n    var row = [];\n\n    for (var j = 0; j < rw.length; j++) {\n      row.push(new mathMLTree.MathNode(\"mtd\", [buildGroup(rw[j], options)]));\n    }\n\n    if (group.tags && group.tags[i]) {\n      row.unshift(glue);\n      row.push(glue);\n\n      if (group.leqno) {\n        row.unshift(tag);\n      } else {\n        row.push(tag);\n      }\n    }\n\n    tbl.push(new mathMLTree.MathNode(\"mtr\", row));\n  }\n\n  var table = new mathMLTree.MathNode(\"mtable\", tbl); // Set column alignment, row spacing, column spacing, and\n  // array lines by setting attributes on the table element.\n  // Set the row spacing. In MathML, we specify a gap distance.\n  // We do not use rowGap[] because MathML automatically increases\n  // cell height with the height/depth of the element content.\n  // LaTeX \\arraystretch multiplies the row baseline-to-baseline distance.\n  // We simulate this by adding (arraystretch - 1)em to the gap. This\n  // does a reasonable job of adjusting arrays containing 1 em tall content.\n  // The 0.16 and 0.09 values are found emprically. They produce an array\n  // similar to LaTeX and in which content does not interfere with \\hines.\n\n  var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}\n  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);\n  table.setAttribute(\"rowspacing\", makeEm(gap)); // MathML table lines go only between cells.\n  // To place a line on an edge we'll use <menclose>, if necessary.\n\n  var menclose = \"\";\n  var align = \"\";\n\n  if (group.cols && group.cols.length > 0) {\n    // Find column alignment, column spacing, and  vertical lines.\n    var cols = group.cols;\n    var columnLines = \"\";\n    var prevTypeWasAlign = false;\n    var iStart = 0;\n    var iEnd = cols.length;\n\n    if (cols[0].type === \"separator\") {\n      menclose += \"top \";\n      iStart = 1;\n    }\n\n    if (cols[cols.length - 1].type === \"separator\") {\n      menclose += \"bottom \";\n      iEnd -= 1;\n    }\n\n    for (var _i = iStart; _i < iEnd; _i++) {\n      if (cols[_i].type === \"align\") {\n        align += alignMap[cols[_i].align];\n\n        if (prevTypeWasAlign) {\n          columnLines += \"none \";\n        }\n\n        prevTypeWasAlign = true;\n      } else if (cols[_i].type === \"separator\") {\n        // MathML accepts only single lines between cells.\n        // So we read only the first of consecutive separators.\n        if (prevTypeWasAlign) {\n          columnLines += cols[_i].separator === \"|\" ? \"solid \" : \"dashed \";\n          prevTypeWasAlign = false;\n        }\n      }\n    }\n\n    table.setAttribute(\"columnalign\", align.trim());\n\n    if (/[sd]/.test(columnLines)) {\n      table.setAttribute(\"columnlines\", columnLines.trim());\n    }\n  } // Set column spacing.\n\n\n  if (group.colSeparationType === \"align\") {\n    var _cols = group.cols || [];\n\n    var spacing = \"\";\n\n    for (var _i2 = 1; _i2 < _cols.length; _i2++) {\n      spacing += _i2 % 2 ? \"0em \" : \"1em \";\n    }\n\n    table.setAttribute(\"columnspacing\", spacing.trim());\n  } else if (group.colSeparationType === \"alignat\" || group.colSeparationType === \"gather\") {\n    table.setAttribute(\"columnspacing\", \"0em\");\n  } else if (group.colSeparationType === \"small\") {\n    table.setAttribute(\"columnspacing\", \"0.2778em\");\n  } else if (group.colSeparationType === \"CD\") {\n    table.setAttribute(\"columnspacing\", \"0.5em\");\n  } else {\n    table.setAttribute(\"columnspacing\", \"1em\");\n  } // Address \\hline and \\hdashline\n\n\n  var rowLines = \"\";\n  var hlines = group.hLinesBeforeRow;\n  menclose += hlines[0].length > 0 ? \"left \" : \"\";\n  menclose += hlines[hlines.length - 1].length > 0 ? \"right \" : \"\";\n\n  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {\n    rowLines += hlines[_i3].length === 0 ? \"none \" // MathML accepts only a single line between rows. Read one element.\n    : hlines[_i3][0] ? \"dashed \" : \"solid \";\n  }\n\n  if (/[sd]/.test(rowLines)) {\n    table.setAttribute(\"rowlines\", rowLines.trim());\n  }\n\n  if (menclose !== \"\") {\n    table = new mathMLTree.MathNode(\"menclose\", [table]);\n    table.setAttribute(\"notation\", menclose.trim());\n  }\n\n  if (group.arraystretch && group.arraystretch < 1) {\n    // A small array. Wrap in scriptstyle so row gap is not too large.\n    table = new mathMLTree.MathNode(\"mstyle\", [table]);\n    table.setAttribute(\"scriptlevel\", \"1\");\n  }\n\n  return table;\n}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.\n\n\nvar alignedHandler = function alignedHandler(context, args) {\n  if (context.envName.indexOf(\"ed\") === -1) {\n    validateAmsEnvironmentContext(context);\n  }\n\n  var cols = [];\n  var separationType = context.envName.indexOf(\"at\") > -1 ? \"alignat\" : \"align\";\n  var isSplit = context.envName === \"split\";\n  var res = parseArray(context.parser, {\n    cols,\n    addJot: true,\n    autoTag: isSplit ? undefined : getAutoTag(context.envName),\n    emptySingleRow: true,\n    colSeparationType: separationType,\n    maxNumCols: isSplit ? 2 : undefined,\n    leqno: context.parser.settings.leqno\n  }, \"display\"); // Determining number of columns.\n  // 1. If the first argument is given, we use it as a number of columns,\n  //    and makes sure that each row doesn't exceed that number.\n  // 2. Otherwise, just count number of columns = maximum number\n  //    of cells in each row (\"aligned\" mode -- isAligned will be true).\n  //\n  // At the same time, prepend empty group {} at beginning of every second\n  // cell in each row (starting with second cell) so that operators become\n  // binary.  This behavior is implemented in amsmath's \\start@aligned.\n\n  var numMaths;\n  var numCols = 0;\n  var emptyGroup = {\n    type: \"ordgroup\",\n    mode: context.mode,\n    body: []\n  };\n\n  if (args[0] && args[0].type === \"ordgroup\") {\n    var arg0 = \"\";\n\n    for (var i = 0; i < args[0].body.length; i++) {\n      var textord = assertNodeType(args[0].body[i], \"textord\");\n      arg0 += textord.text;\n    }\n\n    numMaths = Number(arg0);\n    numCols = numMaths * 2;\n  }\n\n  var isAligned = !numCols;\n  res.body.forEach(function (row) {\n    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {\n      // Modify ordgroup node within styling node\n      var styling = assertNodeType(row[_i4], \"styling\");\n      var ordgroup = assertNodeType(styling.body[0], \"ordgroup\");\n      ordgroup.body.unshift(emptyGroup);\n    }\n\n    if (!isAligned) {\n      // Case 1\n      var curMaths = row.length / 2;\n\n      if (numMaths < curMaths) {\n        throw new ParseError(\"Too many math in a row: \" + (\"expected \" + numMaths + \", but got \" + curMaths), row[0]);\n      }\n    } else if (numCols < row.length) {\n      // Case 2\n      numCols = row.length;\n    }\n  }); // Adjusting alignment.\n  // In aligned mode, we add one \\qquad between columns;\n  // otherwise we add nothing.\n\n  for (var _i5 = 0; _i5 < numCols; ++_i5) {\n    var align = \"r\";\n    var pregap = 0;\n\n    if (_i5 % 2 === 1) {\n      align = \"l\";\n    } else if (_i5 > 0 && isAligned) {\n      // \"aligned\" mode.\n      pregap = 1; // add one \\quad\n    }\n\n    cols[_i5] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  res.colSeparationType = isAligned ? \"align\" : \"alignat\";\n  return res;\n}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n// {darray} is an {array} environment where cells are set in \\displaystyle,\n// as defined in nccmath.sty.\n\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"array\", \"darray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Since no types are specified above, the two possibilities are\n    // - The argument is wrapped in {} or [], in which case Parser's\n    //   parseGroup() returns an \"ordgroup\" wrapping some symbol node.\n    // - The argument is a bare symbol node.\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text;\n\n      if (\"lcr\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      } else if (ca === \"|\") {\n        return {\n          type: \"separator\",\n          separator: \"|\"\n        };\n      } else if (ca === \":\") {\n        return {\n          type: \"separator\",\n          separator: \":\"\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n    var res = {\n      cols,\n      hskipBeforeAndAfter: true,\n      // \\@preamble in lttab.dtx\n      maxNumCols: cols.length\n    };\n    return parseArray(context.parser, res, dCellStyle(context.envName));\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n// The mathtools package adds starred versions of the same environments.\n// These have an optional argument to choose left|center|right justification.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\", \"matrix*\", \"pmatrix*\", \"bmatrix*\", \"Bmatrix*\", \"vmatrix*\", \"Vmatrix*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var delimiters = {\n      \"matrix\": null,\n      \"pmatrix\": [\"(\", \")\"],\n      \"bmatrix\": [\"[\", \"]\"],\n      \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n      \"vmatrix\": [\"|\", \"|\"],\n      \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName.replace(\"*\", \"\")]; // \\hskip -\\arraycolsep in amsmath\n\n    var colAlign = \"c\";\n    var payload = {\n      hskipBeforeAndAfter: false,\n      cols: [{\n        type: \"align\",\n        align: colAlign\n      }]\n    };\n\n    if (context.envName.charAt(context.envName.length - 1) === \"*\") {\n      // It's one of the mathtools starred functions.\n      // Parse the optional alignment argument.\n      var parser = context.parser;\n      parser.consumeSpaces();\n\n      if (parser.fetch().text === \"[\") {\n        parser.consume();\n        parser.consumeSpaces();\n        colAlign = parser.fetch().text;\n\n        if (\"lcr\".indexOf(colAlign) === -1) {\n          throw new ParseError(\"Expected l or c or r\", parser.nextToken);\n        }\n\n        parser.consume();\n        parser.consumeSpaces();\n        parser.expect(\"]\");\n        parser.consume();\n        payload.cols = [{\n          type: \"align\",\n          align: colAlign\n        }];\n      }\n    }\n\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.\n\n    var numCols = Math.max(0, ...res.body.map(row => row.length));\n    res.cols = new Array(numCols).fill({\n      type: \"align\",\n      align: colAlign\n    });\n    return delimiters ? {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1],\n      rightColor: undefined // \\right uninfluenced by \\color in array\n\n    } : res;\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"smallmatrix\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 0.5\n    };\n    var res = parseArray(context.parser, payload, \"script\");\n    res.colSeparationType = \"small\";\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"subarray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Parsing of {subarray} is similar to {array}\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text; // {subarray} only recognizes \"l\" & \"c\"\n\n      if (\"lc\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n\n    if (cols.length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    var res = {\n      cols,\n      hskipBeforeAndAfter: false,\n      arraystretch: 0.5\n    };\n    res = parseArray(context.parser, res, \"script\");\n\n    if (res.body.length > 0 && res.body[0].length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\n// {dcases} is a {cases} environment where cells are set in \\displaystyle,\n// as defined in mathtools.sty.\n// {rcases} is another mathtools environment. It's brace is on the right side.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"cases\", \"dcases\", \"rcases\", \"drcases\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 1.2,\n      cols: [{\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        // TODO(kevinb) get the current style.\n        // For now we use the metrics for TEXT style which is what we were\n        // doing before.  Before attempting to get the current style we\n        // should look at TeX's behavior especially for \\over and matrices.\n        postgap: 1.0\n        /* 1em quad */\n\n      }, {\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        postgap: 0\n      }]\n    };\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: context.envName.indexOf(\"r\") > -1 ? \".\" : \"\\\\{\",\n      right: context.envName.indexOf(\"r\") > -1 ? \"\\\\}\" : \".\",\n      rightColor: undefined\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n}); // In the align environment, one uses ampersands, &, to specify number of\n// columns in each row, and to locate spacing between each column.\n// align gets automatic numbering. align* and aligned do not.\n// The alignedat environment can be used in math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"align\", \"align*\", \"aligned\", \"split\"],\n  props: {\n    numArgs: 0\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n}); // A gathered environment is like an array environment with one centered\n// column, but where rows are considered lines so get \\jot line spacing\n// and contents are set in \\displaystyle.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"gathered\", \"gather\", \"gather*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    if (utils.contains([\"gather\", \"gather*\"], context.envName)) {\n      validateAmsEnvironmentContext(context);\n    }\n\n    var res = {\n      cols: [{\n        type: \"align\",\n        align: \"c\"\n      }],\n      addJot: true,\n      colSeparationType: \"gather\",\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n}); // alignat environment is like an align environment, but one must explicitly\n// specify maximum number of columns in each row, and can adjust spacing between\n// each columns.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"alignat\", \"alignat*\", \"alignedat\"],\n  props: {\n    numArgs: 1\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"equation\", \"equation*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    var res = {\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      singleRow: true,\n      maxNumCols: 1,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"CD\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    return parseCD(context.parser);\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineMacro(\"\\\\nonumber\", \"\\\\gdef\\\\@eqnsw{0}\");\ndefineMacro(\"\\\\notag\", \"\\\\nonumber\"); // Catch \\hline outside array environment\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\hline\", \"\\\\hdashline\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: true\n  },\n\n  handler(context, args) {\n    throw new ParseError(context.funcName + \" valid only within array environment\");\n  }\n\n});\n\nvar environments = _environments;\n\n// defineEnvironment definitions.\n\ndefineFunction({\n  type: \"environment\",\n  names: [\"\\\\begin\", \"\\\\end\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var nameGroup = args[0];\n\n    if (nameGroup.type !== \"ordgroup\") {\n      throw new ParseError(\"Invalid environment name\", nameGroup);\n    }\n\n    var envName = \"\";\n\n    for (var i = 0; i < nameGroup.body.length; ++i) {\n      envName += assertNodeType(nameGroup.body[i], \"textord\").text;\n    }\n\n    if (funcName === \"\\\\begin\") {\n      // begin...end is similar to left...right\n      if (!environments.hasOwnProperty(envName)) {\n        throw new ParseError(\"No such environment: \" + envName, nameGroup);\n      } // Build the environment object. Arguments and other information will\n      // be made available to the begin and end methods using properties.\n\n\n      var env = environments[envName];\n      var {\n        args: _args,\n        optArgs\n      } = parser.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n      var context = {\n        mode: parser.mode,\n        envName,\n        parser\n      };\n      var result = env.handler(context, _args, optArgs);\n      parser.expect(\"\\\\end\", false);\n      var endNameToken = parser.nextToken;\n      var end = assertNodeType(parser.parseFunction(), \"environment\");\n\n      if (end.name !== envName) {\n        throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched by \\\\end{\" + end.name + \"}\", endNameToken);\n      } // $FlowFixMe, \"environment\" handler returns an environment ParseNode\n\n\n      return result;\n    }\n\n    return {\n      type: \"environment\",\n      mode: parser.mode,\n      name: envName,\n      nameGroup\n    };\n  }\n\n});\n\nvar makeSpan = buildCommon.makeSpan;\n\nfunction htmlBuilder$6(group, options) {\n  var elements = buildExpression$1(group.body, options, true);\n  return makeSpan([group.mclass], elements, options);\n}\n\nfunction mathmlBuilder$5(group, options) {\n  var node;\n  var inner = buildExpression(group.body, options);\n\n  if (group.mclass === \"minner\") {\n    node = new mathMLTree.MathNode(\"mpadded\", inner);\n  } else if (group.mclass === \"mord\") {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mi\";\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", inner);\n    }\n  } else {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mo\";\n    } else {\n      node = new mathMLTree.MathNode(\"mo\", inner);\n    } // Set spacing based on what is the most likely adjacent atom type.\n    // See TeXbook p170.\n\n\n    if (group.mclass === \"mbin\") {\n      node.attributes.lspace = \"0.22em\"; // medium space\n\n      node.attributes.rspace = \"0.22em\";\n    } else if (group.mclass === \"mpunct\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0.17em\"; // thinspace\n    } else if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0em\";\n    } else if (group.mclass === \"minner\") {\n      node.attributes.lspace = \"0.0556em\"; // 1 mu is the most likely option\n\n      node.attributes.width = \"+0.1111em\";\n    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo\n\n  }\n\n  return node;\n} // Math class commands except \\mathop\n\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: \"m\" + funcName.substr(5),\n      // TODO(kevinb): don't prefix with 'm'\n      body: ordargument(body),\n      isCharacterBox: utils.isCharacterBox(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\nvar binrelClass = arg => {\n  // \\binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.\n  // (by rendering separately and with {}s before and after, and measuring\n  // the change in spacing).  We'll do roughly the same by detecting the\n  // atom type directly.\n  var atom = arg.type === \"ordgroup\" && arg.body.length ? arg.body[0] : arg;\n\n  if (atom.type === \"atom\" && (atom.family === \"bin\" || atom.family === \"rel\")) {\n    return \"m\" + atom.family;\n  } else {\n    return \"mord\";\n  }\n}; // \\@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.\n// This is equivalent to \\binrel@{x}\\binrel@@{y} in AMSTeX.\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\@binrel\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[1]),\n      isCharacterBox: utils.isCharacterBox(args[1])\n    };\n  }\n\n}); // Build a relation or stacked op by placing one symbol on top of another\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\stackrel\", \"\\\\overset\", \"\\\\underset\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var baseArg = args[1];\n    var shiftedArg = args[0];\n    var mclass;\n\n    if (funcName !== \"\\\\stackrel\") {\n      // LaTeX applies \\binrel spacing to \\overset and \\underset.\n      mclass = binrelClass(baseArg);\n    } else {\n      mclass = \"mrel\"; // for \\stackrel\n    }\n\n    var baseOp = {\n      type: \"op\",\n      mode: baseArg.mode,\n      limits: true,\n      alwaysHandleSupSub: true,\n      parentIsSupSub: false,\n      symbol: false,\n      suppressBaseShift: funcName !== \"\\\\stackrel\",\n      body: ordargument(baseArg)\n    };\n    var supsub = {\n      type: \"supsub\",\n      mode: shiftedArg.mode,\n      base: baseOp,\n      sup: funcName === \"\\\\underset\" ? null : shiftedArg,\n      sub: funcName === \"\\\\underset\" ? shiftedArg : null\n    };\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass,\n      body: [supsub],\n      isCharacterBox: utils.isCharacterBox(supsub)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\n\n// TODO(kevinb): implement \\\\sl and \\\\sc\n\nvar htmlBuilder$5 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup$1(group.body, newOptions);\n};\n\nvar mathmlBuilder$4 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup(group.body, newOptions);\n};\n\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\",\n  \"\\\\bm\": \"\\\\boldsymbol\"\n};\ndefineFunction({\n  type: \"font\",\n  names: [// styles, except \\boldsymbol defined below\n  \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", \"\\\\mathnormal\", // families\n  \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases, except \\bm defined below\n  \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"],\n  props: {\n    numArgs: 1,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = normalizeArgument(args[0]);\n    var func = funcName;\n\n    if (func in fontAliases) {\n      func = fontAliases[func];\n    }\n\n    return {\n      type: \"font\",\n      mode: parser.mode,\n      font: func.slice(1),\n      body\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\boldsymbol\", \"\\\\bm\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \\boldsymbol uses \\binrel spacing to inherit the\n    // argument's bin|rel|ord status\n\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(body),\n      body: [{\n        type: \"font\",\n        mode: parser.mode,\n        font: \"boldsymbol\",\n        body\n      }],\n      isCharacterBox: isCharacterBox\n    };\n  }\n}); // Old font changing functions\n\ndefineFunction({\n  type: \"font\",\n  names: [\"\\\\rm\", \"\\\\sf\", \"\\\\tt\", \"\\\\bf\", \"\\\\it\", \"\\\\cal\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser,\n      funcName,\n      breakOnTokenText\n    } = _ref3;\n    var {\n      mode\n    } = parser;\n    var body = parser.parseExpression(true, breakOnTokenText);\n    var style = \"math\" + funcName.slice(1);\n    return {\n      type: \"font\",\n      mode: mode,\n      font: style,\n      body: {\n        type: \"ordgroup\",\n        mode: parser.mode,\n        body\n      }\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\n\nvar adjustStyle = (size, originalStyle) => {\n  // Figure out what style this fraction should be in based on the\n  // function used\n  var style = originalStyle;\n\n  if (size === \"display\") {\n    // Get display style as a default.\n    // If incoming style is sub/sup, use style.text() to get correct size.\n    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;\n  } else if (size === \"text\" && style.size === Style$1.DISPLAY.size) {\n    // We're in a \\tfrac but incoming style is displaystyle, so:\n    style = Style$1.TEXT;\n  } else if (size === \"script\") {\n    style = Style$1.SCRIPT;\n  } else if (size === \"scriptscript\") {\n    style = Style$1.SCRIPTSCRIPT;\n  }\n\n  return style;\n};\n\nvar htmlBuilder$4 = (group, options) => {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  var style = adjustStyle(group.size, options.style);\n  var nstyle = style.fracNum();\n  var dstyle = style.fracDen();\n  var newOptions;\n  newOptions = options.havingStyle(nstyle);\n  var numerm = buildGroup$1(group.numer, newOptions, options);\n\n  if (group.continued) {\n    // \\cfrac inserts a \\strut into the numerator.\n    // Get \\strut dimensions from TeXbook page 353.\n    var hStrut = 8.5 / options.fontMetrics().ptPerEm;\n    var dStrut = 3.5 / options.fontMetrics().ptPerEm;\n    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;\n    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;\n  }\n\n  newOptions = options.havingStyle(dstyle);\n  var denomm = buildGroup$1(group.denom, newOptions, options);\n  var rule;\n  var ruleWidth;\n  var ruleSpacing;\n\n  if (group.hasBarLine) {\n    if (group.barSize) {\n      ruleWidth = calculateSize(group.barSize, options);\n      rule = buildCommon.makeLineSpan(\"frac-line\", options, ruleWidth);\n    } else {\n      rule = buildCommon.makeLineSpan(\"frac-line\", options);\n    }\n\n    ruleWidth = rule.height;\n    ruleSpacing = rule.height;\n  } else {\n    rule = null;\n    ruleWidth = 0;\n    ruleSpacing = options.fontMetrics().defaultRuleThickness;\n  } // Rule 15b\n\n\n  var numShift;\n  var clearance;\n  var denomShift;\n\n  if (style.size === Style$1.DISPLAY.size || group.size === \"display\") {\n    numShift = options.fontMetrics().num1;\n\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleSpacing;\n    } else {\n      clearance = 7 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = options.fontMetrics().num2;\n      clearance = ruleSpacing;\n    } else {\n      numShift = options.fontMetrics().num3;\n      clearance = 3 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom2;\n  }\n\n  var frac;\n\n  if (!rule) {\n    // Rule 15c\n    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);\n\n    if (candidateClearance < clearance) {\n      numShift += 0.5 * (clearance - candidateClearance);\n      denomShift += 0.5 * (clearance - candidateClearance);\n    }\n\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } else {\n    // Rule 15d\n    var axisHeight = options.fontMetrics().axisHeight;\n\n    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n\n    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));\n    }\n\n    var midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: rule,\n        shift: midShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n\n\n  newOptions = options.havingStyle(style);\n  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;\n  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e\n\n  var delimSize;\n\n  if (style.size === Style$1.DISPLAY.size) {\n    delimSize = options.fontMetrics().delim1;\n  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {\n    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;\n  } else {\n    delimSize = options.fontMetrics().delim2;\n  }\n\n  var leftDelim;\n  var rightDelim;\n\n  if (group.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mopen\"]);\n  }\n\n  if (group.continued) {\n    rightDelim = buildCommon.makeSpan([]); // zero width for \\cfrac\n  } else if (group.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mclose\"]);\n  }\n\n  return buildCommon.makeSpan([\"mord\"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan([\"mfrac\"], [frac]), rightDelim], options);\n};\n\nvar mathmlBuilder$3 = (group, options) => {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);\n\n  if (!group.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  } else if (group.barSize) {\n    var ruleWidth = calculateSize(group.barSize, options);\n    node.setAttribute(\"linethickness\", makeEm(ruleWidth));\n  }\n\n  var style = adjustStyle(group.size, options.style);\n\n  if (style.size !== options.style.size) {\n    node = new mathMLTree.MathNode(\"mstyle\", [node]);\n    var isDisplay = style.size === Style$1.DISPLAY.size ? \"true\" : \"false\";\n    node.setAttribute(\"displaystyle\", isDisplay);\n    node.setAttribute(\"scriptlevel\", \"0\");\n  }\n\n  if (group.leftDelim != null || group.rightDelim != null) {\n    var withDelims = [];\n\n    if (group.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.leftDelim.replace(\"\\\\\", \"\"))]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.rightDelim.replace(\"\\\\\", \"\"))]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    return makeRow(withDelims);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\", // can’t be entered directly\n  \"\\\\\\\\bracefrac\", \"\\\\\\\\brackfrac\" // ditto\n  ],\n  props: {\n    numArgs: 2,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\frac\":\n      case \"\\\\tfrac\":\n        hasBarLine = true;\n        break;\n\n      case \"\\\\\\\\atopfrac\":\n        hasBarLine = false;\n        break;\n\n      case \"\\\\dbinom\":\n      case \"\\\\binom\":\n      case \"\\\\tbinom\":\n        hasBarLine = false;\n        leftDelim = \"(\";\n        rightDelim = \")\";\n        break;\n\n      case \"\\\\\\\\bracefrac\":\n        hasBarLine = false;\n        leftDelim = \"\\\\{\";\n        rightDelim = \"\\\\}\";\n        break;\n\n      case \"\\\\\\\\brackfrac\":\n        hasBarLine = false;\n        leftDelim = \"[\";\n        rightDelim = \"]\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\dbinom\":\n        size = \"display\";\n        break;\n\n      case \"\\\\tfrac\":\n      case \"\\\\tbinom\":\n        size = \"text\";\n        break;\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: false,\n      numer,\n      denom,\n      hasBarLine,\n      leftDelim,\n      rightDelim,\n      size,\n      barSize: null\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\cfrac\"],\n  props: {\n    numArgs: 2\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var numer = args[0];\n    var denom = args[1];\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: true,\n      numer,\n      denom,\n      hasBarLine: true,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"display\",\n      barSize: null\n    };\n  }\n}); // Infix generalized fractions -- these are not rendered directly, but replaced\n// immediately by one of the variants above.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\over\", \"\\\\choose\", \"\\\\atop\", \"\\\\brace\", \"\\\\brack\"],\n  props: {\n    numArgs: 0,\n    infix: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref3;\n    var replaceWith;\n\n    switch (funcName) {\n      case \"\\\\over\":\n        replaceWith = \"\\\\frac\";\n        break;\n\n      case \"\\\\choose\":\n        replaceWith = \"\\\\binom\";\n        break;\n\n      case \"\\\\atop\":\n        replaceWith = \"\\\\\\\\atopfrac\";\n        break;\n\n      case \"\\\\brace\":\n        replaceWith = \"\\\\\\\\bracefrac\";\n        break;\n\n      case \"\\\\brack\":\n        replaceWith = \"\\\\\\\\brackfrac\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized infix genfrac command\");\n    }\n\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith,\n      token\n    };\n  }\n\n});\nvar stylArray = [\"display\", \"text\", \"script\", \"scriptscript\"];\n\nvar delimFromValue = function delimFromValue(delimString) {\n  var delim = null;\n\n  if (delimString.length > 0) {\n    delim = delimString;\n    delim = delim === \".\" ? null : delim;\n  }\n\n  return delim;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\genfrac\"],\n  props: {\n    numArgs: 6,\n    allowedInArgument: true,\n    argTypes: [\"math\", \"math\", \"size\", \"text\", \"math\", \"math\"]\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser\n    } = _ref4;\n    var numer = args[4];\n    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.\n\n    var leftNode = normalizeArgument(args[0]);\n    var leftDelim = leftNode.type === \"atom\" && leftNode.family === \"open\" ? delimFromValue(leftNode.text) : null;\n    var rightNode = normalizeArgument(args[1]);\n    var rightDelim = rightNode.type === \"atom\" && rightNode.family === \"close\" ? delimFromValue(rightNode.text) : null;\n    var barNode = assertNodeType(args[2], \"size\");\n    var hasBarLine;\n    var barSize = null;\n\n    if (barNode.isBlank) {\n      // \\genfrac acts differently than \\above.\n      // \\genfrac treats an empty size group as a signal to use a\n      // standard bar size. \\above would see size = 0 and omit the bar.\n      hasBarLine = true;\n    } else {\n      barSize = barNode.value;\n      hasBarLine = barSize.number > 0;\n    } // Find out if we want displaystyle, textstyle, etc.\n\n\n    var size = \"auto\";\n    var styl = args[3];\n\n    if (styl.type === \"ordgroup\") {\n      if (styl.body.length > 0) {\n        var textOrd = assertNodeType(styl.body[0], \"textord\");\n        size = stylArray[Number(textOrd.text)];\n      }\n    } else {\n      styl = assertNodeType(styl, \"textord\");\n      size = stylArray[Number(styl.text)];\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim,\n      rightDelim,\n      size\n    };\n  },\n\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n}); // \\above is an infix fraction that also defines a fraction bar size.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\above\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    infix: true\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref5;\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: \"\\\\\\\\abovefrac\",\n      size: assertNodeType(args[0], \"size\").value,\n      token\n    };\n  }\n\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\\\\\abovefrac\"],\n  props: {\n    numArgs: 3,\n    argTypes: [\"math\", \"size\", \"math\"]\n  },\n  handler: (_ref6, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref6;\n    var numer = args[0];\n    var barSize = assert(assertNodeType(args[1], \"infix\").size);\n    var denom = args[2];\n    var hasBarLine = barSize.number > 0;\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"auto\"\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"horizBrace\", but\n// also \"supsub\" since an over/underbrace can affect super/subscripting.\nvar htmlBuilder$3 = (grp, options) => {\n  var style = options.style; // Pull out the `ParseNode<\"horizBrace\">` if `grp` is a \"supsub\" node.\n\n  var supSubGroup;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // Ref: LaTeX source2e: }}}}\\limits}\n    // i.e. LaTeX treats the brace similar to an op and passes it\n    // with \\limits, so we need to assign supsub style.\n    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);\n    group = assertNodeType(grp.base, \"horizBrace\");\n  } else {\n    group = assertNodeType(grp, \"horizBrace\");\n  } // Build the base group\n\n\n  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element\n\n  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        ┏━━━━━━━━┓\n  // This first vlist contains the content and the brace:   equation\n\n  var vlist;\n\n  if (group.isOver) {\n    vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: braceBody\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: body.depth + 0.1 + braceBody.height,\n      children: [{\n        type: \"elem\",\n        elem: braceBody\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: body\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[0].classes.push(\"svg-align\");\n  }\n\n  if (supSubGroup) {\n    // To write the supsub, wrap the first vlist in another vlist:\n    // They can't all go in the same vlist, because the note might be\n    // wider than the equation. We want the equation to control the\n    // brace width.\n    //      note          long note           long note\n    //   ┏━━━━━━━━┓   or    ┏━━━┓     not    ┏━━━━━━━━━┓\n    //    equation           eqn                 eqn\n    var vSpan = buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n\n    if (group.isOver) {\n      vlist = buildCommon.makeVList({\n        positionType: \"firstBaseline\",\n        children: [{\n          type: \"elem\",\n          elem: vSpan\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: supSubGroup\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"bottom\",\n        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,\n        children: [{\n          type: \"elem\",\n          elem: supSubGroup\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: vSpan\n        }]\n      }, options);\n    }\n  }\n\n  return buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n};\n\nvar mathmlBuilder$2 = (group, options) => {\n  var accentNode = stretchy.mathMLnode(group.label);\n  return new mathMLTree.MathNode(group.isOver ? \"mover\" : \"munder\", [buildGroup(group.base, options), accentNode]);\n}; // Horizontal stretchy braces\n\n\ndefineFunction({\n  type: \"horizBrace\",\n  names: [\"\\\\overbrace\", \"\\\\underbrace\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"horizBrace\",\n      mode: parser.mode,\n      label: funcName,\n      isOver: /^\\\\over/.test(funcName),\n      base: args[0]\n    };\n  },\n\n  htmlBuilder: htmlBuilder$3,\n  mathmlBuilder: mathmlBuilder$2\n});\n\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\href\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"url\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[1];\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\href\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\href\");\n    }\n\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeAnchor(group.href, [], elements, options);\n  },\n  mathmlBuilder: (group, options) => {\n    var math = buildExpressionRow(group.body, options);\n\n    if (!(math instanceof MathNode)) {\n      math = new MathNode(\"mrow\", [math]);\n    }\n\n    math.setAttribute(\"href\", group.href);\n    return math;\n  }\n});\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\url\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"url\"],\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\url\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\url\");\n    }\n\n    var chars = [];\n\n    for (var i = 0; i < href.length; i++) {\n      var c = href[i];\n\n      if (c === \"~\") {\n        c = \"\\\\textasciitilde\";\n      }\n\n      chars.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: c\n      });\n    }\n\n    var body = {\n      type: \"text\",\n      mode: parser.mode,\n      font: \"\\\\texttt\",\n      body: chars\n    };\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  }\n});\n\n// In LaTeX, \\vcenter can act only on a box, as in\n// \\vcenter{\\hbox{$\\frac{a+b}{\\dfrac{c}{d}}$}}\n// This function by itself doesn't do anything but prevent a soft line break.\n\ndefineFunction({\n  type: \"hbox\",\n  names: [\"\\\\hbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"hbox\",\n      mode: parser.mode,\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", buildExpression(group.body, options));\n  }\n\n});\n\ndefineFunction({\n  type: \"html\",\n  names: [\"\\\\htmlClass\", \"\\\\htmlId\", \"\\\\htmlStyle\", \"\\\\htmlData\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"raw\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref;\n    var value = assertNodeType(args[0], \"raw\").string;\n    var body = args[1];\n\n    if (parser.settings.strict) {\n      parser.settings.reportNonstrict(\"htmlExtension\", \"HTML extension is disabled on strict mode\");\n    }\n\n    var trustContext;\n    var attributes = {};\n\n    switch (funcName) {\n      case \"\\\\htmlClass\":\n        attributes.class = value;\n        trustContext = {\n          command: \"\\\\htmlClass\",\n          class: value\n        };\n        break;\n\n      case \"\\\\htmlId\":\n        attributes.id = value;\n        trustContext = {\n          command: \"\\\\htmlId\",\n          id: value\n        };\n        break;\n\n      case \"\\\\htmlStyle\":\n        attributes.style = value;\n        trustContext = {\n          command: \"\\\\htmlStyle\",\n          style: value\n        };\n        break;\n\n      case \"\\\\htmlData\":\n        {\n          var data = value.split(\",\");\n\n          for (var i = 0; i < data.length; i++) {\n            var keyVal = data[i].split(\"=\");\n\n            if (keyVal.length !== 2) {\n              throw new ParseError(\"Error parsing key-value for \\\\htmlData\");\n            }\n\n            attributes[\"data-\" + keyVal[0].trim()] = keyVal[1].trim();\n          }\n\n          trustContext = {\n            command: \"\\\\htmlData\",\n            attributes\n          };\n          break;\n        }\n\n      default:\n        throw new Error(\"Unrecognized html command\");\n    }\n\n    if (!parser.settings.isTrusted(trustContext)) {\n      return parser.formatUnsupportedCmd(funcName);\n    }\n\n    return {\n      type: \"html\",\n      mode: parser.mode,\n      attributes,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    var classes = [\"enclosing\"];\n\n    if (group.attributes.class) {\n      classes.push(...group.attributes.class.trim().split(/\\s+/));\n    }\n\n    var span = buildCommon.makeSpan(classes, elements, options);\n\n    for (var attr in group.attributes) {\n      if (attr !== \"class\" && group.attributes.hasOwnProperty(attr)) {\n        span.setAttribute(attr, group.attributes[attr]);\n      }\n    }\n\n    return span;\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.body, options);\n  }\n});\n\ndefineFunction({\n  type: \"htmlmathml\",\n  names: [\"\\\\html@mathml\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"htmlmathml\",\n      mode: parser.mode,\n      html: ordargument(args[0]),\n      mathml: ordargument(args[1])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.html, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.mathml, options);\n  }\n});\n\nvar sizeData = function sizeData(str) {\n  if (/^[-+]? *(\\d+(\\.\\d*)?|\\.\\d+)$/.test(str)) {\n    // str is a number with no unit specified.\n    // default unit is bp, per graphix package.\n    return {\n      number: +str,\n      unit: \"bp\"\n    };\n  } else {\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(str);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + str + \"' in \\\\includegraphics\");\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"' in \\\\includegraphics.\");\n    }\n\n    return data;\n  }\n};\n\ndefineFunction({\n  type: \"includegraphics\",\n  names: [\"\\\\includegraphics\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    argTypes: [\"raw\", \"url\"],\n    allowedInText: false\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var width = {\n      number: 0,\n      unit: \"em\"\n    };\n    var height = {\n      number: 0.9,\n      unit: \"em\"\n    }; // sorta character sized.\n\n    var totalheight = {\n      number: 0,\n      unit: \"em\"\n    };\n    var alt = \"\";\n\n    if (optArgs[0]) {\n      var attributeStr = assertNodeType(optArgs[0], \"raw\").string; // Parser.js does not parse key/value pairs. We get a string.\n\n      var attributes = attributeStr.split(\",\");\n\n      for (var i = 0; i < attributes.length; i++) {\n        var keyVal = attributes[i].split(\"=\");\n\n        if (keyVal.length === 2) {\n          var str = keyVal[1].trim();\n\n          switch (keyVal[0].trim()) {\n            case \"alt\":\n              alt = str;\n              break;\n\n            case \"width\":\n              width = sizeData(str);\n              break;\n\n            case \"height\":\n              height = sizeData(str);\n              break;\n\n            case \"totalheight\":\n              totalheight = sizeData(str);\n              break;\n\n            default:\n              throw new ParseError(\"Invalid key: '\" + keyVal[0] + \"' in \\\\includegraphics.\");\n          }\n        }\n      }\n    }\n\n    var src = assertNodeType(args[0], \"url\").url;\n\n    if (alt === \"\") {\n      // No alt given. Use the file name. Strip away the path.\n      alt = src;\n      alt = alt.replace(/^.*[\\\\/]/, '');\n      alt = alt.substring(0, alt.lastIndexOf('.'));\n    }\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\includegraphics\",\n      url: src\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\includegraphics\");\n    }\n\n    return {\n      type: \"includegraphics\",\n      mode: parser.mode,\n      alt: alt,\n      width: width,\n      height: height,\n      totalheight: totalheight,\n      src: src\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n    }\n\n    var width = 0;\n\n    if (group.width.number > 0) {\n      width = calculateSize(group.width, options);\n    }\n\n    var style = {\n      height: makeEm(height + depth)\n    };\n\n    if (width > 0) {\n      style.width = makeEm(width);\n    }\n\n    if (depth > 0) {\n      style.verticalAlign = makeEm(-depth);\n    }\n\n    var node = new Img(group.src, group.alt, style);\n    node.height = height;\n    node.depth = depth;\n    return node;\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mglyph\", []);\n    node.setAttribute(\"alt\", group.alt);\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n      node.setAttribute(\"valign\", makeEm(-depth));\n    }\n\n    node.setAttribute(\"height\", makeEm(height + depth));\n\n    if (group.width.number > 0) {\n      var width = calculateSize(group.width, options);\n      node.setAttribute(\"width\", makeEm(width));\n    }\n\n    node.setAttribute(\"src\", group.src);\n    return node;\n  }\n});\n\n// Horizontal spacing commands\n\ndefineFunction({\n  type: \"kern\",\n  names: [\"\\\\kern\", \"\\\\mkern\", \"\\\\hskip\", \"\\\\mskip\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    primitive: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var size = assertNodeType(args[0], \"size\");\n\n    if (parser.settings.strict) {\n      var mathFunction = funcName[1] === 'm'; // \\mkern, \\mskip\n\n      var muUnit = size.value.unit === 'mu';\n\n      if (mathFunction) {\n        if (!muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" supports only mu units, \" + (\"not \" + size.value.unit + \" units\"));\n        }\n\n        if (parser.mode !== \"math\") {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" works only in math mode\");\n        }\n      } else {\n        // !mathFunction\n        if (muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" doesn't support mu units\");\n        }\n      }\n    }\n\n    return {\n      type: \"kern\",\n      mode: parser.mode,\n      dimension: size.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeGlue(group.dimension, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var dimension = calculateSize(group.dimension, options);\n    return new mathMLTree.SpaceNode(dimension);\n  }\n\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"lap\",\n  names: [\"\\\\mathllap\", \"\\\\mathrlap\", \"\\\\mathclap\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"lap\",\n      mode: parser.mode,\n      alignment: funcName.slice(5),\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var inner;\n\n    if (group.alignment === \"clap\") {\n      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/\n      inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span\n\n      inner = buildCommon.makeSpan([\"inner\"], [inner], options);\n    } else {\n      inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options)]);\n    }\n\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the\n    // two items involved in the lap.\n    // Next, use a strut to set the height of the HTML bounding box.\n    // Otherwise, a tall argument may be misplaced.\n    // This code resolved issue #1153\n\n    var strut = buildCommon.makeSpan([\"strut\"]);\n    strut.style.height = makeEm(node.height + node.depth);\n\n    if (node.depth) {\n      strut.style.verticalAlign = makeEm(-node.depth);\n    }\n\n    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.\n    // This code resolves issue #1234\n\n    node = buildCommon.makeSpan([\"thinbox\"], [node], options);\n    return buildCommon.makeSpan([\"mord\", \"vbox\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.alignment !== \"rlap\") {\n      var offset = group.alignment === \"llap\" ? \"-1\" : \"-0.5\";\n      node.setAttribute(\"lspace\", offset + \"width\");\n    }\n\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\(\", \"$\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(_ref, args) {\n    var {\n      funcName,\n      parser\n    } = _ref;\n    var outerMode = parser.mode;\n    parser.switchMode(\"math\");\n    var close = funcName === \"\\\\(\" ? \"\\\\)\" : \"$\";\n    var body = parser.parseExpression(false, close);\n    parser.expect(close);\n    parser.switchMode(outerMode);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      style: \"text\",\n      body\n    };\n  }\n\n}); // Check for extra closing math delimiters\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\)\", \"\\\\]\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(context, args) {\n    throw new ParseError(\"Mismatched \" + context.funcName);\n  }\n\n});\n\nvar chooseMathStyle = (group, options) => {\n  switch (options.style.size) {\n    case Style$1.DISPLAY.size:\n      return group.display;\n\n    case Style$1.TEXT.size:\n      return group.text;\n\n    case Style$1.SCRIPT.size:\n      return group.script;\n\n    case Style$1.SCRIPTSCRIPT.size:\n      return group.scriptscript;\n\n    default:\n      return group.text;\n  }\n};\n\ndefineFunction({\n  type: \"mathchoice\",\n  names: [\"\\\\mathchoice\"],\n  props: {\n    numArgs: 4,\n    primitive: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"mathchoice\",\n      mode: parser.mode,\n      display: ordargument(args[0]),\n      text: ordargument(args[1]),\n      script: ordargument(args[2]),\n      scriptscript: ordargument(args[3])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    var elements = buildExpression$1(body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    return buildExpressionRow(body, options);\n  }\n});\n\nvar assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {\n  base = buildCommon.makeSpan([], [base]);\n  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);\n  var sub;\n  var sup; // We manually have to handle the superscripts and subscripts. This,\n  // aside from the kern calculations, is copied from supsub.\n\n  if (supGroup) {\n    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);\n    sup = {\n      elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)\n    };\n  }\n\n  if (subGroup) {\n    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);\n\n    sub = {\n      elem: _elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)\n    };\n  } // Build the final group as a vlist of the possible subscript, base,\n  // and possible superscript.\n\n\n  var finalGroup;\n\n  if (sup && sub) {\n    var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else if (sub) {\n    var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note\n    // that we are supposed to shift the limits by 1/2 of the slant,\n    // but since we are centering the limits adding a full slant of\n    // margin will shift by 1/2 that.\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: top,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }]\n    }, options);\n  } else if (sup) {\n    var _bottom = base.depth + baseShift;\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: _bottom,\n      children: [{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else {\n    // This case probably shouldn't occur (this would mean the\n    // supsub was sending us a group with no superscript or\n    // subscript) but be safe.\n    return base;\n  }\n\n  var parts = [finalGroup];\n\n  if (sub && slant !== 0 && !subIsSingleCharacter) {\n    // A negative margin-left was applied to the lower limit.\n    // Avoid an overlap by placing a spacer on the left on the group.\n    var spacer = buildCommon.makeSpan([\"mspace\"], [], options);\n    spacer.style.marginRight = makeEm(slant);\n    parts.unshift(spacer);\n  }\n\n  return buildCommon.makeSpan([\"mop\", \"op-limits\"], parts, options);\n};\n\n// Limits, symbols\n// Most operators have a large successor symbol, but these don't.\nvar noSuccessor = [\"\\\\smallint\"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only \"op\", but also\n// \"supsub\" since some of them (like \\int) can affect super/subscripting.\n\nvar htmlBuilder$2 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"op\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"op\");\n  }\n\n  var style = options.style;\n  var large = false;\n\n  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n\n  var base;\n\n  if (group.symbol) {\n    // If this is a symbol, create the symbol.\n    var fontName = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    var stash = \"\";\n\n    if (group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") {\n      // No font glyphs yet, so use a glyph w/o the oval.\n      // TODO: When font glyphs are available, delete this code.\n      stash = group.name.substr(1);\n      group.name = stash === \"oiint\" ? \"\\\\iint\" : \"\\\\iiint\";\n    }\n\n    base = buildCommon.makeSymbol(group.name, fontName, \"math\", options, [\"mop\", \"op-symbol\", large ? \"large-op\" : \"small-op\"]);\n\n    if (stash.length > 0) {\n      // We're in \\oiint or \\oiiint. Overlay the oval.\n      // TODO: When font glyphs are available, delete this code.\n      var italic = base.italic;\n      var oval = buildCommon.staticSvg(stash + \"Size\" + (large ? \"2\" : \"1\"), options);\n      base = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: base,\n          shift: 0\n        }, {\n          type: \"elem\",\n          elem: oval,\n          shift: large ? 0.08 : 0\n        }]\n      }, options);\n      group.name = \"\\\\\" + stash;\n      base.classes.unshift(\"mop\"); // $FlowFixMe\n\n      base.italic = italic;\n    }\n  } else if (group.body) {\n    // If this is a list, compose that list.\n    var inner = buildExpression$1(group.body, options, true);\n\n    if (inner.length === 1 && inner[0] instanceof SymbolNode) {\n      base = inner[0];\n      base.classes[0] = \"mop\"; // replace old mclass\n    } else {\n      base = buildCommon.makeSpan([\"mop\"], inner, options);\n    }\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    var output = [];\n\n    for (var i = 1; i < group.name.length; i++) {\n      output.push(buildCommon.mathsym(group.name[i], group.mode, options));\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], output, options);\n  } // If content of op is a single symbol, shift it vertically.\n\n\n  var baseShift = 0;\n  var slant = 0;\n\n  if ((base instanceof SymbolNode || group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") && !group.suppressBaseShift) {\n    // We suppress the shift of the base of \\overset and \\underset. Otherwise,\n    // shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.\n    // $FlowFixMe\n\n    slant = base.italic;\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);\n  } else {\n    if (baseShift) {\n      base.style.position = \"relative\";\n      base.style.top = makeEm(baseShift);\n    }\n\n    return base;\n  }\n};\n\nvar mathmlBuilder$1 = (group, options) => {\n  var node;\n\n  if (group.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new MathNode(\"mo\", [makeText(group.name, group.mode)]);\n\n    if (utils.contains(noSuccessor, group.name)) {\n      node.setAttribute(\"largeop\", \"false\");\n    }\n  } else if (group.body) {\n    // This is an operator with children. Add them.\n    node = new MathNode(\"mo\", buildExpression(group.body, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    node = new MathNode(\"mi\", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.\n    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4\n\n    var operator = new MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n    if (group.parentIsSupSub) {\n      node = new MathNode(\"mrow\", [node, operator]);\n    } else {\n      node = newDocumentFragment([node, operator]);\n    }\n  }\n\n  return node;\n};\n\nvar singleCharBigOps = {\n  \"\\u220F\": \"\\\\prod\",\n  \"\\u2210\": \"\\\\coprod\",\n  \"\\u2211\": \"\\\\sum\",\n  \"\\u22c0\": \"\\\\bigwedge\",\n  \"\\u22c1\": \"\\\\bigvee\",\n  \"\\u22c2\": \"\\\\bigcap\",\n  \"\\u22c3\": \"\\\\bigcup\",\n  \"\\u2a00\": \"\\\\bigodot\",\n  \"\\u2a01\": \"\\\\bigoplus\",\n  \"\\u2a02\": \"\\\\bigotimes\",\n  \"\\u2a04\": \"\\\\biguplus\",\n  \"\\u2a06\": \"\\\\bigsqcup\"\n};\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\", \"\\u220F\", \"\\u2210\", \"\\u2211\", \"\\u22c0\", \"\\u22c1\", \"\\u22c2\", \"\\u22c3\", \"\\u2a00\", \"\\u2a01\", \"\\u2a02\", \"\\u2a04\", \"\\u2a06\"],\n  props: {\n    numArgs: 0\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharBigOps[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Note: calling defineFunction with a type that's already been defined only\n// works because the same htmlBuilder and mathmlBuilder are being used.\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\mathop\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\nvar singleCharIntegrals = {\n  \"\\u222b\": \"\\\\int\",\n  \"\\u222c\": \"\\\\iint\",\n  \"\\u222d\": \"\\\\iiint\",\n  \"\\u222e\": \"\\\\oint\",\n  \"\\u222f\": \"\\\\oiint\",\n  \"\\u2230\": \"\\\\oiiint\"\n}; // No limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arctg\", \"\\\\arcctg\", \"\\\\arg\", \"\\\\ch\", \"\\\\cos\", \"\\\\cosec\", \"\\\\cosh\", \"\\\\cot\", \"\\\\cotg\", \"\\\\coth\", \"\\\\csc\", \"\\\\ctg\", \"\\\\cth\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\sh\", \"\\\\tan\", \"\\\\tanh\", \"\\\\tg\", \"\\\\th\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // No limits, symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\", \"\\\\oiint\", \"\\\\oiiint\", \"\\u222b\", \"\\u222c\", \"\\u222d\", \"\\u222e\", \"\\u222f\", \"\\u2230\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref5) {\n    var {\n      parser,\n      funcName\n    } = _ref5;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharIntegrals[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only\n// \"operatorname\", but also  \"supsub\" since \\operatorname* can\n// affect super/subscripting.\nvar htmlBuilder$1 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"operatorname\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"operatorname\");\n  }\n\n  var base;\n\n  if (group.body.length > 0) {\n    var body = group.body.map(child => {\n      // $FlowFixMe: Check if the node has a string `text` property.\n      var childText = child.text;\n\n      if (typeof childText === \"string\") {\n        return {\n          type: \"textord\",\n          mode: child.mode,\n          text: childText\n        };\n      } else {\n        return child;\n      }\n    }); // Consolidate function names into symbol characters.\n\n    var expression = buildExpression$1(body, options.withFont(\"mathrm\"), true);\n\n    for (var i = 0; i < expression.length; i++) {\n      var child = expression[i];\n\n      if (child instanceof SymbolNode) {\n        // Per amsopn package,\n        // change minus to hyphen and \\ast to asterisk\n        child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n      }\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], expression, options);\n  } else {\n    base = buildCommon.makeSpan([\"mop\"], [], options);\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);\n  } else {\n    return base;\n  }\n};\n\nvar mathmlBuilder = (group, options) => {\n  // The steps taken here are similar to the html version.\n  var expression = buildExpression(group.body, options.withFont(\"mathrm\")); // Is expression a string or has it something like a fraction?\n\n  var isAllString = true; // default\n\n  for (var i = 0; i < expression.length; i++) {\n    var node = expression[i];\n\n    if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {\n      switch (node.type) {\n        case \"mi\":\n        case \"mn\":\n        case \"ms\":\n        case \"mspace\":\n        case \"mtext\":\n          break;\n        // Do nothing yet.\n\n        case \"mo\":\n          {\n            var child = node.children[0];\n\n            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {\n              child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n            } else {\n              isAllString = false;\n            }\n\n            break;\n          }\n\n        default:\n          isAllString = false;\n      }\n    } else {\n      isAllString = false;\n    }\n  }\n\n  if (isAllString) {\n    // Write a single TextNode instead of multiple nested tags.\n    var word = expression.map(node => node.toText()).join(\"\");\n    expression = [new mathMLTree.TextNode(word)];\n  }\n\n  var identifier = new mathMLTree.MathNode(\"mi\", expression);\n  identifier.setAttribute(\"mathvariant\", \"normal\"); // \\u2061 is the same as &ApplyFunction;\n  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp\n\n  var operator = new mathMLTree.MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n  if (group.parentIsSupSub) {\n    return new mathMLTree.MathNode(\"mrow\", [identifier, operator]);\n  } else {\n    return mathMLTree.newDocumentFragment([identifier, operator]);\n  }\n}; // \\operatorname\n// amsopn.dtx: \\mathop{#1\\kern\\z@\\operator@font#3}\\newmcodes@\n\n\ndefineFunction({\n  type: \"operatorname\",\n  names: [\"\\\\operatorname@\", \"\\\\operatornamewithlimits\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"operatorname\",\n      mode: parser.mode,\n      body: ordargument(body),\n      alwaysHandleSupSub: funcName === \"\\\\operatornamewithlimits\",\n      limits: false,\n      parentIsSupSub: false\n    };\n  },\n  htmlBuilder: htmlBuilder$1,\n  mathmlBuilder\n});\ndefineMacro(\"\\\\operatorname\", \"\\\\@ifstar\\\\operatornamewithlimits\\\\operatorname@\");\n\ndefineFunctionBuilders({\n  type: \"ordgroup\",\n\n  htmlBuilder(group, options) {\n    if (group.semisimple) {\n      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));\n    }\n\n    return buildCommon.makeSpan([\"mord\"], buildExpression$1(group.body, options, true), options);\n  },\n\n  mathmlBuilder(group, options) {\n    return buildExpressionRow(group.body, options, true);\n  }\n\n});\n\ndefineFunction({\n  type: \"overline\",\n  names: [\"\\\\overline\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"overline\",\n      mode: parser.mode,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Overlines are handled in the TeXbook pg 443, Rule 9.\n    // Build the inner group in the cramped style.\n    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle()); // Create the line above the body\n\n    var line = buildCommon.makeLineSpan(\"overline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: innerGroup\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: defaultRuleThickness\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"overline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accent\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"phantom\",\n  names: [\"\\\\phantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"phantom\",\n      mode: parser.mode,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options.withPhantom(), false); // \\phantom isn't supposed to affect the elements it contains.\n    // See \"color\" for more details.\n\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(group.body, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n  }\n});\ndefineFunction({\n  type: \"hphantom\",\n  names: [\"\\\\hphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"hphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);\n    node.height = 0;\n    node.depth = 0;\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        node.children[i].height = 0;\n        node.children[i].depth = 0;\n      }\n    } // See smash for comment re: use of makeVList\n\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\smash as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"height\", \"0px\");\n    node.setAttribute(\"depth\", \"0px\");\n    return node;\n  }\n});\ndefineFunction({\n  type: \"vphantom\",\n  names: [\"\\\\vphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser\n    } = _ref3;\n    var body = args[0];\n    return {\n      type: \"vphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options.withPhantom())]);\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    return buildCommon.makeSpan([\"mord\", \"rlap\"], [inner, fix], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"raisebox\",\n  names: [\"\\\\raisebox\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"size\", \"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var amount = assertNodeType(args[0], \"size\").value;\n    var body = args[1];\n    return {\n      type: \"raisebox\",\n      mode: parser.mode,\n      dy: amount,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var dy = calculateSize(group.dy, options);\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: -dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n    var dy = group.dy.number + group.dy.unit;\n    node.setAttribute(\"voffset\", dy);\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\relax\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\ndefineFunction({\n  type: \"rule\",\n  names: [\"\\\\rule\"],\n  props: {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var shift = optArgs[0];\n    var width = assertNodeType(args[0], \"size\");\n    var height = assertNodeType(args[1], \"size\");\n    return {\n      type: \"rule\",\n      mode: parser.mode,\n      shift: shift && assertNodeType(shift, \"size\").value,\n      width: width.value,\n      height: height.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Make an empty span for the rule\n    var rule = buildCommon.makeSpan([\"mord\", \"rule\"], [], options); // Calculate the shift, width, and height of the rule, and account for units\n\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size\n\n    rule.style.borderRightWidth = makeEm(width);\n    rule.style.borderTopWidth = makeEm(height);\n    rule.style.bottom = makeEm(shift); // Record the height and width\n\n    rule.width = width;\n    rule.height = height + shift;\n    rule.depth = -shift; // Font size is the number large enough that the browser will\n    // reserve at least `absHeight` space above the baseline.\n    // The 1.125 factor was empirically determined\n\n    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;\n    return rule;\n  },\n\n  mathmlBuilder(group, options) {\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0;\n    var color = options.color && options.getColor() || \"black\";\n    var rule = new mathMLTree.MathNode(\"mspace\");\n    rule.setAttribute(\"mathbackground\", color);\n    rule.setAttribute(\"width\", makeEm(width));\n    rule.setAttribute(\"height\", makeEm(height));\n    var wrapper = new mathMLTree.MathNode(\"mpadded\", [rule]);\n\n    if (shift >= 0) {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n    } else {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n      wrapper.setAttribute(\"depth\", makeEm(-shift));\n    }\n\n    wrapper.setAttribute(\"voffset\", makeEm(shift));\n    return wrapper;\n  }\n\n});\n\nfunction sizingGroup(value, options, baseOptions) {\n  var inner = buildExpression$1(value, options, false);\n  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize\n  // manually. Handle nested size changes.\n\n  for (var i = 0; i < inner.length; i++) {\n    var pos = inner[i].classes.indexOf(\"sizing\");\n\n    if (pos < 0) {\n      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));\n    } else if (inner[i].classes[pos + 1] === \"reset-size\" + options.size) {\n      // This is a nested size change: e.g., inner[i] is the \"b\" in\n      // `\\Huge a \\small b`. Override the old size (the `reset-` class)\n      // but not the new size.\n      inner[i].classes[pos + 1] = \"reset-size\" + baseOptions.size;\n    }\n\n    inner[i].height *= multiplier;\n    inner[i].depth *= multiplier;\n  }\n\n  return buildCommon.makeFragment(inner);\n}\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\sixptsize\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\nvar htmlBuilder = (group, options) => {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  var newOptions = options.havingSize(group.size);\n  return sizingGroup(group.body, newOptions, options);\n};\ndefineFunction({\n  type: \"sizing\",\n  names: sizeFuncs,\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    var body = parser.parseExpression(false, breakOnTokenText);\n    return {\n      type: \"sizing\",\n      mode: parser.mode,\n      // Figure out what size to use based on the list of functions above\n      size: sizeFuncs.indexOf(funcName) + 1,\n      body\n    };\n  },\n  htmlBuilder,\n  mathmlBuilder: (group, options) => {\n    var newOptions = options.havingSize(group.size);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n\n    node.setAttribute(\"mathsize\", makeEm(newOptions.sizeMultiplier));\n    return node;\n  }\n});\n\n// smash, with optional [tb], as in AMS\ndefineFunction({\n  type: \"smash\",\n  names: [\"\\\\smash\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var smashHeight = false;\n    var smashDepth = false;\n    var tbArg = optArgs[0] && assertNodeType(optArgs[0], \"ordgroup\");\n\n    if (tbArg) {\n      // Optional [tb] argument is engaged.\n      // ref: amsmath: \\renewcommand{\\smash}[1][tb]{%\n      //               def\\mb@t{\\ht}\\def\\mb@b{\\dp}\\def\\mb@tb{\\ht\\z@\\z@\\dp}%\n      var letter = \"\";\n\n      for (var i = 0; i < tbArg.body.length; ++i) {\n        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n        letter = node.text;\n\n        if (letter === \"t\") {\n          smashHeight = true;\n        } else if (letter === \"b\") {\n          smashDepth = true;\n        } else {\n          smashHeight = false;\n          smashDepth = false;\n          break;\n        }\n      }\n    } else {\n      smashHeight = true;\n      smashDepth = true;\n    }\n\n    var body = args[0];\n    return {\n      type: \"smash\",\n      mode: parser.mode,\n      body,\n      smashHeight,\n      smashDepth\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);\n\n    if (!group.smashHeight && !group.smashDepth) {\n      return node;\n    }\n\n    if (group.smashHeight) {\n      node.height = 0; // In order to influence makeVList, we have to reset the children.\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          node.children[i].height = 0;\n        }\n      }\n    }\n\n    if (group.smashDepth) {\n      node.depth = 0;\n\n      if (node.children) {\n        for (var _i = 0; _i < node.children.length; _i++) {\n          node.children[_i].depth = 0;\n        }\n      }\n    } // At this point, we've reset the TeX-like height and depth values.\n    // But the span still has an HTML line height.\n    // makeVList applies \"display: table-cell\", which prevents the browser\n    // from acting on that line height. So we'll call makeVList now.\n\n\n    var smashedNode = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\hphantom as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [smashedNode], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.smashHeight) {\n      node.setAttribute(\"height\", \"0px\");\n    }\n\n    if (group.smashDepth) {\n      node.setAttribute(\"depth\", \"0px\");\n    }\n\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"sqrt\",\n  names: [\"\\\\sqrt\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var index = optArgs[0];\n    var body = args[0];\n    return {\n      type: \"sqrt\",\n      mode: parser.mode,\n      body,\n      index\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Square roots are handled in the TeXbook pg. 443, Rule 11.\n    // First, we do the same steps as in overline to build the inner group\n    // and line\n    var inner = buildGroup$1(group.body, options.havingCrampedStyle());\n\n    if (inner.height === 0) {\n      // Render a small surd.\n      inner.height = options.fontMetrics().xHeight;\n    } // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n\n    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \\surd delimiter\n\n    var metrics = options.fontMetrics();\n    var theta = metrics.defaultRuleThickness;\n    var phi = theta;\n\n    if (options.style.id < Style$1.TEXT.id) {\n      phi = options.fontMetrics().xHeight;\n    } // Calculate the clearance between the body and line\n\n\n    var lineClearance = theta + phi / 4;\n    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size\n\n    var {\n      span: img,\n      ruleWidth,\n      advanceWidth\n    } = delimiter.sqrtImage(minDelimiterHeight, options);\n    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size\n\n    if (delimDepth > inner.height + inner.depth + lineClearance) {\n      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n    } // Shift the sqrt image\n\n\n    var imgShift = img.height - inner.height - lineClearance - ruleWidth;\n    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.\n\n    var body = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: inner,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: -(inner.height + imgShift)\n      }, {\n        type: \"elem\",\n        elem: img\n      }, {\n        type: \"kern\",\n        size: ruleWidth\n      }]\n    }, options);\n\n    if (!group.index) {\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [body], options);\n    } else {\n      // Handle the optional root index\n      // The index is always in scriptscript style\n      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);\n      var rootm = buildGroup$1(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX\n      // source, in the definition of `\\r@@t`.\n\n      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly\n\n      var rootVList = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -toShift,\n        children: [{\n          type: \"elem\",\n          elem: rootm\n        }]\n      }, options); // Add a class surrounding it so we can add on the appropriate\n      // kerning\n\n      var rootVListWrap = buildCommon.makeSpan([\"root\"], [rootVList]);\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [rootVListWrap, body], options);\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var {\n      body,\n      index\n    } = group;\n    return index ? new mathMLTree.MathNode(\"mroot\", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode(\"msqrt\", [buildGroup(body, options)]);\n  }\n\n});\n\nvar styleMap = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    // parse out the implicit body\n    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.\n    // here and in buildHTML and de-dupe the enumeration of all the styles).\n    // $FlowFixMe: The names above exactly match the styles.\n\n    var style = funcName.slice(1, funcName.length - 5);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle).withFont('');\n    return sizingGroup(group.body, newOptions, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Figure out what style we're changing to.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    var styleAttributes = {\n      \"display\": [\"0\", \"true\"],\n      \"text\": [\"0\", \"false\"],\n      \"script\": [\"1\", \"false\"],\n      \"scriptscript\": [\"2\", \"false\"]\n    };\n    var attr = styleAttributes[group.style];\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n    return node;\n  }\n\n});\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * Sometimes, groups perform special rules when they have superscripts or\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nvar htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {\n  var base = group.base;\n\n  if (!base) {\n    return null;\n  } else if (base.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);\n    return delegate ? htmlBuilder$2 : null;\n  } else if (base.type === \"operatorname\") {\n    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);\n\n    return _delegate ? htmlBuilder$1 : null;\n  } else if (base.type === \"accent\") {\n    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;\n  } else if (base.type === \"horizBrace\") {\n    var isSup = !group.sub;\n    return isSup === base.isOver ? htmlBuilder$3 : null;\n  } else {\n    return null;\n  }\n}; // Super scripts and subscripts, whose precise placement can depend on other\n// functions that precede them.\n\n\ndefineFunctionBuilders({\n  type: \"supsub\",\n\n  htmlBuilder(group, options) {\n    // Superscript and subscripts are handled in the TeXbook on page\n    // 445-446, rules 18(a-f).\n    // Here is where we defer to the inner group if it should handle\n    // superscripts and subscripts itself.\n    var builderDelegate = htmlBuilderDelegate(group, options);\n\n    if (builderDelegate) {\n      return builderDelegate(group, options);\n    }\n\n    var {\n      base: valueBase,\n      sup: valueSup,\n      sub: valueSub\n    } = group;\n    var base = buildGroup$1(valueBase, options);\n    var supm;\n    var subm;\n    var metrics = options.fontMetrics(); // Rule 18a\n\n    var supShift = 0;\n    var subShift = 0;\n    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);\n\n    if (valueSup) {\n      var newOptions = options.havingStyle(options.style.sup());\n      supm = buildGroup$1(valueSup, newOptions, options);\n\n      if (!isCharacterBox) {\n        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    }\n\n    if (valueSub) {\n      var _newOptions = options.havingStyle(options.style.sub());\n\n      subm = buildGroup$1(valueSub, _newOptions, options);\n\n      if (!isCharacterBox) {\n        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    } // Rule 18c\n\n\n    var minSupShift;\n\n    if (options.style === Style$1.DISPLAY) {\n      minSupShift = metrics.sup1;\n    } else if (options.style.cramped) {\n      minSupShift = metrics.sup3;\n    } else {\n      minSupShift = metrics.sup2;\n    } // scriptspace is a font-size-independent size, so scale it\n    // appropriately for use as the marginRight.\n\n\n    var multiplier = options.sizeMultiplier;\n    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);\n    var marginLeft = null;\n\n    if (subm) {\n      // Subscripts shouldn't be shifted by the base's italic correction.\n      // Account for that by shifting the subscript back the appropriate\n      // amount. Note we only do this when the base is a single symbol.\n      var isOiint = group.base && group.base.type === \"op\" && group.base.name && (group.base.name === \"\\\\oiint\" || group.base.name === \"\\\\oiiint\");\n\n      if (base instanceof SymbolNode || isOiint) {\n        // $FlowFixMe\n        marginLeft = makeEm(-base.italic);\n      }\n    }\n\n    var supsub;\n\n    if (supm && subm) {\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      subShift = Math.max(subShift, metrics.sub2);\n      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e\n\n      var maxWidth = 4 * ruleWidth;\n\n      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {\n        subShift = maxWidth - (supShift - supm.depth) + subm.height;\n        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);\n\n        if (psi > 0) {\n          supShift += psi;\n          subShift -= psi;\n        }\n      }\n\n      var vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        shift: subShift,\n        marginRight,\n        marginLeft\n      }, {\n        type: \"elem\",\n        elem: supm,\n        shift: -supShift,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: vlistElem\n      }, options);\n    } else if (subm) {\n      // Rule 18b\n      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);\n      var _vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        marginLeft,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: subShift,\n        children: _vlistElem\n      }, options);\n    } else if (supm) {\n      // Rule 18c, d\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -supShift,\n        children: [{\n          type: \"elem\",\n          elem: supm,\n          marginRight\n        }]\n      }, options);\n    } else {\n      throw new Error(\"supsub must have either sup or sub.\");\n    } // Wrap the supsub vlist in a span.msupsub to reset text-align.\n\n\n    var mclass = getTypeOfDomTree(base, \"right\") || \"mord\";\n    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan([\"msupsub\"], [supsub])], options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Is the inner group a relevant horizonal brace?\n    var isBrace = false;\n    var isOver;\n    var isSup;\n\n    if (group.base && group.base.type === \"horizBrace\") {\n      isSup = !!group.sup;\n\n      if (isSup === group.base.isOver) {\n        isBrace = true;\n        isOver = group.base.isOver;\n      }\n    }\n\n    if (group.base && (group.base.type === \"op\" || group.base.type === \"operatorname\")) {\n      group.base.parentIsSupSub = true;\n    }\n\n    var children = [buildGroup(group.base, options)];\n\n    if (group.sub) {\n      children.push(buildGroup(group.sub, options));\n    }\n\n    if (group.sup) {\n      children.push(buildGroup(group.sup, options));\n    }\n\n    var nodeType;\n\n    if (isBrace) {\n      nodeType = isOver ? \"mover\" : \"munder\";\n    } else if (!group.sub) {\n      var base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"mover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"mover\";\n      } else {\n        nodeType = \"msup\";\n      }\n    } else if (!group.sup) {\n      var _base = group.base;\n\n      if (_base && _base.type === \"op\" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {\n        nodeType = \"munder\";\n      } else if (_base && _base.type === \"operatorname\" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"munder\";\n      } else {\n        nodeType = \"msub\";\n      }\n    } else {\n      var _base2 = group.base;\n\n      if (_base2 && _base2.type === \"op\" && _base2.limits && options.style === Style$1.DISPLAY) {\n        nodeType = \"munderover\";\n      } else if (_base2 && _base2.type === \"operatorname\" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {\n        nodeType = \"munderover\";\n      } else {\n        nodeType = \"msubsup\";\n      }\n    }\n\n    return new mathMLTree.MathNode(nodeType, children);\n  }\n\n});\n\ndefineFunctionBuilders({\n  type: \"atom\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.mathsym(group.text, group.mode, options, [\"m\" + group.family]);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mo\", [makeText(group.text, group.mode)]);\n\n    if (group.family === \"bin\") {\n      var variant = getVariant(group, options);\n\n      if (variant === \"bold-italic\") {\n        node.setAttribute(\"mathvariant\", variant);\n      }\n    } else if (group.family === \"punct\") {\n      node.setAttribute(\"separator\", \"true\");\n    } else if (group.family === \"open\" || group.family === \"close\") {\n      // Delims built here should not stretch vertically.\n      // See delimsizing.js for stretchy delims.\n      node.setAttribute(\"stretchy\", \"false\");\n    }\n\n    return node;\n  }\n\n});\n\n// \"mathord\" and \"textord\" ParseNodes created in Parser.js from symbol Groups in\n// src/symbols.js.\nvar defaultVariant = {\n  \"mi\": \"italic\",\n  \"mn\": \"normal\",\n  \"mtext\": \"normal\"\n};\ndefineFunctionBuilders({\n  type: \"mathord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"mathord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mi\", [makeText(group.text, group.mode, options)]);\n    var variant = getVariant(group, options) || \"italic\";\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\ndefineFunctionBuilders({\n  type: \"textord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"textord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var text = makeText(group.text, group.mode, options);\n    var variant = getVariant(group, options) || \"normal\";\n    var node;\n\n    if (group.mode === 'text') {\n      node = new mathMLTree.MathNode(\"mtext\", [text]);\n    } else if (/[0-9]/.test(group.text)) {\n      node = new mathMLTree.MathNode(\"mn\", [text]);\n    } else if (group.text === \"\\\\prime\") {\n      node = new mathMLTree.MathNode(\"mo\", [text]);\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", [text]);\n    }\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\n\nvar cssSpace = {\n  \"\\\\nobreak\": \"nobreak\",\n  \"\\\\allowbreak\": \"allowbreak\"\n}; // A lookup table to determine whether a spacing function/symbol should be\n// treated like a regular space character.  If a symbol or command is a key\n// in this table, then it should be a regular space character.  Furthermore,\n// the associated value may have a `className` specifying an extra CSS class\n// to add to the created `span`.\n\nvar regularSpace = {\n  \" \": {},\n  \"\\\\ \": {},\n  \"~\": {\n    className: \"nobreak\"\n  },\n  \"\\\\space\": {},\n  \"\\\\nobreakspace\": {\n    className: \"nobreak\"\n  }\n}; // ParseNode<\"spacing\"> created in Parser.js from the \"spacing\" symbol Groups in\n// src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"spacing\",\n\n  htmlBuilder(group, options) {\n    if (regularSpace.hasOwnProperty(group.text)) {\n      var className = regularSpace[group.text].className || \"\"; // Spaces are generated by adding an actual space. Each of these\n      // things has an entry in the symbols table, so these will be turned\n      // into appropriate outputs.\n\n      if (group.mode === \"text\") {\n        var ord = buildCommon.makeOrd(group, options, \"textord\");\n        ord.classes.push(className);\n        return ord;\n      } else {\n        return buildCommon.makeSpan([\"mspace\", className], [buildCommon.mathsym(group.text, group.mode, options)], options);\n      }\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // Spaces based on just a CSS class.\n      return buildCommon.makeSpan([\"mspace\", cssSpace[group.text]], [], options);\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var node;\n\n    if (regularSpace.hasOwnProperty(group.text)) {\n      node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // CSS-based MathML spaces (\\nobreak, \\allowbreak) are ignored\n      return new mathMLTree.MathNode(\"mspace\");\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n\n    return node;\n  }\n\n});\n\nvar pad = () => {\n  var padNode = new mathMLTree.MathNode(\"mtd\", []);\n  padNode.setAttribute(\"width\", \"50%\");\n  return padNode;\n};\n\ndefineFunctionBuilders({\n  type: \"tag\",\n\n  mathmlBuilder(group, options) {\n    var table = new mathMLTree.MathNode(\"mtable\", [new mathMLTree.MathNode(\"mtr\", [pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.tag, options)])])]);\n    table.setAttribute(\"width\", \"100%\");\n    return table; // TODO: Left-aligned tags.\n    // Currently, the group and options passed here do not contain\n    // enough info to set tag alignment. `leqno` is in Settings but it is\n    // not passed to Options. On the HTML side, leqno is\n    // set by a CSS class applied in buildTree.js. That would have worked\n    // in MathML if browsers supported <mlabeledtr>. Since they don't, we\n    // need to rewrite the way this function is called.\n  }\n\n});\n\nvar textFontFamilies = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"textrm\",\n  \"\\\\textsf\": \"textsf\",\n  \"\\\\texttt\": \"texttt\",\n  \"\\\\textnormal\": \"textrm\"\n};\nvar textFontWeights = {\n  \"\\\\textbf\": \"textbf\",\n  \"\\\\textmd\": \"textmd\"\n};\nvar textFontShapes = {\n  \"\\\\textit\": \"textit\",\n  \"\\\\textup\": \"textup\"\n};\n\nvar optionsWithFont = (group, options) => {\n  var font = group.font; // Checks if the argument is a font family or a font style.\n\n  if (!font) {\n    return options;\n  } else if (textFontFamilies[font]) {\n    return options.withTextFontFamily(textFontFamilies[font]);\n  } else if (textFontWeights[font]) {\n    return options.withTextFontWeight(textFontWeights[font]);\n  } else {\n    return options.withTextFontShape(textFontShapes[font]);\n  }\n};\n\ndefineFunction({\n  type: \"text\",\n  names: [// Font families\n  \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", // Font weights\n  \"\\\\textbf\", \"\\\\textmd\", // Font Shapes\n  \"\\\\textit\", \"\\\\textup\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInArgument: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"text\",\n      mode: parser.mode,\n      body: ordargument(body),\n      font: funcName\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    var inner = buildExpression$1(group.body, newOptions, true);\n    return buildCommon.makeSpan([\"mord\", \"text\"], inner, newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    return buildExpressionRow(group.body, newOptions);\n  }\n\n});\n\ndefineFunction({\n  type: \"underline\",\n  names: [\"\\\\underline\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"underline\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Underlines are handled in the TeXbook pg 443, Rule 10.\n    // Build the inner group.\n    var innerGroup = buildGroup$1(group.body, options); // Create the line to go below the body\n\n    var line = buildCommon.makeLineSpan(\"underline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"kern\",\n        size: defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"underline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"vcenter\",\n  names: [\"\\\\vcenter\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"original\"],\n    // In LaTeX, \\vcenter can act only on a box.\n    allowedInText: false\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"vcenter\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var axisHeight = options.fontMetrics().axisHeight;\n    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // There is no way to do this in MathML.\n    // Write a class as a breadcrumb in case some post-processor wants\n    // to perform a vcenter adjustment.\n    return new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)], [\"vcenter\"]);\n  }\n\n});\n\ndefineFunction({\n  type: \"verb\",\n  names: [\"\\\\verb\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(context, args, optArgs) {\n    // \\verb and \\verb* are dealt with directly in Parser.js.\n    // If we end up here, it's because of a failure to match the two delimiters\n    // in the regex in Lexer.js.  LaTeX raises the following error when \\verb is\n    // terminated by end of line (or file).\n    throw new ParseError(\"\\\\verb ended by end of line instead of matching delimiter\");\n  },\n\n  htmlBuilder(group, options) {\n    var text = makeVerb(group);\n    var body = []; // \\verb enters text mode and therefore is sized like \\textstyle\n\n    var newOptions = options.havingStyle(options.style.text());\n\n    for (var i = 0; i < text.length; i++) {\n      var c = text[i];\n\n      if (c === '~') {\n        c = '\\\\textasciitilde';\n      }\n\n      body.push(buildCommon.makeSymbol(c, \"Typewriter-Regular\", group.mode, newOptions, [\"mord\", \"texttt\"]));\n    }\n\n    return buildCommon.makeSpan([\"mord\", \"text\"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var text = new mathMLTree.TextNode(makeVerb(group));\n    var node = new mathMLTree.MathNode(\"mtext\", [text]);\n    node.setAttribute(\"mathvariant\", \"monospace\");\n    return node;\n  }\n\n});\n/**\n * Converts verb group into body string.\n *\n * \\verb* replaces each space with an open box \\u2423\n * \\verb replaces each space with a no-break space \\xA0\n */\n\nvar makeVerb = group => group.body.replace(/ /g, group.star ? '\\u2423' : '\\xA0');\n\n/** Include this to ensure that all functions are defined. */\nvar functions = _functions;\n\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more whitespace characters\n * - matches a backslash followed by one or more letters then whitespace\n * - matches a backslash followed by any BMP character\n * Capturing groups:\n *   [1] regular whitespace\n *   [2] backslash followed by whitespace\n *   [3] anything else, which may include:\n *     [4] left character of \\verb*\n *     [5] left character of \\verb\n *     [6] backslash followed by word, excluding any trailing whitespace\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar spaceRegexString = \"[ \\r\\n\\t]\";\nvar controlWordRegexString = \"\\\\\\\\[a-zA-Z@]+\";\nvar controlSymbolRegexString = \"\\\\\\\\[^\\uD800-\\uDFFF]\";\nvar controlWordWhitespaceRegexString = \"(\" + controlWordRegexString + \")\" + spaceRegexString + \"*\";\nvar controlSpaceRegexString = \"\\\\\\\\(\\n|[ \\r\\t]+\\n?)[ \\r\\t]*\";\nvar combiningDiacriticalMarkString = \"[\\u0300-\\u036f]\";\nvar combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + \"+$\");\nvar tokenRegexString = \"(\" + spaceRegexString + \"+)|\" + ( // whitespace\ncontrolSpaceRegexString + \"|\") + // \\whitespace\n\"([!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" + ( // single codepoint\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" + ( // surrogate pair\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|\\\\\\\\verb\\\\*([^]).*?\\\\4\" + // \\verb*\n\"|\\\\\\\\verb([^*a-zA-Z]).*?\\\\5\" + ( // \\verb unstarred\n\"|\" + controlWordWhitespaceRegexString) + ( // \\macroName + spaces\n\"|\" + controlSymbolRegexString + \")\"); // \\\\, \\', etc.\n\n/** Main Lexer class */\n\nclass Lexer {\n  // Category codes. The lexer only supports comment characters (14) for now.\n  // MacroExpander additionally distinguishes active (13).\n  constructor(input, settings) {\n    this.input = void 0;\n    this.settings = void 0;\n    this.tokenRegex = void 0;\n    this.catcodes = void 0;\n    // Separate accents from characters\n    this.input = input;\n    this.settings = settings;\n    this.tokenRegex = new RegExp(tokenRegexString, 'g');\n    this.catcodes = {\n      \"%\": 14,\n      // comment character\n      \"~\": 13 // active character\n\n    };\n  }\n\n  setCatcode(char, code) {\n    this.catcodes[char] = code;\n  }\n  /**\n   * This function lexes a single token.\n   */\n\n\n  lex() {\n    var input = this.input;\n    var pos = this.tokenRegex.lastIndex;\n\n    if (pos === input.length) {\n      return new Token(\"EOF\", new SourceLocation(this, pos, pos));\n    }\n\n    var match = this.tokenRegex.exec(input);\n\n    if (match === null || match.index !== pos) {\n      throw new ParseError(\"Unexpected character: '\" + input[pos] + \"'\", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));\n    }\n\n    var text = match[6] || match[3] || (match[2] ? \"\\\\ \" : \" \");\n\n    if (this.catcodes[text] === 14) {\n      // comment character\n      var nlIndex = input.indexOf('\\n', this.tokenRegex.lastIndex);\n\n      if (nlIndex === -1) {\n        this.tokenRegex.lastIndex = input.length; // EOF\n\n        this.settings.reportNonstrict(\"commentAtEnd\", \"% comment has no terminating newline; LaTeX would \" + \"fail because of commenting the end of math mode (e.g. $)\");\n      } else {\n        this.tokenRegex.lastIndex = nlIndex + 1;\n      }\n\n      return this.lex();\n    }\n\n    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));\n  }\n\n}\n\n/**\n * A `Namespace` refers to a space of nameable things like macros or lengths,\n * which can be `set` either globally or local to a nested group, using an\n * undo stack similar to how TeX implements this functionality.\n * Performance-wise, `get` and local `set` take constant time, while global\n * `set` takes time proportional to the depth of group nesting.\n */\nclass Namespace {\n  /**\n   * Both arguments are optional.  The first argument is an object of\n   * built-in mappings which never change.  The second argument is an object\n   * of initial (global-level) mappings, which will constantly change\n   * according to any global/top-level `set`s done.\n   */\n  constructor(builtins, globalMacros) {\n    if (builtins === void 0) {\n      builtins = {};\n    }\n\n    if (globalMacros === void 0) {\n      globalMacros = {};\n    }\n\n    this.current = void 0;\n    this.builtins = void 0;\n    this.undefStack = void 0;\n    this.current = globalMacros;\n    this.builtins = builtins;\n    this.undefStack = [];\n  }\n  /**\n   * Start a new nested group, affecting future local `set`s.\n   */\n\n\n  beginGroup() {\n    this.undefStack.push({});\n  }\n  /**\n   * End current nested group, restoring values before the group began.\n   */\n\n\n  endGroup() {\n    if (this.undefStack.length === 0) {\n      throw new ParseError(\"Unbalanced namespace destruction: attempt \" + \"to pop global namespace; please report this as a bug\");\n    }\n\n    var undefs = this.undefStack.pop();\n\n    for (var undef in undefs) {\n      if (undefs.hasOwnProperty(undef)) {\n        if (undefs[undef] == null) {\n          delete this.current[undef];\n        } else {\n          this.current[undef] = undefs[undef];\n        }\n      }\n    }\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    while (this.undefStack.length > 0) {\n      this.endGroup();\n    }\n  }\n  /**\n   * Detect whether `name` has a definition.  Equivalent to\n   * `get(name) != null`.\n   */\n\n\n  has(name) {\n    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);\n  }\n  /**\n   * Get the current value of a name, or `undefined` if there is no value.\n   *\n   * Note: Do not use `if (namespace.get(...))` to detect whether a macro\n   * is defined, as the definition may be the empty string which evaluates\n   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or\n   * `if (namespace.has(...))`.\n   */\n\n\n  get(name) {\n    if (this.current.hasOwnProperty(name)) {\n      return this.current[name];\n    } else {\n      return this.builtins[name];\n    }\n  }\n  /**\n   * Set the current value of a name, and optionally set it globally too.\n   * Local set() sets the current value and (when appropriate) adds an undo\n   * operation to the undo stack.  Global set() may change the undo\n   * operation at every level, so takes time linear in their number.\n   * A value of undefined means to delete existing definitions.\n   */\n\n\n  set(name, value, global) {\n    if (global === void 0) {\n      global = false;\n    }\n\n    if (global) {\n      // Global set is equivalent to setting in all groups.  Simulate this\n      // by destroying any undos currently scheduled for this name,\n      // and adding an undo with the *new* value (in case it later gets\n      // locally reset within this environment).\n      for (var i = 0; i < this.undefStack.length; i++) {\n        delete this.undefStack[i][name];\n      }\n\n      if (this.undefStack.length > 0) {\n        this.undefStack[this.undefStack.length - 1][name] = value;\n      }\n    } else {\n      // Undo this set at end of this group (possibly to `undefined`),\n      // unless an undo is already in place, in which case that older\n      // value is the correct one.\n      var top = this.undefStack[this.undefStack.length - 1];\n\n      if (top && !top.hasOwnProperty(name)) {\n        top[name] = this.current[name];\n      }\n    }\n\n    if (value == null) {\n      delete this.current[name];\n    } else {\n      this.current[name] = value;\n    }\n  }\n\n}\n\n/**\n * Predefined macros for KaTeX.\n * This can be used to define some commands in terms of others.\n */\nvar macros = _macros;\n// macro tools\n\ndefineMacro(\"\\\\noexpand\", function (context) {\n  // The expansion is the token itself; but that token is interpreted\n  // as if its meaning were ‘\\relax’ if it is a control sequence that\n  // would ordinarily be expanded by TeX’s expansion rules.\n  var t = context.popToken();\n\n  if (context.isExpandable(t.text)) {\n    t.noexpand = true;\n    t.treatAsRelax = true;\n  }\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n});\ndefineMacro(\"\\\\expandafter\", function (context) {\n  // TeX first reads the token that comes immediately after \\expandafter,\n  // without expanding it; let’s call this token t. Then TeX reads the\n  // token that comes after t (and possibly more tokens, if that token\n  // has an argument), replacing it by its expansion. Finally TeX puts\n  // t back in front of that expansion.\n  var t = context.popToken();\n  context.expandOnce(true); // expand only an expandable token\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n}); // LaTeX's \\@firstoftwo{#1}{#2} expands to #1, skipping #2\n// TeX source: \\long\\def\\@firstoftwo#1#2{#1}\n\ndefineMacro(\"\\\\@firstoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[0],\n    numArgs: 0\n  };\n}); // LaTeX's \\@secondoftwo{#1}{#2} expands to #2, skipping #1\n// TeX source: \\long\\def\\@secondoftwo#1#2{#2}\n\ndefineMacro(\"\\\\@secondoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[1],\n    numArgs: 0\n  };\n}); // LaTeX's \\@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)\n// symbol that isn't a space, consuming any spaces but not consuming the\n// first nonspace character.  If that nonspace character matches #1, then\n// the macro expands to #2; otherwise, it expands to #3.\n\ndefineMacro(\"\\\\@ifnextchar\", function (context) {\n  var args = context.consumeArgs(3); // symbol, if, else\n\n  context.consumeSpaces();\n  var nextToken = context.future();\n\n  if (args[0].length === 1 && args[0][0].text === nextToken.text) {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[2],\n      numArgs: 0\n    };\n  }\n}); // LaTeX's \\@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.\n// If it is `*`, then it consumes the symbol, and the macro expands to #1;\n// otherwise, the macro expands to #2 (without consuming the symbol).\n// TeX source: \\def\\@ifstar#1{\\@ifnextchar *{\\@firstoftwo{#1}}}\n\ndefineMacro(\"\\\\@ifstar\", \"\\\\@ifnextchar *{\\\\@firstoftwo{#1}}\"); // LaTeX's \\TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode\n\ndefineMacro(\"\\\\TextOrMath\", function (context) {\n  var args = context.consumeArgs(2);\n\n  if (context.mode === 'text') {\n    return {\n      tokens: args[0],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  }\n}); // Lookup table for parsing numbers in base 8 through 16\n\nvar digitToNumber = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"a\": 10,\n  \"A\": 10,\n  \"b\": 11,\n  \"B\": 11,\n  \"c\": 12,\n  \"C\": 12,\n  \"d\": 13,\n  \"D\": 13,\n  \"e\": 14,\n  \"E\": 14,\n  \"f\": 15,\n  \"F\": 15\n}; // TeX \\char makes a literal character (catcode 12) using the following forms:\n// (see The TeXBook, p. 43)\n//   \\char123  -- decimal\n//   \\char'123 -- octal\n//   \\char\"123 -- hex\n//   \\char`x   -- character that can be written (i.e. isn't active)\n//   \\char`\\x  -- character that cannot be written (e.g. %)\n// These all refer to characters from the font, so we turn them into special\n// calls to a function \\@char dealt with in the Parser.\n\ndefineMacro(\"\\\\char\", function (context) {\n  var token = context.popToken();\n  var base;\n  var number = '';\n\n  if (token.text === \"'\") {\n    base = 8;\n    token = context.popToken();\n  } else if (token.text === '\"') {\n    base = 16;\n    token = context.popToken();\n  } else if (token.text === \"`\") {\n    token = context.popToken();\n\n    if (token.text[0] === \"\\\\\") {\n      number = token.text.charCodeAt(1);\n    } else if (token.text === \"EOF\") {\n      throw new ParseError(\"\\\\char` missing argument\");\n    } else {\n      number = token.text.charCodeAt(0);\n    }\n  } else {\n    base = 10;\n  }\n\n  if (base) {\n    // Parse a number in the given base, starting with first `token`.\n    number = digitToNumber[token.text];\n\n    if (number == null || number >= base) {\n      throw new ParseError(\"Invalid base-\" + base + \" digit \" + token.text);\n    }\n\n    var digit;\n\n    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {\n      number *= base;\n      number += digit;\n      context.popToken();\n    }\n  }\n\n  return \"\\\\@char{\" + number + \"}\";\n}); // \\newcommand{\\macro}[args]{definition}\n// \\renewcommand{\\macro}[args]{definition}\n// TODO: Optional arguments: \\newcommand{\\macro}[args][default]{definition}\n\nvar newcommand = (context, existsOK, nonexistsOK) => {\n  var arg = context.consumeArg().tokens;\n\n  if (arg.length !== 1) {\n    throw new ParseError(\"\\\\newcommand's first argument must be a macro name\");\n  }\n\n  var name = arg[0].text;\n  var exists = context.isDefined(name);\n\n  if (exists && !existsOK) {\n    throw new ParseError(\"\\\\newcommand{\" + name + \"} attempting to redefine \" + (name + \"; use \\\\renewcommand\"));\n  }\n\n  if (!exists && !nonexistsOK) {\n    throw new ParseError(\"\\\\renewcommand{\" + name + \"} when command \" + name + \" \" + \"does not yet exist; use \\\\newcommand\");\n  }\n\n  var numArgs = 0;\n  arg = context.consumeArg().tokens;\n\n  if (arg.length === 1 && arg[0].text === \"[\") {\n    var argText = '';\n    var token = context.expandNextToken();\n\n    while (token.text !== \"]\" && token.text !== \"EOF\") {\n      // TODO: Should properly expand arg, e.g., ignore {}s\n      argText += token.text;\n      token = context.expandNextToken();\n    }\n\n    if (!argText.match(/^\\s*[0-9]+\\s*$/)) {\n      throw new ParseError(\"Invalid number of arguments: \" + argText);\n    }\n\n    numArgs = parseInt(argText);\n    arg = context.consumeArg().tokens;\n  } // Final arg is the expansion of the macro\n\n\n  context.macros.set(name, {\n    tokens: arg,\n    numArgs\n  });\n  return '';\n};\n\ndefineMacro(\"\\\\newcommand\", context => newcommand(context, false, true));\ndefineMacro(\"\\\\renewcommand\", context => newcommand(context, true, false));\ndefineMacro(\"\\\\providecommand\", context => newcommand(context, true, true)); // terminal (console) tools\n\ndefineMacro(\"\\\\message\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.log(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\errmessage\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.error(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\show\", context => {\n  var tok = context.popToken();\n  var name = tok.text; // eslint-disable-next-line no-console\n\n  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);\n  return '';\n}); //////////////////////////////////////////////////////////////////////\n// Grouping\n// \\let\\bgroup={ \\let\\egroup=}\n\ndefineMacro(\"\\\\bgroup\", \"{\");\ndefineMacro(\"\\\\egroup\", \"}\"); // Symbols from latex.ltx:\n// \\def~{\\nobreakspace{}}\n// \\def\\lq{`}\n// \\def\\rq{'}\n// \\def \\aa {\\r a}\n// \\def \\AA {\\r A}\n\ndefineMacro(\"~\", \"\\\\nobreakspace\");\ndefineMacro(\"\\\\lq\", \"`\");\ndefineMacro(\"\\\\rq\", \"'\");\ndefineMacro(\"\\\\aa\", \"\\\\r a\");\ndefineMacro(\"\\\\AA\", \"\\\\r A\"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.\n// \\DeclareTextCommandDefault{\\textcopyright}{\\textcircled{c}}\n// \\DeclareTextCommandDefault{\\textregistered}{\\textcircled{%\n//      \\check@mathfonts\\fontsize\\sf@size\\z@\\math@fontsfalse\\selectfont R}}\n// \\DeclareRobustCommand{\\copyright}{%\n//    \\ifmmode{\\nfss@text{\\textcopyright}}\\else\\textcopyright\\fi}\n\ndefineMacro(\"\\\\textcopyright\", \"\\\\html@mathml{\\\\textcircled{c}}{\\\\char`©}\");\ndefineMacro(\"\\\\copyright\", \"\\\\TextOrMath{\\\\textcopyright}{\\\\text{\\\\textcopyright}}\");\ndefineMacro(\"\\\\textregistered\", \"\\\\html@mathml{\\\\textcircled{\\\\scriptsize R}}{\\\\char`®}\"); // Characters omitted from Unicode range 1D400–1D7FF\n\ndefineMacro(\"\\u212C\", \"\\\\mathscr{B}\"); // script\n\ndefineMacro(\"\\u2130\", \"\\\\mathscr{E}\");\ndefineMacro(\"\\u2131\", \"\\\\mathscr{F}\");\ndefineMacro(\"\\u210B\", \"\\\\mathscr{H}\");\ndefineMacro(\"\\u2110\", \"\\\\mathscr{I}\");\ndefineMacro(\"\\u2112\", \"\\\\mathscr{L}\");\ndefineMacro(\"\\u2133\", \"\\\\mathscr{M}\");\ndefineMacro(\"\\u211B\", \"\\\\mathscr{R}\");\ndefineMacro(\"\\u212D\", \"\\\\mathfrak{C}\"); // Fraktur\n\ndefineMacro(\"\\u210C\", \"\\\\mathfrak{H}\");\ndefineMacro(\"\\u2128\", \"\\\\mathfrak{Z}\"); // Define \\Bbbk with a macro that works in both HTML and MathML.\n\ndefineMacro(\"\\\\Bbbk\", \"\\\\Bbb{k}\"); // Unicode middle dot\n// The KaTeX fonts do not contain U+00B7. Instead, \\cdotp displays\n// the dot at U+22C5 and gives it punct spacing.\n\ndefineMacro(\"\\u00b7\", \"\\\\cdotp\"); // \\llap and \\rlap render their contents in text mode\n\ndefineMacro(\"\\\\llap\", \"\\\\mathllap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\rlap\", \"\\\\mathrlap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\clap\", \"\\\\mathclap{\\\\textrm{#1}}\"); // \\mathstrut from the TeXbook, p 360\n\ndefineMacro(\"\\\\mathstrut\", \"\\\\vphantom{(}\"); // \\underbar from TeXbook p 353\n\ndefineMacro(\"\\\\underbar\", \"\\\\underline{\\\\text{#1}}\"); // \\not is defined by base/fontmath.ltx via\n// \\DeclareMathSymbol{\\not}{\\mathrel}{symbols}{\"36}\n// It's thus treated like a \\mathrel, but defined by a symbol that has zero\n// width but extends to the right.  We use \\rlap to get that spacing.\n// For MathML we write U+0338 here. buildMathML.js will then do the overlay.\n\ndefineMacro(\"\\\\not\", '\\\\html@mathml{\\\\mathrel{\\\\mathrlap\\\\@not}}{\\\\char\"338}'); // Negated symbols from base/fontmath.ltx:\n// \\def\\neq{\\not=} \\let\\ne=\\neq\n// \\DeclareRobustCommand\n//   \\notin{\\mathrel{\\m@th\\mathpalette\\c@ncel\\in}}\n// \\def\\c@ncel#1#2{\\m@th\\ooalign{$\\hfil#1\\mkern1mu/\\hfil$\\crcr$#1#2$}}\n\ndefineMacro(\"\\\\neq\", \"\\\\html@mathml{\\\\mathrel{\\\\not=}}{\\\\mathrel{\\\\char`≠}}\");\ndefineMacro(\"\\\\ne\", \"\\\\neq\");\ndefineMacro(\"\\u2260\", \"\\\\neq\");\ndefineMacro(\"\\\\notin\", \"\\\\html@mathml{\\\\mathrel{{\\\\in}\\\\mathllap{/\\\\mskip1mu}}}\" + \"{\\\\mathrel{\\\\char`∉}}\");\ndefineMacro(\"\\u2209\", \"\\\\notin\"); // Unicode stacked relations\n\ndefineMacro(\"\\u2258\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\kern{-1em}\\\\raisebox{0.4em}{$\\\\scriptsize\\\\frown$}}\" + \"}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u2259\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\wedge}{=}}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u225A\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\vee}{=}}{\\\\mathrel{\\\\char`\\u225A}}\");\ndefineMacro(\"\\u225B\", \"\\\\html@mathml{\\\\stackrel{\\\\scriptsize\\\\star}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225B}}\");\ndefineMacro(\"\\u225D\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{def}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225D}}\");\ndefineMacro(\"\\u225E\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{m}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225E}}\");\ndefineMacro(\"\\u225F\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny?}{=}}{\\\\mathrel{\\\\char`\\u225F}}\"); // Misc Unicode\n\ndefineMacro(\"\\u27C2\", \"\\\\perp\");\ndefineMacro(\"\\u203C\", \"\\\\mathclose{!\\\\mkern-0.8mu!}\");\ndefineMacro(\"\\u220C\", \"\\\\notni\");\ndefineMacro(\"\\u231C\", \"\\\\ulcorner\");\ndefineMacro(\"\\u231D\", \"\\\\urcorner\");\ndefineMacro(\"\\u231E\", \"\\\\llcorner\");\ndefineMacro(\"\\u231F\", \"\\\\lrcorner\");\ndefineMacro(\"\\u00A9\", \"\\\\copyright\");\ndefineMacro(\"\\u00AE\", \"\\\\textregistered\");\ndefineMacro(\"\\uFE0F\", \"\\\\textregistered\"); // The KaTeX fonts have corners at codepoints that don't match Unicode.\n// For MathML purposes, use the Unicode code point.\n\ndefineMacro(\"\\\\ulcorner\", \"\\\\html@mathml{\\\\@ulcorner}{\\\\mathop{\\\\char\\\"231c}}\");\ndefineMacro(\"\\\\urcorner\", \"\\\\html@mathml{\\\\@urcorner}{\\\\mathop{\\\\char\\\"231d}}\");\ndefineMacro(\"\\\\llcorner\", \"\\\\html@mathml{\\\\@llcorner}{\\\\mathop{\\\\char\\\"231e}}\");\ndefineMacro(\"\\\\lrcorner\", \"\\\\html@mathml{\\\\@lrcorner}{\\\\mathop{\\\\char\\\"231f}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX_2ε\n// \\vdots{\\vbox{\\baselineskip4\\p@  \\lineskiplimit\\z@\n// \\kern6\\p@\\hbox{.}\\hbox{.}\\hbox{.}}}\n// We'll call \\varvdots, which gets a glyph from symbols.js.\n// The zero-width rule gets us an equivalent to the vertical 6pt kern.\n\ndefineMacro(\"\\\\vdots\", \"\\\\mathord{\\\\varvdots\\\\rule{0pt}{15pt}}\");\ndefineMacro(\"\\u22ee\", \"\\\\vdots\"); //////////////////////////////////////////////////////////////////////\n// amsmath.sty\n// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf\n// Italic Greek capital letters.  AMS defines these with \\DeclareMathSymbol,\n// but they are equivalent to \\mathit{\\Letter}.\n\ndefineMacro(\"\\\\varGamma\", \"\\\\mathit{\\\\Gamma}\");\ndefineMacro(\"\\\\varDelta\", \"\\\\mathit{\\\\Delta}\");\ndefineMacro(\"\\\\varTheta\", \"\\\\mathit{\\\\Theta}\");\ndefineMacro(\"\\\\varLambda\", \"\\\\mathit{\\\\Lambda}\");\ndefineMacro(\"\\\\varXi\", \"\\\\mathit{\\\\Xi}\");\ndefineMacro(\"\\\\varPi\", \"\\\\mathit{\\\\Pi}\");\ndefineMacro(\"\\\\varSigma\", \"\\\\mathit{\\\\Sigma}\");\ndefineMacro(\"\\\\varUpsilon\", \"\\\\mathit{\\\\Upsilon}\");\ndefineMacro(\"\\\\varPhi\", \"\\\\mathit{\\\\Phi}\");\ndefineMacro(\"\\\\varPsi\", \"\\\\mathit{\\\\Psi}\");\ndefineMacro(\"\\\\varOmega\", \"\\\\mathit{\\\\Omega}\"); //\\newcommand{\\substack}[1]{\\subarray{c}#1\\endsubarray}\n\ndefineMacro(\"\\\\substack\", \"\\\\begin{subarray}{c}#1\\\\end{subarray}\"); // \\renewcommand{\\colon}{\\nobreak\\mskip2mu\\mathpunct{}\\nonscript\n// \\mkern-\\thinmuskip{:}\\mskip6muplus1mu\\relax}\n\ndefineMacro(\"\\\\colon\", \"\\\\nobreak\\\\mskip2mu\\\\mathpunct{}\" + \"\\\\mathchoice{\\\\mkern-3mu}{\\\\mkern-3mu}{}{}{:}\\\\mskip6mu\\\\relax\"); // \\newcommand{\\boxed}[1]{\\fbox{\\m@th$\\displaystyle#1$}}\n\ndefineMacro(\"\\\\boxed\", \"\\\\fbox{$\\\\displaystyle{#1}$}\"); // \\def\\iff{\\DOTSB\\;\\Longleftrightarrow\\;}\n// \\def\\implies{\\DOTSB\\;\\Longrightarrow\\;}\n// \\def\\impliedby{\\DOTSB\\;\\Longleftarrow\\;}\n\ndefineMacro(\"\\\\iff\", \"\\\\DOTSB\\\\;\\\\Longleftrightarrow\\\\;\");\ndefineMacro(\"\\\\implies\", \"\\\\DOTSB\\\\;\\\\Longrightarrow\\\\;\");\ndefineMacro(\"\\\\impliedby\", \"\\\\DOTSB\\\\;\\\\Longleftarrow\\\\;\"); // AMSMath's automatic \\dots, based on \\mdots@@ macro.\n\nvar dotsByToken = {\n  ',': '\\\\dotsc',\n  '\\\\not': '\\\\dotsb',\n  // \\keybin@ checks for the following:\n  '+': '\\\\dotsb',\n  '=': '\\\\dotsb',\n  '<': '\\\\dotsb',\n  '>': '\\\\dotsb',\n  '-': '\\\\dotsb',\n  '*': '\\\\dotsb',\n  ':': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSB:\n  '\\\\DOTSB': '\\\\dotsb',\n  '\\\\coprod': '\\\\dotsb',\n  '\\\\bigvee': '\\\\dotsb',\n  '\\\\bigwedge': '\\\\dotsb',\n  '\\\\biguplus': '\\\\dotsb',\n  '\\\\bigcap': '\\\\dotsb',\n  '\\\\bigcup': '\\\\dotsb',\n  '\\\\prod': '\\\\dotsb',\n  '\\\\sum': '\\\\dotsb',\n  '\\\\bigotimes': '\\\\dotsb',\n  '\\\\bigoplus': '\\\\dotsb',\n  '\\\\bigodot': '\\\\dotsb',\n  '\\\\bigsqcup': '\\\\dotsb',\n  '\\\\And': '\\\\dotsb',\n  '\\\\longrightarrow': '\\\\dotsb',\n  '\\\\Longrightarrow': '\\\\dotsb',\n  '\\\\longleftarrow': '\\\\dotsb',\n  '\\\\Longleftarrow': '\\\\dotsb',\n  '\\\\longleftrightarrow': '\\\\dotsb',\n  '\\\\Longleftrightarrow': '\\\\dotsb',\n  '\\\\mapsto': '\\\\dotsb',\n  '\\\\longmapsto': '\\\\dotsb',\n  '\\\\hookrightarrow': '\\\\dotsb',\n  '\\\\doteq': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathbin:\n  '\\\\mathbin': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathrel:\n  '\\\\mathrel': '\\\\dotsb',\n  '\\\\relbar': '\\\\dotsb',\n  '\\\\Relbar': '\\\\dotsb',\n  '\\\\xrightarrow': '\\\\dotsb',\n  '\\\\xleftarrow': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSI:\n  '\\\\DOTSI': '\\\\dotsi',\n  '\\\\int': '\\\\dotsi',\n  '\\\\oint': '\\\\dotsi',\n  '\\\\iint': '\\\\dotsi',\n  '\\\\iiint': '\\\\dotsi',\n  '\\\\iiiint': '\\\\dotsi',\n  '\\\\idotsint': '\\\\dotsi',\n  // Symbols whose definition starts with \\DOTSX:\n  '\\\\DOTSX': '\\\\dotsx'\n};\ndefineMacro(\"\\\\dots\", function (context) {\n  // TODO: If used in text mode, should expand to \\textellipsis.\n  // However, in KaTeX, \\textellipsis and \\ldots behave the same\n  // (in text mode), and it's unlikely we'd see any of the math commands\n  // that affect the behavior of \\dots when in text mode.  So fine for now\n  // (until we support \\ifmmode ... \\else ... \\fi).\n  var thedots = '\\\\dotso';\n  var next = context.expandAfterFuture().text;\n\n  if (next in dotsByToken) {\n    thedots = dotsByToken[next];\n  } else if (next.substr(0, 4) === '\\\\not') {\n    thedots = '\\\\dotsb';\n  } else if (next in symbols.math) {\n    if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {\n      thedots = '\\\\dotsb';\n    }\n  }\n\n  return thedots;\n});\nvar spaceAfterDots = {\n  // \\rightdelim@ checks for the following:\n  ')': true,\n  ']': true,\n  '\\\\rbrack': true,\n  '\\\\}': true,\n  '\\\\rbrace': true,\n  '\\\\rangle': true,\n  '\\\\rceil': true,\n  '\\\\rfloor': true,\n  '\\\\rgroup': true,\n  '\\\\rmoustache': true,\n  '\\\\right': true,\n  '\\\\bigr': true,\n  '\\\\biggr': true,\n  '\\\\Bigr': true,\n  '\\\\Biggr': true,\n  // \\extra@ also tests for the following:\n  '$': true,\n  // \\extrap@ checks for the following:\n  ';': true,\n  '.': true,\n  ',': true\n};\ndefineMacro(\"\\\\dotso\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\dotsc\", function (context) {\n  var next = context.future().text; // \\dotsc uses \\extra@ but not \\extrap@, instead specially checking for\n  // ';' and '.', but doesn't check for ','.\n\n  if (next in spaceAfterDots && next !== ',') {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\cdots\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\@cdots\\\\,\";\n  } else {\n    return \"\\\\@cdots\";\n  }\n});\ndefineMacro(\"\\\\dotsb\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsm\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsi\", \"\\\\!\\\\cdots\"); // amsmath doesn't actually define \\dotsx, but \\dots followed by a macro\n// starting with \\DOTSX implies \\dotso, and then \\extra@ detects this case\n// and forces the added `\\,`.\n\ndefineMacro(\"\\\\dotsx\", \"\\\\ldots\\\\,\"); // \\let\\DOTSI\\relax\n// \\let\\DOTSB\\relax\n// \\let\\DOTSX\\relax\n\ndefineMacro(\"\\\\DOTSI\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSB\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSX\", \"\\\\relax\"); // Spacing, based on amsmath.sty's override of LaTeX defaults\n// \\DeclareRobustCommand{\\tmspace}[3]{%\n//   \\ifmmode\\mskip#1#2\\else\\kern#1#3\\fi\\relax}\n\ndefineMacro(\"\\\\tmspace\", \"\\\\TextOrMath{\\\\kern#1#3}{\\\\mskip#1#2}\\\\relax\"); // \\renewcommand{\\,}{\\tmspace+\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\,\", \"\\\\tmspace+{3mu}{.1667em}\"); // \\let\\thinspace\\,\n\ndefineMacro(\"\\\\thinspace\", \"\\\\,\"); // \\def\\>{\\mskip\\medmuskip}\n// \\renewcommand{\\:}{\\tmspace+\\medmuskip{.2222em}}\n// TODO: \\> and math mode of \\: should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\>\", \"\\\\mskip{4mu}\");\ndefineMacro(\"\\\\:\", \"\\\\tmspace+{4mu}{.2222em}\"); // \\let\\medspace\\:\n\ndefineMacro(\"\\\\medspace\", \"\\\\:\"); // \\renewcommand{\\;}{\\tmspace+\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip = 5mu plus 5mu\n\ndefineMacro(\"\\\\;\", \"\\\\tmspace+{5mu}{.2777em}\"); // \\let\\thickspace\\;\n\ndefineMacro(\"\\\\thickspace\", \"\\\\;\"); // \\renewcommand{\\!}{\\tmspace-\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\!\", \"\\\\tmspace-{3mu}{.1667em}\"); // \\let\\negthinspace\\!\n\ndefineMacro(\"\\\\negthinspace\", \"\\\\!\"); // \\newcommand{\\negmedspace}{\\tmspace-\\medmuskip{.2222em}}\n// TODO: math mode should use \\medmuskip\n\ndefineMacro(\"\\\\negmedspace\", \"\\\\tmspace-{4mu}{.2222em}\"); // \\newcommand{\\negthickspace}{\\tmspace-\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip\n\ndefineMacro(\"\\\\negthickspace\", \"\\\\tmspace-{5mu}{.277em}\"); // \\def\\enspace{\\kern.5em }\n\ndefineMacro(\"\\\\enspace\", \"\\\\kern.5em \"); // \\def\\enskip{\\hskip.5em\\relax}\n\ndefineMacro(\"\\\\enskip\", \"\\\\hskip.5em\\\\relax\"); // \\def\\quad{\\hskip1em\\relax}\n\ndefineMacro(\"\\\\quad\", \"\\\\hskip1em\\\\relax\"); // \\def\\qquad{\\hskip2em\\relax}\n\ndefineMacro(\"\\\\qquad\", \"\\\\hskip2em\\\\relax\"); // \\tag@in@display form of \\tag\n\ndefineMacro(\"\\\\tag\", \"\\\\@ifstar\\\\tag@literal\\\\tag@paren\");\ndefineMacro(\"\\\\tag@paren\", \"\\\\tag@literal{({#1})}\");\ndefineMacro(\"\\\\tag@literal\", context => {\n  if (context.macros.get(\"\\\\df@tag\")) {\n    throw new ParseError(\"Multiple \\\\tag\");\n  }\n\n  return \"\\\\gdef\\\\df@tag{\\\\text{#1}}\";\n}); // \\renewcommand{\\bmod}{\\nonscript\\mskip-\\medmuskip\\mkern5mu\\mathbin\n//   {\\operator@font mod}\\penalty900\n//   \\mkern5mu\\nonscript\\mskip-\\medmuskip}\n// \\newcommand{\\pod}[1]{\\allowbreak\n//   \\if@display\\mkern18mu\\else\\mkern8mu\\fi(#1)}\n// \\renewcommand{\\pmod}[1]{\\pod{{\\operator@font mod}\\mkern6mu#1}}\n// \\newcommand{\\mod}[1]{\\allowbreak\\if@display\\mkern18mu\n//   \\else\\mkern12mu\\fi{\\operator@font mod}\\,\\,#1}\n// TODO: math mode should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\bmod\", \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\" + \"\\\\mathbin{\\\\rm mod}\" + \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\");\ndefineMacro(\"\\\\pod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern8mu}{\\\\mkern8mu}{\\\\mkern8mu}(#1)\");\ndefineMacro(\"\\\\pmod\", \"\\\\pod{{\\\\rm mod}\\\\mkern6mu#1}\");\ndefineMacro(\"\\\\mod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern12mu}{\\\\mkern12mu}{\\\\mkern12mu}\" + \"{\\\\rm mod}\\\\,\\\\,#1\"); // \\pmb    --   A simulation of bold.\n// The version in ambsy.sty works by typesetting three copies of the argument\n// with small offsets. We use two copies. We omit the vertical offset because\n// of rendering problems that makeVList encounters in Safari.\n\ndefineMacro(\"\\\\pmb\", \"\\\\html@mathml{\" + \"\\\\@binrel{#1}{\\\\mathrlap{#1}\\\\kern0.5px#1}}\" + \"{\\\\mathbf{#1}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX source2e\n// \\expandafter\\let\\expandafter\\@normalcr\n//     \\csname\\expandafter\\@gobble\\string\\\\ \\endcsname\n// \\DeclareRobustCommand\\newline{\\@normalcr\\relax}\n\ndefineMacro(\"\\\\newline\", \"\\\\\\\\\\\\relax\"); // \\def\\TeX{T\\kern-.1667em\\lower.5ex\\hbox{E}\\kern-.125emX\\@}\n// TODO: Doesn't normally work in math mode because \\@ fails.  KaTeX doesn't\n// support \\@ yet, so that's omitted, and we add \\text so that the result\n// doesn't look funny in math mode.\n\ndefineMacro(\"\\\\TeX\", \"\\\\textrm{\\\\html@mathml{\" + \"T\\\\kern-.1667em\\\\raisebox{-.5ex}{E}\\\\kern-.125emX\" + \"}{TeX}}\"); // \\DeclareRobustCommand{\\LaTeX}{L\\kern-.36em%\n//         {\\sbox\\z@ T%\n//          \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts\n//                               \\fontsize\\sf@size\\z@\n//                               \\math@fontsfalse\\selectfont\n//                               A}%\n//                         \\vss}%\n//         }%\n//         \\kern-.15em%\n//         \\TeX}\n// This code aligns the top of the A with the T (from the perspective of TeX's\n// boxes, though visually the A appears to extend above slightly).\n// We compute the corresponding \\raisebox when A is rendered in \\normalsize\n// \\scriptstyle, which has a scale factor of 0.7 (see Options.js).\n\nvar latexRaiseA = makeEm(fontMetricsData['Main-Regular'][\"T\".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular'][\"A\".charCodeAt(0)][1]);\ndefineMacro(\"\\\\LaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"L\\\\kern-.36em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{LaTeX}}\"); // New KaTeX logo based on tweaking LaTeX logo\n\ndefineMacro(\"\\\\KaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"K\\\\kern-.17em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{KaTeX}}\"); // \\DeclareRobustCommand\\hspace{\\@ifstar\\@hspacer\\@hspace}\n// \\def\\@hspace#1{\\hskip  #1\\relax}\n// \\def\\@hspacer#1{\\vrule \\@width\\z@\\nobreak\n//                 \\hskip #1\\hskip \\z@skip}\n\ndefineMacro(\"\\\\hspace\", \"\\\\@ifstar\\\\@hspacer\\\\@hspace\");\ndefineMacro(\"\\\\@hspace\", \"\\\\hskip #1\\\\relax\");\ndefineMacro(\"\\\\@hspacer\", \"\\\\rule{0pt}{0pt}\\\\hskip #1\\\\relax\"); //////////////////////////////////////////////////////////////////////\n// mathtools.sty\n//\\providecommand\\ordinarycolon{:}\n\ndefineMacro(\"\\\\ordinarycolon\", \":\"); //\\def\\vcentcolon{\\mathrel{\\mathop\\ordinarycolon}}\n//TODO(edemaine): Not yet centered. Fix via \\raisebox or #726\n\ndefineMacro(\"\\\\vcentcolon\", \"\\\\mathrel{\\\\mathop\\\\ordinarycolon}\"); // \\providecommand*\\dblcolon{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}\n\ndefineMacro(\"\\\\dblcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-.9mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2237}}\"); // \\providecommand*\\coloneqq{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2254}}\"); // ≔\n// \\providecommand*\\Coloneqq{\\dblcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\Coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"3d}}\"); // \\providecommand*\\coloneq{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2212}}\"); // \\providecommand*\\Coloneq{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\Coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2212}}\"); // \\providecommand*\\eqqcolon{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2255}}\"); // ≕\n// \\providecommand*\\Eqqcolon{=\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"3d\\\\char\\\"2237}}\"); // \\providecommand*\\eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2239}}\"); // \\providecommand*\\Eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"2212\\\\char\\\"2237}}\"); // \\providecommand*\\colonapprox{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2248}}\"); // \\providecommand*\\Colonapprox{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\Colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2248}}\"); // \\providecommand*\\colonsim{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"223c}}\"); // \\providecommand*\\Colonsim{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\Colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"223c}}\"); // Some Unicode characters are implemented with macros to mathtools functions.\n\ndefineMacro(\"\\u2237\", \"\\\\dblcolon\"); // ::\n\ndefineMacro(\"\\u2239\", \"\\\\eqcolon\"); // -:\n\ndefineMacro(\"\\u2254\", \"\\\\coloneqq\"); // :=\n\ndefineMacro(\"\\u2255\", \"\\\\eqqcolon\"); // =:\n\ndefineMacro(\"\\u2A74\", \"\\\\Coloneqq\"); // ::=\n//////////////////////////////////////////////////////////////////////\n// colonequals.sty\n// Alternate names for mathtools's macros:\n\ndefineMacro(\"\\\\ratio\", \"\\\\vcentcolon\");\ndefineMacro(\"\\\\coloncolon\", \"\\\\dblcolon\");\ndefineMacro(\"\\\\colonequals\", \"\\\\coloneqq\");\ndefineMacro(\"\\\\coloncolonequals\", \"\\\\Coloneqq\");\ndefineMacro(\"\\\\equalscolon\", \"\\\\eqqcolon\");\ndefineMacro(\"\\\\equalscoloncolon\", \"\\\\Eqqcolon\");\ndefineMacro(\"\\\\colonminus\", \"\\\\coloneq\");\ndefineMacro(\"\\\\coloncolonminus\", \"\\\\Coloneq\");\ndefineMacro(\"\\\\minuscolon\", \"\\\\eqcolon\");\ndefineMacro(\"\\\\minuscoloncolon\", \"\\\\Eqcolon\"); // \\colonapprox name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonapprox\", \"\\\\Colonapprox\"); // \\colonsim name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonsim\", \"\\\\Colonsim\"); // Additional macros, implemented by analogy with mathtools definitions:\n\ndefineMacro(\"\\\\simcolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\simcoloncolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\");\ndefineMacro(\"\\\\approxcolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\approxcoloncolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\"); // Present in newtxmath, pxfonts and txfonts\n\ndefineMacro(\"\\\\notni\", \"\\\\html@mathml{\\\\not\\\\ni}{\\\\mathrel{\\\\char`\\u220C}}\");\ndefineMacro(\"\\\\limsup\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,sup}\");\ndefineMacro(\"\\\\liminf\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,inf}\"); //////////////////////////////////////////////////////////////////////\n// From amsopn.sty\n\ndefineMacro(\"\\\\injlim\", \"\\\\DOTSB\\\\operatorname*{inj\\\\,lim}\");\ndefineMacro(\"\\\\projlim\", \"\\\\DOTSB\\\\operatorname*{proj\\\\,lim}\");\ndefineMacro(\"\\\\varlimsup\", \"\\\\DOTSB\\\\operatorname*{\\\\overline{lim}}\");\ndefineMacro(\"\\\\varliminf\", \"\\\\DOTSB\\\\operatorname*{\\\\underline{lim}}\");\ndefineMacro(\"\\\\varinjlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underrightarrow{lim}}\");\ndefineMacro(\"\\\\varprojlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underleftarrow{lim}}\"); //////////////////////////////////////////////////////////////////////\n// MathML alternates for KaTeX glyphs in the Unicode private area\n\ndefineMacro(\"\\\\gvertneqq\", \"\\\\html@mathml{\\\\@gvertneqq}{\\u2269}\");\ndefineMacro(\"\\\\lvertneqq\", \"\\\\html@mathml{\\\\@lvertneqq}{\\u2268}\");\ndefineMacro(\"\\\\ngeqq\", \"\\\\html@mathml{\\\\@ngeqq}{\\u2271}\");\ndefineMacro(\"\\\\ngeqslant\", \"\\\\html@mathml{\\\\@ngeqslant}{\\u2271}\");\ndefineMacro(\"\\\\nleqq\", \"\\\\html@mathml{\\\\@nleqq}{\\u2270}\");\ndefineMacro(\"\\\\nleqslant\", \"\\\\html@mathml{\\\\@nleqslant}{\\u2270}\");\ndefineMacro(\"\\\\nshortmid\", \"\\\\html@mathml{\\\\@nshortmid}{∤}\");\ndefineMacro(\"\\\\nshortparallel\", \"\\\\html@mathml{\\\\@nshortparallel}{∦}\");\ndefineMacro(\"\\\\nsubseteqq\", \"\\\\html@mathml{\\\\@nsubseteqq}{\\u2288}\");\ndefineMacro(\"\\\\nsupseteqq\", \"\\\\html@mathml{\\\\@nsupseteqq}{\\u2289}\");\ndefineMacro(\"\\\\varsubsetneq\", \"\\\\html@mathml{\\\\@varsubsetneq}{⊊}\");\ndefineMacro(\"\\\\varsubsetneqq\", \"\\\\html@mathml{\\\\@varsubsetneqq}{⫋}\");\ndefineMacro(\"\\\\varsupsetneq\", \"\\\\html@mathml{\\\\@varsupsetneq}{⊋}\");\ndefineMacro(\"\\\\varsupsetneqq\", \"\\\\html@mathml{\\\\@varsupsetneqq}{⫌}\");\ndefineMacro(\"\\\\imath\", \"\\\\html@mathml{\\\\@imath}{\\u0131}\");\ndefineMacro(\"\\\\jmath\", \"\\\\html@mathml{\\\\@jmath}{\\u0237}\"); //////////////////////////////////////////////////////////////////////\n// stmaryrd and semantic\n// The stmaryrd and semantic packages render the next four items by calling a\n// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.\n\ndefineMacro(\"\\\\llbracket\", \"\\\\html@mathml{\" + \"\\\\mathopen{[\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u27e6}}\");\ndefineMacro(\"\\\\rrbracket\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu]}}\" + \"{\\\\mathclose{\\\\char`\\u27e7}}\");\ndefineMacro(\"\\u27e6\", \"\\\\llbracket\"); // blackboard bold [\n\ndefineMacro(\"\\u27e7\", \"\\\\rrbracket\"); // blackboard bold ]\n\ndefineMacro(\"\\\\lBrace\", \"\\\\html@mathml{\" + \"\\\\mathopen{\\\\{\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u2983}}\");\ndefineMacro(\"\\\\rBrace\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu\\\\}}}\" + \"{\\\\mathclose{\\\\char`\\u2984}}\");\ndefineMacro(\"\\u2983\", \"\\\\lBrace\"); // blackboard bold {\n\ndefineMacro(\"\\u2984\", \"\\\\rBrace\"); // blackboard bold }\n// TODO: Create variable sized versions of the last two items. I believe that\n// will require new font glyphs.\n// The stmaryrd function `\\minuso` provides a \"Plimsoll\" symbol that\n// superimposes the characters \\circ and \\mathminus. Used in chemistry.\n\ndefineMacro(\"\\\\minuso\", \"\\\\mathbin{\\\\html@mathml{\" + \"{\\\\mathrlap{\\\\mathchoice{\\\\kern{0.145em}}{\\\\kern{0.145em}}\" + \"{\\\\kern{0.1015em}}{\\\\kern{0.0725em}}\\\\circ}{-}}}\" + \"{\\\\char`⦵}}\");\ndefineMacro(\"⦵\", \"\\\\minuso\"); //////////////////////////////////////////////////////////////////////\n// texvc.sty\n// The texvc package contains macros available in mediawiki pages.\n// We omit the functions deprecated at\n// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax\n// We also omit texvc's \\O, which conflicts with \\text{\\O}\n\ndefineMacro(\"\\\\darr\", \"\\\\downarrow\");\ndefineMacro(\"\\\\dArr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\Darr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\lang\", \"\\\\langle\");\ndefineMacro(\"\\\\rang\", \"\\\\rangle\");\ndefineMacro(\"\\\\uarr\", \"\\\\uparrow\");\ndefineMacro(\"\\\\uArr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\Uarr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\N\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\R\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Z\", \"\\\\mathbb{Z}\");\ndefineMacro(\"\\\\alef\", \"\\\\aleph\");\ndefineMacro(\"\\\\alefsym\", \"\\\\aleph\");\ndefineMacro(\"\\\\Alpha\", \"\\\\mathrm{A}\");\ndefineMacro(\"\\\\Beta\", \"\\\\mathrm{B}\");\ndefineMacro(\"\\\\bull\", \"\\\\bullet\");\ndefineMacro(\"\\\\Chi\", \"\\\\mathrm{X}\");\ndefineMacro(\"\\\\clubs\", \"\\\\clubsuit\");\ndefineMacro(\"\\\\cnums\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Complex\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Dagger\", \"\\\\ddagger\");\ndefineMacro(\"\\\\diamonds\", \"\\\\diamondsuit\");\ndefineMacro(\"\\\\empty\", \"\\\\emptyset\");\ndefineMacro(\"\\\\Epsilon\", \"\\\\mathrm{E}\");\ndefineMacro(\"\\\\Eta\", \"\\\\mathrm{H}\");\ndefineMacro(\"\\\\exist\", \"\\\\exists\");\ndefineMacro(\"\\\\harr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\hArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Harr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\hearts\", \"\\\\heartsuit\");\ndefineMacro(\"\\\\image\", \"\\\\Im\");\ndefineMacro(\"\\\\infin\", \"\\\\infty\");\ndefineMacro(\"\\\\Iota\", \"\\\\mathrm{I}\");\ndefineMacro(\"\\\\isin\", \"\\\\in\");\ndefineMacro(\"\\\\Kappa\", \"\\\\mathrm{K}\");\ndefineMacro(\"\\\\larr\", \"\\\\leftarrow\");\ndefineMacro(\"\\\\lArr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\Larr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\lrarr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\lrArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Lrarr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Mu\", \"\\\\mathrm{M}\");\ndefineMacro(\"\\\\natnums\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\Nu\", \"\\\\mathrm{N}\");\ndefineMacro(\"\\\\Omicron\", \"\\\\mathrm{O}\");\ndefineMacro(\"\\\\plusmn\", \"\\\\pm\");\ndefineMacro(\"\\\\rarr\", \"\\\\rightarrow\");\ndefineMacro(\"\\\\rArr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\Rarr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\real\", \"\\\\Re\");\ndefineMacro(\"\\\\reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Rho\", \"\\\\mathrm{P}\");\ndefineMacro(\"\\\\sdot\", \"\\\\cdot\");\ndefineMacro(\"\\\\sect\", \"\\\\S\");\ndefineMacro(\"\\\\spades\", \"\\\\spadesuit\");\ndefineMacro(\"\\\\sub\", \"\\\\subset\");\ndefineMacro(\"\\\\sube\", \"\\\\subseteq\");\ndefineMacro(\"\\\\supe\", \"\\\\supseteq\");\ndefineMacro(\"\\\\Tau\", \"\\\\mathrm{T}\");\ndefineMacro(\"\\\\thetasym\", \"\\\\vartheta\"); // TODO: defineMacro(\"\\\\varcoppa\", \"\\\\\\mbox{\\\\coppa}\");\n\ndefineMacro(\"\\\\weierp\", \"\\\\wp\");\ndefineMacro(\"\\\\Zeta\", \"\\\\mathrm{Z}\"); //////////////////////////////////////////////////////////////////////\n// statmath.sty\n// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf\n\ndefineMacro(\"\\\\argmin\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,min}\");\ndefineMacro(\"\\\\argmax\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,max}\");\ndefineMacro(\"\\\\plim\", \"\\\\DOTSB\\\\mathop{\\\\operatorname{plim}}\\\\limits\"); //////////////////////////////////////////////////////////////////////\n// braket.sty\n// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf\n\ndefineMacro(\"\\\\bra\", \"\\\\mathinner{\\\\langle{#1}|}\");\ndefineMacro(\"\\\\ket\", \"\\\\mathinner{|{#1}\\\\rangle}\");\ndefineMacro(\"\\\\braket\", \"\\\\mathinner{\\\\langle{#1}\\\\rangle}\");\ndefineMacro(\"\\\\Bra\", \"\\\\left\\\\langle#1\\\\right|\");\ndefineMacro(\"\\\\Ket\", \"\\\\left|#1\\\\right\\\\rangle\");\n\nvar braketHelper = one => context => {\n  var left = context.consumeArg().tokens;\n  var middle = context.consumeArg().tokens;\n  var middleDouble = context.consumeArg().tokens;\n  var right = context.consumeArg().tokens;\n  var oldMiddle = context.macros.get(\"|\");\n  var oldMiddleDouble = context.macros.get(\"\\\\|\");\n  context.macros.beginGroup();\n\n  var midMacro = double => context => {\n    if (one) {\n      // Only modify the first instance of | or \\|\n      context.macros.set(\"|\", oldMiddle);\n\n      if (middleDouble.length) {\n        context.macros.set(\"\\\\|\", oldMiddleDouble);\n      }\n    }\n\n    var doubled = double;\n\n    if (!double && middleDouble.length) {\n      // Mimic \\@ifnextchar\n      var nextToken = context.future();\n\n      if (nextToken.text === \"|\") {\n        context.popToken();\n        doubled = true;\n      }\n    }\n\n    return {\n      tokens: doubled ? middleDouble : middle,\n      numArgs: 0\n    };\n  };\n\n  context.macros.set(\"|\", midMacro(false));\n\n  if (middleDouble.length) {\n    context.macros.set(\"\\\\|\", midMacro(true));\n  }\n\n  var arg = context.consumeArg().tokens;\n  var expanded = context.expandTokens([...right, ...arg, ...left // reversed\n  ]);\n  context.macros.endGroup();\n  return {\n    tokens: expanded.reverse(),\n    numArgs: 0\n  };\n};\n\ndefineMacro(\"\\\\bra@ket\", braketHelper(false));\ndefineMacro(\"\\\\bra@set\", braketHelper(true));\ndefineMacro(\"\\\\Braket\", \"\\\\bra@ket{\\\\left\\\\langle}\" + \"{\\\\,\\\\middle\\\\vert\\\\,}{\\\\,\\\\middle\\\\vert\\\\,}{\\\\right\\\\rangle}\");\ndefineMacro(\"\\\\Set\", \"\\\\bra@set{\\\\left\\\\{\\\\:}\" + \"{\\\\;\\\\middle\\\\vert\\\\;}{\\\\;\\\\middle\\\\Vert\\\\;}{\\\\:\\\\right\\\\}}\");\ndefineMacro(\"\\\\set\", \"\\\\bra@set{\\\\{\\\\,}{\\\\mid}{}{\\\\,\\\\}}\"); // has no support for special || or \\|\n//////////////////////////////////////////////////////////////////////\n// actuarialangle.dtx\n\ndefineMacro(\"\\\\angln\", \"{\\\\angl n}\"); // Custom Khan Academy colors, should be moved to an optional package\n\ndefineMacro(\"\\\\blue\", \"\\\\textcolor{##6495ed}{#1}\");\ndefineMacro(\"\\\\orange\", \"\\\\textcolor{##ffa500}{#1}\");\ndefineMacro(\"\\\\pink\", \"\\\\textcolor{##ff00af}{#1}\");\ndefineMacro(\"\\\\red\", \"\\\\textcolor{##df0030}{#1}\");\ndefineMacro(\"\\\\green\", \"\\\\textcolor{##28ae7b}{#1}\");\ndefineMacro(\"\\\\gray\", \"\\\\textcolor{gray}{#1}\");\ndefineMacro(\"\\\\purple\", \"\\\\textcolor{##9d38bd}{#1}\");\ndefineMacro(\"\\\\blueA\", \"\\\\textcolor{##ccfaff}{#1}\");\ndefineMacro(\"\\\\blueB\", \"\\\\textcolor{##80f6ff}{#1}\");\ndefineMacro(\"\\\\blueC\", \"\\\\textcolor{##63d9ea}{#1}\");\ndefineMacro(\"\\\\blueD\", \"\\\\textcolor{##11accd}{#1}\");\ndefineMacro(\"\\\\blueE\", \"\\\\textcolor{##0c7f99}{#1}\");\ndefineMacro(\"\\\\tealA\", \"\\\\textcolor{##94fff5}{#1}\");\ndefineMacro(\"\\\\tealB\", \"\\\\textcolor{##26edd5}{#1}\");\ndefineMacro(\"\\\\tealC\", \"\\\\textcolor{##01d1c1}{#1}\");\ndefineMacro(\"\\\\tealD\", \"\\\\textcolor{##01a995}{#1}\");\ndefineMacro(\"\\\\tealE\", \"\\\\textcolor{##208170}{#1}\");\ndefineMacro(\"\\\\greenA\", \"\\\\textcolor{##b6ffb0}{#1}\");\ndefineMacro(\"\\\\greenB\", \"\\\\textcolor{##8af281}{#1}\");\ndefineMacro(\"\\\\greenC\", \"\\\\textcolor{##74cf70}{#1}\");\ndefineMacro(\"\\\\greenD\", \"\\\\textcolor{##1fab54}{#1}\");\ndefineMacro(\"\\\\greenE\", \"\\\\textcolor{##0d923f}{#1}\");\ndefineMacro(\"\\\\goldA\", \"\\\\textcolor{##ffd0a9}{#1}\");\ndefineMacro(\"\\\\goldB\", \"\\\\textcolor{##ffbb71}{#1}\");\ndefineMacro(\"\\\\goldC\", \"\\\\textcolor{##ff9c39}{#1}\");\ndefineMacro(\"\\\\goldD\", \"\\\\textcolor{##e07d10}{#1}\");\ndefineMacro(\"\\\\goldE\", \"\\\\textcolor{##a75a05}{#1}\");\ndefineMacro(\"\\\\redA\", \"\\\\textcolor{##fca9a9}{#1}\");\ndefineMacro(\"\\\\redB\", \"\\\\textcolor{##ff8482}{#1}\");\ndefineMacro(\"\\\\redC\", \"\\\\textcolor{##f9685d}{#1}\");\ndefineMacro(\"\\\\redD\", \"\\\\textcolor{##e84d39}{#1}\");\ndefineMacro(\"\\\\redE\", \"\\\\textcolor{##bc2612}{#1}\");\ndefineMacro(\"\\\\maroonA\", \"\\\\textcolor{##ffbde0}{#1}\");\ndefineMacro(\"\\\\maroonB\", \"\\\\textcolor{##ff92c6}{#1}\");\ndefineMacro(\"\\\\maroonC\", \"\\\\textcolor{##ed5fa6}{#1}\");\ndefineMacro(\"\\\\maroonD\", \"\\\\textcolor{##ca337c}{#1}\");\ndefineMacro(\"\\\\maroonE\", \"\\\\textcolor{##9e034e}{#1}\");\ndefineMacro(\"\\\\purpleA\", \"\\\\textcolor{##ddd7ff}{#1}\");\ndefineMacro(\"\\\\purpleB\", \"\\\\textcolor{##c6b9fc}{#1}\");\ndefineMacro(\"\\\\purpleC\", \"\\\\textcolor{##aa87ff}{#1}\");\ndefineMacro(\"\\\\purpleD\", \"\\\\textcolor{##7854ab}{#1}\");\ndefineMacro(\"\\\\purpleE\", \"\\\\textcolor{##543b78}{#1}\");\ndefineMacro(\"\\\\mintA\", \"\\\\textcolor{##f5f9e8}{#1}\");\ndefineMacro(\"\\\\mintB\", \"\\\\textcolor{##edf2df}{#1}\");\ndefineMacro(\"\\\\mintC\", \"\\\\textcolor{##e0e5cc}{#1}\");\ndefineMacro(\"\\\\grayA\", \"\\\\textcolor{##f6f7f7}{#1}\");\ndefineMacro(\"\\\\grayB\", \"\\\\textcolor{##f0f1f2}{#1}\");\ndefineMacro(\"\\\\grayC\", \"\\\\textcolor{##e3e5e6}{#1}\");\ndefineMacro(\"\\\\grayD\", \"\\\\textcolor{##d6d8da}{#1}\");\ndefineMacro(\"\\\\grayE\", \"\\\\textcolor{##babec2}{#1}\");\ndefineMacro(\"\\\\grayF\", \"\\\\textcolor{##888d93}{#1}\");\ndefineMacro(\"\\\\grayG\", \"\\\\textcolor{##626569}{#1}\");\ndefineMacro(\"\\\\grayH\", \"\\\\textcolor{##3b3e40}{#1}\");\ndefineMacro(\"\\\\grayI\", \"\\\\textcolor{##21242c}{#1}\");\ndefineMacro(\"\\\\kaBlue\", \"\\\\textcolor{##314453}{#1}\");\ndefineMacro(\"\\\\kaGreen\", \"\\\\textcolor{##71B307}{#1}\");\n\n/**\n * This file contains the “gullet” where macros are expanded\n * until only non-macro tokens remain.\n */\n// List of commands that act like macros but aren't defined as a macro,\n// function, or symbol.  Used in `isDefined`.\nvar implicitCommands = {\n  \"^\": true,\n  // Parser.js\n  \"_\": true,\n  // Parser.js\n  \"\\\\limits\": true,\n  // Parser.js\n  \"\\\\nolimits\": true // Parser.js\n\n};\nclass MacroExpander {\n  constructor(input, settings, mode) {\n    this.settings = void 0;\n    this.expansionCount = void 0;\n    this.lexer = void 0;\n    this.macros = void 0;\n    this.stack = void 0;\n    this.mode = void 0;\n    this.settings = settings;\n    this.expansionCount = 0;\n    this.feed(input); // Make new global namespace\n\n    this.macros = new Namespace(macros, settings.macros);\n    this.mode = mode;\n    this.stack = []; // contains tokens in REVERSE order\n  }\n  /**\n   * Feed a new input string to the same MacroExpander\n   * (with existing macros etc.).\n   */\n\n\n  feed(input) {\n    this.lexer = new Lexer(input, this.settings);\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n  }\n  /**\n   * Start a new group nesting within all namespaces.\n   */\n\n\n  beginGroup() {\n    this.macros.beginGroup();\n  }\n  /**\n   * End current group nesting within all namespaces.\n   */\n\n\n  endGroup() {\n    this.macros.endGroup();\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    this.macros.endGroups();\n  }\n  /**\n   * Returns the topmost token on the stack, without expanding it.\n   * Similar in behavior to TeX's `\\futurelet`.\n   */\n\n\n  future() {\n    if (this.stack.length === 0) {\n      this.pushToken(this.lexer.lex());\n    }\n\n    return this.stack[this.stack.length - 1];\n  }\n  /**\n   * Remove and return the next unexpanded token.\n   */\n\n\n  popToken() {\n    this.future(); // ensure non-empty stack\n\n    return this.stack.pop();\n  }\n  /**\n   * Add a given token to the token stack.  In particular, this get be used\n   * to put back a token returned from one of the other methods.\n   */\n\n\n  pushToken(token) {\n    this.stack.push(token);\n  }\n  /**\n   * Append an array of tokens to the token stack.\n   */\n\n\n  pushTokens(tokens) {\n    this.stack.push(...tokens);\n  }\n  /**\n   * Find an macro argument without expanding tokens and append the array of\n   * tokens to the token stack. Uses Token as a container for the result.\n   */\n\n\n  scanArgument(isOptional) {\n    var start;\n    var end;\n    var tokens;\n\n    if (isOptional) {\n      this.consumeSpaces(); // \\@ifnextchar gobbles any space following it\n\n      if (this.future().text !== \"[\") {\n        return null;\n      }\n\n      start = this.popToken(); // don't include [ in tokens\n\n      ({\n        tokens,\n        end\n      } = this.consumeArg([\"]\"]));\n    } else {\n      ({\n        tokens,\n        start,\n        end\n      } = this.consumeArg());\n    } // indicate the end of an argument\n\n\n    this.pushToken(new Token(\"EOF\", end.loc));\n    this.pushTokens(tokens);\n    return start.range(end, \"\");\n  }\n  /**\n   * Consume all following space tokens, without expansion.\n   */\n\n\n  consumeSpaces() {\n    for (;;) {\n      var token = this.future();\n\n      if (token.text === \" \") {\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Consume an argument from the token stream, and return the resulting array\n   * of tokens and start/end token.\n   */\n\n\n  consumeArg(delims) {\n    // The argument for a delimited parameter is the shortest (possibly\n    // empty) sequence of tokens with properly nested {...} groups that is\n    // followed ... by this particular list of non-parameter tokens.\n    // The argument for an undelimited parameter is the next nonblank\n    // token, unless that token is ‘{’, when the argument will be the\n    // entire {...} group that follows.\n    var tokens = [];\n    var isDelimited = delims && delims.length > 0;\n\n    if (!isDelimited) {\n      // Ignore spaces between arguments.  As the TeXbook says:\n      // \"After you have said ‘\\def\\row#1#2{...}’, you are allowed to\n      //  put spaces between the arguments (e.g., ‘\\row x n’), because\n      //  TeX doesn’t use single spaces as undelimited arguments.\"\n      this.consumeSpaces();\n    }\n\n    var start = this.future();\n    var tok;\n    var depth = 0;\n    var match = 0;\n\n    do {\n      tok = this.popToken();\n      tokens.push(tok);\n\n      if (tok.text === \"{\") {\n        ++depth;\n      } else if (tok.text === \"}\") {\n        --depth;\n\n        if (depth === -1) {\n          throw new ParseError(\"Extra }\", tok);\n        }\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Unexpected end of input in a macro argument\" + \", expected '\" + (delims && isDelimited ? delims[match] : \"}\") + \"'\", tok);\n      }\n\n      if (delims && isDelimited) {\n        if ((depth === 0 || depth === 1 && delims[match] === \"{\") && tok.text === delims[match]) {\n          ++match;\n\n          if (match === delims.length) {\n            // don't include delims in tokens\n            tokens.splice(-match, match);\n            break;\n          }\n        } else {\n          match = 0;\n        }\n      }\n    } while (depth !== 0 || isDelimited); // If the argument found ... has the form ‘{<nested tokens>}’,\n    // ... the outermost braces enclosing the argument are removed\n\n\n    if (start.text === \"{\" && tokens[tokens.length - 1].text === \"}\") {\n      tokens.pop();\n      tokens.shift();\n    }\n\n    tokens.reverse(); // to fit in with stack order\n\n    return {\n      tokens,\n      start,\n      end: tok\n    };\n  }\n  /**\n   * Consume the specified number of (delimited) arguments from the token\n   * stream and return the resulting array of arguments.\n   */\n\n\n  consumeArgs(numArgs, delimiters) {\n    if (delimiters) {\n      if (delimiters.length !== numArgs + 1) {\n        throw new ParseError(\"The length of delimiters doesn't match the number of args!\");\n      }\n\n      var delims = delimiters[0];\n\n      for (var i = 0; i < delims.length; i++) {\n        var tok = this.popToken();\n\n        if (delims[i] !== tok.text) {\n          throw new ParseError(\"Use of the macro doesn't match its definition\", tok);\n        }\n      }\n    }\n\n    var args = [];\n\n    for (var _i = 0; _i < numArgs; _i++) {\n      args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);\n    }\n\n    return args;\n  }\n  /**\n   * Expand the next token only once if possible.\n   *\n   * If the token is expanded, the resulting tokens will be pushed onto\n   * the stack in reverse order and will be returned as an array,\n   * also in reverse order.\n   *\n   * If not, the next token will be returned without removing it\n   * from the stack.  This case can be detected by a `Token` return value\n   * instead of an `Array` return value.\n   *\n   * In either case, the next token will be on the top of the stack,\n   * or the stack will be empty.\n   *\n   * Used to implement `expandAfterFuture` and `expandNextToken`.\n   *\n   * If expandableOnly, only expandable tokens are expanded and\n   * an undefined control sequence results in an error.\n   */\n\n\n  expandOnce(expandableOnly) {\n    var topToken = this.popToken();\n    var name = topToken.text;\n    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;\n\n    if (expansion == null || expandableOnly && expansion.unexpandable) {\n      if (expandableOnly && expansion == null && name[0] === \"\\\\\" && !this.isDefined(name)) {\n        throw new ParseError(\"Undefined control sequence: \" + name);\n      }\n\n      this.pushToken(topToken);\n      return topToken;\n    }\n\n    this.expansionCount++;\n\n    if (this.expansionCount > this.settings.maxExpand) {\n      throw new ParseError(\"Too many expansions: infinite loop or \" + \"need to increase maxExpand setting\");\n    }\n\n    var tokens = expansion.tokens;\n    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);\n\n    if (expansion.numArgs) {\n      // paste arguments in place of the placeholders\n      tokens = tokens.slice(); // make a shallow copy\n\n      for (var i = tokens.length - 1; i >= 0; --i) {\n        var tok = tokens[i];\n\n        if (tok.text === \"#\") {\n          if (i === 0) {\n            throw new ParseError(\"Incomplete placeholder at end of macro body\", tok);\n          }\n\n          tok = tokens[--i]; // next token on stack\n\n          if (tok.text === \"#\") {\n            // ## → #\n            tokens.splice(i + 1, 1); // drop first #\n          } else if (/^[1-9]$/.test(tok.text)) {\n            // replace the placeholder with the indicated argument\n            tokens.splice(i, 2, ...args[+tok.text - 1]);\n          } else {\n            throw new ParseError(\"Not a valid argument number\", tok);\n          }\n        }\n      }\n    } // Concatenate expansion onto top of stack.\n\n\n    this.pushTokens(tokens);\n    return tokens;\n  }\n  /**\n   * Expand the next token only once (if possible), and return the resulting\n   * top token on the stack (without removing anything from the stack).\n   * Similar in behavior to TeX's `\\expandafter\\futurelet`.\n   * Equivalent to expandOnce() followed by future().\n   */\n\n\n  expandAfterFuture() {\n    this.expandOnce();\n    return this.future();\n  }\n  /**\n   * Recursively expand first token, then return first non-expandable token.\n   */\n\n\n  expandNextToken() {\n    for (;;) {\n      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.\n\n      if (expanded instanceof Token) {\n        // the token after \\noexpand is interpreted as if its meaning\n        // were ‘\\relax’\n        if (expanded.treatAsRelax) {\n          expanded.text = \"\\\\relax\";\n        }\n\n        return this.stack.pop(); // === expanded\n      }\n    } // Flow unable to figure out that this pathway is impossible.\n    // https://github.com/facebook/flow/issues/4808\n\n\n    throw new Error(); // eslint-disable-line no-unreachable\n  }\n  /**\n   * Fully expand the given macro name and return the resulting list of\n   * tokens, or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacro(name) {\n    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;\n  }\n  /**\n   * Fully expand the given token stream and return the resulting list of\n   * tokens.  Note that the input tokens are in reverse order, but the\n   * output tokens are in forward order.\n   */\n\n\n  expandTokens(tokens) {\n    var output = [];\n    var oldStackLength = this.stack.length;\n    this.pushTokens(tokens);\n\n    while (this.stack.length > oldStackLength) {\n      var expanded = this.expandOnce(true); // expand only expandable tokens\n      // expandOnce returns Token if and only if it's fully expanded.\n\n      if (expanded instanceof Token) {\n        if (expanded.treatAsRelax) {\n          // the expansion of \\noexpand is the token itself\n          expanded.noexpand = false;\n          expanded.treatAsRelax = false;\n        }\n\n        output.push(this.stack.pop());\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Fully expand the given macro name and return the result as a string,\n   * or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacroAsText(name) {\n    var tokens = this.expandMacro(name);\n\n    if (tokens) {\n      return tokens.map(token => token.text).join(\"\");\n    } else {\n      return tokens;\n    }\n  }\n  /**\n   * Returns the expanded macro as a reversed array of tokens and a macro\n   * argument count.  Or returns `null` if no such macro.\n   */\n\n\n  _getExpansion(name) {\n    var definition = this.macros.get(name);\n\n    if (definition == null) {\n      // mainly checking for undefined here\n      return definition;\n    } // If a single character has an associated catcode other than 13\n    // (active character), then don't expand it.\n\n\n    if (name.length === 1) {\n      var catcode = this.lexer.catcodes[name];\n\n      if (catcode != null && catcode !== 13) {\n        return;\n      }\n    }\n\n    var expansion = typeof definition === \"function\" ? definition(this) : definition;\n\n    if (typeof expansion === \"string\") {\n      var numArgs = 0;\n\n      if (expansion.indexOf(\"#\") !== -1) {\n        var stripped = expansion.replace(/##/g, \"\");\n\n        while (stripped.indexOf(\"#\" + (numArgs + 1)) !== -1) {\n          ++numArgs;\n        }\n      }\n\n      var bodyLexer = new Lexer(expansion, this.settings);\n      var tokens = [];\n      var tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        tokens.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      tokens.reverse(); // to fit in with stack using push and pop\n\n      var expanded = {\n        tokens,\n        numArgs\n      };\n      return expanded;\n    }\n\n    return expansion;\n  }\n  /**\n   * Determine whether a command is currently \"defined\" (has some\n   * functionality), meaning that it's a macro (in the current group),\n   * a function, a symbol, or one of the special commands listed in\n   * `implicitCommands`.\n   */\n\n\n  isDefined(name) {\n    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);\n  }\n  /**\n   * Determine whether a command is expandable.\n   */\n\n\n  isExpandable(name) {\n    var macro = this.macros.get(name);\n    return macro != null ? typeof macro === \"string\" || typeof macro === \"function\" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;\n  }\n\n}\n\n// Helpers for Parser.js handling of Unicode (sub|super)script characters.\nvar unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;\nvar uSubsAndSups = Object.freeze({\n  '₊': '+',\n  '₋': '-',\n  '₌': '=',\n  '₍': '(',\n  '₎': ')',\n  '₀': '0',\n  '₁': '1',\n  '₂': '2',\n  '₃': '3',\n  '₄': '4',\n  '₅': '5',\n  '₆': '6',\n  '₇': '7',\n  '₈': '8',\n  '₉': '9',\n  '\\u2090': 'a',\n  '\\u2091': 'e',\n  '\\u2095': 'h',\n  '\\u1D62': 'i',\n  '\\u2C7C': 'j',\n  '\\u2096': 'k',\n  '\\u2097': 'l',\n  '\\u2098': 'm',\n  '\\u2099': 'n',\n  '\\u2092': 'o',\n  '\\u209A': 'p',\n  '\\u1D63': 'r',\n  '\\u209B': 's',\n  '\\u209C': 't',\n  '\\u1D64': 'u',\n  '\\u1D65': 'v',\n  '\\u2093': 'x',\n  '\\u1D66': 'β',\n  '\\u1D67': 'γ',\n  '\\u1D68': 'ρ',\n  '\\u1D69': '\\u03d5',\n  '\\u1D6A': 'χ',\n  '⁺': '+',\n  '⁻': '-',\n  '⁼': '=',\n  '⁽': '(',\n  '⁾': ')',\n  '⁰': '0',\n  '¹': '1',\n  '²': '2',\n  '³': '3',\n  '⁴': '4',\n  '⁵': '5',\n  '⁶': '6',\n  '⁷': '7',\n  '⁸': '8',\n  '⁹': '9',\n  '\\u1D2C': 'A',\n  '\\u1D2E': 'B',\n  '\\u1D30': 'D',\n  '\\u1D31': 'E',\n  '\\u1D33': 'G',\n  '\\u1D34': 'H',\n  '\\u1D35': 'I',\n  '\\u1D36': 'J',\n  '\\u1D37': 'K',\n  '\\u1D38': 'L',\n  '\\u1D39': 'M',\n  '\\u1D3A': 'N',\n  '\\u1D3C': 'O',\n  '\\u1D3E': 'P',\n  '\\u1D3F': 'R',\n  '\\u1D40': 'T',\n  '\\u1D41': 'U',\n  '\\u2C7D': 'V',\n  '\\u1D42': 'W',\n  '\\u1D43': 'a',\n  '\\u1D47': 'b',\n  '\\u1D9C': 'c',\n  '\\u1D48': 'd',\n  '\\u1D49': 'e',\n  '\\u1DA0': 'f',\n  '\\u1D4D': 'g',\n  '\\u02B0': 'h',\n  '\\u2071': 'i',\n  '\\u02B2': 'j',\n  '\\u1D4F': 'k',\n  '\\u02E1': 'l',\n  '\\u1D50': 'm',\n  '\\u207F': 'n',\n  '\\u1D52': 'o',\n  '\\u1D56': 'p',\n  '\\u02B3': 'r',\n  '\\u02E2': 's',\n  '\\u1D57': 't',\n  '\\u1D58': 'u',\n  '\\u1D5B': 'v',\n  '\\u02B7': 'w',\n  '\\u02E3': 'x',\n  '\\u02B8': 'y',\n  '\\u1DBB': 'z',\n  '\\u1D5D': 'β',\n  '\\u1D5E': 'γ',\n  '\\u1D5F': 'δ',\n  '\\u1D60': '\\u03d5',\n  '\\u1D61': 'χ',\n  '\\u1DBF': 'θ'\n});\n\n/* eslint no-constant-condition:0 */\n\nvar unicodeAccents = {\n  \"́\": {\n    \"text\": \"\\\\'\",\n    \"math\": \"\\\\acute\"\n  },\n  \"̀\": {\n    \"text\": \"\\\\`\",\n    \"math\": \"\\\\grave\"\n  },\n  \"̈\": {\n    \"text\": \"\\\\\\\"\",\n    \"math\": \"\\\\ddot\"\n  },\n  \"̃\": {\n    \"text\": \"\\\\~\",\n    \"math\": \"\\\\tilde\"\n  },\n  \"̄\": {\n    \"text\": \"\\\\=\",\n    \"math\": \"\\\\bar\"\n  },\n  \"̆\": {\n    \"text\": \"\\\\u\",\n    \"math\": \"\\\\breve\"\n  },\n  \"̌\": {\n    \"text\": \"\\\\v\",\n    \"math\": \"\\\\check\"\n  },\n  \"̂\": {\n    \"text\": \"\\\\^\",\n    \"math\": \"\\\\hat\"\n  },\n  \"̇\": {\n    \"text\": \"\\\\.\",\n    \"math\": \"\\\\dot\"\n  },\n  \"̊\": {\n    \"text\": \"\\\\r\",\n    \"math\": \"\\\\mathring\"\n  },\n  \"̋\": {\n    \"text\": \"\\\\H\"\n  },\n  \"̧\": {\n    \"text\": \"\\\\c\"\n  }\n};\nvar unicodeSymbols = {\n  \"á\": \"á\",\n  \"à\": \"à\",\n  \"ä\": \"ä\",\n  \"ǟ\": \"ǟ\",\n  \"ã\": \"ã\",\n  \"ā\": \"ā\",\n  \"ă\": \"ă\",\n  \"ắ\": \"ắ\",\n  \"ằ\": \"ằ\",\n  \"ẵ\": \"ẵ\",\n  \"ǎ\": \"ǎ\",\n  \"â\": \"â\",\n  \"ấ\": \"ấ\",\n  \"ầ\": \"ầ\",\n  \"ẫ\": \"ẫ\",\n  \"ȧ\": \"ȧ\",\n  \"ǡ\": \"ǡ\",\n  \"å\": \"å\",\n  \"ǻ\": \"ǻ\",\n  \"ḃ\": \"ḃ\",\n  \"ć\": \"ć\",\n  \"ḉ\": \"ḉ\",\n  \"č\": \"č\",\n  \"ĉ\": \"ĉ\",\n  \"ċ\": \"ċ\",\n  \"ç\": \"ç\",\n  \"ď\": \"ď\",\n  \"ḋ\": \"ḋ\",\n  \"ḑ\": \"ḑ\",\n  \"é\": \"é\",\n  \"è\": \"è\",\n  \"ë\": \"ë\",\n  \"ẽ\": \"ẽ\",\n  \"ē\": \"ē\",\n  \"ḗ\": \"ḗ\",\n  \"ḕ\": \"ḕ\",\n  \"ĕ\": \"ĕ\",\n  \"ḝ\": \"ḝ\",\n  \"ě\": \"ě\",\n  \"ê\": \"ê\",\n  \"ế\": \"ế\",\n  \"ề\": \"ề\",\n  \"ễ\": \"ễ\",\n  \"ė\": \"ė\",\n  \"ȩ\": \"ȩ\",\n  \"ḟ\": \"ḟ\",\n  \"ǵ\": \"ǵ\",\n  \"ḡ\": \"ḡ\",\n  \"ğ\": \"ğ\",\n  \"ǧ\": \"ǧ\",\n  \"ĝ\": \"ĝ\",\n  \"ġ\": \"ġ\",\n  \"ģ\": \"ģ\",\n  \"ḧ\": \"ḧ\",\n  \"ȟ\": \"ȟ\",\n  \"ĥ\": \"ĥ\",\n  \"ḣ\": \"ḣ\",\n  \"ḩ\": \"ḩ\",\n  \"í\": \"í\",\n  \"ì\": \"ì\",\n  \"ï\": \"ï\",\n  \"ḯ\": \"ḯ\",\n  \"ĩ\": \"ĩ\",\n  \"ī\": \"ī\",\n  \"ĭ\": \"ĭ\",\n  \"ǐ\": \"ǐ\",\n  \"î\": \"î\",\n  \"ǰ\": \"ǰ\",\n  \"ĵ\": \"ĵ\",\n  \"ḱ\": \"ḱ\",\n  \"ǩ\": \"ǩ\",\n  \"ķ\": \"ķ\",\n  \"ĺ\": \"ĺ\",\n  \"ľ\": \"ľ\",\n  \"ļ\": \"ļ\",\n  \"ḿ\": \"ḿ\",\n  \"ṁ\": \"ṁ\",\n  \"ń\": \"ń\",\n  \"ǹ\": \"ǹ\",\n  \"ñ\": \"ñ\",\n  \"ň\": \"ň\",\n  \"ṅ\": \"ṅ\",\n  \"ņ\": \"ņ\",\n  \"ó\": \"ó\",\n  \"ò\": \"ò\",\n  \"ö\": \"ö\",\n  \"ȫ\": \"ȫ\",\n  \"õ\": \"õ\",\n  \"ṍ\": \"ṍ\",\n  \"ṏ\": \"ṏ\",\n  \"ȭ\": \"ȭ\",\n  \"ō\": \"ō\",\n  \"ṓ\": \"ṓ\",\n  \"ṑ\": \"ṑ\",\n  \"ŏ\": \"ŏ\",\n  \"ǒ\": \"ǒ\",\n  \"ô\": \"ô\",\n  \"ố\": \"ố\",\n  \"ồ\": \"ồ\",\n  \"ỗ\": \"ỗ\",\n  \"ȯ\": \"ȯ\",\n  \"ȱ\": \"ȱ\",\n  \"ő\": \"ő\",\n  \"ṕ\": \"ṕ\",\n  \"ṗ\": \"ṗ\",\n  \"ŕ\": \"ŕ\",\n  \"ř\": \"ř\",\n  \"ṙ\": \"ṙ\",\n  \"ŗ\": \"ŗ\",\n  \"ś\": \"ś\",\n  \"ṥ\": \"ṥ\",\n  \"š\": \"š\",\n  \"ṧ\": \"ṧ\",\n  \"ŝ\": \"ŝ\",\n  \"ṡ\": \"ṡ\",\n  \"ş\": \"ş\",\n  \"ẗ\": \"ẗ\",\n  \"ť\": \"ť\",\n  \"ṫ\": \"ṫ\",\n  \"ţ\": \"ţ\",\n  \"ú\": \"ú\",\n  \"ù\": \"ù\",\n  \"ü\": \"ü\",\n  \"ǘ\": \"ǘ\",\n  \"ǜ\": \"ǜ\",\n  \"ǖ\": \"ǖ\",\n  \"ǚ\": \"ǚ\",\n  \"ũ\": \"ũ\",\n  \"ṹ\": \"ṹ\",\n  \"ū\": \"ū\",\n  \"ṻ\": \"ṻ\",\n  \"ŭ\": \"ŭ\",\n  \"ǔ\": \"ǔ\",\n  \"û\": \"û\",\n  \"ů\": \"ů\",\n  \"ű\": \"ű\",\n  \"ṽ\": \"ṽ\",\n  \"ẃ\": \"ẃ\",\n  \"ẁ\": \"ẁ\",\n  \"ẅ\": \"ẅ\",\n  \"ŵ\": \"ŵ\",\n  \"ẇ\": \"ẇ\",\n  \"ẘ\": \"ẘ\",\n  \"ẍ\": \"ẍ\",\n  \"ẋ\": \"ẋ\",\n  \"ý\": \"ý\",\n  \"ỳ\": \"ỳ\",\n  \"ÿ\": \"ÿ\",\n  \"ỹ\": \"ỹ\",\n  \"ȳ\": \"ȳ\",\n  \"ŷ\": \"ŷ\",\n  \"ẏ\": \"ẏ\",\n  \"ẙ\": \"ẙ\",\n  \"ź\": \"ź\",\n  \"ž\": \"ž\",\n  \"ẑ\": \"ẑ\",\n  \"ż\": \"ż\",\n  \"Á\": \"Á\",\n  \"À\": \"À\",\n  \"Ä\": \"Ä\",\n  \"Ǟ\": \"Ǟ\",\n  \"Ã\": \"Ã\",\n  \"Ā\": \"Ā\",\n  \"Ă\": \"Ă\",\n  \"Ắ\": \"Ắ\",\n  \"Ằ\": \"Ằ\",\n  \"Ẵ\": \"Ẵ\",\n  \"Ǎ\": \"Ǎ\",\n  \"Â\": \"Â\",\n  \"Ấ\": \"Ấ\",\n  \"Ầ\": \"Ầ\",\n  \"Ẫ\": \"Ẫ\",\n  \"Ȧ\": \"Ȧ\",\n  \"Ǡ\": \"Ǡ\",\n  \"Å\": \"Å\",\n  \"Ǻ\": \"Ǻ\",\n  \"Ḃ\": \"Ḃ\",\n  \"Ć\": \"Ć\",\n  \"Ḉ\": \"Ḉ\",\n  \"Č\": \"Č\",\n  \"Ĉ\": \"Ĉ\",\n  \"Ċ\": \"Ċ\",\n  \"Ç\": \"Ç\",\n  \"Ď\": \"Ď\",\n  \"Ḋ\": \"Ḋ\",\n  \"Ḑ\": \"Ḑ\",\n  \"É\": \"É\",\n  \"È\": \"È\",\n  \"Ë\": \"Ë\",\n  \"Ẽ\": \"Ẽ\",\n  \"Ē\": \"Ē\",\n  \"Ḗ\": \"Ḗ\",\n  \"Ḕ\": \"Ḕ\",\n  \"Ĕ\": \"Ĕ\",\n  \"Ḝ\": \"Ḝ\",\n  \"Ě\": \"Ě\",\n  \"Ê\": \"Ê\",\n  \"Ế\": \"Ế\",\n  \"Ề\": \"Ề\",\n  \"Ễ\": \"Ễ\",\n  \"Ė\": \"Ė\",\n  \"Ȩ\": \"Ȩ\",\n  \"Ḟ\": \"Ḟ\",\n  \"Ǵ\": \"Ǵ\",\n  \"Ḡ\": \"Ḡ\",\n  \"Ğ\": \"Ğ\",\n  \"Ǧ\": \"Ǧ\",\n  \"Ĝ\": \"Ĝ\",\n  \"Ġ\": \"Ġ\",\n  \"Ģ\": \"Ģ\",\n  \"Ḧ\": \"Ḧ\",\n  \"Ȟ\": \"Ȟ\",\n  \"Ĥ\": \"Ĥ\",\n  \"Ḣ\": \"Ḣ\",\n  \"Ḩ\": \"Ḩ\",\n  \"Í\": \"Í\",\n  \"Ì\": \"Ì\",\n  \"Ï\": \"Ï\",\n  \"Ḯ\": \"Ḯ\",\n  \"Ĩ\": \"Ĩ\",\n  \"Ī\": \"Ī\",\n  \"Ĭ\": \"Ĭ\",\n  \"Ǐ\": \"Ǐ\",\n  \"Î\": \"Î\",\n  \"İ\": \"İ\",\n  \"Ĵ\": \"Ĵ\",\n  \"Ḱ\": \"Ḱ\",\n  \"Ǩ\": \"Ǩ\",\n  \"Ķ\": \"Ķ\",\n  \"Ĺ\": \"Ĺ\",\n  \"Ľ\": \"Ľ\",\n  \"Ļ\": \"Ļ\",\n  \"Ḿ\": \"Ḿ\",\n  \"Ṁ\": \"Ṁ\",\n  \"Ń\": \"Ń\",\n  \"Ǹ\": \"Ǹ\",\n  \"Ñ\": \"Ñ\",\n  \"Ň\": \"Ň\",\n  \"Ṅ\": \"Ṅ\",\n  \"Ņ\": \"Ņ\",\n  \"Ó\": \"Ó\",\n  \"Ò\": \"Ò\",\n  \"Ö\": \"Ö\",\n  \"Ȫ\": \"Ȫ\",\n  \"Õ\": \"Õ\",\n  \"Ṍ\": \"Ṍ\",\n  \"Ṏ\": \"Ṏ\",\n  \"Ȭ\": \"Ȭ\",\n  \"Ō\": \"Ō\",\n  \"Ṓ\": \"Ṓ\",\n  \"Ṑ\": \"Ṑ\",\n  \"Ŏ\": \"Ŏ\",\n  \"Ǒ\": \"Ǒ\",\n  \"Ô\": \"Ô\",\n  \"Ố\": \"Ố\",\n  \"Ồ\": \"Ồ\",\n  \"Ỗ\": \"Ỗ\",\n  \"Ȯ\": \"Ȯ\",\n  \"Ȱ\": \"Ȱ\",\n  \"Ő\": \"Ő\",\n  \"Ṕ\": \"Ṕ\",\n  \"Ṗ\": \"Ṗ\",\n  \"Ŕ\": \"Ŕ\",\n  \"Ř\": \"Ř\",\n  \"Ṙ\": \"Ṙ\",\n  \"Ŗ\": \"Ŗ\",\n  \"Ś\": \"Ś\",\n  \"Ṥ\": \"Ṥ\",\n  \"Š\": \"Š\",\n  \"Ṧ\": \"Ṧ\",\n  \"Ŝ\": \"Ŝ\",\n  \"Ṡ\": \"Ṡ\",\n  \"Ş\": \"Ş\",\n  \"Ť\": \"Ť\",\n  \"Ṫ\": \"Ṫ\",\n  \"Ţ\": \"Ţ\",\n  \"Ú\": \"Ú\",\n  \"Ù\": \"Ù\",\n  \"Ü\": \"Ü\",\n  \"Ǘ\": \"Ǘ\",\n  \"Ǜ\": \"Ǜ\",\n  \"Ǖ\": \"Ǖ\",\n  \"Ǚ\": \"Ǚ\",\n  \"Ũ\": \"Ũ\",\n  \"Ṹ\": \"Ṹ\",\n  \"Ū\": \"Ū\",\n  \"Ṻ\": \"Ṻ\",\n  \"Ŭ\": \"Ŭ\",\n  \"Ǔ\": \"Ǔ\",\n  \"Û\": \"Û\",\n  \"Ů\": \"Ů\",\n  \"Ű\": \"Ű\",\n  \"Ṽ\": \"Ṽ\",\n  \"Ẃ\": \"Ẃ\",\n  \"Ẁ\": \"Ẁ\",\n  \"Ẅ\": \"Ẅ\",\n  \"Ŵ\": \"Ŵ\",\n  \"Ẇ\": \"Ẇ\",\n  \"Ẍ\": \"Ẍ\",\n  \"Ẋ\": \"Ẋ\",\n  \"Ý\": \"Ý\",\n  \"Ỳ\": \"Ỳ\",\n  \"Ÿ\": \"Ÿ\",\n  \"Ỹ\": \"Ỹ\",\n  \"Ȳ\": \"Ȳ\",\n  \"Ŷ\": \"Ŷ\",\n  \"Ẏ\": \"Ẏ\",\n  \"Ź\": \"Ź\",\n  \"Ž\": \"Ž\",\n  \"Ẑ\": \"Ẑ\",\n  \"Ż\": \"Ż\",\n  \"ά\": \"ά\",\n  \"ὰ\": \"ὰ\",\n  \"ᾱ\": \"ᾱ\",\n  \"ᾰ\": \"ᾰ\",\n  \"έ\": \"έ\",\n  \"ὲ\": \"ὲ\",\n  \"ή\": \"ή\",\n  \"ὴ\": \"ὴ\",\n  \"ί\": \"ί\",\n  \"ὶ\": \"ὶ\",\n  \"ϊ\": \"ϊ\",\n  \"ΐ\": \"ΐ\",\n  \"ῒ\": \"ῒ\",\n  \"ῑ\": \"ῑ\",\n  \"ῐ\": \"ῐ\",\n  \"ό\": \"ό\",\n  \"ὸ\": \"ὸ\",\n  \"ύ\": \"ύ\",\n  \"ὺ\": \"ὺ\",\n  \"ϋ\": \"ϋ\",\n  \"ΰ\": \"ΰ\",\n  \"ῢ\": \"ῢ\",\n  \"ῡ\": \"ῡ\",\n  \"ῠ\": \"ῠ\",\n  \"ώ\": \"ώ\",\n  \"ὼ\": \"ὼ\",\n  \"Ύ\": \"Ύ\",\n  \"Ὺ\": \"Ὺ\",\n  \"Ϋ\": \"Ϋ\",\n  \"Ῡ\": \"Ῡ\",\n  \"Ῠ\": \"Ῠ\",\n  \"Ώ\": \"Ώ\",\n  \"Ὼ\": \"Ὼ\"\n};\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\nclass Parser {\n  constructor(input, settings) {\n    this.mode = void 0;\n    this.gullet = void 0;\n    this.settings = void 0;\n    this.leftrightDepth = void 0;\n    this.nextToken = void 0;\n    // Start in math mode\n    this.mode = \"math\"; // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n\n    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing\n\n    this.settings = settings; // Count leftright depth (for \\middle errors)\n\n    this.leftrightDepth = 0;\n  }\n  /**\n   * Checks a result to make sure it has the right type, and throws an\n   * appropriate error otherwise.\n   */\n\n\n  expect(text, consume) {\n    if (consume === void 0) {\n      consume = true;\n    }\n\n    if (this.fetch().text !== text) {\n      throw new ParseError(\"Expected '\" + text + \"', got '\" + this.fetch().text + \"'\", this.fetch());\n    }\n\n    if (consume) {\n      this.consume();\n    }\n  }\n  /**\n   * Discards the current lookahead token, considering it consumed.\n   */\n\n\n  consume() {\n    this.nextToken = null;\n  }\n  /**\n   * Return the current lookahead token, or if there isn't one (at the\n   * beginning, or if the previous lookahead token was consume()d),\n   * fetch the next token as the new lookahead token and return it.\n   */\n\n\n  fetch() {\n    if (this.nextToken == null) {\n      this.nextToken = this.gullet.expandNextToken();\n    }\n\n    return this.nextToken;\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n    this.gullet.switchMode(newMode);\n  }\n  /**\n   * Main parsing function, which parses an entire input.\n   */\n\n\n  parse() {\n    if (!this.settings.globalGroup) {\n      // Create a group namespace for the math expression.\n      // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n      this.gullet.beginGroup();\n    } // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n    // We do this within the group for the math expression, so it doesn't\n    // pollute settings.macros.\n\n\n    if (this.settings.colorIsTextColor) {\n      this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n    }\n\n    try {\n      // Try to parse the input\n      var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n      this.expect(\"EOF\"); // End the group namespace for the expression\n\n      if (!this.settings.globalGroup) {\n        this.gullet.endGroup();\n      }\n\n      return parse; // Close any leftover groups in case of a parse error.\n    } finally {\n      this.gullet.endGroups();\n    }\n  }\n  /**\n   * Fully parse a separate sequence of tokens as a separate job.\n   * Tokens should be specified in reverse order, as in a MacroDefinition.\n   */\n\n\n  subparse(tokens) {\n    // Save the next token from the current job.\n    var oldToken = this.nextToken;\n    this.consume(); // Run the new job, terminating it with an excess '}'\n\n    this.gullet.pushToken(new Token(\"}\"));\n    this.gullet.pushTokens(tokens);\n    var parse = this.parseExpression(false);\n    this.expect(\"}\"); // Restore the next token from the current job.\n\n    this.nextToken = oldToken;\n    return parse;\n  }\n\n  /**\n   * Parses an \"expression\", which is a list of atoms.\n   *\n   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n   *                 happens when functions have higher precendence han infix\n   *                 nodes in implicit parses.\n   *\n   * `breakOnTokenText`: The text of the token that the expression should end\n   *                     with, or `null` if something else should end the\n   *                     expression.\n   */\n  parseExpression(breakOnInfix, breakOnTokenText) {\n    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n\n    while (true) {\n      // Ignore spaces in math mode\n      if (this.mode === \"math\") {\n        this.consumeSpaces();\n      }\n\n      var lex = this.fetch();\n\n      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n        break;\n      }\n\n      if (breakOnTokenText && lex.text === breakOnTokenText) {\n        break;\n      }\n\n      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n        break;\n      }\n\n      var atom = this.parseAtom(breakOnTokenText);\n\n      if (!atom) {\n        break;\n      } else if (atom.type === \"internal\") {\n        continue;\n      }\n\n      body.push(atom);\n    }\n\n    if (this.mode === \"text\") {\n      this.formLigatures(body);\n    }\n\n    return this.handleInfixNodes(body);\n  }\n  /**\n   * Rewrites infix operators such as \\over with corresponding commands such\n   * as \\frac.\n   *\n   * There can only be one infix operator per group.  If there's more than one\n   * then the expression is ambiguous.  This can be resolved by adding {}.\n   */\n\n\n  handleInfixNodes(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n      if (body[i].type === \"infix\") {\n        if (overIndex !== -1) {\n          throw new ParseError(\"only one infix operator per group\", body[i].token);\n        }\n\n        overIndex = i;\n        funcName = body[i].replaceWith;\n      }\n    }\n\n    if (overIndex !== -1 && funcName) {\n      var numerNode;\n      var denomNode;\n      var numerBody = body.slice(0, overIndex);\n      var denomBody = body.slice(overIndex + 1);\n\n      if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n        numerNode = numerBody[0];\n      } else {\n        numerNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: numerBody\n        };\n      }\n\n      if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n        denomNode = denomBody[0];\n      } else {\n        denomNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: denomBody\n        };\n      }\n\n      var node;\n\n      if (funcName === \"\\\\\\\\abovefrac\") {\n        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);\n      } else {\n        node = this.callFunction(funcName, [numerNode, denomNode], []);\n      }\n\n      return [node];\n    } else {\n      return body;\n    }\n  }\n  /**\n   * Handle a subscript or superscript with nice errors.\n   */\n\n\n  handleSupSubscript(name // For error reporting.\n  ) {\n    var symbolToken = this.fetch();\n    var symbol = symbolToken.text;\n    this.consume();\n    this.consumeSpaces(); // ignore spaces before sup/subscript argument\n\n    var group = this.parseGroup(name);\n\n    if (!group) {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n\n    return group;\n  }\n  /**\n   * Converts the textual input of an unsupported command into a text node\n   * contained within a color node whose color is determined by errorColor\n   */\n\n\n  formatUnsupportedCmd(text) {\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n      textordArray.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: text[i]\n      });\n    }\n\n    var textNode = {\n      type: \"text\",\n      mode: this.mode,\n      body: textordArray\n    };\n    var colorNode = {\n      type: \"color\",\n      mode: this.mode,\n      color: this.settings.errorColor,\n      body: [textNode]\n    };\n    return colorNode;\n  }\n  /**\n   * Parses a group with optional super/subscripts.\n   */\n\n\n  parseAtom(breakOnTokenText) {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseGroup(\"atom\", breakOnTokenText); // In text mode, we don't have superscripts or subscripts\n\n    if (this.mode === \"text\") {\n      return base;\n    } // Note that base may be empty (i.e. null) at this point.\n\n\n    var superscript;\n    var subscript;\n\n    while (true) {\n      // Guaranteed in math mode, so eat any spaces first.\n      this.consumeSpaces(); // Lex the first token\n\n      var lex = this.fetch();\n\n      if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n        // We got a limit control\n        if (base && base.type === \"op\") {\n          var limits = lex.text === \"\\\\limits\";\n          base.limits = limits;\n          base.alwaysHandleSupSub = true;\n        } else if (base && base.type === \"operatorname\") {\n          if (base.alwaysHandleSupSub) {\n            base.limits = lex.text === \"\\\\limits\";\n          }\n        } else {\n          throw new ParseError(\"Limit controls must follow a math operator\", lex);\n        }\n\n        this.consume();\n      } else if (lex.text === \"^\") {\n        // We got a superscript start\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        superscript = this.handleSupSubscript(\"superscript\");\n      } else if (lex.text === \"_\") {\n        // We got a subscript start\n        if (subscript) {\n          throw new ParseError(\"Double subscript\", lex);\n        }\n\n        subscript = this.handleSupSubscript(\"subscript\");\n      } else if (lex.text === \"'\") {\n        // We got a prime\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        var prime = {\n          type: \"textord\",\n          mode: this.mode,\n          text: \"\\\\prime\"\n        }; // Many primes can be grouped together, so we handle this here\n\n        var primes = [prime];\n        this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n        while (this.fetch().text === \"'\") {\n          // For each one, add another prime to the list\n          primes.push(prime);\n          this.consume();\n        } // If there's a superscript following the primes, combine that\n        // superscript in with the primes.\n\n\n        if (this.fetch().text === \"^\") {\n          primes.push(this.handleSupSubscript(\"superscript\"));\n        } // Put everything into an ordgroup as the superscript\n\n\n        superscript = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: primes\n        };\n      } else if (uSubsAndSups[lex.text]) {\n        // A Unicode subscript or superscript character.\n        // We treat these similarly to the unicode-math package.\n        // So we render a string of Unicode (sub|super)scripts the\n        // same as a (sub|super)script of regular characters.\n        var str = uSubsAndSups[lex.text];\n        var isSub = unicodeSubRegEx.test(lex.text);\n        this.consume(); // Continue fetching tokens to fill out the string.\n\n        while (true) {\n          var token = this.fetch().text;\n\n          if (!uSubsAndSups[token]) {\n            break;\n          }\n\n          if (unicodeSubRegEx.test(token) !== isSub) {\n            break;\n          }\n\n          this.consume();\n          str += uSubsAndSups[token];\n        } // Now create a (sub|super)script.\n\n\n        var body = new Parser(str, this.settings).parse();\n\n        if (isSub) {\n          subscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        } else {\n          superscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        }\n      } else {\n        // If it wasn't ^, _, or ', stop parsing super/subscripts\n        break;\n      }\n    } // Base must be set if superscript or subscript are set per logic above,\n    // but need to check here for type check to pass.\n\n\n    if (superscript || subscript) {\n      // If we got either a superscript or subscript, create a supsub\n      return {\n        type: \"supsub\",\n        mode: this.mode,\n        base: base,\n        sup: superscript,\n        sub: subscript\n      };\n    } else {\n      // Otherwise return the original body\n      return base;\n    }\n  }\n  /**\n   * Parses an entire function, including its base and all of its arguments.\n   */\n\n\n  parseFunction(breakOnTokenText, name // For determining its context\n  ) {\n    var token = this.fetch();\n    var func = token.text;\n    var funcData = functions[func];\n\n    if (!funcData) {\n      return null;\n    }\n\n    this.consume(); // consume command token\n\n    if (name && name !== \"atom\" && !funcData.allowedInArgument) {\n      throw new ParseError(\"Got function '\" + func + \"' with no arguments\" + (name ? \" as \" + name : \"\"), token);\n    } else if (this.mode === \"text\" && !funcData.allowedInText) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", token);\n    } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in math mode\", token);\n    }\n\n    var {\n      args,\n      optArgs\n    } = this.parseArguments(func, funcData);\n    return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n  }\n  /**\n   * Call a function handler with a suitable context and arguments.\n   */\n\n\n  callFunction(name, args, optArgs, token, breakOnTokenText) {\n    var context = {\n      funcName: name,\n      parser: this,\n      token,\n      breakOnTokenText\n    };\n    var func = functions[name];\n\n    if (func && func.handler) {\n      return func.handler(context, args, optArgs);\n    } else {\n      throw new ParseError(\"No function handler for \" + name);\n    }\n  }\n  /**\n   * Parses the arguments of a function or environment\n   */\n\n\n  parseArguments(func, // Should look like \"\\name\" or \"\\begin{name}\".\n  funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n    if (totalArgs === 0) {\n      return {\n        args: [],\n        optArgs: []\n      };\n    }\n\n    var args = [];\n    var optArgs = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n      var argType = funcData.argTypes && funcData.argTypes[i];\n      var isOptional = i < funcData.numOptionalArgs;\n\n      if (funcData.primitive && argType == null || // \\sqrt expands into primitive if optional argument doesn't exist\n      funcData.type === \"sqrt\" && i === 1 && optArgs[0] == null) {\n        argType = \"primitive\";\n      }\n\n      var arg = this.parseGroupOfType(\"argument to '\" + func + \"'\", argType, isOptional);\n\n      if (isOptional) {\n        optArgs.push(arg);\n      } else if (arg != null) {\n        args.push(arg);\n      } else {\n        // should be unreachable\n        throw new ParseError(\"Null argument, please report this as a bug\");\n      }\n    }\n\n    return {\n      args,\n      optArgs\n    };\n  }\n  /**\n   * Parses a group when the mode is changing.\n   */\n\n\n  parseGroupOfType(name, type, optional) {\n    switch (type) {\n      case \"color\":\n        return this.parseColorGroup(optional);\n\n      case \"size\":\n        return this.parseSizeGroup(optional);\n\n      case \"url\":\n        return this.parseUrlGroup(optional);\n\n      case \"math\":\n      case \"text\":\n        return this.parseArgumentGroup(optional, type);\n\n      case \"hbox\":\n        {\n          // hbox argument type wraps the argument in the equivalent of\n          // \\hbox, which is like \\text but switching to \\textstyle size.\n          var group = this.parseArgumentGroup(optional, \"text\");\n          return group != null ? {\n            type: \"styling\",\n            mode: group.mode,\n            body: [group],\n            style: \"text\" // simulate \\textstyle\n\n          } : null;\n        }\n\n      case \"raw\":\n        {\n          var token = this.parseStringGroup(\"raw\", optional);\n          return token != null ? {\n            type: \"raw\",\n            mode: \"text\",\n            string: token.text\n          } : null;\n        }\n\n      case \"primitive\":\n        {\n          if (optional) {\n            throw new ParseError(\"A primitive argument cannot be optional\");\n          }\n\n          var _group = this.parseGroup(name);\n\n          if (_group == null) {\n            throw new ParseError(\"Expected group as \" + name, this.fetch());\n          }\n\n          return _group;\n        }\n\n      case \"original\":\n      case null:\n      case undefined:\n        return this.parseArgumentGroup(optional);\n\n      default:\n        throw new ParseError(\"Unknown group type as \" + name, this.fetch());\n    }\n  }\n  /**\n   * Discard any space tokens, fetching the next non-space token.\n   */\n\n\n  consumeSpaces() {\n    while (this.fetch().text === \" \") {\n      this.consume();\n    }\n  }\n  /**\n   * Parses a group, essentially returning the string formed by the\n   * brace-enclosed tokens plus some position information.\n   */\n\n\n  parseStringGroup(modeName, // Used to describe the mode in error messages.\n  optional) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\") {\n      str += nextToken.text;\n      this.consume();\n    }\n\n    this.consume(); // consume the end of the argument\n\n    argToken.text = str;\n    return argToken;\n  }\n  /**\n   * Parses a regex-delimited group: the largest sequence of tokens\n   * whose concatenated strings match `regex`. Returns the string\n   * formed by the tokens plus some position information.\n   */\n\n\n  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.\n  ) {\n    var firstToken = this.fetch();\n    var lastToken = firstToken;\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\" && regex.test(str + nextToken.text)) {\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    if (str === \"\") {\n      throw new ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n    }\n\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a color description.\n   */\n\n\n  parseColorGroup(optional) {\n    var res = this.parseStringGroup(\"color\", optional);\n\n    if (res == null) {\n      return null;\n    }\n\n    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n\n    var color = match[0];\n\n    if (/^[0-9a-f]{6}$/i.test(color)) {\n      // We allow a 6-digit HTML color spec without a leading \"#\".\n      // This follows the xcolor package's HTML color model.\n      // Predefined color names are all missed by this RegEx pattern.\n      color = \"#\" + color;\n    }\n\n    return {\n      type: \"color-token\",\n      mode: this.mode,\n      color\n    };\n  }\n  /**\n   * Parses a size specification, consisting of magnitude and unit.\n   */\n\n\n  parseSizeGroup(optional) {\n    var res;\n    var isBlank = false; // don't expand before parseStringGroup\n\n    this.gullet.consumeSpaces();\n\n    if (!optional && this.gullet.future().text !== \"{\") {\n      res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n    } else {\n      res = this.parseStringGroup(\"size\", optional);\n    }\n\n    if (!res) {\n      return null;\n    }\n\n    if (!optional && res.text.length === 0) {\n      // Because we've tested for what is !optional, this block won't\n      // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n      // to \\genfrac and \\above.\n      res.text = \"0pt\"; // Enable \\above{}\n\n      isBlank = true; // This is here specifically for \\genfrac\n    }\n\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n\n    return {\n      type: \"size\",\n      mode: this.mode,\n      value: data,\n      isBlank\n    };\n  }\n  /**\n   * Parses an URL, checking escaped letters and allowed protocols,\n   * and setting the catcode of % as an active character (as in \\hyperref).\n   */\n\n\n  parseUrlGroup(optional) {\n    this.gullet.lexer.setCatcode(\"%\", 13); // active character\n\n    this.gullet.lexer.setCatcode(\"~\", 12); // other character\n\n    var res = this.parseStringGroup(\"url\", optional);\n    this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n\n    this.gullet.lexer.setCatcode(\"~\", 13); // active character\n\n    if (res == null) {\n      return null;\n    } // hyperref package allows backslashes alone in href, but doesn't\n    // generate valid links in such cases; we interpret this as\n    // \"undefined\" behaviour, and keep them as-is. Some browser will\n    // replace backslashes with forward slashes.\n\n\n    var url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n    return {\n      type: \"url\",\n      mode: this.mode,\n      url\n    };\n  }\n  /**\n   * Parses an argument with the mode specified.\n   */\n\n\n  parseArgumentGroup(optional, mode) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var outerMode = this.mode;\n\n    if (mode) {\n      // Switch to specified mode\n      this.switchMode(mode);\n    }\n\n    this.gullet.beginGroup();\n    var expression = this.parseExpression(false, \"EOF\"); // TODO: find an alternative way to denote the end\n\n    this.expect(\"EOF\"); // expect the end of the argument\n\n    this.gullet.endGroup();\n    var result = {\n      type: \"ordgroup\",\n      mode: this.mode,\n      loc: argToken.loc,\n      body: expression\n    };\n\n    if (mode) {\n      // Switch mode back\n      this.switchMode(outerMode);\n    }\n\n    return result;\n  }\n  /**\n   * Parses an ordinary group, which is either a single nucleus (like \"x\")\n   * or an expression in braces (like \"{x+y}\") or an implicit group, a group\n   * that starts at the current position, and ends right before a higher explicit\n   * group ends, or at EOF.\n   */\n\n\n  parseGroup(name, // For error reporting.\n  breakOnTokenText) {\n    var firstToken = this.fetch();\n    var text = firstToken.text;\n    var result; // Try to parse an open brace or \\begingroup\n\n    if (text === \"{\" || text === \"\\\\begingroup\") {\n      this.consume();\n      var groupEnd = text === \"{\" ? \"}\" : \"\\\\endgroup\";\n      this.gullet.beginGroup(); // If we get a brace, parse an expression\n\n      var expression = this.parseExpression(false, groupEnd);\n      var lastToken = this.fetch();\n      this.expect(groupEnd); // Check that we got a matching closing brace\n\n      this.gullet.endGroup();\n      result = {\n        type: \"ordgroup\",\n        mode: this.mode,\n        loc: SourceLocation.range(firstToken, lastToken),\n        body: expression,\n        // A group formed by \\begingroup...\\endgroup is a semi-simple group\n        // which doesn't affect spacing in math mode, i.e., is transparent.\n        // https://tex.stackexchange.com/questions/1930/when-should-one-\n        // use-begingroup-instead-of-bgroup\n        semisimple: text === \"\\\\begingroup\" || undefined\n      };\n    } else {\n      // If there exists a function with this name, parse the function.\n      // Otherwise, just return a nucleus\n      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();\n\n      if (result == null && text[0] === \"\\\\\" && !implicitCommands.hasOwnProperty(text)) {\n        if (this.settings.throwOnError) {\n          throw new ParseError(\"Undefined control sequence: \" + text, firstToken);\n        }\n\n        result = this.formatUnsupportedCmd(text);\n        this.consume();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Form ligature-like combinations of characters for text mode.\n   * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n   * The result will simply replace multiple textord nodes with a single\n   * character in each value by a single textord node having multiple\n   * characters in its value.  The representation is still ASCII source.\n   * The group will be modified in place.\n   */\n\n\n  formLigatures(group) {\n    var n = group.length - 1;\n\n    for (var i = 0; i < n; ++i) {\n      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n      var v = a.text;\n\n      if (v === \"-\" && group[i + 1].text === \"-\") {\n        if (i + 1 < n && group[i + 2].text === \"-\") {\n          group.splice(i, 3, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 2]),\n            text: \"---\"\n          });\n          n -= 2;\n        } else {\n          group.splice(i, 2, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 1]),\n            text: \"--\"\n          });\n          n -= 1;\n        }\n      }\n\n      if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n        group.splice(i, 2, {\n          type: \"textord\",\n          mode: \"text\",\n          loc: SourceLocation.range(a, group[i + 1]),\n          text: v + v\n        });\n        n -= 1;\n      }\n    }\n  }\n  /**\n   * Parse a single symbol out of the string. Here, we handle single character\n   * symbols and special functions like \\verb.\n   */\n\n\n  parseSymbol() {\n    var nucleus = this.fetch();\n    var text = nucleus.text;\n\n    if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n      this.consume();\n      var arg = text.slice(5);\n      var star = arg.charAt(0) === \"*\";\n\n      if (star) {\n        arg = arg.slice(1);\n      } // Lexer's tokenRegex is constructed to always have matching\n      // first/last characters.\n\n\n      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n        throw new ParseError(\"\\\\verb assertion failed --\\n                    please report what input caused this bug\");\n      }\n\n      arg = arg.slice(1, -1); // remove first and last char\n\n      return {\n        type: \"verb\",\n        mode: \"text\",\n        body: arg,\n        star\n      };\n    } // At this point, we should have a symbol, possibly with accents.\n    // First expand any accented base symbol according to unicodeSymbols.\n\n\n    if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {\n      // This behavior is not strict (XeTeX-compatible) in math mode.\n      if (this.settings.strict && this.mode === \"math\") {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Accented Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      text = unicodeSymbols[text[0]] + text.substr(1);\n    } // Strip off any combining characters\n\n\n    var match = combiningDiacriticalMarksEndRegex.exec(text);\n\n    if (match) {\n      text = text.substring(0, match.index);\n\n      if (text === 'i') {\n        text = '\\u0131'; // dotless i, in math and text mode\n      } else if (text === 'j') {\n        text = '\\u0237'; // dotless j, in math and text mode\n      }\n    } // Recognize base symbol\n\n\n    var symbol;\n\n    if (symbols[this.mode][text]) {\n      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Latin-1/Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      var group = symbols[this.mode][text].group;\n      var loc = SourceLocation.range(nucleus);\n      var s;\n\n      if (ATOMS.hasOwnProperty(group)) {\n        // $FlowFixMe\n        var family = group;\n        s = {\n          type: \"atom\",\n          mode: this.mode,\n          family,\n          loc,\n          text\n        };\n      } else {\n        // $FlowFixMe\n        s = {\n          type: group,\n          mode: this.mode,\n          loc,\n          text\n        };\n      } // $FlowFixMe\n\n\n      symbol = s;\n    } else if (text.charCodeAt(0) >= 0x80) {\n      // no symbol for e.g. ^\n      if (this.settings.strict) {\n        if (!supportedCodepoint(text.charCodeAt(0))) {\n          this.settings.reportNonstrict(\"unknownSymbol\", \"Unrecognized Unicode character \\\"\" + text[0] + \"\\\"\" + (\" (\" + text.charCodeAt(0) + \")\"), nucleus);\n        } else if (this.mode === \"math\") {\n          this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Unicode text character \\\"\" + text[0] + \"\\\" used in math mode\", nucleus);\n        }\n      } // All nonmathematical Unicode characters are rendered as if they\n      // are in text mode (wrapped in \\text) because that's what it\n      // takes to render them in LaTeX.  Setting `mode: this.mode` is\n      // another natural choice (the user requested math mode), but\n      // this makes it more difficult for getCharacterMetrics() to\n      // distinguish Unicode characters without metrics and those for\n      // which we want to simulate the letter M.\n\n\n      symbol = {\n        type: \"textord\",\n        mode: \"text\",\n        loc: SourceLocation.range(nucleus),\n        text\n      };\n    } else {\n      return null; // EOF, ^, _, {, }, etc.\n    }\n\n    this.consume(); // Transform combining characters into accents\n\n    if (match) {\n      for (var i = 0; i < match[0].length; i++) {\n        var accent = match[0][i];\n\n        if (!unicodeAccents[accent]) {\n          throw new ParseError(\"Unknown accent ' \" + accent + \"'\", nucleus);\n        }\n\n        var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;\n\n        if (!command) {\n          throw new ParseError(\"Accent \" + accent + \" unsupported in \" + this.mode + \" mode\", nucleus);\n        }\n\n        symbol = {\n          type: \"accent\",\n          mode: this.mode,\n          loc: SourceLocation.range(nucleus),\n          label: command,\n          isStretchy: false,\n          isShifty: true,\n          // $FlowFixMe\n          base: symbol\n        };\n      }\n    } // $FlowFixMe\n\n\n    return symbol;\n  }\n\n}\nParser.endOfExpression = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\n\n/**\n * Provides a single function for parsing an expression using a Parser\n * TODO(emily): Remove this\n */\n\n/**\n * Parses an expression using a Parser, then returns the parsed result.\n */\nvar parseTree = function parseTree(toParse, settings) {\n  if (!(typeof toParse === 'string' || toParse instanceof String)) {\n    throw new TypeError('KaTeX can only parse string typed expression');\n  }\n\n  var parser = new Parser(toParse, settings); // Blank out any \\df@tag to avoid spurious \"Duplicate \\tag\" errors\n\n  delete parser.gullet.macros.current[\"\\\\df@tag\"];\n  var tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().\n\n  delete parser.gullet.macros.current[\"\\\\current@color\"];\n  delete parser.gullet.macros.current[\"\\\\color\"]; // If the input used \\tag, it will set the \\df@tag macro to the tag.\n  // In this case, we separately parse the tag and wrap the tree.\n\n  if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n    if (!settings.displayMode) {\n      throw new ParseError(\"\\\\tag works only in display equations\");\n    }\n\n    tree = [{\n      type: \"tag\",\n      mode: \"text\",\n      body: tree,\n      tag: parser.subparse([new Token(\"\\\\df@tag\")])\n    }];\n  }\n\n  return tree;\n};\n\n/* eslint no-console:0 */\n\n/**\n * Parse and build an expression, and place that expression in the DOM node\n * given.\n */\nvar render = function render(expression, baseNode, options) {\n  baseNode.textContent = \"\";\n  var node = renderToDomTree(expression, options).toNode();\n  baseNode.appendChild(node);\n}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and\n// disable rendering.\n\n\nif (typeof document !== \"undefined\") {\n  if (document.compatMode !== \"CSS1Compat\") {\n    typeof console !== \"undefined\" && console.warn(\"Warning: KaTeX doesn't work in quirks mode. Make sure your \" + \"website has a suitable doctype.\");\n\n    render = function render() {\n      throw new ParseError(\"KaTeX doesn't work in quirks mode.\");\n    };\n  }\n}\n/**\n * Parse and build an expression, and return the markup for that.\n */\n\n\nvar renderToString = function renderToString(expression, options) {\n  var markup = renderToDomTree(expression, options).toMarkup();\n  return markup;\n};\n/**\n * Parse an expression and return the parse tree.\n */\n\n\nvar generateParseTree = function generateParseTree(expression, options) {\n  var settings = new Settings(options);\n  return parseTree(expression, settings);\n};\n/**\n * If the given error is a KaTeX ParseError and options.throwOnError is false,\n * renders the invalid LaTeX as a span with hover title giving the KaTeX\n * error message.  Otherwise, simply throws the error.\n */\n\n\nvar renderError = function renderError(error, expression, options) {\n  if (options.throwOnError || !(error instanceof ParseError)) {\n    throw error;\n  }\n\n  var node = buildCommon.makeSpan([\"katex-error\"], [new SymbolNode(expression)]);\n  node.setAttribute(\"title\", error.toString());\n  node.setAttribute(\"style\", \"color:\" + options.errorColor);\n  return node;\n};\n/**\n * Generates and returns the katex build tree. This is used for advanced\n * use cases (like rendering to custom output).\n */\n\n\nvar renderToDomTree = function renderToDomTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n/**\n * Generates and returns the katex build tree, with just HTML (no MathML).\n * This is used for advanced use cases (like rendering to custom output).\n */\n\n\nvar renderToHTMLTree = function renderToHTMLTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildHTMLTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n\nvar katex = {\n  /**\n   * Current KaTeX version\n   */\n  version: \"0.15.6\",\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination, and adds\n   * it as a child to the specified DOM node.\n   */\n  render,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination string,\n   * for sending to the client.\n   */\n  renderToString,\n\n  /**\n   * KaTeX error, usually during parsing.\n   */\n  ParseError,\n\n  /**\n   * The shema of Settings\n   */\n  SETTINGS_SCHEMA,\n\n  /**\n   * Parses the given LaTeX into KaTeX's internal parse tree structure,\n   * without rendering to HTML or MathML.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __parse: generateParseTree,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML internal DOM tree\n   * representation, without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToDomTree: renderToDomTree,\n\n  /**\n   * Renders the given LaTeX into an HTML internal DOM tree representation,\n   * without MathML and without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToHTMLTree: renderToHTMLTree,\n\n  /**\n   * extends internal font metrics object with a new object\n   * each key in the new object represents a font name\n  */\n  __setFontMetrics: setFontMetrics,\n\n  /**\n   * adds a new symbol to builtin symbols table\n   */\n  __defineSymbol: defineSymbol,\n\n  /**\n   * adds a new macro to builtin macro list\n   */\n  __defineMacro: defineMacro,\n\n  /**\n   * Expose the dom tree node types, which can be useful for type checking nodes.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __domTree: {\n    Span,\n    Anchor,\n    SymbolNode,\n    SvgNode,\n    PathNode,\n    LineNode\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7O0FBR1IsNEVBQTRFOztBQUU1RTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBLDhCQUE4Qjs7QUFFOUIsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0dBQXdHLE1BQU07QUFDOUc7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU8sTUFBTTtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixpTkFBaU47O0FBRWpOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHFCQUFxQjs7QUFFckIsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxZQUFZLFFBQVEsT0FBTyxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOENBQThDOztBQUU5Qyw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakIsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7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QUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0QsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEZBQTBGOzs7QUFHMUY7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBOztB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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVO0FBQ1YsVUFBVTtBQUNWLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVk7QUFDWjtBQUNB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O0FBRW5FO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0EsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRCx1QkFBdUI7O0FBRXZCLHFCQUFxQjtBQUNyQjs7QUFFQSwwREFBMEQ7O0FBRTFEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSiwrREFBK0Q7O0FBRS9ELGdFQUFnRTtBQUNoRSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMsMEVBQTBFOztBQUUxRSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQyxpSEFBaUg7O0FBRWpIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRUFBa0U7QUFDbEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixxQkFBcUIsZ0VBQWdFLFVBQVU7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3TUFBd007O0FBRXhNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJILElBQUk7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsaUNBQWlDLHdCQUF3QixHQUFHLFlBQVk7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7O0FBRUEsaUZBQWlGOztBQUVqRix5RkFBeUY7O0FBRXpGO0FBQ0Esc0NBQXNDO0FBQ3RDLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7O0FBRXBCLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHlCQUF5QixlQUFlLEVBQUUsZUFBZTtBQUN6RDtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DOztBQUVBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Ysd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLDRCQUE0Qjs7QUFFNUIsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsSUFBSSxLQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0Esc0JBQXNCLEtBQUssS0FBSzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxVQUFVO0FBQ1YscUNBQXFDOzs7QUFHckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQyxRQUFROzs7QUFHakQ7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQyxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKLGlGQUFpRjs7QUFFakYsb0RBQW9EO0FBQ3BEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxZQUFZOztBQUVqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssWUFBWTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFlBQVksTUFBTSxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUc7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0RBQXdELEVBQUU7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG9DQUFvQztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtB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VCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRCw2RkFBNkY7QUFDN0YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhEQUE4RCxLQUFLO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1qcz85MDc1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGV4aW5nIG9yIHBhcnNpbmcgcG9zaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogVGhpcyBvYmplY3QgaXMgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIC8vIFRoZSArIHByZWZpeCBpbmRpY2F0ZXMgdGhhdCB0aGVzZSBmaWVsZHMgYXJlbid0IHdyaXRlYWJsZVxuICAvLyBMZXhlciBob2xkaW5nIHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIFN0YXJ0IG9mZnNldCwgemVyby1iYXNlZCBpbmNsdXNpdmUuXG4gIC8vIEVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlLlxuICBjb25zdHJ1Y3RvcihsZXhlciwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgdHdvIGBTb3VyY2VMb2NhdGlvbmBzIGZyb20gbG9jYXRpb24gcHJvdmlkZXJzLCBnaXZlbiB0aGV5IGFyZVxuICAgKiBwcm92aWRlZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgKiAtIFJldHVybnMgdGhlIGZpcnN0IG9uZSdzIGxvY2F0aW9uIGlmIG9ubHkgdGhlIGZpcnN0IGlzIHByb3ZpZGVkLlxuICAgKiAtIFJldHVybnMgYSBtZXJnZWQgcmFuZ2Ugb2YgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBpZiBib3RoIGFyZSBwcm92aWRlZFxuICAgKiAgIGFuZCB0aGVpciBsZXhlcnMgbWF0Y2guXG4gICAqIC0gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gICAqL1xuXG5cbiAgc3RhdGljIHJhbmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYztcbiAgICB9IGVsc2UgaWYgKCFmaXJzdCB8fCAhZmlyc3QubG9jIHx8ICFzZWNvbmQubG9jIHx8IGZpcnN0LmxvYy5sZXhlciAhPT0gc2Vjb25kLmxvYy5sZXhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTtcbiAgICB9XG4gIH1cblxufVxuXG4vKipcbiAqIEludGVyZmFjZSByZXF1aXJlZCB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gVG9rZW4sIExleGVyLCBhbmRcbiAqIFBhcnNlRXJyb3IuXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzdWx0aW5nIHRva2VuIHJldHVybmVkIGZyb20gYGxleGAuXG4gKlxuICogSXQgY29uc2lzdHMgb2YgdGhlIHRva2VuIHRleHQgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIGVzc2VudGlhbGx5IGEgcmFuZ2UgaW4gYW4gaW5wdXQgc3RyaW5nLFxuICogYnV0IGluc3RlYWQgb2YgcmVmZXJlbmNpbmcgdGhlIGJhcmUgaW5wdXQgc3RyaW5nLCB3ZSByZWZlciB0byB0aGUgbGV4ZXIuXG4gKiBUaGF0IHdheSBpdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggZXh0cmEgbWV0YWRhdGEgdG8gdGhlIGlucHV0IHN0cmluZyxcbiAqIGxpa2UgZm9yIGV4YW1wbGUgYSBmaWxlIG5hbWUgb3Igc2ltaWxhci5cbiAqXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgb3B0aW9uYWwsIHNvIGl0IGlzIE9LIHRvIGNvbnN0cnVjdCBzeW50aGV0aWNcbiAqIHRva2VucyBpZiBhcHByb3ByaWF0ZS4gTm90IHByb3ZpZGluZyBhdmFpbGFibGUgcG9zaXRpb24gaW5mb3JtYXRpb24gbWF5XG4gKiBsZWFkIHRvIGRlZ3JhZGVkIGVycm9yIHJlcG9ydGluZywgdGhvdWdoLlxuICovXG5jbGFzcyBUb2tlbiB7XG4gIC8vIGRvbid0IGV4cGFuZCB0aGUgdG9rZW5cbiAgLy8gdXNlZCBpbiBcXG5vZXhwYW5kXG4gIGNvbnN0cnVjdG9yKHRleHQsIC8vIHRoZSB0ZXh0IG9mIHRoaXMgdG9rZW5cbiAgbG9jKSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9jID0gdm9pZCAwO1xuICAgIHRoaXMubm9leHBhbmQgPSB2b2lkIDA7XG4gICAgdGhpcy50cmVhdEFzUmVsYXggPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmxvYyA9IGxvYztcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gYSBwYWlyIG9mIHRva2VucyAodGhpcyBhbmQgZW5kVG9rZW4pLCBjb21wdXRlIGEgYFRva2VuYCBlbmNvbXBhc3NpbmdcbiAgICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAgICovXG5cblxuICByYW5nZShlbmRUb2tlbiwgLy8gbGFzdCB0b2tlbiBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZVxuICB0ZXh0IC8vIHRoZSB0ZXh0IG9mIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB0b2tlblxuICApIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIFNvdXJjZUxvY2F0aW9uLnJhbmdlKHRoaXMsIGVuZFRva2VuKSk7XG4gIH1cblxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIFBhcnNlRXJyb3IgY2xhc3MsIHdoaWNoIGlzIHRoZSBtYWluIGVycm9yIHRocm93biBieSBLYVRlWFxuICogZnVuY3Rpb25zIHdoZW4gc29tZXRoaW5nIGhhcyBnb25lIHdyb25nLiBUaGlzIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggaW50ZXJuYWxcbiAqIGVycm9ycyBmcm9tIGVycm9ycyBpbiB0aGUgZXhwcmVzc2lvbiB0aGF0IHRoZSB1c2VyIHByb3ZpZGVkLlxuICpcbiAqIElmIHBvc3NpYmxlLCBhIGNhbGxlciBzaG91bGQgcHJvdmlkZSBhIFRva2VuIG9yIFBhcnNlTm9kZSB3aXRoIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGVyZSBpbiB0aGUgc291cmNlIHN0cmluZyB0aGUgcHJvYmxlbSBvY2N1cnJlZC5cbiAqL1xuY2xhc3MgUGFyc2VFcnJvciB7XG4gIC8vIEVycm9yIHBvc2l0aW9uIGJhc2VkIG9uIHBhc3NlZC1pbiBUb2tlbiBvciBQYXJzZU5vZGUuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIC8vIFRoZSBlcnJvciBtZXNzYWdlXG4gIHRva2VuIC8vIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZvaWQgMDtcbiAgICB2YXIgZXJyb3IgPSBcIkthVGVYIHBhcnNlIGVycm9yOiBcIiArIG1lc3NhZ2U7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBsb2MgPSB0b2tlbiAmJiB0b2tlbi5sb2M7XG5cbiAgICBpZiAobG9jICYmIGxvYy5zdGFydCA8PSBsb2MuZW5kKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBpbnB1dCBhbmQgYSBwb3NpdGlvbiwgbWFrZSB0aGUgZXJyb3IgYSBiaXQgZmFuY2llclxuICAgICAgLy8gR2V0IHRoZSBpbnB1dFxuICAgICAgdmFyIGlucHV0ID0gbG9jLmxleGVyLmlucHV0OyAvLyBQcmVwZW5kIHNvbWUgaW5mb3JtYXRpb25cblxuICAgICAgc3RhcnQgPSBsb2Muc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gbG9jLmVuZDtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgZW5kIG9mIGlucHV0OiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IHBvc2l0aW9uIFwiICsgKHN0YXJ0ICsgMSkgKyBcIjogXCI7XG4gICAgICB9IC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcblxuXG4gICAgICB2YXIgdW5kZXJsaW5lZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLnJlcGxhY2UoL1teXS9nLCBcIiQmXFx1MDMzMlwiKTsgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcblxuICAgICAgdmFyIGxlZnQ7XG5cbiAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgIGxlZnQgPSBcIuKAplwiICsgaW5wdXQuc2xpY2Uoc3RhcnQgLSAxNSwgc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IGlucHV0LnNsaWNlKDAsIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0O1xuXG4gICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQsIGVuZCArIDE1KSArIFwi4oCmXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfSAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0NjA3NTNcblxuXG4gICAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBzZWxmLl9fcHJvdG9fXyA9IFBhcnNlRXJyb3IucHJvdG90eXBlOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxufSAvLyAkRmxvd0ZpeE1lIE1vcmUgaGFja2VyeVxuXG5cblBhcnNlRXJyb3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIHV0aWxpdHkgZnVuY3Rpb25zIHdoaWNoIGFyZSB1c2VmdWwgaW4gb3RoZXJcbiAqIGZpbGVzLlxuICovXG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBjb250YWluZWQgaW4gYSBsaXN0XG4gKi9cbnZhciBjb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGxpc3QsIGVsZW0pIHtcbiAgcmV0dXJuIGxpc3QuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG59O1xuLyoqXG4gKiBQcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBpZiBhIHNldHRpbmcgaXMgdW5kZWZpbmVkXG4gKiBOT1RFOiBDb3VsZG4ndCB1c2UgYFRgIGFzIHRoZSBvdXRwdXQgdHlwZSBkdWUgdG8gZmFjZWJvb2svZmxvdyM1MDIyLlxuICovXG5cblxudmFyIGRlZmx0ID0gZnVuY3Rpb24gZGVmbHQoc2V0dGluZywgZGVmYXVsdElmVW5kZWZpbmVkKSB7XG4gIHJldHVybiBzZXR0aW5nID09PSB1bmRlZmluZWQgPyBkZWZhdWx0SWZVbmRlZmluZWQgOiBzZXR0aW5nO1xufTsgLy8gaHlwaGVuYXRlIGFuZCBlc2NhcGUgYWRhcHRlZCBmcm9tIEZhY2Vib29rJ3MgUmVhY3QgdW5kZXIgQXBhY2hlIDIgbGljZW5zZVxuXG5cbnZhciB1cHBlcmNhc2UgPSAvKFtBLVpdKS9nO1xuXG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodXBwZXJjYXNlLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gIHJldHVybiBTdHJpbmcodGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIG1hdGNoID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cblxuXG52YXIgZ2V0QmFzZUVsZW0gPSBmdW5jdGlvbiBnZXRCYXNlRWxlbShncm91cCkge1xuICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJmb250XCIpIHtcbiAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG59O1xuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cblxuXG52YXIgaXNDaGFyYWN0ZXJCb3ggPSBmdW5jdGlvbiBpc0NoYXJhY3RlckJveChncm91cCkge1xuICB2YXIgYmFzZUVsZW0gPSBnZXRCYXNlRWxlbShncm91cCk7IC8vIFRoZXNlIGFyZSBhbGwgdGhleSB0eXBlcyBvZiBncm91cHMgd2hpY2ggaG9sZCBzaW5nbGUgY2hhcmFjdGVyc1xuXG4gIHJldHVybiBiYXNlRWxlbS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcInRleHRvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcImF0b21cIjtcbn07XG5cbnZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLW51bGwsIGJ1dCBnb3QgJyArIFN0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBwcm90b2NvbCBvZiBhIFVSTCwgb3IgXCJfcmVsYXRpdmVcIiBpZiB0aGUgVVJMIGRvZXMgbm90IHNwZWNpZnkgYVxuICogcHJvdG9jb2wgKGFuZCB0aHVzIGlzIHJlbGF0aXZlKS5cbiAqL1xuXG52YXIgcHJvdG9jb2xGcm9tVXJsID0gZnVuY3Rpb24gcHJvdG9jb2xGcm9tVXJsKHVybCkge1xuICB2YXIgcHJvdG9jb2wgPSAvXlxccyooW15cXFxcLyNdKj8pKD86OnwmIzAqNTh8JiN4MCozYSkvaS5leGVjKHVybCk7XG4gIHJldHVybiBwcm90b2NvbCAhPSBudWxsID8gcHJvdG9jb2xbMV0gOiBcIl9yZWxhdGl2ZVwiO1xufTtcbnZhciB1dGlscyA9IHtcbiAgY29udGFpbnMsXG4gIGRlZmx0LFxuICBlc2NhcGUsXG4gIGh5cGhlbmF0ZSxcbiAgZ2V0QmFzZUVsZW0sXG4gIGlzQ2hhcmFjdGVyQm94LFxuICBwcm90b2NvbEZyb21Vcmxcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8vIFRPRE86IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgZG9jdW1lbnRhdGlvblxuLy8gVE9ETzogY2hlY2sgYWxsIHByb3BlcnRpZXMgb24gU2V0dGluZ3MgZXhpc3Rcbi8vIFRPRE86IGNoZWNrIHRoZSB0eXBlIG9mIGEgcHJvcGVydHkgb24gU2V0dGluZ3MgbWF0Y2hlc1xudmFyIFNFVFRJTkdTX1NDSEVNQSA9IHtcbiAgZGlzcGxheU1vZGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgbWF0aCBpbiBkaXNwbGF5IG1vZGUsIHdoaWNoIHB1dHMgdGhlIG1hdGggaW4gXCIgKyBcImRpc3BsYXkgc3R5bGUgKHNvIFxcXFxpbnQgYW5kIFxcXFxzdW0gYXJlIGxhcmdlLCBmb3IgZXhhbXBsZSksIGFuZCBcIiArIFwiY2VudGVycyB0aGUgbWF0aCBvbiB0aGUgcGFnZSBvbiBpdHMgb3duIGxpbmUuXCIsXG4gICAgY2xpOiBcIi1kLCAtLWRpc3BsYXktbW9kZVwiXG4gIH0sXG4gIG91dHB1dDoge1xuICAgIHR5cGU6IHtcbiAgICAgIGVudW06IFtcImh0bWxBbmRNYXRobWxcIiwgXCJodG1sXCIsIFwibWF0aG1sXCJdXG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjogXCJEZXRlcm1pbmVzIHRoZSBtYXJrdXAgbGFuZ3VhZ2Ugb2YgdGhlIG91dHB1dC5cIixcbiAgICBjbGk6IFwiLUYsIC0tZm9ybWF0IDx0eXBlPlwiXG4gIH0sXG4gIGxlcW5vOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVuZGVyIGRpc3BsYXkgbWF0aCBpbiBsZXFubyBzdHlsZSAobGVmdC1qdXN0aWZpZWQgdGFncykuXCJcbiAgfSxcbiAgZmxlcW46IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgZGlzcGxheSBtYXRoIGZsdXNoIGxlZnQuXCJcbiAgfSxcbiAgdGhyb3dPbkVycm9yOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBjbGk6IFwiLXQsIC0tbm8tdGhyb3ctb24tZXJyb3JcIixcbiAgICBjbGlEZXNjcmlwdGlvbjogXCJSZW5kZXIgZXJyb3JzIChpbiB0aGUgY29sb3IgZ2l2ZW4gYnkgLS1lcnJvci1jb2xvcikgaW5zXCIgKyBcInRlYWQgb2YgdGhyb3dpbmcgYSBQYXJzZUVycm9yIGV4Y2VwdGlvbiB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci5cIlxuICB9LFxuICBlcnJvckNvbG9yOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkZWZhdWx0OiBcIiNjYzAwMDBcIixcbiAgICBjbGk6IFwiLWMsIC0tZXJyb3ItY29sb3IgPGNvbG9yPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkEgY29sb3Igc3RyaW5nIGdpdmVuIGluIHRoZSBmb3JtYXQgJ3JnYicgb3IgJ3JyZ2diYicgXCIgKyBcIihubyAjKS4gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB0aGUgY29sb3Igb2YgZXJyb3JzIHJlbmRlcmVkIGJ5IHRoZSBcIiArIFwiLXQgb3B0aW9uLlwiLFxuICAgIGNsaVByb2Nlc3NvcjogY29sb3IgPT4gXCIjXCIgKyBjb2xvclxuICB9LFxuICBtYWNyb3M6IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGNsaTogXCItbSwgLS1tYWNybyA8ZGVmPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkRlZmluZSBjdXN0b20gbWFjcm8gb2YgdGhlIGZvcm0gJ1xcXFxmb286ZXhwYW5zaW9uJyAodXNlIFwiICsgXCJtdWx0aXBsZSAtbSBhcmd1bWVudHMgZm9yIG11bHRpcGxlIG1hY3JvcykuXCIsXG4gICAgY2xpRGVmYXVsdDogW10sXG4gICAgY2xpUHJvY2Vzc29yOiAoZGVmLCBkZWZzKSA9PiB7XG4gICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgfSxcbiAgbWluUnVsZVRoaWNrbmVzczoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3BlY2lmaWVzIGEgbWluaW11bSB0aGlja25lc3MsIGluIGVtcywgZm9yIGZyYWN0aW9uIGxpbmVzLFwiICsgXCIgYFxcXFxzcXJ0YCB0b3AgbGluZXMsIGB7YXJyYXl9YCB2ZXJ0aWNhbCBsaW5lcywgYFxcXFxobGluZWAsIFwiICsgXCJgXFxcXGhkYXNobGluZWAsIGBcXFxcdW5kZXJsaW5lYCwgYFxcXFxvdmVybGluZWAsIGFuZCB0aGUgYm9yZGVycyBvZiBcIiArIFwiYFxcXFxmYm94YCwgYFxcXFxib3hlZGAsIGFuZCBgXFxcXGZjb2xvcmJveGAuXCIsXG4gICAgcHJvY2Vzc29yOiB0ID0+IE1hdGgubWF4KDAsIHQpLFxuICAgIGNsaTogXCItLW1pbi1ydWxlLXRoaWNrbmVzcyA8c2l6ZT5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlRmxvYXRcbiAgfSxcbiAgY29sb3JJc1RleHRDb2xvcjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1ha2VzIFxcXFxjb2xvciBiZWhhdmUgbGlrZSBMYVRlWCdzIDItYXJndW1lbnQgXFxcXHRleHRjb2xvciwgXCIgKyBcImluc3RlYWQgb2YgTGFUZVgncyBvbmUtYXJndW1lbnQgXFxcXGNvbG9yIG1vZGUgY2hhbmdlLlwiLFxuICAgIGNsaTogXCItYiwgLS1jb2xvci1pcy10ZXh0LWNvbG9yXCJcbiAgfSxcbiAgc3RyaWN0OiB7XG4gICAgdHlwZTogW3tcbiAgICAgIGVudW06IFtcIndhcm5cIiwgXCJpZ25vcmVcIiwgXCJlcnJvclwiXVxuICAgIH0sIFwiYm9vbGVhblwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR1cm4gb24gc3RyaWN0IC8gTGFUZVggZmFpdGhmdWxuZXNzIG1vZGUsIHdoaWNoIHRocm93cyBhbiBcIiArIFwiZXJyb3IgaWYgdGhlIGlucHV0IHVzZXMgZmVhdHVyZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSBMYVRlWC5cIixcbiAgICBjbGk6IFwiLVMsIC0tc3RyaWN0XCIsXG4gICAgY2xpRGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgdHJ1c3Q6IHtcbiAgICB0eXBlOiBbXCJib29sZWFuXCIsIFwiZnVuY3Rpb25cIl0sXG4gICAgZGVzY3JpcHRpb246IFwiVHJ1c3QgdGhlIGlucHV0LCBlbmFibGluZyBhbGwgSFRNTCBmZWF0dXJlcyBzdWNoIGFzIFxcXFx1cmwuXCIsXG4gICAgY2xpOiBcIi1ULCAtLXRydXN0XCJcbiAgfSxcbiAgbWF4U2l6ZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogSW5maW5pdHksXG4gICAgZGVzY3JpcHRpb246IFwiSWYgbm9uLXplcm8sIGFsbCB1c2VyLXNwZWNpZmllZCBzaXplcywgZS5nLiBpbiBcIiArIFwiXFxcXHJ1bGV7NTAwZW19ezUwMGVtfSwgd2lsbCBiZSBjYXBwZWQgdG8gbWF4U2l6ZSBlbXMuIE90aGVyd2lzZSwgXCIgKyBcImVsZW1lbnRzIGFuZCBzcGFjZXMgY2FuIGJlIGFyYml0cmFyaWx5IGxhcmdlXCIsXG4gICAgcHJvY2Vzc29yOiBzID0+IE1hdGgubWF4KDAsIHMpLFxuICAgIGNsaTogXCItcywgLS1tYXgtc2l6ZSA8bj5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlSW50XG4gIH0sXG4gIG1heEV4cGFuZDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTAwMCxcbiAgICBkZXNjcmlwdGlvbjogXCJMaW1pdCB0aGUgbnVtYmVyIG9mIG1hY3JvIGV4cGFuc2lvbnMgdG8gdGhlIHNwZWNpZmllZCBcIiArIFwibnVtYmVyLCB0byBwcmV2ZW50IGUuZy4gaW5maW5pdGUgbWFjcm8gbG9vcHMuIElmIHNldCB0byBJbmZpbml0eSwgXCIgKyBcInRoZSBtYWNybyBleHBhbmRlciB3aWxsIHRyeSB0byBmdWxseSBleHBhbmQgYXMgaW4gTGFUZVguXCIsXG4gICAgcHJvY2Vzc29yOiBuID0+IE1hdGgubWF4KDAsIG4pLFxuICAgIGNsaTogXCItZSwgLS1tYXgtZXhwYW5kIDxuPlwiLFxuICAgIGNsaVByb2Nlc3NvcjogbiA9PiBuID09PSBcIkluZmluaXR5XCIgPyBJbmZpbml0eSA6IHBhcnNlSW50KG4pXG4gIH0sXG4gIGdsb2JhbEdyb3VwOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgY2xpOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZGVmYXVsdCkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gIHZhciBkZWZhdWx0VHlwZSA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlWzBdIDogdHlwZTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRUeXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZWZhdWx0VHlwZS5lbnVtWzBdO1xuICB9XG5cbiAgc3dpdGNoIChkZWZhdWx0VHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gMDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4ge307XG4gIH1cbn1cbi8qKlxuICogVGhlIG1haW4gU2V0dGluZ3Mgb2JqZWN0XG4gKlxuICogVGhlIGN1cnJlbnQgb3B0aW9ucyBzdG9yZWQgYXJlOlxuICogIC0gZGlzcGxheU1vZGU6IFdoZXRoZXIgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHR5cGVzZXQgYXMgaW5saW5lIG1hdGhcbiAqICAgICAgICAgICAgICAgICAoZmFsc2UsIHRoZSBkZWZhdWx0KSwgbWVhbmluZyB0aGF0IHRoZSBtYXRoIHN0YXJ0cyBpblxuICogICAgICAgICAgICAgICAgIFxcdGV4dHN0eWxlIGFuZCBpcyBwbGFjZWQgaW4gYW4gaW5saW5lLWJsb2NrKTsgb3IgYXMgZGlzcGxheVxuICogICAgICAgICAgICAgICAgIG1hdGggKHRydWUpLCBtZWFuaW5nIHRoYXQgdGhlIG1hdGggc3RhcnRzIGluIFxcZGlzcGxheXN0eWxlXG4gKiAgICAgICAgICAgICAgICAgYW5kIGlzIHBsYWNlZCBpbiBhIGJsb2NrIHdpdGggdmVydGljYWwgbWFyZ2luLlxuICovXG5cblxuY2xhc3MgU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5kaXNwbGF5TW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxlcW5vID0gdm9pZCAwO1xuICAgIHRoaXMuZmxlcW4gPSB2b2lkIDA7XG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckNvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMubWFjcm9zID0gdm9pZCAwO1xuICAgIHRoaXMubWluUnVsZVRoaWNrbmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbG9ySXNUZXh0Q29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJpY3QgPSB2b2lkIDA7XG4gICAgdGhpcy50cnVzdCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhFeHBhbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5nbG9iYWxHcm91cCA9IHZvaWQgMDtcbiAgICAvLyBhbGxvdyBudWxsIG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gU0VUVElOR1NfU0NIRU1BKSB7XG4gICAgICBpZiAoU0VUVElOR1NfU0NIRU1BLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdmFyIHNjaGVtYSA9IFNFVFRJTkdTX1NDSEVNQVtwcm9wXTsgLy8gVE9ETzogdmFsaWRhdGUgb3B0aW9uc1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gIT09IHVuZGVmaW5lZCA/IHNjaGVtYS5wcm9jZXNzb3IgPyBzY2hlbWEucHJvY2Vzc29yKG9wdGlvbnNbcHJvcF0pIDogb3B0aW9uc1twcm9wXSA6IGdldERlZmF1bHRWYWx1ZShzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwb3J0IG5vbnN0cmljdCAobm9uLUxhVGVYLWNvbXBhdGlibGUpIGlucHV0LlxuICAgKiBDYW4gc2FmZWx5IG5vdCBiZSBjYWxsZWQgaWYgYHRoaXMuc3RyaWN0YCBpcyBmYWxzZSBpbiBKYXZhU2NyaXB0LlxuICAgKi9cblxuXG4gIHJlcG9ydE5vbnN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbikge1xuICAgIHZhciBzdHJpY3QgPSB0aGlzLnN0cmljdDtcblxuICAgIGlmICh0eXBlb2Ygc3RyaWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIEFsbG93IHJldHVybiB2YWx1ZSBvZiBzdHJpY3QgZnVuY3Rpb24gdG8gYmUgYm9vbGVhbiBvciBzdHJpbmdcbiAgICAgIC8vIChvciBudWxsL3VuZGVmaW5lZCwgbWVhbmluZyBubyBmdXJ0aGVyIHByb2Nlc3NpbmcpLlxuICAgICAgc3RyaWN0ID0gc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0cmljdCB8fCBzdHJpY3QgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnZXJyb3InOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0IChMYVRlWC1hZGhlcmluZykgYmVoYXZpb3IgZm9yIHVudXN1YWxcbiAgICogaW5wdXQgKGxpa2UgYFxcXFxgKS4gIFVubGlrZSBgbm9uc3RyaWN0YCwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3I7XG4gICAqIGluc3RlYWQsIFwiZXJyb3JcIiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGB0cnVlYCwgd2hpbGUgXCJpZ25vcmVcIlxuICAgKiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAuICBNYXkgc3RpbGwgcHJpbnQgYSB3YXJuaW5nOlxuICAgKiBcIndhcm5cIiBwcmludHMgYSB3YXJuaW5nIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLlxuICAgKi9cblxuXG4gIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICAvLyBCdXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGZ1bmN0aW9uLCB0cmVhdGluZyB0aGVtXG4gICAgICAvLyBsaWtlIFwiZXJyb3JcIi5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdHJpY3QgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuXG5cbiAgaXNUcnVzdGVkKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC51cmwgJiYgIWNvbnRleHQucHJvdG9jb2wpIHtcbiAgICAgIGNvbnRleHQucHJvdG9jb2wgPSB1dGlscy5wcm90b2NvbEZyb21VcmwoY29udGV4dC51cmwpO1xuICAgIH1cblxuICAgIHZhciB0cnVzdCA9IHR5cGVvZiB0aGlzLnRydXN0ID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnRydXN0KGNvbnRleHQpIDogdGhpcy50cnVzdDtcbiAgICByZXR1cm4gQm9vbGVhbih0cnVzdCk7XG4gIH1cblxufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhbmQgY2xhc3NlcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2Ygc3R5bGVzXG4gKiB1c2VkIGluIFRlWC4gSXQgcHJvdmlkZXMgYSBnZW5lcmljIGBTdHlsZWAgY2xhc3MsIHdoaWNoIGhvbGRzIGluZm9ybWF0aW9uXG4gKiBhYm91dCBhIHNwZWNpZmljIHN0eWxlLiBJdCB0aGVuIHByb3ZpZGVzIGluc3RhbmNlcyBvZiBhbGwgdGhlIGRpZmZlcmVudCBraW5kc1xuICogb2Ygc3R5bGVzIHBvc3NpYmxlLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIG1vdmUgYmV0d2VlbiB0aGVtIGFuZCBnZXRcbiAqIGluZm9ybWF0aW9uIGFib3V0IHRoZW0uXG4gKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBzdHlsZSBjbGFzcy4gQ29udGFpbnMgYSB1bmlxdWUgaWQgZm9yIHRoZSBzdHlsZSwgYSBzaXplICh3aGljaCBpc1xuICogdGhlIHNhbWUgZm9yIGNyYW1wZWQgYW5kIHVuY3JhbXBlZCB2ZXJzaW9uIG9mIGEgc3R5bGUpLCBhbmQgYSBjcmFtcGVkIGZsYWcuXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgY29uc3RydWN0b3IoaWQsIHNpemUsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNyYW1wZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jcmFtcGVkID0gY3JhbXBlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1cGVyc2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG5cblxuICBzdXAoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdXBbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3Vic2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG5cblxuICBzdWIoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICAgKiBzdHlsZS5cbiAgICovXG5cblxuICBmcmFjTnVtKCkge1xuICAgIHJldHVybiBzdHlsZXNbZnJhY051bVt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBmcmFjdGlvbiBkZW5vbWluYXRvciBnaXZlbiB0aGUgZnJhY3Rpb24gaW4gdGhlIGN1cnJlbnRcbiAgICogc3R5bGUuXG4gICAqL1xuXG5cbiAgZnJhY0RlbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZyYWNEZW5bdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyYW1wZWQgdmVyc2lvbiBvZiBhIHN0eWxlIChpbiBwYXJ0aWN1bGFyLCBjcmFtcGluZyBhIGNyYW1wZWQgc3R5bGVcbiAgICogZG9lc24ndCBjaGFuZ2UgdGhlIHN0eWxlKS5cbiAgICovXG5cblxuICBjcmFtcCgpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdGV4dCBvciBkaXNwbGF5IHZlcnNpb24gb2YgdGhpcyBzdHlsZS5cbiAgICovXG5cblxuICB0ZXh0KCkge1xuICAgIHJldHVybiBzdHlsZXNbdGV4dCQxW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBzdHlsZSBpcyB0aWdodGx5IHNwYWNlZCAoc2NyaXB0c3R5bGUvc2NyaXB0c2NyaXB0c3R5bGUpXG4gICAqL1xuXG5cbiAgaXNUaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID49IDI7XG4gIH1cblxufSAvLyBFeHBvcnQgYW4gaW50ZXJmYWNlIGZvciB0eXBlIGNoZWNraW5nLCBidXQgZG9uJ3QgZXhwb3NlIHRoZSBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoaXMgd2F5LCBubyBtb3JlIHN0eWxlcyBjYW4gYmUgZ2VuZXJhdGVkLlxuXG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3OyAvLyBJbnN0YW5jZXMgb2YgdGhlIGRpZmZlcmVudCBzdHlsZXNcblxudmFyIHN0eWxlcyA9IFtuZXcgU3R5bGUoRCwgMCwgZmFsc2UpLCBuZXcgU3R5bGUoRGMsIDAsIHRydWUpLCBuZXcgU3R5bGUoVCwgMSwgZmFsc2UpLCBuZXcgU3R5bGUoVGMsIDEsIHRydWUpLCBuZXcgU3R5bGUoUywgMiwgZmFsc2UpLCBuZXcgU3R5bGUoU2MsIDIsIHRydWUpLCBuZXcgU3R5bGUoU1MsIDMsIGZhbHNlKSwgbmV3IFN0eWxlKFNTYywgMywgdHJ1ZSldOyAvLyBMb29rdXAgdGFibGVzIGZvciBzd2l0Y2hpbmcgZnJvbSBvbmUgc3R5bGUgdG8gYW5vdGhlclxuXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcbnZhciB0ZXh0JDEgPSBbRCwgRGMsIFQsIFRjLCBULCBUYywgVCwgVGNdOyAvLyBXZSBvbmx5IGV4cG9ydCBzb21lIG9mIHRoZSBzdHlsZXMuXG5cbnZhciBTdHlsZSQxID0ge1xuICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gIFRFWFQ6IHN0eWxlc1tUXSxcbiAgU0NSSVBUOiBzdHlsZXNbU10sXG4gIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcblxuLypcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBVbmljb2RlIHNjcmlwdHMgYW5kIHNjcmlwdCBmYW1pbGllcyB0aGF0IHdlXG4gKiBzdXBwb3J0LiBUbyBhZGQgbmV3IHNjcmlwdHMgb3IgZmFtaWxpZXMsIGp1c3QgYWRkIGEgbmV3IGVudHJ5IHRvIHRoZVxuICogc2NyaXB0RGF0YSBhcnJheSBiZWxvdy4gQWRkaW5nIHNjcmlwdHMgdG8gdGhlIHNjcmlwdERhdGEgYXJyYXkgYWxsb3dzXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhhdCBzY3JpcHQgdG8gYXBwZWFyIGluIFxcdGV4dHt9IGVudmlyb25tZW50cy5cbiAqL1xuXG4vKipcbiAqIEVhY2ggc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHkgaGFzIGEgbmFtZSBhbmQgYW4gYXJyYXkgb2YgYmxvY2tzLlxuICogRWFjaCBibG9jayBpcyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB3aGljaCBzcGVjaWZ5IHRoZSBzdGFydCBhbmRcbiAqIGVuZCBwb2ludHMgKGluY2x1c2l2ZSkgb2YgYSBibG9jayBvZiBVbmljb2RlIGNvZGVwb2ludHMuXG4gKi9cblxuLyoqXG4gKiBVbmljb2RlIGJsb2NrIGRhdGEgZm9yIHRoZSBmYW1pbGllcyBvZiBzY3JpcHRzIHdlIHN1cHBvcnQgaW4gXFx0ZXh0e30uXG4gKiBTY3JpcHRzIG9ubHkgbmVlZCB0byBhcHBlYXIgaGVyZSBpZiB0aGV5IGRvIG5vdCBoYXZlIGZvbnQgbWV0cmljcy5cbiAqL1xudmFyIHNjcmlwdERhdGEgPSBbe1xuICAvLyBMYXRpbiBjaGFyYWN0ZXJzIGJleW9uZCB0aGUgTGF0aW4tMSBjaGFyYWN0ZXJzIHdlIGhhdmUgbWV0cmljcyBmb3IuXG4gIC8vIE5lZWRlZCBmb3IgQ3plY2gsIEh1bmdhcmlhbiBhbmQgVHVya2lzaCB0ZXh0LCBmb3IgZXhhbXBsZS5cbiAgbmFtZTogJ2xhdGluJyxcbiAgYmxvY2tzOiBbWzB4MDEwMCwgMHgwMjRmXSwgLy8gTGF0aW4gRXh0ZW5kZWQtQSBhbmQgTGF0aW4gRXh0ZW5kZWQtQlxuICBbMHgwMzAwLCAweDAzNmZdIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBtYXJrc1xuICBdXG59LCB7XG4gIC8vIFRoZSBDeXJpbGxpYyBzY3JpcHQgdXNlZCBieSBSdXNzaWFuIGFuZCByZWxhdGVkIGxhbmd1YWdlcy5cbiAgLy8gQSBDeXJpbGxpYyBzdWJzZXQgdXNlZCB0byBiZSBzdXBwb3J0ZWQgYXMgZXhwbGljaXRseSBkZWZpbmVkXG4gIC8vIHN5bWJvbHMgaW4gc3ltYm9scy5qc1xuICBuYW1lOiAnY3lyaWxsaWMnLFxuICBibG9ja3M6IFtbMHgwNDAwLCAweDA0ZmZdXVxufSwge1xuICAvLyBBcm1lbmlhblxuICBuYW1lOiAnYXJtZW5pYW4nLFxuICBibG9ja3M6IFtbMHgwNTMwLCAweDA1OEZdXVxufSwge1xuICAvLyBUaGUgQnJhaG1pYyBzY3JpcHRzIG9mIFNvdXRoIGFuZCBTb3V0aGVhc3QgQXNpYVxuICAvLyBEZXZhbmFnYXJpICgwOTAw4oCTMDk3RilcbiAgLy8gQmVuZ2FsaSAoMDk4MOKAkzA5RkYpXG4gIC8vIEd1cm11a2hpICgwQTAw4oCTMEE3RilcbiAgLy8gR3VqYXJhdGkgKDBBODDigJMwQUZGKVxuICAvLyBPcml5YSAoMEIwMOKAkzBCN0YpXG4gIC8vIFRhbWlsICgwQjgw4oCTMEJGRilcbiAgLy8gVGVsdWd1ICgwQzAw4oCTMEM3RilcbiAgLy8gS2FubmFkYSAoMEM4MOKAkzBDRkYpXG4gIC8vIE1hbGF5YWxhbSAoMEQwMOKAkzBEN0YpXG4gIC8vIFNpbmhhbGEgKDBEODDigJMwREZGKVxuICAvLyBUaGFpICgwRTAw4oCTMEU3RilcbiAgLy8gTGFvICgwRTgw4oCTMEVGRilcbiAgLy8gVGliZXRhbiAoMEYwMOKAkzBGRkYpXG4gIC8vIE15YW5tYXIgKDEwMDDigJMxMDlGKVxuICBuYW1lOiAnYnJhaG1pYycsXG4gIGJsb2NrczogW1sweDA5MDAsIDB4MTA5Rl1dXG59LCB7XG4gIG5hbWU6ICdnZW9yZ2lhbicsXG4gIGJsb2NrczogW1sweDEwQTAsIDB4MTBmZl1dXG59LCB7XG4gIC8vIENoaW5lc2UgYW5kIEphcGFuZXNlLlxuICAvLyBUaGUgXCJrXCIgaW4gY2prIGlzIGZvciBLb3JlYW4sIGJ1dCB3ZSd2ZSBzZXBhcmF0ZWQgS29yZWFuIG91dFxuICBuYW1lOiBcImNqa1wiLFxuICBibG9ja3M6IFtbMHgzMDAwLCAweDMwRkZdLCAvLyBDSksgc3ltYm9scyBhbmQgcHVuY3R1YXRpb24sIEhpcmFnYW5hLCBLYXRha2FuYVxuICBbMHg0RTAwLCAweDlGQUZdLCAvLyBDSksgaWRlb2dyYW1zXG4gIFsweEZGMDAsIDB4RkY2MF0gLy8gRnVsbHdpZHRoIHB1bmN0dWF0aW9uXG4gIC8vIFRPRE86IGFkZCBoYWxmd2lkdGggS2F0YWthbmEgYW5kIFJvbWFuamkgZ2x5cGhzXG4gIF1cbn0sIHtcbiAgLy8gS29yZWFuXG4gIG5hbWU6ICdoYW5ndWwnLFxuICBibG9ja3M6IFtbMHhBQzAwLCAweEQ3QUZdXVxufV07XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5XG4gKiBpdCBpcyBmcm9tLCBvciBudWxsIGlmIGl0IGlzIG5vdCBwYXJ0IG9mIGEga25vd24gYmxvY2tcbiAqL1xuXG5mdW5jdGlvbiBzY3JpcHRGcm9tQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0RGF0YVtpXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzY3JpcHQuYmxvY2tzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGJsb2NrID0gc2NyaXB0LmJsb2Nrc1tfaV07XG5cbiAgICAgIGlmIChjb2RlcG9pbnQgPj0gYmxvY2tbMF0gJiYgY29kZXBvaW50IDw9IGJsb2NrWzFdKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHQubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbGwgdGhlIHN1cHBvcnRlZCBibG9ja3MgaW4gYSBzaW5nbGUgYXJyYXkuXG4gKiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBtYWtlIHN1cHBvcnRlZENvZGVwb2ludCgpIGZhc3QuXG4gKi9cblxudmFyIGFsbEJsb2NrcyA9IFtdO1xuc2NyaXB0RGF0YS5mb3JFYWNoKHMgPT4gcy5ibG9ja3MuZm9yRWFjaChiID0+IGFsbEJsb2Nrcy5wdXNoKC4uLmIpKSk7XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdHJ1ZSBpZiBpdCBmYWxscyB3aXRoaW4gb25lIG9mIHRoZVxuICogc2NyaXB0cyBvciBzY3JpcHQgZmFtaWxpZXMgZGVmaW5lZCBhYm92ZSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIE1pY3JvIGJlbmNobWFya3Mgc2hvd3MgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuXG4gKiAvW1xcdTMwMDAtXFx1MzBGRlxcdTRFMDAtXFx1OUZBRlxcdUZGMDAtXFx1RkY2MFxcdUFDMDAtXFx1RDdBRlxcdTA5MDAtXFx1MTA5Rl0vLnRlc3QoKVxuICogaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBOb2RlLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZENvZGVwb2ludChjb2RlcG9pbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxCbG9ja3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoY29kZXBvaW50ID49IGFsbEJsb2Nrc1tpXSAmJiBjb2RlcG9pbnQgPD0gYWxsQmxvY2tzW2kgKyAxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzdXBwb3J0IHRvIGRvbVRyZWUuanMgYW5kIGRlbGltaXRlci5qcy5cbiAqIEl0J3MgYSBzdG9yZWhvdXNlIG9mIHBhdGggZ2VvbWV0cnkgZm9yIFNWRyBpbWFnZXMuXG4gKi9cbi8vIEluIGFsbCBwYXRocyBiZWxvdywgdGhlIHZpZXdCb3gtdG8tZW0gc2NhbGUgaXMgMTAwMDoxLlxudmFyIGhMaW5lUGFkID0gODA7IC8vIHBhZGRpbmcgYWJvdmUgYSBzcXJ0IHZpbmljdWx1bS4gUHJldmVudHMgaW1hZ2UgY3JvcHBpbmcuXG4vLyBUaGUgdmluaWN1bHVtIG9mIGEgXFxzcXJ0IGNhbiBiZSBtYWRlIHRoaWNrZXIgYnkgYSBLYVRlWCByZW5kZXJpbmcgb3B0aW9uLlxuLy8gVGhpbmsgb2YgdmFyaWFibGUgZXh0cmFWaW5pY3VsdW0gYXMgdHdvIGRldG91cnMgaW4gdGhlIFNWRyBwYXRoLlxuLy8gVGhlIGRldG91ciBiZWdpbnMgYXQgdGhlIGxvd2VyIGxlZnQgb2YgdGhlIGFyZWEgbGFiZWxlZCBleHRyYVZpbmljdWx1bSBiZWxvdy5cbi8vIFRoZSBkZXRvdXIgcHJvY2VlZHMgb25lIGV4dHJhVmluaWN1bHVtIGRpc3RhbmNlIHVwIGFuZCBzbGlnaHRseSB0byB0aGUgcmlnaHQsXG4vLyBkaXNwbGFjaW5nIHRoZSByYWRpdXNlZCBjb3JuZXIgYmV0d2VlbiBzdXJkIGFuZCB2aW5pY3VsdW0uIFRoZSByYWRpdXMgaXNcbi8vIHRyYXZlcnNlZCBhcyB1c3VhbCwgdGhlbiB0aGUgZGV0b3VyIHJlc3VtZXMuIEl0IGdvZXMgcmlnaHQsIHRvIHRoZSBlbmQgb2Zcbi8vIHRoZSB2ZXJ5IGxvbmcgdmluaWN1bHVtbiwgdGhlbiBkb3duIG9uZSBleHRyYVZpbmljdWx1bSBkaXN0YW5jZSxcbi8vIGFmdGVyIHdoaWNoIGl0IHJlc3VtZXMgcmVndWxhciBwYXRoIGdlb21ldHJ5IGZvciB0aGUgcmFkaWNhbC5cblxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpbmljdWx1bVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1xuICAgICAgICAgL+KWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKWkuKGkGV4dHJhVmluaWN1bHVtXG4gICAgICAgIC8g4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4paI4oaQMC4wNGVtICg0MCB1bml0KSBzdGQgdmluaWN1bHVtIHRoaWNrbmVzc1xuICAgICAgIC8gL1xuICAgICAgLyAvXG4gICAgIC8gL1xcXG4gICAgLyAvIHN1cmRcbiovXG5cbnZhciBzcXJ0TWFpbiA9IGZ1bmN0aW9uIHNxcnRNYWluKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzcXJ0TWFpbiBwYXRoIGdlb21ldHJ5IGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVggTWFpblxuICByZXR1cm4gXCJNOTUsXCIgKyAoNjIyICsgZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmMtMi43LDAsLTcuMTcsLTIuNywtMTMuNSwtOGMtNS44LC01LjMsLTkuNSwtMTAsLTkuNSwtMTRcXG5jMCwtMiwwLjMsLTMuMywxLC00YzEuMywtMi43LDIzLjgzLC0yMC43LDY3LjUsLTU0XFxuYzQ0LjIsLTMzLjMsNjUuOCwtNTAuMyw2Ni41LC01MWMxLjMsLTEuMywzLC0yLDUsLTJjNC43LDAsOC43LDMuMywxMiwxMFxcbnMxNzMsMzc4LDE3MywzNzhjMC43LDAsMzUuMywtNzEsMTA0LC0yMTNjNjguNywtMTQyLDEzNy41LC0yODUsMjA2LjUsLTQyOVxcbmM2OSwtMTQ0LDEwNC41LC0yMTcuNywxMDYuNSwtMjIxXFxubFwiICsgZXh0cmFWaW5pY3VsdW0gLyAyLjA3NSArIFwiIC1cIiArIGV4dHJhVmluaWN1bHVtICsgXCJcXG5jNS4zLC05LjMsMTIsLTE0LDIwLC0xNFxcbkg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkg4NDUuMjcyNFxcbnMtMjI1LjI3Miw0NjcsLTIyNS4yNzIsNDY3cy0yMzUsNDg2LC0yMzUsNDg2Yy0yLjcsNC43LC05LDcsLTE5LDdcXG5jLTYsMCwtMTAsLTEsLTEyLC0zcy0xOTQsLTQyMiwtMTk0LC00MjJzLTY1LDQ3LC02NSw0N3pcXG5NXCIgKyAoODM0ICsgZXh0cmFWaW5pY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiaC00MDAwMDB6XCI7XG59O1xuXG52YXIgc3FydFNpemUxID0gZnVuY3Rpb24gc3FydFNpemUxKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplMSBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemUxLVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTI2MyxcIiArICg2MDEgKyBleHRyYVZpbmljdWx1bSArIGhMaW5lUGFkKSArIFwiYzAuNywwLDE4LDM5LjcsNTIsMTE5XFxuYzM0LDc5LjMsNjguMTY3LDE1OC43LDEwMi41LDIzOGMzNC4zLDc5LjMsNTEuOCwxMTkuMyw1Mi41LDEyMFxcbmMzNDAsLTcwNC43LDUxMC43LC0xMDYwLjMsNTEyLC0xMDY3XFxubFwiICsgZXh0cmFWaW5pY3VsdW0gLyAyLjA4NCArIFwiIC1cIiArIGV4dHJhVmluaWN1bHVtICsgXCJcXG5jNC43LC03LjMsMTEsLTExLDE5LC0xMVxcbkg0MDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiSDEwMTIuM1xcbnMtMjcxLjMsNTY3LC0yNzEuMyw1NjdjLTM4LjcsODAuNywtODQsMTc1LC0xMzYsMjgzYy01MiwxMDgsLTg5LjE2NywxODUuMywtMTExLjUsMjMyXFxuYy0yMi4zLDQ2LjcsLTMzLjgsNzAuMywtMzQuNSw3MWMtNC43LDQuNywtMTIuMyw3LC0yMyw3cy0xMiwtMSwtMTIsLTFcXG5zLTEwOSwtMjUzLC0xMDksLTI1M2MtNzIuNywtMTY4LC0xMDkuMywtMjUyLC0xMTAsLTI1MmMtMTAuNyw4LC0yMiwxNi43LC0zNCwyNlxcbmMtMjIsMTcuMywtMzMuMywyNiwtMzQsMjZzLTI2LC0yNiwtMjYsLTI2czc2LC01OSw3NiwtNTlzNzYsLTYwLDc2LC02MHpcXG5NXCIgKyAoMTAwMSArIGV4dHJhVmluaWN1bHVtKSArIFwiIFwiICsgaExpbmVQYWQgKyBcImg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxudmFyIHNxcnRTaXplMiA9IGZ1bmN0aW9uIHNxcnRTaXplMihleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTIgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMi1SZWd1bGFyXG4gIHJldHVybiBcIk05ODMgXCIgKyAoMTAgKyBleHRyYVZpbmljdWx1bSArIGhMaW5lUGFkKSArIFwiXFxubFwiICsgZXh0cmFWaW5pY3VsdW0gLyAzLjEzICsgXCIgLVwiICsgZXh0cmFWaW5pY3VsdW0gKyBcIlxcbmM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJcXG5IMTAxMy4xcy04My40LDI2OCwtMjY0LjEsODQwYy0xODAuNyw1NzIsLTI3Nyw4NzYuMywtMjg5LDkxM2MtNC43LDQuNywtMTIuNyw3LC0yNCw3XFxucy0xMiwwLC0xMiwwYy0xLjMsLTMuMywtMy43LC0xMS43LC03LC0yNWMtMzUuMywtMTI1LjMsLTEwNi43LC0zNzMuMywtMjE0LC03NDRcXG5jLTEwLDEyLC0yMSwyNSwtMzMsMzlzLTMyLDM5LC0zMiwzOWMtNiwtNS4zLC0xNSwtMTQsLTI3LC0yNnMyNSwtMzAsMjUsLTMwXFxuYzI2LjcsLTMyLjcsNTIsLTYzLDc2LC05MXM1MiwtNjAsNTIsLTYwczIwOCw3MjIsMjA4LDcyMlxcbmM1NiwtMTc1LjMsMTI2LjMsLTM5Ny4zLDIxMSwtNjY2Yzg0LjcsLTI2OC43LDE1My44LC00ODguMiwyMDcuNSwtNjU4LjVcXG5jNTMuNywtMTcwLjMsODQuNSwtMjY2LjgsOTIuNSwtMjg5LjV6XFxuTVwiICsgKDEwMDEgKyBleHRyYVZpbmljdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTMgPSBmdW5jdGlvbiBzcXJ0U2l6ZTMoZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemUzIGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTMtUmVndWxhclxuICByZXR1cm4gXCJNNDI0LFwiICsgKDIzOTggKyBleHRyYVZpbmljdWx1bSArIGhMaW5lUGFkKSArIFwiXFxuYy0xLjMsLTAuNywtMzguNSwtMTcyLC0xMTEuNSwtNTE0Yy03MywtMzQyLC0xMDkuOCwtNTEzLjMsLTExMC41LC01MTRcXG5jMCwtMiwtMTAuNywxNC4zLC0zMiw0OWMtNC43LDcuMywtOS44LDE1LjcsLTE1LjUsMjVjLTUuNyw5LjMsLTkuOCwxNiwtMTIuNSwyMFxcbnMtNSw3LC01LDdjLTQsLTMuMywtOC4zLC03LjcsLTEzLC0xM3MtMTMsLTEzLC0xMywtMTNzNzYsLTEyMiw3NiwtMTIyczc3LC0xMjEsNzcsLTEyMVxcbnMyMDksOTY4LDIwOSw5NjhjMCwtMiw4NC43LC0zNjEuNywyNTQsLTEwNzljMTY5LjMsLTcxNy4zLDI1NC43LC0xMDc3LjcsMjU2LC0xMDgxXFxubFwiICsgZXh0cmFWaW5pY3VsdW0gLyA0LjIyMyArIFwiIC1cIiArIGV4dHJhVmluaWN1bHVtICsgXCJjNCwtNi43LDEwLC0xMCwxOCwtMTAgSDQwMDAwMFxcbnZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiSDEwMTQuNlxcbnMtODcuMywzNzguNywtMjcyLjYsMTE2NmMtMTg1LjMsNzg3LjMsLTI3OS4zLDExODIuMywtMjgyLDExODVcXG5jLTIsNiwtMTAsOSwtMjQsOVxcbmMtOCwwLC0xMiwtMC43LC0xMiwtMnogTVwiICsgKDEwMDEgKyBleHRyYVZpbmljdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJcXG5oNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5pY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTQgPSBmdW5jdGlvbiBzcXJ0U2l6ZTQoZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNpemU0IGlzIGZyb20gZ2x5cGggVTIyMUEgaW4gdGhlIGZvbnQgS2FUZVhfU2l6ZTQtUmVndWxhclxuICByZXR1cm4gXCJNNDczLFwiICsgKDI3MTMgKyBleHRyYVZpbmljdWx1bSArIGhMaW5lUGFkKSArIFwiXFxuYzMzOS4zLC0xNzk5LjMsNTA5LjMsLTI3MDAsNTEwLC0yNzAyIGxcIiArIGV4dHJhVmluaWN1bHVtIC8gNS4yOTggKyBcIiAtXCIgKyBleHRyYVZpbmljdWx1bSArIFwiXFxuYzMuMywtNy4zLDkuMywtMTEsMTgsLTExIEg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkgxMDE3LjdcXG5zLTkwLjUsNDc4LC0yNzYuMiwxNDY2Yy0xODUuNyw5ODgsLTI3OS41LDE0ODMsLTI4MS41LDE0ODVjLTIsNiwtMTAsOSwtMjQsOVxcbmMtOCwwLC0xMiwtMC43LC0xMiwtMmMwLC0xLjMsLTUuMywtMzIsLTE2LC05MmMtNTAuNywtMjkzLjMsLTExOS43LC02OTMuMywtMjA3LC0xMjAwXFxuYzAsLTEuMywtNS4zLDguNywtMTYsMzBjLTEwLjcsMjEuMywtMjEuMyw0Mi43LC0zMiw2NHMtMTYsMzMsLTE2LDMzcy0yNiwtMjYsLTI2LC0yNlxcbnM3NiwtMTUzLDc2LC0xNTNzNzcsLTE1MSw3NywtMTUxYzAuNywwLjcsMzUuNywyMDIsMTA1LDYwNGM2Ny4zLDQwMC43LDEwMiw2MDIuNywxMDQsXFxuNjA2ek1cIiArICgxMDAxICsgZXh0cmFWaW5pY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiSDEwMTcuN3pcIjtcbn07XG5cbnZhciBwaGFzZVBhdGggPSBmdW5jdGlvbiBwaGFzZVBhdGgoeSkge1xuICB2YXIgeCA9IHkgLyAyOyAvLyB4IGNvb3JkaW5hdGUgYXQgdG9wIG9mIGFuZ2xlXG5cbiAgcmV0dXJuIFwiTTQwMDAwMCBcIiArIHkgKyBcIiBIMCBMXCIgKyB4ICsgXCIgMCBsNjUgNDUgTDE0NSBcIiArICh5IC0gODApICsgXCIgSDQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0VGFsbCA9IGZ1bmN0aW9uIHNxcnRUYWxsKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCwgdmlld0JveEhlaWdodCkge1xuICAvLyBzcXJ0VGFsbCBpcyBmcm9tIGdseXBoIFUyM0I3IGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgLy8gT25lIHBhdGggZWRnZSBoYXMgYSB2YXJpYWJsZSBsZW5ndGguIEl0IHJ1bnMgdmVydGljYWxseSBmcm9tIHRoZSB2aW5pY3VsdW1uXG4gIC8vIHRvIGEgcG9pbnQgbmVhciAoMTQgdW5pdHMpIHRoZSBib3R0b20gb2YgdGhlIHN1cmQuIFRoZSB2aW5pY3VsdW1cbiAgLy8gaXMgbm9ybWFsbHkgNDAgdW5pdHMgdGhpY2suIFNvIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgaW4gcXVlc3Rpb24gaXM6XG4gIHZhciB2ZXJ0U2VnbWVudCA9IHZpZXdCb3hIZWlnaHQgLSA1NCAtIGhMaW5lUGFkIC0gZXh0cmFWaW5pY3VsdW07XG4gIHJldHVybiBcIk03MDIgXCIgKyAoZXh0cmFWaW5pY3VsdW0gKyBoTGluZVBhZCkgKyBcIkg0MDAwMDBcIiArICg0MCArIGV4dHJhVmluaWN1bHVtKSArIFwiXFxuSDc0MnZcIiArIHZlcnRTZWdtZW50ICsgXCJsLTQgNC00IDRjLS42NjcuNyAtMiAxLjUtNCAyLjVzLTQuMTY3IDEuODMzLTYuNSAyLjUtNS41IDEtOS41IDFcXG5oLTEybC0yOC04NGMtMTYuNjY3LTUyLTk2LjY2NyAtMjk0LjMzMy0yNDAtNzI3bC0yMTIgLTY0MyAtODUgMTcwXFxuYy00LTMuMzMzLTguMzMzLTcuNjY3LTEzIC0xM2wtMTMtMTNsNzctMTU1IDc3LTE1NmM2NiAxOTkuMzMzIDEzOSA0MTkuNjY3XFxuMjE5IDY2MSBsMjE4IDY2MXpNNzAyIFwiICsgaExpbmVQYWQgKyBcIkg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmljdWx1bSkgKyBcIkg3NDJ6XCI7XG59O1xuXG52YXIgc3FydFBhdGggPSBmdW5jdGlvbiBzcXJ0UGF0aChzaXplLCBleHRyYVZpbmljdWx1bSwgdmlld0JveEhlaWdodCkge1xuICBleHRyYVZpbmljdWx1bSA9IDEwMDAgKiBleHRyYVZpbmljdWx1bTsgLy8gQ29udmVydCBmcm9tIGRvY3VtZW50IGVtcyB0byB2aWV3Qm94LlxuXG4gIHZhciBwYXRoID0gXCJcIjtcblxuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlIFwic3FydE1haW5cIjpcbiAgICAgIHBhdGggPSBzcXJ0TWFpbihleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemUxXCI6XG4gICAgICBwYXRoID0gc3FydFNpemUxKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0U2l6ZTJcIjpcbiAgICAgIHBhdGggPSBzcXJ0U2l6ZTIoZXh0cmFWaW5pY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplM1wiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplMyhleHRyYVZpbmljdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemU0XCI6XG4gICAgICBwYXRoID0gc3FydFNpemU0KGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0VGFsbFwiOlxuICAgICAgcGF0aCA9IHNxcnRUYWxsKGV4dHJhVmluaWN1bHVtLCBoTGluZVBhZCwgdmlld0JveEhlaWdodCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn07XG52YXIgaW5uZXJQYXRoID0gZnVuY3Rpb24gaW5uZXJQYXRoKG5hbWUsIGhlaWdodCkge1xuICAvLyBUaGUgaW5uZXIgcGFydCBvZiBzdHJldGNoeSB0YWxsIGRlbGltaXRlcnNcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcIlxcdTIzOWNcIjpcbiAgICAgIHJldHVybiBcIk0yOTEgMCBINDE3IFZcIiArIGhlaWdodCArIFwiIEgyOTF6IE0yOTEgMCBINDE3IFZcIiArIGhlaWdodCArIFwiIEgyOTF6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjIyM1wiOlxuICAgICAgcmV0dXJuIFwiTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXogTTE0NSAwIEgxODggVlwiICsgaGVpZ2h0ICsgXCIgSDE0NXpcIjtcblxuICAgIGNhc2UgXCJcXHUyMjI1XCI6XG4gICAgICByZXR1cm4gXCJNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1eiBNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1elwiICsgKFwiTTM2NyAwIEg0MTAgVlwiICsgaGVpZ2h0ICsgXCIgSDM2N3ogTTM2NyAwIEg0MTAgVlwiICsgaGVpZ2h0ICsgXCIgSDM2N3pcIik7XG5cbiAgICBjYXNlIFwiXFx1MjM5ZlwiOlxuICAgICAgcmV0dXJuIFwiTTQ1NyAwIEg1ODMgVlwiICsgaGVpZ2h0ICsgXCIgSDQ1N3ogTTQ1NyAwIEg1ODMgVlwiICsgaGVpZ2h0ICsgXCIgSDQ1N3pcIjtcblxuICAgIGNhc2UgXCJcXHUyM2EyXCI6XG4gICAgICByZXR1cm4gXCJNMzE5IDAgSDQwMyBWXCIgKyBoZWlnaHQgKyBcIiBIMzE5eiBNMzE5IDAgSDQwMyBWXCIgKyBoZWlnaHQgKyBcIiBIMzE5elwiO1xuXG4gICAgY2FzZSBcIlxcdTIzYTVcIjpcbiAgICAgIHJldHVybiBcIk0yNjMgMCBIMzQ3IFZcIiArIGhlaWdodCArIFwiIEgyNjN6IE0yNjMgMCBIMzQ3IFZcIiArIGhlaWdodCArIFwiIEgyNjN6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjNhYVwiOlxuICAgICAgcmV0dXJuIFwiTTM4NCAwIEg1MDQgVlwiICsgaGVpZ2h0ICsgXCIgSDM4NHogTTM4NCAwIEg1MDQgVlwiICsgaGVpZ2h0ICsgXCIgSDM4NHpcIjtcblxuICAgIGNhc2UgXCJcXHUyM2QwXCI6XG4gICAgICByZXR1cm4gXCJNMzEyIDAgSDM1NSBWXCIgKyBoZWlnaHQgKyBcIiBIMzEyeiBNMzEyIDAgSDM1NSBWXCIgKyBoZWlnaHQgKyBcIiBIMzEyelwiO1xuXG4gICAgY2FzZSBcIlxcdTIwMTZcIjpcbiAgICAgIHJldHVybiBcIk0yNTcgMCBIMzAwIFZcIiArIGhlaWdodCArIFwiIEgyNTd6IE0yNTcgMCBIMzAwIFZcIiArIGhlaWdodCArIFwiIEgyNTd6XCIgKyAoXCJNNDc4IDAgSDUyMSBWXCIgKyBoZWlnaHQgKyBcIiBINDc4eiBNNDc4IDAgSDUyMSBWXCIgKyBoZWlnaHQgKyBcIiBINDc4elwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcbnZhciBwYXRoID0ge1xuICAvLyBUaGUgZG91YmxlbGVmdGFycm93IGdlb21ldHJ5IGlzIGZyb20gZ2x5cGggVSsyMUQwIGluIHRoZSBmb250IEthVGVYIE1haW5cbiAgZG91YmxlbGVmdGFycm93OiBcIk0yNjIgMTU3XFxubDEwLTEwYzM0LTM2IDYyLjctNzcgODYtMTIzIDMuMy04IDUtMTMuMyA1LTE2IDAtNS4zLTYuNy04LTIwLTgtNy4zXFxuIDAtMTIuMi41LTE0LjUgMS41LTIuMyAxLTQuOCA0LjUtNy41IDEwLjUtNDkuMyA5Ny4zLTEyMS43IDE2OS4zLTIxNyAyMTYtMjhcXG4gMTQtNTcuMyAyNS04OCAzMy02LjcgMi0xMSAzLjgtMTMgNS41LTIgMS43LTMgNC4yLTMgNy41czEgNS44IDMgNy41XFxuYzIgMS43IDYuMyAzLjUgMTMgNS41IDY4IDE3LjMgMTI4LjIgNDcuOCAxODAuNSA5MS41IDUyLjMgNDMuNyA5My44IDk2LjIgMTI0LjVcXG4gMTU3LjUgOS4zIDggMTUuMyAxMi4zIDE4IDEzaDZjMTItLjcgMTgtNCAxOC0xMCAwLTItMS43LTctNS0xNS0yMy4zLTQ2LTUyLTg3XFxuLTg2LTEyM2wtMTAtMTBoMzk5NzM4di00MEgyMThjMzI4IDAgMCAwIDAgMGwtMTAtOGMtMjYuNy0yMC02NS43LTQzLTExNy02OSAyLjdcXG4tMiA2LTMuNyAxMC01IDM2LjctMTYgNzIuMy0zNy4zIDEwNy02NGwxMC04aDM5OTc4MnYtNDB6XFxubTggMHY0MGgzOTk3MzB2LTQwem0wIDE5NHY0MGgzOTk3MzB2LTQwelwiLFxuICAvLyBkb3VibGVyaWdodGFycm93IGlzIGZyb20gZ2x5cGggVSsyMUQyIGluIGZvbnQgS2FUZVggTWFpblxuICBkb3VibGVyaWdodGFycm93OiBcIk0zOTk3MzggMzkybFxcbi0xMCAxMGMtMzQgMzYtNjIuNyA3Ny04NiAxMjMtMy4zIDgtNSAxMy4zLTUgMTYgMCA1LjMgNi43IDggMjAgOCA3LjMgMCAxMi4yLS41XFxuIDE0LjUtMS41IDIuMy0xIDQuOC00LjUgNy41LTEwLjUgNDkuMy05Ny4zIDEyMS43LTE2OS4zIDIxNy0yMTYgMjgtMTQgNTcuMy0yNSA4OFxcbi0zMyA2LjctMiAxMS0zLjggMTMtNS41IDItMS43IDMtNC4yIDMtNy41cy0xLTUuOC0zLTcuNWMtMi0xLjctNi4zLTMuNS0xMy01LjUtNjhcXG4tMTcuMy0xMjguMi00Ny44LTE4MC41LTkxLjUtNTIuMy00My43LTkzLjgtOTYuMi0xMjQuNS0xNTcuNS05LjMtOC0xNS4zLTEyLjMtMThcXG4tMTNoLTZjLTEyIC43LTE4IDQtMTggMTAgMCAyIDEuNyA3IDUgMTUgMjMuMyA0NiA1MiA4NyA4NiAxMjNsMTAgMTBIMHY0MGgzOTk3ODJcXG5jLTMyOCAwIDAgMCAwIDBsMTAgOGMyNi43IDIwIDY1LjcgNDMgMTE3IDY5LTIuNyAyLTYgMy43LTEwIDUtMzYuNyAxNi03Mi4zIDM3LjNcXG4tMTA3IDY0bC0xMCA4SDB2NDB6TTAgMTU3djQwaDM5OTczMHYtNDB6bTAgMTk0djQwaDM5OTczMHYtNDB6XCIsXG4gIC8vIGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW5cbiAgbGVmdGFycm93OiBcIk00MDAwMDAgMjQxSDExMGwzLTNjNjguNy01Mi43IDExMy43LTEyMFxcbiAxMzUtMjAyIDQtMTQuNyA2LTIzIDYtMjUgMC03LjMtNy0xMS0yMS0xMS04IDAtMTMuMi44LTE1LjUgMi41LTIuMyAxLjctNC4yIDUuOFxcbi01LjUgMTIuNS0xLjMgNC43LTIuNyAxMC4zLTQgMTctMTIgNDguNy0zNC44IDkyLTY4LjUgMTMwUzY1LjMgMjI4LjMgMTggMjQ3XFxuYy0xMCA0LTE2IDcuNy0xOCAxMSAwIDguNyA2IDE0LjMgMTggMTcgNDcuMyAxOC43IDg3LjggNDcgMTIxLjUgODVTMTk2IDQ0MS4zIDIwOFxcbiA0OTBjLjcgMiAxLjMgNSAyIDlzMS4yIDYuNyAxLjUgOGMuMyAxLjMgMSAzLjMgMiA2czIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjNcXG4gMS44IDYgMi41czYgMSAxMCAxYzE0IDAgMjEtMy43IDIxLTExIDAtMi0yLTEwLjMtNi0yNS0yMC03OS4zLTY1LTE0Ni43LTEzNS0yMDJcXG4gbC0zLTNoMzk5ODkwek0xMDAgMjQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIG92ZXJicmFjZSBpcyBmcm9tIGdseXBocyBVKzIzQTkvMjNBOC8yM0E3IGluIGZvbnQgS2FUZVhfU2l6ZTQtUmVndWxhclxuICBsZWZ0YnJhY2U6IFwiTTYgNTQ4bC02LTZ2LTM1bDYtMTFjNTYtMTA0IDEzNS4zLTE4MS4zIDIzOC0yMzIgNTcuMy0yOC43IDExN1xcbi00NSAxNzktNTBoMzk5NTc3djEyMEg0MDNjLTQzLjMgNy04MSAxNS0xMTMgMjYtMTAwLjcgMzMtMTc5LjcgOTEtMjM3IDE3NC0yLjdcXG4gNS02IDktMTAgMTMtLjcgMS03LjMgMS0yMCAxSDZ6XCIsXG4gIGxlZnRicmFjZXVuZGVyOiBcIk0wIDZsNi02aDE3YzEyLjY4OCAwIDE5LjMxMy4zIDIwIDEgNCA0IDcuMzEzIDguMyAxMCAxM1xcbiAzNS4zMTMgNTEuMyA4MC44MTMgOTMuOCAxMzYuNSAxMjcuNSA1NS42ODggMzMuNyAxMTcuMTg4IDU1LjggMTg0LjUgNjYuNS42ODhcXG4gMCAyIC4zIDQgMSAxOC42ODggMi43IDc2IDQuMyAxNzIgNWgzOTk0NTB2MTIwSDQyOWwtNi0xYy0xMjQuNjg4LTgtMjM1LTYxLjdcXG4tMzMxLTE2MUM2MC42ODcgMTM4LjcgMzIuMzEyIDk5LjMgNyA1NEwwIDQxVjZ6XCIsXG4gIC8vIG92ZXJncm91cCBpcyBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlIChwdWJsaWMgZG9tYWluKVxuICBsZWZ0Z3JvdXA6IFwiTTQwMDAwMCA4MFxcbkg0MzVDNjQgODAgMTY4LjMgMjI5LjQgMjEgMjYwYy01LjkgMS4yLTE4IDAtMTggMC0yIDAtMy0xLTMtM3YtMzhDNzYgNjEgMjU3IDBcXG4gNDM1IDBoMzk5NTY1elwiLFxuICBsZWZ0Z3JvdXB1bmRlcjogXCJNNDAwMDAwIDI2Mlxcbkg0MzVDNjQgMjYyIDE2OC4zIDExMi42IDIxIDgyYy01LjktMS4yLTE4IDAtMTggMC0yIDAtMyAxLTMgM3YzOGM3NiAxNTggMjU3IDIxOVxcbiA0MzUgMjE5aDM5OTU2NXpcIixcbiAgLy8gSGFycG9vbnMgYXJlIGZyb20gZ2x5cGggVSsyMUJEIGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0aGFycG9vbjogXCJNMCAyNjdjLjcgNS4zIDMgMTAgNyAxNGgzOTk5OTN2LTQwSDkzYzMuM1xcbi0zLjMgMTAuMi05LjUgMjAuNS0xOC41czE3LjgtMTUuOCAyMi41LTIwLjVjNTAuNy01MiA4OC0xMTAuMyAxMTItMTc1IDQtMTEuMyA1XFxuLTE4LjMgMy0yMS0xLjMtNC03LjMtNi0xOC02LTggMC0xMyAuNy0xNSAycy00LjcgNi43LTggMTZjLTQyIDk4LjctMTA3LjMgMTc0LjdcXG4tMTk2IDIyOC02LjcgNC43LTEwLjcgOC0xMiAxMC0xLjMgMi0yIDUuNy0yIDExem0xMDAtMjZ2NDBoMzk5OTAwdi00MHpcIixcbiAgbGVmdGhhcnBvb25wbHVzOiBcIk0wIDI2N2MuNyA1LjMgMyAxMCA3IDE0aDM5OTk5M3YtNDBIOTNjMy4zLTMuMyAxMC4yLTkuNVxcbiAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDUtMTguMyAzLTIxLTEuM1xcbi00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuNy0xOTYgMjI4LTYuNyA0LjdcXG4tMTAuNyA4LTEyIDEwLTEuMyAyLTIgNS43LTIgMTF6bTEwMC0yNnY0MGgzOTk5MDB2LTQwek0wIDQzNXY0MGg0MDAwMDB2LTQwelxcbm0wIDB2NDBoNDAwMDAwdi00MHpcIixcbiAgbGVmdGhhcnBvb25kb3duOiBcIk03IDI0MWMtNCA0LTYuMzMzIDguNjY3LTcgMTQgMCA1LjMzMy42NjcgOSAyIDExczUuMzMzXFxuIDUuMzMzIDEyIDEwYzkwLjY2NyA1NCAxNTYgMTMwIDE5NiAyMjggMy4zMzMgMTAuNjY3IDYuMzMzIDE2LjMzMyA5IDE3IDIgLjY2NyA1XFxuIDEgOSAxaDVjMTAuNjY3IDAgMTYuNjY3LTIgMTgtNiAyLTIuNjY3IDEtOS42NjctMy0yMS0zMi04Ny4zMzMtODIuNjY3LTE1Ny42NjdcXG4tMTUyLTIxMWwtMy0zaDM5OTkwN3YtNDB6TTkzIDI4MSBINDAwMDAwIHYtNDBMNyAyNDF6XCIsXG4gIGxlZnRoYXJwb29uZG93bnBsdXM6IFwiTTcgNDM1Yy00IDQtNi4zIDguNy03IDE0IDAgNS4zLjcgOSAyIDExczUuMyA1LjMgMTJcXG4gMTBjOTAuNyA1NCAxNTYgMTMwIDE5NiAyMjggMy4zIDEwLjcgNi4zIDE2LjMgOSAxNyAyIC43IDUgMSA5IDFoNWMxMC43IDAgMTYuN1xcbi0yIDE4LTYgMi0yLjcgMS05LjctMy0yMS0zMi04Ny4zLTgyLjctMTU3LjctMTUyLTIxMWwtMy0zaDM5OTkwN3YtNDBIN3ptOTMgMFxcbnY0MGgzOTk5MDB2LTQwek0wIDI0MXY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gaG9vayBpcyBmcm9tIGdseXBoIFUrMjFBOSBpbiBmb250IEthVGVYIE1haW5cbiAgbGVmdGhvb2s6IFwiTTQwMDAwMCAyODEgSDEwM3MtMzMtMTEuMi02MS0zMy41UzAgMTk3LjMgMCAxNjRzMTQuMi02MS4yIDQyLjVcXG4tODMuNUM3MC44IDU4LjIgMTA0IDQ3IDE0MiA0NyBjMTYuNyAwIDI1IDYuNyAyNSAyMCAwIDEyLTguNyAxOC43LTI2IDIwLTQwIDMuM1xcbi02OC43IDE1LjctODYgMzctMTAgMTItMTUgMjUuMy0xNSA0MCAwIDIyLjcgOS44IDQwLjcgMjkuNSA1NCAxOS43IDEzLjMgNDMuNSAyMVxcbiA3MS41IDIzaDM5OTg1OXpNMTAzIDI4MXYtNDBoMzk5ODk3djQwelwiLFxuICBsZWZ0bGluZXNlZ21lbnQ6IFwiTTQwIDI4MSBWNDI4IEgwIFY5NCBINDAgVjI0MSBINDAwMDAwIHY0MHpcXG5NNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelwiLFxuICBsZWZ0bWFwc3RvOiBcIk00MCAyODEgVjQ0OEgwVjc0SDQwVjI0MUg0MDAwMDB2NDB6XFxuTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHpcIixcbiAgLy8gdG9mcm9tIGlzIGZyb20gZ2x5cGggVSsyMUM0IGluIGZvbnQgS2FUZVggQU1TIFJlZ3VsYXJcbiAgbGVmdFRvRnJvbTogXCJNMCAxNDdoNDAwMDAwdjQwSDB6bTAgMjE0YzY4IDQwIDExNS43IDk1LjcgMTQzIDE2N2gyMmMxNS4zIDAgMjNcXG4tLjMgMjMtMSAwLTEuMy01LjMtMTMuNy0xNi0zNy0xOC0zNS4zLTQxLjMtNjktNzAtMTAxbC03LThoMzk5OTA1di00MEg5NWw3LThcXG5jMjguNy0zMiA1Mi02NS43IDcwLTEwMSAxMC43LTIzLjMgMTYtMzUuNyAxNi0zNyAwLS43LTcuNy0xLTIzLTFoLTIyQzExNS43IDI2NS4zXFxuIDY4IDMyMSAwIDM2MXptMC0xNzR2LTQwaDM5OTkwMHY0MHptMTAwIDE1NHY0MGgzOTk5MDB2LTQwelwiLFxuICBsb25nZXF1YWw6IFwiTTAgNTAgaDQwMDAwMCB2NDBIMHogbTAgMTk0aDQwMDAwdjQwSDB6XFxuTTAgNTAgaDQwMDAwMCB2NDBIMHogbTAgMTk0aDQwMDAwdjQwSDB6XCIsXG4gIG1pZGJyYWNlOiBcIk0yMDA0MjggMzM0XFxuYy0xMDAuNy04LjMtMTk1LjMtNDQtMjgwLTEwOC01NS4zLTQyLTEwMS43LTkzLTEzOS0xNTNsLTktMTRjLTIuNyA0LTUuNyA4LjctOSAxNFxcbi01My4zIDg2LjctMTIzLjcgMTUzLTIxMSAxOTktNjYuNyAzNi0xMzcuMyA1Ni4zLTIxMiA2MkgwVjIxNGgxOTk1NjhjMTc4LjMtMTEuN1xcbiAzMTEuNy03OC4zIDQwMy0yMDEgNi04IDkuNy0xMiAxMS0xMiAuNy0uNyA2LjctMSAxOC0xczE3LjMuMyAxOCAxYzEuMyAwIDUgNCAxMVxcbiAxMiA0NC43IDU5LjMgMTAxLjMgMTA2LjMgMTcwIDE0MXMxNDUuMyA1NC4zIDIyOSA2MGgxOTk1NzJ2MTIwelwiLFxuICBtaWRicmFjZXVuZGVyOiBcIk0xOTk1NzIgMjE0XFxuYzEwMC43IDguMyAxOTUuMyA0NCAyODAgMTA4IDU1LjMgNDIgMTAxLjcgOTMgMTM5IDE1M2w5IDE0YzIuNy00IDUuNy04LjcgOS0xNFxcbiA1My4zLTg2LjcgMTIzLjctMTUzIDIxMS0xOTkgNjYuNy0zNiAxMzcuMy01Ni4zIDIxMi02MmgxOTk1Njh2MTIwSDIwMDQzMmMtMTc4LjNcXG4gMTEuNy0zMTEuNyA3OC4zLTQwMyAyMDEtNiA4LTkuNyAxMi0xMSAxMi0uNy43LTYuNyAxLTE4IDFzLTE3LjMtLjMtMTgtMWMtMS4zIDBcXG4tNS00LTExLTEyLTQ0LjctNTkuMy0xMDEuMy0xMDYuMy0xNzAtMTQxcy0xNDUuMy01NC4zLTIyOS02MEgwVjIxNHpcIixcbiAgb2lpbnRTaXplMTogXCJNNTEyLjYgNzEuNmMyNzIuNiAwIDMyMC4zIDEwNi44IDMyMC4zIDE3OC4yIDAgNzAuOC00Ny43IDE3Ny42XFxuLTMyMC4zIDE3Ny42UzE5My4xIDMyMC42IDE5My4xIDI0OS44YzAtNzEuNCA0Ni45LTE3OC4yIDMxOS41LTE3OC4yelxcbm0zNjguMSAxNzguMmMwLTg2LjQtNjAuOS0yMTUuNC0zNjguMS0yMTUuNC0zMDYuNCAwLTM2Ny4zIDEyOS0zNjcuMyAyMTUuNCAwIDg1LjhcXG42MC45IDIxNC44IDM2Ny4zIDIxNC44IDMwNy4yIDAgMzY4LjEtMTI5IDM2OC4xLTIxNC44elwiLFxuICBvaWludFNpemUyOiBcIk03NTcuOCAxMDAuMWMzODQuNyAwIDQ1MS4xIDEzNy42IDQ1MS4xIDIzMCAwIDkxLjMtNjYuNCAyMjguOFxcbi00NTEuMSAyMjguOC0zODYuMyAwLTQ1Mi43LTEzNy41LTQ1Mi43LTIyOC44IDAtOTIuNCA2Ni40LTIzMCA0NTIuNy0yMzB6XFxubTUwMi40IDIzMGMwLTExMS4yLTgyLjQtMjc3LjItNTAyLjQtMjc3LjJzLTUwNCAxNjYtNTA0IDI3Ny4yXFxuYzAgMTEwIDg0IDI3NiA1MDQgMjc2czUwMi40LTE2NiA1MDIuNC0yNzZ6XCIsXG4gIG9paWludFNpemUxOiBcIk02ODEuNCA3MS42YzQwOC45IDAgNDgwLjUgMTA2LjggNDgwLjUgMTc4LjIgMCA3MC44LTcxLjYgMTc3LjZcXG4tNDgwLjUgMTc3LjZTMjAyLjEgMzIwLjYgMjAyLjEgMjQ5LjhjMC03MS40IDcwLjUtMTc4LjIgNDc5LjMtMTc4LjJ6XFxubTUyNS44IDE3OC4yYzAtODYuNC04Ni44LTIxNS40LTUyNS43LTIxNS40LTQzNy45IDAtNTI0LjcgMTI5LTUyNC43IDIxNS40IDBcXG44NS44IDg2LjggMjE0LjggNTI0LjcgMjE0LjggNDM4LjkgMCA1MjUuNy0xMjkgNTI1LjctMjE0Ljh6XCIsXG4gIG9paWludFNpemUyOiBcIk0xMDIxLjIgNTNjNjAzLjYgMCA3MDcuOCAxNjUuOCA3MDcuOCAyNzcuMiAwIDExMC0xMDQuMiAyNzUuOFxcbi03MDcuOCAyNzUuOC02MDYgMC03MTAuMi0xNjUuOC03MTAuMi0yNzUuOEMzMTEgMjE4LjggNDE1LjIgNTMgMTAyMS4yIDUzelxcbm03NzAuNCAyNzcuMWMwLTEzMS4yLTEyNi40LTMyNy42LTc3MC41LTMyNy42UzI0OC40IDE5OC45IDI0OC40IDMzMC4xXFxuYzAgMTMwIDEyOC44IDMyNi40IDc3Mi43IDMyNi40czc3MC41LTE5Ni40IDc3MC41LTMyNi40elwiLFxuICByaWdodGFycm93OiBcIk0wIDI0MXY0MGgzOTk4OTFjLTQ3LjMgMzUuMy04NCA3OC0xMTAgMTI4XFxuLTE2LjcgMzItMjcuNyA2My43LTMzIDk1IDAgMS4zLS4yIDIuNy0uNSA0LS4zIDEuMy0uNSAyLjMtLjUgMyAwIDcuMyA2LjcgMTEgMjBcXG4gMTEgOCAwIDEzLjItLjggMTUuNS0yLjUgMi4zLTEuNyA0LjItNS41IDUuNS0xMS41IDItMTMuMyA1LjctMjcgMTEtNDEgMTQuNy00NC43XFxuIDM5LTg0LjUgNzMtMTE5LjVzNzMuNy02MC4yIDExOS03NS41YzYtMiA5LTUuNyA5LTExcy0zLTktOS0xMWMtNDUuMy0xNS4zLTg1XFxuLTQwLjUtMTE5LTc1LjVzLTU4LjMtNzQuOC03My0xMTkuNWMtNC43LTE0LTguMy0yNy4zLTExLTQwLTEuMy02LjctMy4yLTEwLjgtNS41XFxuLTEyLjUtMi4zLTEuNy03LjUtMi41LTE1LjUtMi41LTE0IDAtMjEgMy43LTIxIDExIDAgMiAyIDEwLjMgNiAyNSAyMC43IDgzLjMgNjdcXG4gMTUxLjcgMTM5IDIwNXptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0YnJhY2U6IFwiTTQwMDAwMCA1NDJsXFxuLTYgNmgtMTdjLTEyLjcgMC0xOS4zLS4zLTIwLTEtNC00LTcuMy04LjMtMTAtMTMtMzUuMy01MS4zLTgwLjgtOTMuOC0xMzYuNS0xMjcuNVxcbnMtMTE3LjItNTUuOC0xODQuNS02Ni41Yy0uNyAwLTItLjMtNC0xLTE4LjctMi43LTc2LTQuMy0xNzItNUgwVjIxNGgzOTk1NzFsNiAxXFxuYzEyNC43IDggMjM1IDYxLjcgMzMxIDE2MSAzMS4zIDMzLjMgNTkuNyA3Mi43IDg1IDExOGw3IDEzdjM1elwiLFxuICByaWdodGJyYWNldW5kZXI6IFwiTTM5OTk5NCAwbDYgNnYzNWwtNiAxMWMtNTYgMTA0LTEzNS4zIDE4MS4zLTIzOCAyMzItNTcuM1xcbiAyOC43LTExNyA0NS0xNzkgNTBILTMwMFYyMTRoMzk5ODk3YzQzLjMtNyA4MS0xNSAxMTMtMjYgMTAwLjctMzMgMTc5LjctOTEgMjM3XFxuLTE3NCAyLjctNSA2LTkgMTAtMTMgLjctMSA3LjMtMSAyMC0xaDE3elwiLFxuICByaWdodGdyb3VwOiBcIk0wIDgwaDM5OTU2NWMzNzEgMCAyNjYuNyAxNDkuNCA0MTQgMTgwIDUuOSAxLjIgMTggMCAxOCAwIDIgMFxcbiAzLTEgMy0zdi0zOGMtNzYtMTU4LTI1Ny0yMTktNDM1LTIxOUgwelwiLFxuICByaWdodGdyb3VwdW5kZXI6IFwiTTAgMjYyaDM5OTU2NWMzNzEgMCAyNjYuNy0xNDkuNCA0MTQtMTgwIDUuOS0xLjIgMTggMCAxOFxcbiAwIDIgMCAzIDEgMyAzdjM4Yy03NiAxNTgtMjU3IDIxOS00MzUgMjE5SDB6XCIsXG4gIHJpZ2h0aGFycG9vbjogXCJNMCAyNDF2NDBoMzk5OTkzYzQuNy00LjcgNy05LjMgNy0xNCAwLTkuM1xcbi0zLjctMTUuMy0xMS0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMlxcbi0xMC43IDAtMTYuNyAyLTE4IDYtMiAyLjctMSA5LjcgMyAyMSAxNS4zIDQyIDM2LjcgODEuOCA2NCAxMTkuNSAyNy4zIDM3LjcgNThcXG4gNjkuMiA5MiA5NC41em0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29ucGx1czogXCJNMCAyNDF2NDBoMzk5OTkzYzQuNy00LjcgNy05LjMgNy0xNCAwLTkuMy0zLjctMTUuMy0xMVxcbi0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMi0xMC43IDAtMTYuN1xcbiAyLTE4IDYtMiAyLjctMSA5LjcgMyAyMSAxNS4zIDQyIDM2LjcgODEuOCA2NCAxMTkuNSAyNy4zIDM3LjcgNTggNjkuMiA5MiA5NC41elxcbm0wIDB2NDBoMzk5OTAwdi00MHogbTEwMCAxOTR2NDBoMzk5OTAwdi00MHptMCAwdjQwaDM5OTkwMHYtNDB6XCIsXG4gIHJpZ2h0aGFycG9vbmRvd246IFwiTTM5OTc0NyA1MTFjMCA3LjMgNi43IDExIDIwIDExIDggMCAxMy0uOCAxNS0yLjVzNC43LTYuOFxcbiA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuMyA4LjUtNS44IDkuNVxcbi03LjUgMS0xLjcgMS41LTUuMiAxLjUtMTAuNXMtMi4zLTEwLjMtNy0xNUgwdjQwaDM5OTkwOGMtMzQgMjUuMy02NC43IDU3LTkyIDk1XFxuLTI3LjMgMzgtNDguNyA3Ny43LTY0IDExOS0zLjMgOC43LTUgMTQtNSAxNnpNMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29uZG93bnBsdXM6IFwiTTM5OTc0NyA3MDVjMCA3LjMgNi43IDExIDIwIDExIDggMCAxMy0uOFxcbiAxNS0yLjVzNC43LTYuOCA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuM1xcbiA4LjUtNS44IDkuNS03LjUgMS0xLjcgMS41LTUuMiAxLjUtMTAuNXMtMi4zLTEwLjMtNy0xNUgwdjQwaDM5OTkwOGMtMzQgMjUuM1xcbi02NC43IDU3LTkyIDk1LTI3LjMgMzgtNDguNyA3Ny43LTY0IDExOS0zLjMgOC43LTUgMTQtNSAxNnpNMCA0MzV2NDBoMzk5OTAwdi00MHpcXG5tMC0xOTR2NDBoNDAwMDAwdi00MHptMCAwdjQwaDQwMDAwMHYtNDB6XCIsXG4gIHJpZ2h0aG9vazogXCJNMzk5ODU5IDI0MWMtNzY0IDAgMCAwIDAgMCA0MC0zLjMgNjguNy0xNS43IDg2LTM3IDEwLTEyIDE1LTI1LjNcXG4gMTUtNDAgMC0yMi43LTkuOC00MC43LTI5LjUtNTQtMTkuNy0xMy4zLTQzLjUtMjEtNzEuNS0yMy0xNy4zLTEuMy0yNi04LTI2LTIwIDBcXG4tMTMuMyA4LjctMjAgMjYtMjAgMzggMCA3MSAxMS4yIDk5IDMzLjUgMCAwIDcgNS42IDIxIDE2LjcgMTQgMTEuMiAyMSAzMy41IDIxXFxuIDY2LjhzLTE0IDYxLjItNDIgODMuNWMtMjggMjIuMy02MSAzMy41LTk5IDMzLjVMMCAyNDF6IE0wIDI4MXYtNDBoMzk5ODU5djQwelwiLFxuICByaWdodGxpbmVzZWdtZW50OiBcIk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcXG5NMzk5OTYwIDI0MSBWOTQgaDQwIFY0MjggaC00MCBWMjgxIEgwIHYtNDB6XCIsXG4gIHJpZ2h0VG9Gcm9tOiBcIk00MDAwMDAgMTY3Yy03MC43LTQyLTExOC05Ny43LTE0Mi0xNjdoLTIzYy0xNS4zIDAtMjMgLjMtMjNcXG4gMSAwIDEuMyA1LjMgMTMuNyAxNiAzNyAxOCAzNS4zIDQxLjMgNjkgNzAgMTAxbDcgOEgwdjQwaDM5OTkwNWwtNyA4Yy0yOC43IDMyXFxuLTUyIDY1LjctNzAgMTAxLTEwLjcgMjMuMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyM2MyNC02OS4zIDcxLjMtMTI1IDE0Mlxcbi0xNjd6IE0xMDAgMTQ3djQwaDM5OTkwMHYtNDB6TTAgMzQxdjQwaDM5OTkwMHYtNDB6XCIsXG4gIC8vIHR3b2hlYWRsZWZ0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxOUUgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhclxuICB0d29oZWFkbGVmdGFycm93OiBcIk0wIDE2N2M2OCA0MFxcbiAxMTUuNyA5NS43IDE0MyAxNjdoMjJjMTUuMyAwIDIzLS4zIDIzLTEgMC0xLjMtNS4zLTEzLjctMTYtMzctMTgtMzUuMy00MS4zLTY5XFxuLTcwLTEwMWwtNy04aDEyNWw5IDdjNTAuNyAzOS4zIDg1IDg2IDEwMyAxNDBoNDZjMC00LjctNi4zLTE4LjctMTktNDItMTgtMzUuM1xcbi00MC02Ny4zLTY2LTk2bC05LTloMzk5NzE2di00MEgyODRsOS05YzI2LTI4LjcgNDgtNjAuNyA2Ni05NiAxMi43LTIzLjMzMyAxOVxcbi0zNy4zMzMgMTktNDJoLTQ2Yy0xOCA1NC01Mi4zIDEwMC43LTEwMyAxNDBsLTkgN0g5NWw3LThjMjguNy0zMiA1Mi02NS43IDcwLTEwMVxcbiAxMC43LTIzLjMzMyAxNi0zNS43IDE2LTM3IDAtLjctNy43LTEtMjMtMWgtMjJDMTE1LjcgNzEuMyA2OCAxMjcgMCAxNjd6XCIsXG4gIHR3b2hlYWRyaWdodGFycm93OiBcIk00MDAwMDAgMTY3XFxuYy02OC00MC0xMTUuNy05NS43LTE0My0xNjdoLTIyYy0xNS4zIDAtMjMgLjMtMjMgMSAwIDEuMyA1LjMgMTMuNyAxNiAzNyAxOCAzNS4zXFxuIDQxLjMgNjkgNzAgMTAxbDcgOGgtMTI1bC05LTdjLTUwLjctMzkuMy04NS04Ni0xMDMtMTQwaC00NmMwIDQuNyA2LjMgMTguNyAxOSA0MlxcbiAxOCAzNS4zIDQwIDY3LjMgNjYgOTZsOSA5SDB2NDBoMzk5NzE2bC05IDljLTI2IDI4LjctNDggNjAuNy02NiA5Ni0xMi43IDIzLjMzM1xcbi0xOSAzNy4zMzMtMTkgNDJoNDZjMTgtNTQgNTIuMy0xMDAuNyAxMDMtMTQwbDktN2gxMjVsLTcgOGMtMjguNyAzMi01MiA2NS43LTcwXFxuIDEwMS0xMC43IDIzLjMzMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyMmMyNy4zLTcxLjMgNzUtMTI3IDE0My0xNjd6XCIsXG4gIC8vIHRpbGRlMSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBnbHlwaCBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlXG4gIHRpbGRlMTogXCJNMjAwIDU1LjUzOGMtNzcgMC0xNjggNzMuOTUzLTE3NyA3My45NTMtMyAwLTdcXG4tMi4xNzUtOS01LjQzN0wyIDk3Yy0xLTItMi00LTItNiAwLTQgMi03IDUtOWwyMC0xMkMxMTYgMTIgMTcxIDAgMjA3IDBjODYgMFxcbiAxMTQgNjggMTkxIDY4IDc4IDAgMTY4LTY4IDE3Ny02OCA0IDAgNyAyIDkgNWwxMiAxOWMxIDIuMTc1IDIgNC4zNSAyIDYuNTI1IDBcXG4gNC4zNS0yIDcuNjEzLTUgOS43ODhsLTE5IDEzLjA1Yy05MiA2My4wNzctMTE2LjkzNyA3NS4zMDgtMTgzIDc2LjEyOFxcbi02OC4yNjcuODQ3LTExMy03My45NTItMTkxLTczLjk1MnpcIixcbiAgLy8gZGl0dG8gdGlsZGUyLCB0aWxkZTMsICYgdGlsZGU0XG4gIHRpbGRlMjogXCJNMzQ0IDU1LjI2NmMtMTQyIDAtMzAwLjYzOCA4MS4zMTYtMzExLjUgODYuNDE4XFxuLTguMDEgMy43NjItMjIuNSAxMC45MS0yMy41IDUuNTYyTDEgMTIwYy0xLTItMS0zLTEtNCAwLTUgMy05IDgtMTBsMTguNC05QzE2MC45XFxuIDMxLjkgMjgzIDAgMzU4IDBjMTQ4IDAgMTg4IDEyMiAzMzEgMTIyczMxNC05NyAzMjYtOTdjNCAwIDggMiAxMCA3bDcgMjEuMTE0XFxuYzEgMi4xNCAxIDMuMjEgMSA0LjI4IDAgNS4zNDctMyA5LjYyNi03IDEwLjY5NmwtMjIuMyAxMi42MjJDODUyLjYgMTU4LjM3MiA3NTFcXG4gMTgxLjQ3NiA2NzYgMTgxLjQ3NmMtMTQ5IDAtMTg5LTEyNi4yMS0zMzItMTI2LjIxelwiLFxuICB0aWxkZTM6IFwiTTc4NiA1OUM0NTcgNTkgMzIgMTc1LjI0MiAxMyAxNzUuMjQyYy02IDAtMTAtMy40NTdcXG4tMTEtMTAuMzdMLjE1IDEzOGMtMS03IDMtMTIgMTAtMTNsMTkuMi02LjRDMzc4LjQgNDAuNyA2MzQuMyAwIDgwNC4zIDBjMzM3IDBcXG4gNDExLjggMTU3IDc0Ni44IDE1NyAzMjggMCA3NTQtMTEyIDc3My0xMTIgNSAwIDEwIDMgMTEgOWwxIDE0LjA3NWMxIDguMDY2LS42OTdcXG4gMTYuNTk1LTYuNjk3IDE3LjQ5MmwtMjEuMDUyIDcuMzFjLTM2Ny45IDk4LjE0Ni02MDkuMTUgMTIyLjY5Ni03NzguMTUgMTIyLjY5NlxcbiAtMzM4IDAtNDA5LTE1Ni41NzMtNzQ0LTE1Ni41NzN6XCIsXG4gIHRpbGRlNDogXCJNNzg2IDU4QzQ1NyA1OCAzMiAxNzcuNDg3IDEzIDE3Ny40ODdjLTYgMC0xMC0zLjM0NVxcbi0xMS0xMC4wMzVMLjE1IDE0M2MtMS03IDMtMTIgMTAtMTNsMjItNi43QzM4MS4yIDM1IDYzNy4xNSAwIDgwNy4xNSAwYzMzNyAwIDQwOVxcbiAxNzcgNzQ0IDE3NyAzMjggMCA3NTQtMTI3IDc3My0xMjcgNSAwIDEwIDMgMTEgOWwxIDE0Ljc5NGMxIDcuODA1LTMgMTMuMzgtOVxcbiAxNC40OTVsLTIwLjcgNS41NzRjLTM2Ni44NSA5OS43OS02MDcuMyAxMzkuMzcyLTc3Ni4zIDEzOS4zNzItMzM4IDAtNDA5XFxuIC0xNzUuMjM2LTc0NC0xNzUuMjM2elwiLFxuICAvLyB2ZWMgaXMgZnJvbSBnbHlwaCBVKzIwRDcgaW4gZm9udCBLYVRlWCBNYWluXG4gIHZlYzogXCJNMzc3IDIwYzAtNS4zMzMgMS44MzMtMTAgNS41LTE0UzM5MSAwIDM5NyAwYzQuNjY3IDAgOC42NjcgMS42NjcgMTIgNVxcbjMuMzMzIDIuNjY3IDYuNjY3IDkgMTAgMTkgNi42NjcgMjQuNjY3IDIwLjMzMyA0My42NjcgNDEgNTcgNy4zMzMgNC42NjcgMTFcXG4xMC42NjcgMTEgMTggMCA2LTEgMTAtMyAxMnMtNi42NjcgNS0xNCA5Yy0yOC42NjcgMTQuNjY3LTUzLjY2NyAzNS42NjctNzUgNjNcXG4tMS4zMzMgMS4zMzMtMy4xNjcgMy41LTUuNSA2LjVzLTQgNC44MzMtNSA1LjVjLTEgLjY2Ny0yLjUgMS4zMzMtNC41IDJzLTQuMzMzIDFcXG4tNyAxYy00LjY2NyAwLTkuMTY3LTEuODMzLTEzLjUtNS41UzMzNyAxODQgMzM3IDE3OGMwLTEyLjY2NyAxNS42NjctMzIuMzMzIDQ3LTU5XFxuSDIxM2wtMTcxLTFjLTguNjY3LTYtMTMtMTIuMzMzLTEzLTE5IDAtNC42NjcgNC4zMzMtMTEuMzMzIDEzLTIwaDM1OVxcbmMtMTYtMjUuMzMzLTI0LTQ1LTI0LTU5elwiLFxuICAvLyB3aWRlaGF0MSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBnbHlwaCBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlXG4gIHdpZGVoYXQxOiBcIk01MjkgMGg1bDUxOSAxMTVjNSAxIDkgNSA5IDEwIDAgMS0xIDItMSAzbC00IDIyXFxuYy0xIDUtNSA5LTExIDloLTJMNTMyIDY3IDE5IDE1OWgtMmMtNSAwLTktNC0xMS05bC01LTIyYy0xLTYgMi0xMiA4LTEzelwiLFxuICAvLyBkaXR0byB3aWRlaGF0Miwgd2lkZWhhdDMsICYgd2lkZWhhdDRcbiAgd2lkZWhhdDI6IFwiTTExODEgMGgybDExNzEgMTc2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDIyMGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICB3aWRlaGF0MzogXCJNMTE4MSAwaDJsMTE3MSAyMzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjgwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIHdpZGVoYXQ0OiBcIk0xMTgxIDBoMmwxMTcxIDI5NmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAzNDBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgLy8gd2lkZWNoZWNrIHBhdGhzIGFyZSBhbGwgaW52ZXJ0ZWQgdmVyc2lvbnMgb2Ygd2lkZWhhdFxuICB3aWRlY2hlY2sxOiBcIk01MjksMTU5aDVsNTE5LC0xMTVjNSwtMSw5LC01LDksLTEwYzAsLTEsLTEsLTIsLTEsLTNsLTQsLTIyYy0xLFxcbi01LC01LC05LC0xMSwtOWgtMmwtNTEyLDkybC01MTMsLTkyaC0yYy01LDAsLTksNCwtMTEsOWwtNSwyMmMtMSw2LDIsMTIsOCwxM3pcIixcbiAgd2lkZWNoZWNrMjogXCJNMTE4MSwyMjBoMmwxMTcxLC0xNzZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMTUzbC0xMTY3LC0xNTNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICB3aWRlY2hlY2szOiBcIk0xMTgxLDI4MGgybDExNzEsLTIzNmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwyMTNsLTExNjcsLTIxM2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIHdpZGVjaGVjazQ6IFwiTTExODEsMzQwaDJsMTE3MSwtMjk2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDI3M2wtMTE2NywtMjczaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgLy8gVGhlIG5leHQgdGVuIHBhdGhzIHN1cHBvcnQgcmVhY3Rpb24gYXJyb3dzIGZyb20gdGhlIG1oY2hlbSBwYWNrYWdlLlxuICAvLyBBcnJvd3MgZm9yIFxcY2V7PC0tPn0gYXJlIG9mZnNldCBmcm9tIHhBeGlzIGJ5IDAuMjJleCwgcGVyIG1oY2hlbSBpbiBMYVRlWFxuICAvLyBiYXJhYm92ZWxlZnRhcnJvdyBpcyBtb3N0bHkgZnJvbSBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW5cbiAgYmFyYWJvdmVsZWZ0YXJyb3c6IFwiTTQwMDAwMCA2MjBoLTM5OTg5MGwzIC0zYzY4LjcgLTUyLjcgMTEzLjcgLTEyMCAxMzUgLTIwMlxcbmM0IC0xNC43IDYgLTIzIDYgLTI1YzAgLTcuMyAtNyAtMTEgLTIxIC0xMWMtOCAwIC0xMy4yIDAuOCAtMTUuNSAyLjVcXG5jLTIuMyAxLjcgLTQuMiA1LjggLTUuNSAxMi41Yy0xLjMgNC43IC0yLjcgMTAuMyAtNCAxN2MtMTIgNDguNyAtMzQuOCA5MiAtNjguNSAxMzBcXG5zLTc0LjIgNjYuMyAtMTIxLjUgODVjLTEwIDQgLTE2IDcuNyAtMTggMTFjMCA4LjcgNiAxNC4zIDE4IDE3YzQ3LjMgMTguNyA4Ny44IDQ3XFxuMTIxLjUgODVzNTYuNSA4MS4zIDY4LjUgMTMwYzAuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4YzAuMyAxLjMgMSAzLjMgMiA2XFxuczIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjMgMS44IDYgMi41czYgMSAxMCAxYzE0IDAgMjEgLTMuNyAyMSAtMTFcXG5jMCAtMiAtMiAtMTAuMyAtNiAtMjVjLTIwIC03OS4zIC02NSAtMTQ2LjcgLTEzNSAtMjAybC0zIC0zaDM5OTg5MHpcXG5NMTAwIDYyMHY0MGgzOTk5MDB2LTQweiBNMCAyNDF2NDBoMzk5OTAwdi00MHpNMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gcmlnaHRhcnJvd2Fib3ZlYmFyIGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MiwgS2FUZVggTWFpblxuICByaWdodGFycm93YWJvdmViYXI6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjgtMTYuNyAzMlxcbi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMCAxMSA4IDBcXG4xMy4yLS44IDE1LjUtMi41IDIuMy0xLjcgNC4yLTUuNSA1LjUtMTEuNSAyLTEzLjMgNS43LTI3IDExLTQxIDE0LjctNDQuNyAzOVxcbi04NC41IDczLTExOS41czczLjctNjAuMiAxMTktNzUuNWM2LTIgOS01LjcgOS0xMXMtMy05LTktMTFjLTQ1LjMtMTUuMy04NS00MC41XFxuLTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxcbi0xMi41LTIuMy0xLjctNy41LTIuNS0xNS41LTIuNS0xNCAwLTIxIDMuNy0yMSAxMSAwIDIgMiAxMC4zIDYgMjUgMjAuNyA4My4zIDY3XFxuMTUxLjcgMTM5IDIwNXptOTYgMzc5aDM5OTg5NHY0MEgwem0wIDBoMzk5OTA0djQwSDB6XCIsXG4gIC8vIFRoZSBzaG9ydCBsZWZ0IGhhcnBvb24gaGFzIDAuNWVtIChpLmUuIDUwMCB1bml0cykga2VybiBvbiB0aGUgbGVmdCBlbmQuXG4gIC8vIFJlZiBmcm9tIG1oY2hlbS5zdHk6IFxccmxhcHtcXHJhaXNlYm94ey0uMjJleH17JFxca2VybjAuNWVtXG4gIGJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vbjogXCJNNTA3LDQzNWMtNCw0LC02LjMsOC43LC03LDE0YzAsNS4zLDAuNyw5LDIsMTFcXG5jMS4zLDIsNS4zLDUuMywxMiwxMGM5MC43LDU0LDE1NiwxMzAsMTk2LDIyOGMzLjMsMTAuNyw2LjMsMTYuMyw5LDE3XFxuYzIsMC43LDUsMSw5LDFjMCwwLDUsMCw1LDBjMTAuNywwLDE2LjcsLTIsMTgsLTZjMiwtMi43LDEsLTkuNywtMywtMjFcXG5jLTMyLC04Ny4zLC04Mi43LC0xNTcuNywtMTUyLC0yMTFjMCwwLC0zLC0zLC0zLC0zbDM5OTM1MSwwbDAsLTQwXFxuYy0zOTg1NzAsMCwtMzk5NDM3LDAsLTM5OTQzNywweiBNNTkzIDQzNSB2NDAgSDM5OTUwMCB2LTQwelxcbk0wIDI4MSB2LTQwIEgzOTk5MDggdjQweiBNMCAyODEgdi00MCBIMzk5OTA4IHY0MHpcIixcbiAgcmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhcjogXCJNMCwyNDEgbDAsNDBjMzk5MTI2LDAsMzk5OTkzLDAsMzk5OTkzLDBcXG5jNC43LC00LjcsNywtOS4zLDcsLTE0YzAsLTkuMywtMy43LC0xNS4zLC0xMSwtMThjLTkyLjcsLTU2LjcsLTE1OSwtMTMzLjcsLTE5OSxcXG4tMjMxYy0zLjMsLTkuMywtNiwtMTQuNywtOCwtMTZjLTIsLTEuMywtNywtMiwtMTUsLTJjLTEwLjcsMCwtMTYuNywyLC0xOCw2XFxuYy0yLDIuNywtMSw5LjcsMywyMWMxNS4zLDQyLDM2LjcsODEuOCw2NCwxMTkuNWMyNy4zLDM3LjcsNTgsNjkuMiw5Miw5NC41elxcbk0wIDI0MSB2NDAgSDM5OTkwOCB2LTQweiBNMCA0NzUgdi00MCBIMzk5NTAwIHY0MHogTTAgNDc1IHYtNDAgSDM5OTUwMCB2NDB6XCIsXG4gIHNob3J0YmFyYWJvdmVsZWZ0aGFycG9vbjogXCJNNyw0MzVjLTQsNCwtNi4zLDguNywtNywxNGMwLDUuMywwLjcsOSwyLDExXFxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN2MyLDAuNyw1LDEsOSxcXG4xYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxYy0zMiwtODcuMywtODIuNywtMTU3LjcsXFxuLTE1MiwtMjExYzAsMCwtMywtMywtMywtM2wzOTk5MDcsMGwwLC00MGMtMzk5MTI2LDAsLTM5OTk5MywwLC0zOTk5OTMsMHpcXG5NOTMgNDM1IHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6XCIsXG4gIHNob3J0cmlnaHRoYXJwb29uYWJvdmViYXI6IFwiTTUzLDI0MWwwLDQwYzM5ODU3MCwwLDM5OTQzNywwLDM5OTQzNywwXFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxcbmMtMiwyLjcsLTEsOS43LDMsMjFjMTUuMyw0MiwzNi43LDgxLjgsNjQsMTE5LjVjMjcuMywzNy43LDU4LDY5LjIsOTIsOTQuNXpcXG5NNTAwIDI0MSB2NDAgSDM5OTQwOCB2LTQweiBNNTAwIDQzNSB2NDAgSDQwMDAwMCB2LTQwelwiXG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gSXQgb25seSBjb250YWluc1xuICogY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgRE9NIG5vZGUgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgRG9jdW1lbnRGcmFnbWVudCB7XG4gIC8vIEh0bWxEb21Ob2RlXG4gIC8vIE5ldmVyIHVzZWQ7IG5lZWRlZCBmb3Igc2F0aXNmeWluZyBpbnRlcmZhY2UuXG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIGEgbm9kZS4gKi9cblxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cC4gKi9cblxuXG4gIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIlwiOyAvLyBTaW1wbHkgY29uY2F0ZW5hdGUgdGhlIG1hcmt1cCBmb3IgdGhlIGNoaWxkcmVuIHRvZ2V0aGVyLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuIEFwcGxpZXMgdG9cbiAgICogTWF0aERvbU5vZGUncyBvbmx5LlxuICAgKi9cblxuXG4gIHRvVGV4dCgpIHtcbiAgICAvLyBUbyBhdm9pZCB0aGlzLCB3ZSB3b3VsZCBzdWJjbGFzcyBkb2N1bWVudEZyYWdtZW50IHNlcGFyYXRlbHkgZm9yXG4gICAgLy8gTWF0aE1MLCBidXQgcG9seWZpbGxzIGZvciBzdWJjbGFzc2luZyBpcyBleHBlbnNpdmUgcGVyIFBSIDE0NjkuXG4gICAgLy8gJEZsb3dGaXhNZTogT25seSB3b3JrcyBmb3IgQ2hpbGRUeXBlID0gTWF0aERvbU5vZGUuXG4gICAgdmFyIHRvVGV4dCA9IGNoaWxkID0+IGNoaWxkLnRvVGV4dCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKHRvVGV4dCkuam9pbihcIlwiKTtcbiAgfVxuXG59XG5cbi8vIFRoaXMgZmlsZSBpcyBHRU5FUkFURUQgYnkgYnVpbGRNZXRyaWNzLnNoLiBETyBOT1QgTU9ESUZZLlxudmFyIGZvbnRNZXRyaWNzRGF0YSA9IHtcbiAgXCJBTVMtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC41XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjgxXCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAxLjBdLFxuICAgIFwiODhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjVcIjogWzAsIDAuNjc1LCAwLjAyNSwgMCwgMC43NV0sXG4gICAgXCIxNzRcIjogWzAuMTU1NTksIDAuNjkyMjQsIDAsIDAsIDAuOTQ2NjZdLFxuICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjI5NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF0sXG4gICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjc3MFwiOiBbMCwgMC44MjUsIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiNzcxXCI6IFswLCAwLjksIDAsIDAsIDIuMzMzMzRdLFxuICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwMDhcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDAsIDAuNjY2NjddLFxuICAgIFwiODI0NVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC4yNzVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF0sXG4gICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg0OThcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODUwMlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg1MDRcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODUxM1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTRcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODYwMlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDZcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjA4XCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4NjExXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg2MTlcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjIwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDEuMzg4ODldLFxuICAgIFwiODYyMlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiODYyNVwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjg2MzBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzNFwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2MzhcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODYzOVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0NFwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDZcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0OFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1MlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTNcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU1XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjZcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2OVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjcyXCI6IFstMC4wNjQsIDAuNDM3LCAwLCAwLCAxLjMzNF0sXG4gICAgXCI4Njc0XCI6IFstMC4wNjQsIDAuNDM3LCAwLCAwLCAxLjMzNF0sXG4gICAgXCI4NzA1XCI6IFswLCAwLjgyNSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODcwOVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQyOTE3XSxcbiAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLFxuICAgIFwiODcyNFwiOiBbMC4wODE5OCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzhcIjogWzAuMDM1MTcsIDAuNTIyMzksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4yMjIyMl0sXG4gICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg3NDFcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiODc0MlwiOiBbMC4yNTE0MiwgMC43NDExMSwgMCwgMCwgMC41XSxcbiAgICBcIjg3NTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc1N1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY1XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzY5XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc0XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4MlwiOiBbMC4wNjA2MiwgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgzXCI6IFswLjA2MDYyLCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NlwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg3XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5MVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzk2XCI6IFswLjA4MTk4LCAwLjkxNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwN1wiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA4XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxMlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC41XSxcbiAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxNVwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE2XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxOFwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE5XCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyM1wiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI4XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMFwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMxXCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzM1wiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MlwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQzXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0OFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU4XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2MVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYyXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY0XCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY1XCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg3NFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg3OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4ODJcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4M1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODVcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4OFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg4OTFcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg5MlwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg5MDNcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwNVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwOFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTEwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjc2MDQyXSxcbiAgICBcIjg5MTFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzYwNDJdLFxuICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTEzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTRcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MThcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjBcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDEuMzMzMzRdLFxuICAgIFwiODkyMVwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMS4zMzMzNF0sXG4gICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjNcIjogWzAuMzg1NjksIDAuODg1NjksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyNlwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjhcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyOVwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzVcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNlwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzhcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzOVwiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk5NFwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk0MTZcIjogWzAuMTU1NTksIDAuNjkyMjQsIDAsIDAsIDAuOTAyMjJdLFxuICAgIFwiOTQ4NFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjk0ODhcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ5NlwiOiBbMCwgMC4zNzc4OCwgMCwgMCwgMC41XSxcbiAgICBcIjk1ODVcIjogWzAuMTk0NDQsIDAuNjg4ODksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTU4NlwiOiBbMC4xOTQ0NCwgMC43NDExMSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjMzXCI6IFswLCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjUwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY1NFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NjYwXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTY2NFwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5Njc0XCI6IFswLjExMTExLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiMTAwMDNcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTAwMTZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTA4NDZcIjogWzAuMTk0NDQsIDAuNzU1ODMsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTA4NzdcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODVcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODhcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4ODlcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTFcIjogWzAuNDgyNTYsIDAuOTgyNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA4OTJcIjogWzAuNDgyNTYsIDAuOTgyNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MDJcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzNcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzVcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzZcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MzhcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NDlcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTVcIjogWzAuMjg0ODEsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5NTZcIjogWzAuMjg0ODEsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMjIyMjJdLFxuICAgIFwiNTczNTFcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNTczNTJcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDAsIDAuNjY2NjddLFxuICAgIFwiNTczNTZcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTdcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNTlcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjZcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjdcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNjlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzBcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdXG4gIH0sXG4gIFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xOTQ0NSwgMC43OTg0N10sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMC4wMzA0MSwgMC4xMzg4OSwgMC42NTY4MV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNTgzNCwgMC4xMzg4OSwgMC41MjY1M10sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NzEzOV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4wODk0NCwgMC4xMTExMSwgMC41Mjc3OF0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4wOTkzMSwgMC4xMTExMSwgMC43MTg3NV0sXG4gICAgXCI3MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wNTkzLCAwLjExMTExLCAwLjU5NDg3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjAwOTY1LCAwLjExMTExLCAwLjg0NDUyXSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLjA3MzgyLCAwLCAwLjU0NDUyXSxcbiAgICBcIjc0XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3LCAwLjY3Nzc4XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjAxNDQ1LCAwLjA1NTU2LCAwLjc2MTk1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAwLjY4OTcyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAxLjIwMDldLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTQ3MzYsIDAuMDgzMzQsIDAuODIwNDldLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTEsIDAuNzk2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuNjk1NTZdLFxuICAgIFwiODFcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAsIDAuMTExMTEsIDAuODE2NjddLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuODQ3NV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMC4wNzUsIDAuMTM4ODksIDAuNjA1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDAsIDAuNTQ0NjRdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMDgzMzQsIDAuNjI1ODNdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAsIDAuNjEyNzhdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuOTg3NzhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMTQ2NDMsIDAuMTM4ODksIDAuNzEzM10sXG4gICAgXCI4OVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC42NjgzNF0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMC4wNzk0NCwgMC4xMzg4OSwgMC43MjQ3M10sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdXG4gIH0sXG4gIFwiRnJha3R1ci1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI5NTc0XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjM4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjczNzg2XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxMjAxXSxcbiAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjQxXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjQyXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwLCAwLjc1NjIzXSxcbiAgICBcIjQ0XCI6IFswLCAwLjEwODAzLCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQ1XCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwLCAwLjc1NjIzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjQ3XCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjQ4XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUwXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUxXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjUzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU3XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMTgxXSxcbiAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjIxNjA2XSxcbiAgICBcIjU5XCI6IFswLjEyNjA0LCAwLjQ3NTM0LCAwLCAwLCAwLjIxNjA2XSxcbiAgICBcIjYxXCI6IFstMC4xMzA5OSwgMC4zNjg2NiwgMCwgMCwgMC43NTYyM10sXG4gICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zNjI0NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43MTc2XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjg4Mzk3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjYxMjU0XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMTU4XSxcbiAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2Mjc4XSxcbiAgICBcIjcwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjYxMTE5XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjc4NTM5XSxcbiAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwLCAwLjcyMDNdLFxuICAgIFwiNzNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTU0NDhdLFxuICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNTUyMzFdLFxuICAgIFwiNzVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY4NDVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY2MDJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDEuMDQ5NTNdLFxuICAgIFwiNzhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMyMTJdLFxuICAgIFwiNzlcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI2OTldLFxuICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuODI3NTNdLFxuICAgIFwiODFcIjogWzAuMDM3ODEsIDAuNjkxNDEsIDAsIDAsIDAuODI2OTldLFxuICAgIFwiODJcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI4MDddLFxuICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODI4NjFdLFxuICAgIFwiODRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjY4OTldLFxuICAgIFwiODVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjQ1NzZdLFxuICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMxMzFdLFxuICAgIFwiODdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDEuMDQ2MDJdLFxuICAgIFwiODhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzE5MjJdLFxuICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuODMyOTNdLFxuICAgIFwiOTBcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNjAyMDFdLFxuICAgIFwiOTFcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMjc3NjRdLFxuICAgIFwiOTRcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNDk5NjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAwNDZdLFxuICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTEzMTVdLFxuICAgIFwiOTlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMzg5NDZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5ODU3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40MDA1M10sXG4gICAgXCIxMDJcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzI2MjZdLFxuICAgIFwiMTAzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMzddLFxuICAgIFwiMTA0XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjUyMTI2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yNzg5OV0sXG4gICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjgwODhdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjM4OTQ2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yNzk1M10sXG4gICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNzY2NzZdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUyNjY2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40ODg4NV0sXG4gICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDAsIDAuNTAwNDZdLFxuICAgIFwiMTEzXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjQ4OTEyXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4zODkxOV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDQyNjZdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjMzMzAxXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MTcyXSxcbiAgICBcIjExOFwiOiBbMCwgMC41MjM5NiwgMCwgMCwgMC41MTE4XSxcbiAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMCwgMC43NzM1MV0sXG4gICAgXCIxMjBcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuMzg4NjVdLFxuICAgIFwiMTIxXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjQ5ODg0XSxcbiAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC4zOTA1NF0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSxcbiAgICBcIjU4MTEyXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5NzQ5XSxcbiAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjQ5ODNdLFxuICAgIFwiNTgxMTRcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzMzMjhdLFxuICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuMzI5MjNdLFxuICAgIFwiNTgxMTZcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAzNDNdLFxuICAgIFwiNTgxMTdcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzMzMDFdLFxuICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMzM0MDldLFxuICAgIFwiNTgxMTlcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAwNzNdXG4gIH0sXG4gIFwiTWFpbi1Cb2xkXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjM1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzgzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMTU1NTYsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI2MFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQzMDVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODE4MDVdLFxuICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODgxOTRdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzU1NTVdLFxuICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzIzNjFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTA0MTZdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC40MzYxMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC41OTQ0NF0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45MDEzOF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wOTE2Nl0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2Mzg4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc4NjExXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwLCAwLjg2Mzg4XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2MjVdLFxuICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODQ3Ml0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMCwgMC44Njk0NF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMCwgMS4xODg4OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4wMjg3NSwgMCwgMC44Njk0NF0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI5MlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NTkwMl0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUyNzA4XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMCwgMC4zNTEzOV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNTc1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM1MTM5XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ3MzYxXSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NTM2MV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC42MDY5NF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuODMwNTVdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTU5NywgMCwgMC42MDY5NF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTIzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMjRcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMTI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY4NTNdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjE3N1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjA0MTY2XSxcbiAgICBcIjIxNVwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzM0NzIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjIzMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjU0MTY3LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAxLjE2OTQ0XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMzUxMzldLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41OTYxMSwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5MTY2XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNTU1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuNTc1XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDEuMTQ5OTldLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sXG4gICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjgyMjVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC4zNDQ0NF0sXG4gICAgXCI4NDA3XCI6IFswLCAwLjcyNDQ0LCAwLjE1NDg2LCAwLCAwLjU3NV0sXG4gICAgXCI4NDYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjg0NjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzM2MV0sXG4gICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjc0MDI3XSxcbiAgICBcIjg0NzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NTkyXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTkzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk0XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg1OTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MzZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NDBcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NDFcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODY1OFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NjYwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODcwNlwiOiBbMCwgMC42OTQ0NCwgMC4wNjM4OSwgMCwgMC42Mjg0N10sXG4gICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiODcxMlwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzE1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODcyM1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyOFwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjlcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzMwXCI6IFswLjE4LCAwLjgyLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODczNFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODc0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODc0M1wiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEyNzc4LCAwLCAwLjU2ODc1XSxcbiAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODc3MVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzczXCI6IFswLjAyNywgMC42MzgsIDAsIDAsIDAuODk0XSxcbiAgICBcIjg3NzZcIjogWzAuMDI0NDQsIDAuNTI0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODc4MVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODAxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDRcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwNVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODEwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg4MTFcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODgyNlwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODI3XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzRcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzNVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzlcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4ODQ5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTBcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1MVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg4NTNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NFwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTZcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1N1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg4NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODg2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg5MDBcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4OTAxXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4OTAyXCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiODk2OFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NzBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk3MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTk0XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4OTk1XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjAyMjIyXSxcbiAgICBcIjk2NTdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjAyMjIyXSxcbiAgICBcIjk2NjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5NzExXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI2XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI5ODM4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiMTAyMTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiMTA4MTVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCIxMDkyN1wiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCIxMDkyOFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI1NzM3NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMF1cbiAgfSxcbiAgXCJNYWluLUJvbGRJdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTE0MTcsIDAsIDAuMzg2MTFdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDc5MzksIDAsIDAuNjIwNTVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDY4MzMsIDAsIDAuOTQ0NDRdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTI4NjEsIDAsIDAuOTQ0NDRdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAuMDg1MjgsIDAsIDAuODg1NTVdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTU4MDYsIDAsIDAuNDczMzNdLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAuMDMzMDYsIDAsIDAuNDczMzNdLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAuMTQzMzMsIDAsIDAuNTkxMTFdLFxuICAgIFwiNDNcIjogWzAuMTAzMzMsIDAuNjAzMzMsIDAuMDMzMDYsIDAsIDAuODg1NTVdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTQ3MjIsIDAsIDAsIDAuMzU1NTVdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAuMDI2MTEsIDAsIDAuNDE0NDRdLFxuICAgIFwiNDZcIjogWzAsIDAuMTQ3MjIsIDAsIDAsIDAuMzU1NTVdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAuMTU4MDYsIDAsIDAuNTkxMTFdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAuMDY2OTUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDY2OTUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNjFcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLjA2ODMzLCAwLCAwLjg4NTU1XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2NTU1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuODE2NjZdLFxuICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuODI2NjZdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODc1NTVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDAuNzU2NjZdLFxuICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNzI3MjJdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAuMDczNDcsIDAsIDAuODk1MjddLFxuICAgIFwiNzJcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4xNTY4MSwgMCwgMC40NzE2Nl0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODYxMSwgMC4xNDUsIDAsIDAuNjEwNTVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuODk0OTldLFxuICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjk3NzddLFxuICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDEuMDcyNzddLFxuICAgIFwiNzhcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NTQ5OV0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjc4NzIxXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg1NDk5XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4NjExLCAwLjAyNTU5LCAwLCAwLjg1OTQ0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLjExMjY0LCAwLCAwLjY0OTk5XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjc5NjFdLFxuICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODgwODNdLFxuICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMTg2MjUsIDAsIDAuODY1NTVdLFxuICAgIFwiODdcIjogWzAsIDAuNjg2MTEsIDAuMTg2MjUsIDAsIDEuMTU5OTldLFxuICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAuMTU2ODEsIDAsIDAuODY1NTVdLFxuICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMTk4MDMsIDAsIDAuODY1NTVdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuNzA4ODhdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTg3NSwgMCwgMC4zNTYxMV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4wOTk3MiwgMCwgMC4zNTYxMV0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMC4wNjcwOSwgMCwgMC41OTExMV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMzQ0NCwgMC4wOTgxMSwgMCwgMC41OTExMV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC41OTExMV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMC4wNzg2MSwgMCwgMC41MzIyMl0sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMC4wNTIyMiwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTA4NjEsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMjE3NzgsIDAsIDAuNF0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQyNiwgMCwgMC41OTExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkzMjYsIDAuMTEzODcsIDAsIDAuMzU1NTVdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5MzI2LCAwLjE2NzIsIDAsIDAuMzU1NTVdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjUzMjIyXSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDg2MSwgMCwgMC4yOTY2Nl0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuOTQ0NDRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjY0OTk5XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMC4wNzg2MSwgMCwgMC41OTExMV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDc4NjEsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNTAxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLjA4MTY3LCAwLCAwLjQ4Njk0XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MzQ5MiwgMC4wOTYzOSwgMCwgMC4zODVdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjYyMDU1XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNzY3NzddLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLjEyNTgzLCAwLCAwLjU2MDU1XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTYxNjZdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLjEzODg5LCAwLCAwLjQ5MDU1XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLjExNDczLCAwLCAwLjU5MTExXSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45NDg4OF0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAxLjAyMjc3XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzQ3MiwgMC4wOTA2MiwgMCwgMC44ODU1NV0sXG4gICAgXCIyMjNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDk3MzYsIDAsIDAuNjY1XSxcbiAgICBcIjIzMFwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuODI2NjZdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjU0MTY3LCAwLjA5NDU4LCAwLCAwLjU5MTExXSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC4zNTU1NV0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDEuMTQwNTRdLFxuICAgIFwiMzM5XCI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC44MjY2Nl0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQ2MTEsIDAsIDAuMzg1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMC4wNjcwOSwgMCwgMC41OTExMV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAuMDgyNzEsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU5NDQ0LCAwLjEwNDQ0LCAwLCAwLjU5MTExXSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMC4wODUyOCwgMCwgMC41OTExMV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjU5MTExXSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTQ4ODhdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNjk3NzddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44ODU1NV0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA2NjZdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjE1MDkyLCAwLCAwLjc2Nzc3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMC44MjY2Nl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjg2MTEsIDAuMTA3NzgsIDAsIDAuODg1NTVdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLjA1NjMyLCAwLCAwLjgyNjY2XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMDc3OCwgMCwgMC44ODU1NV0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC44MjY2Nl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjA5ODExLCAwLCAwLjU5MTExXSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDk4MTEsIDAsIDEuMTgyMjFdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTY3NzIsIDAsIDAuNjIwNTVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMC4wNzkzOSwgMCwgMC42MjA1NV1cbiAgfSxcbiAgXCJNYWluLUl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMC4wNjk2MSwgMCwgMC41MTQ0NF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjYxNiwgMCwgMC44MTc3N10sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4xMzYzOSwgMCwgMC44MTc3N10sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wOTY5NCwgMCwgMC43NjY2Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xNjE5NCwgMCwgMC40MDg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMzY5NCwgMCwgMC40MDg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDkxNywgMCwgMC41MTExMV0sXG4gICAgXCI0M1wiOiBbMC4wNTY2NywgMC41NjE2NywgMC4wMzY5NCwgMCwgMC43NjY2Nl0sXG4gICAgXCI0NFwiOiBbMC4xOTQ0NCwgMC4xMDU1NiwgMCwgMCwgMC4zMDY2N10sXG4gICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMC4wMjgyNiwgMCwgMC4zNTc3OF0sXG4gICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMCwgMC4zMDY2N10sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xNjE5NCwgMCwgMC41MTExMV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMCwgMC41MTExMV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMC4wNTgyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA1ODIsIDAsIDAuMzA2NjddLFxuICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLjA2NjE2LCAwLCAwLjc2NjY2XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLjEyMjUsIDAsIDAuNTExMTFdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAuMDk1OTcsIDAsIDAuNzY2NjZdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzQzMzNdLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNzAzODldLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNzE1NTVdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzU1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjY3ODMzXSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjY1Mjc3XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4MzMzLCAwLjA4NzIyLCAwLCAwLjc3MzYxXSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLjE1ODA2LCAwLCAwLjM4NTU1XSxcbiAgICBcIjc0XCI6IFswLCAwLjY4MzMzLCAwLjE0MDI4LCAwLCAwLjUyNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMCwgMC43Njg4OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjcyMl0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC44OTY2Nl0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC42NzgzM10sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMzg2OCwgMCwgMC43Mjk0NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMC4xMTk3MiwgMCwgMC41NjIyMl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC43MTU1NV0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4xODM2MSwgMCwgMC43NDMzM10sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4xODM2MSwgMCwgMC45OTg4OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMCwgMC43NDMzM10sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4xOTM4MywgMCwgMC43NDMzM10sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMCwgMC42MTMzM10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwLCAwLjMwNjY3XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjEwNTI4LCAwLCAwLjMwNjY3XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA2NjQ2LCAwLCAwLjUxMTExXSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjA5MjA4LCAwLCAwLjUxMTExXSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjUxMTExXSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjA2MzEyLCAwLCAwLjQ2XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLjA1NjUzLCAwLCAwLjQ2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC41MTExMV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNDZdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxMTk0LCAwLCAwLjMwNjY3XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMCwgMC40Nl0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAuMDc2NzEsIDAsIDAuNTExMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY1NTM2LCAwLjEwMTksIDAsIDAuMzA2NjddLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY1NTM2LCAwLjE0NDY3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4xMDc2NCwgMCwgMC40Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuMjU1NTVdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjgxNzc3XSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41NjIyMl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAuMDYzMTIsIDAsIDAuNTExMTFdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA2MzEyLCAwLCAwLjUxMTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMCwgMC40Nl0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNDIxNjZdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLjA4MjA4LCAwLCAwLjQwODg5XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMC4wOTQ4NiwgMCwgMC4zMzIyMl0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTM2NjZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjQ2XSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC42NjQ0NF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAuMTIwNDIsIDAsIDAuNDYzODldLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ4NTU1XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4xMjI5MiwgMCwgMC40MDg4OV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAuMTE1ODUsIDAsIDAuNTExMTFdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42Njc4NiwgMC4xMDQ3NCwgMCwgMC41MTExMV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMxMjldLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ2XSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC44ODI3N10sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzMxOTQsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiMjIzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNTE0LCAwLCAwLjUzNjY2XSxcbiAgICBcIjIzMFwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC43MTU1NV0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTI3NzgsIDAuMDkxOTQsIDAsIDAuNTExMTFdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjk4NDk5XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC43MTU1NV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDAsIDAuNTExMTFdLFxuICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLjA4Mjk1LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxM1wiOiBbMCwgMC41NjE2NywgMC4xMDMzMywgMCwgMC41MTExMV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDk2OTQsIDAsIDAuNTExMTFdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDgwNiwgMCwgMC41MTExMV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjY3ODYsIDAuMTE3NTIsIDAsIDAuMzA2NjddLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMTI5XSxcbiAgICBcIjczMlwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMCwgMC41MTExMV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMTIyNSwgMCwgMC41MTExMV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNjI3MjJdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgxNzc3XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NjY2Nl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjkyMjJdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwLCAwLjY2NDQ0XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuNzE1NTVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMC4wNTk4NiwgMCwgMC43MTU1NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTExMTEsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjcxNTU1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDMwNTYsIDAuMDkyMDgsIDAsIDAuNTExMTFdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40MzA1NiwgMC4wOTIwOCwgMCwgMS4wMjIyMl0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNjg1LCAwLCAwLjUxNDQ0XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDAsIDAuNTE0NDRdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF1cbiAgfSxcbiAgXCJNYWluLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjJcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc2Mzg5XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY4MDU2XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY1Mjc4XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc4NDcyXSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjM2MTExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjUxMzg5XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNV0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC45MTY2N10sXG4gICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wMTM4OSwgMCwgMC43NV0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4wMTM4OSwgMCwgMS4wMjc3OF0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4wMjUsIDAsIDAuNzVdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiOTJcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42Njc4NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMzkxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5NDQ1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjUyNzc4XSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC43MjIyMl0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMjNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIxMjRcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMTI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMxNzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NjkwOV0sXG4gICAgXCIxNjdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjVdLFxuICAgIFwiMTcyXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NV0sXG4gICAgXCIxNzdcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTgyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxOThcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTAyNzhdLFxuICAgIFwiMjE1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjIxNlwiOiBbMC4wNDg2MSwgMC43MzE5NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyMjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiMjQ3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41Mjc3OCwgMCwgMCwgMC41XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIzMzhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDEuMDEzODldLFxuICAgIFwiMzM5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjI4NDcsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1XSxcbiAgICBcIjczMlwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjgyMzBcIjogWzAsIDAuMTIzLCAwLCAwLCAxLjE3Ml0sXG4gICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjI3NV0sXG4gICAgXCI4NDA3XCI6IFswLCAwLjcxNDQ0LCAwLjE1MzgyLCAwLCAwLjVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NDAyOF0sXG4gICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg0NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTExMTEsIDAuNDE2NjddLFxuICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4xMTExMSwgMC42MzY0Nl0sXG4gICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg1MDFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODU5MlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTkzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODU5NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODU5NlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg1OTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MTRcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MTdcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4xMjZdLFxuICAgIFwiODYxOFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjEyNl0sXG4gICAgXCI4NjM2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2MzdcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0MFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTJcIjogWzAuMDExLCAwLjY3MSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NjU4XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODY2MFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODcwNlwiOiBbMCwgMC42OTQ0NCwgMC4wNTU1NiwgMC4wODMzNCwgMC41MzA5XSxcbiAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODcwOVwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MTFcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODcxMlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODcxNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODcyMlwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzIzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyN1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI4XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjlcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLFxuICAgIFwiODczMFwiOiBbMC4yLCAwLjgsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODczM1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzM0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxLjBdLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTExMTEsIDAsIDAuNDE2NjddLFxuICAgIFwiODc2NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzcxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzczXCI6IFstMC4wMjIsIDAuNTg5LCAwLCAwLCAwLjc3OF0sXG4gICAgXCI4Nzc2XCI6IFstMC4wMTY4OCwgMC40ODMxMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg0XCI6IFstMC4xMzMsIDAuNjczLCAwLCAwLCAwLjc3OF0sXG4gICAgXCI4ODAxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA0XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDVcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxMFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4ODExXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4MjZcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjdcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzRcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzhcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzOVwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg4NDlcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg4NTJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODg1M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU0XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NlwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg3MlwiOiBbMC4yNDksIDAuNzUsIDAsIDAsIDAuODY3XSxcbiAgICBcIjg5MDBcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLFxuICAgIFwiODkwMVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODkwMlwiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sXG4gICAgXCI4OTA0XCI6IFswLjAwNSwgMC41MDUsIDAsIDAsIDAuOV0sXG4gICAgXCI4OTQyXCI6IFswLjAzLCAwLjkwMywgMCwgMCwgMC4yNzhdLFxuICAgIFwiODk0M1wiOiBbLTAuMTksIDAuMzEzLCAwLCAwLCAxLjE3Ml0sXG4gICAgXCI4OTQ1XCI6IFstMC4xLCAwLjgyMywgMCwgMCwgMS4yODJdLFxuICAgIFwiODk2OFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NzBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk3MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg5OTVcIjogWy0wLjE0MjM2LCAwLjM1NzY0LCAwLCAwLCAxLjBdLFxuICAgIFwiOTEzNlwiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwLCAwLjQxMl0sXG4gICAgXCI5MTM3XCI6IFswLjI0NCwgMC43NDUsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTY1N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2NjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI2XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI5ODM4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMTdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NSwgMCwgMCwgMC40MTJdLFxuICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MDldLFxuICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS44NTldLFxuICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS42MDldLFxuICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMCwgMS44NThdLFxuICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS42MzhdLFxuICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTA5MjdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMTA5MjhcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNTczNzZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdXG4gIH0sXG4gIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMC4wNDgzNSwgMCwgMC44NjY0XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjgxNjk0XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjkzODEyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwLCAwLjgxMDA3XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY4ODg5XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4NjczXSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwLCAwLjk4MjI5XSxcbiAgICBcIjczXCI6IFswLCAwLjY4NjExLCAwLjA3Nzc4LCAwLCAwLjUxMTExXSxcbiAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLjEwMDY5LCAwLCAwLjYzMTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjk3MTE4XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc1NTU1XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAxLjE0MjAxXSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAwLjk1MDM0XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjgzNjY2XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjcyMzA5XSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwLCAwLjg2ODYxXSxcbiAgICBcIjgyXCI6IFswLCAwLjY4NjExLCAwLjAwNDIxLCAwLCAwLjg3MjM1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLjA1MzgyLCAwLCAwLjY5MjcxXSxcbiAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjYzNjYzXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAwLjgwMDI3XSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3Nzc4XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAxLjA5MzA1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLjA3Nzc4LCAwLCAwLjk0NzIyXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3NDU4XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjc3MjU3XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzMjg3XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyMDgzXSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMzQyXSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDk3Ml0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTUzNjFdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwLCAwLjU2ODA2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDQ5XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkzMjYsIDAsIDAsIDAuNDA0OF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMCwgMC40NzA4M10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMDE4NTIsIDAsIDAuNjAzN10sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMCwgMC4zNDgxNV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMDMyNF0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzEyOTZdLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU4NDcyXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MDA5Ml0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTQyMTNdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjUyODddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUzMTI1XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MzQ5MiwgMCwgMCwgMC40MTUyOF0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjgxMDJdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU2NjY2XSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMC44MzE0OF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjU5MDNdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU5MDI4XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4wNDIxMywgMCwgMC41NTUwOV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY1Njk0XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDAsIDAuODY3MjJdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNTU1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMC4wNzQ1OCwgMCwgMC44NDEyNV0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDAsIDAuOTgyMjldLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwLCAwLjg4NTA3XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42NzA4M10sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLjExNjUzLCAwLCAwLjcxNDAyXSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMC4wNDgzNSwgMCwgMC44Nzg5XSxcbiAgICBcIjk0NVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43NjA2NF0sXG4gICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDM0MDMsIDAsIDAuNjU5NzJdLFxuICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Mzg5LCAwLCAwLjU5MDAzXSxcbiAgICBcIjk0OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzgxOSwgMCwgMC41MjIyMl0sXG4gICAgXCI5NDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTI4ODJdLFxuICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2MjE1LCAwLCAwLjUwODMzXSxcbiAgICBcIjk1MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42XSxcbiAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMzE5NCwgMCwgMC41NjE4XSxcbiAgICBcIjk1M1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40MTIwNF0sXG4gICAgXCI5NTRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjY3NTldLFxuICAgIFwiOTU1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MDgzXSxcbiAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43MDc4N10sXG4gICAgXCI5NTdcIjogWzAsIDAuNDQ0NDQsIDAuMDY4OTgsIDAsIDAuNTc2ODVdLFxuICAgIFwiOTU4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzMDIxLCAwLCAwLjUwODMzXSxcbiAgICBcIjk1OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41ODQ3Ml0sXG4gICAgXCI5NjBcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjgyNDFdLFxuICAgIFwiOTYxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYxMThdLFxuICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQ0NDQ0LCAwLjA3OTE3LCAwLCAwLjQyMzYxXSxcbiAgICBcIjk2M1wiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42ODU4OF0sXG4gICAgXCI5NjRcIjogWzAsIDAuNDQ0NDQsIDAuMTM0NzIsIDAsIDAuNTIwODNdLFxuICAgIFwiOTY1XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjYzMDU1XSxcbiAgICBcIjk2NlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43NDcyMl0sXG4gICAgXCI5NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzE4MDVdLFxuICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNzA0LCAwLCAwLjc1ODMzXSxcbiAgICBcIjk2OVwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC43MTc4Ml0sXG4gICAgXCI5NzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjkxNTVdLFxuICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcxMjVdLFxuICAgIFwiOTgyXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjk3NV0sXG4gICAgXCIxMDA5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYxMThdLFxuICAgIFwiMTAxM1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40ODMzM10sXG4gICAgXCI1NzY0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zOTM1Ml0sXG4gICAgXCI1NzkxMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC40Mzg4OV1cbiAgfSxcbiAgXCJNYXRoLUl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAwLjc1XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc1ODUxXSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0LCAwLjcxNDcyXSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA1NTU2LCAwLjgyNzkyXSxcbiAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjczODJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQzMDZdLFxuICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzg2MjVdLFxuICAgIFwiNzJcIjogWzAsIDAuNjgzMzMsIDAuMDgxMjUsIDAuMDU1NTYsIDAuODMxMjVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDc4NDcsIDAuMTExMTEsIDAuNDM5NThdLFxuICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjcsIDAuNTU0NTFdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDU1NTYsIDAuODQ5MzFdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDI3NzgsIDAuNjgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuOTcwMTRdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzQsIDAuODAzNDddLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzYyNzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjQyMDFdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuNzkwNTZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDA3NzMsIDAuMDgzMzQsIDAuNzU5MjldLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNjEzMl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC41ODQzOF0sXG4gICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OCwgMC42ODI3OF0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODMzM10sXG4gICAgXCI4N1wiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNCwgMC44Mjg0N10sXG4gICAgXCI4OVwiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODA1Nl0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC42ODI2NF0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41Mjg1OV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40MjkxN10sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40MzI3Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjcsIDAuNTIwNDldLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2NTYzXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDc2NCwgMC4xNjY2NywgMC40ODk1OV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDc2OTddLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTk1MiwgMCwgMCwgMC4zNDQ1MV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDAsIDAuNDExODFdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAzMTQ4LCAwLCAwLjUyMDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0LCAwLjI5ODM4XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44NzgwMV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjAwMjNdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ4NDcyXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MDMxM10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDgzMzQsIDAuNDQ2NDFdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2LCAwLjQ1MTE2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40Njg3NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAuMDgzMzQsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MjQ2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40ODQ3Ml0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDI2OTEsIDAuMDgzMzQsIDAuNzE1OTJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MTUzXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTAyOF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMDQzOTgsIDAuMDU1NTYsIDAuNDY1MDVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42MTUyOF0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc2Mjc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMC4xNjY2NywgMC42OTQ0NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzQsIDAuNzQyMzZdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2LCAwLjgzMTI1XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC43Nzk4Nl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTYsIDAuNTgzMzNdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjY2NjY3XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMSwgMC4wNTU1NiwgMC42MTIyMl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzQsIDAuNzcyNF0sXG4gICAgXCI5NDVcIjogWzAsIDAuNDMwNTYsIDAuMDAzNywgMC4wMjc3OCwgMC42Mzk3XSxcbiAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNTI3OCwgMC4wODMzNCwgMC41NjU2M10sXG4gICAgXCI5NDdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU1NTYsIDAsIDAuNTE3NzNdLFxuICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2LCAwLjQ0NDQ0XSxcbiAgICBcIjk0OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC40NjYzMl0sXG4gICAgXCI5NTBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDczNzgsIDAuMDgzMzQsIDAuNDM3NV0sXG4gICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTYsIDAuNDk2NTNdLFxuICAgIFwiOTUyXCI6IFswLCAwLjY5NDQ0LCAwLjAyNzc4LCAwLjA4MzM0LCAwLjQ2OTQ0XSxcbiAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC4zNTM5NF0sXG4gICAgXCI5NTRcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTc2MTZdLFxuICAgIFwiOTU1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC42MDI1NV0sXG4gICAgXCI5NTdcIjogWzAsIDAuNDMwNTYsIDAuMDYzNjYsIDAuMDI3NzgsIDAuNDkzOThdLFxuICAgIFwiOTU4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA0NjAxLCAwLjExMTExLCAwLjQzNzVdLFxuICAgIFwiOTU5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ4NDcyXSxcbiAgICBcIjk2MFwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC41NzAwM10sXG4gICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNTE3MDJdLFxuICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQzMDU2LCAwLjA3OTg2LCAwLjA4MzM0LCAwLjM2Mjg1XSxcbiAgICBcIjk2M1wiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC41NzE0MV0sXG4gICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OCwgMC40MzcxNV0sXG4gICAgXCI5NjVcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNTQwMjhdLFxuICAgIFwiOTY2XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjY1NDE3XSxcbiAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC42MjU2OV0sXG4gICAgXCI5NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDM1ODgsIDAuMTExMTEsIDAuNjUxMzldLFxuICAgIFwiOTY5XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjYyMjQ1XSxcbiAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNCwgMC41OTE0NF0sXG4gICAgXCI5ODFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAuMDgzMzQsIDAuNTk1ODNdLFxuICAgIFwiOTgyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAwLjgyODEzXSxcbiAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNTE3MDJdLFxuICAgIFwiMTAxM1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40MDU5XSxcbiAgICBcIjU3NjQ5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjMyMjQ2XSxcbiAgICBcIjU3OTExXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjM4NDAzXVxuICB9LFxuICBcIlNhbnNTZXJpZi1Cb2xkXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjM2NjY3XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1ODM0XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjkxNjY3XSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU1XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAxLjAyOTEyXSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU2XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQyNzc4XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQyNzc4XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjU1XSxcbiAgICBcIjQzXCI6IFswLjExNjY3LCAwLjYxNjY3LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjQ0XCI6IFswLjEwNTU2LCAwLjEzMDU2LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjM2NjY3XSxcbiAgICBcIjQ2XCI6IFswLCAwLjEzMDU2LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjUwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjUxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjUyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjUzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjU0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjU1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjU2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjU3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjU5XCI6IFswLjEwNTU2LCAwLjQ1ODMzLCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjYxXCI6IFstMC4wOTM3NSwgMC40MDYyNSwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTk0NV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3OF0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NDE2N10sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMzA1Nl0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTk0NV0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NjM4OV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODA1Nl0sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45Nzc3OF0sXG4gICAgXCI3OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3OF0sXG4gICAgXCI4MVwiOiBbMC4xMDU1NiwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3OF0sXG4gICAgXCI4M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NjM4OV0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTQ0NCwgMC4wMTUyOCwgMCwgMC43MzMzNF0sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4wMTUyOCwgMCwgMS4wMzg4OV0sXG4gICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI4OVwiOiBbMCwgMC42OTQ0NCwgMC4wMjc1LCAwLCAwLjczMzM0XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MjIzXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM0MzA2XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM0MzA2XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjk1XCI6IFswLjM1LCAwLjEwODMzLCAwLjAzMDU2LCAwLCAwLjU1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCI5OVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzYzOSwgMCwgMC4zMzYxMV0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuNTVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNTU1Nl0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMjg2MTFdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUzMDU2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNTU1Nl0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuODY2NjddLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExMVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC4zNzIyMl0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDIxNjddLFxuICAgIFwiMTE2XCI6IFswLCAwLjU4OTI5LCAwLCAwLCAwLjQwNDE3XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuNV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuNzQ0NDVdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjVdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjVdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQ3NjM5XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCIxODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4yNTU1Nl0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDU4MzMsIDAsIDAsIDAuMjg2MTFdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcxMVwiOiBbMCwgMC42MzU0MiwgMCwgMCwgMC41NV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNjM3NzgsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjkxNjY3XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcyMjNdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDAuNTVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40NTgzMywgMC4wMzA1NiwgMCwgMS4xMDAwMV0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1ODM0XVxuICB9LFxuICBcIlNhbnNTZXJpZi1JdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMDU3MzMsIDAsIDAuMzE5NDVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDAzMTYsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNTA4NywgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjAzMTI2LCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU4LCAwLCAwLjc1ODM0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjEzMTY0LCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAyNTM2LCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjExNzc1LCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAuMDI1MzYsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTI1LCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLjAxOTQ2LCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjEzMTY0LCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMC4wMjUwMiwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAuMDI1MDIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzLCAwLjM3LCAwLjA1MDg3LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLjExODA5LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjYzODg5XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjcyMjIzXSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjU5NzIyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjU2OTQ1XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjg3NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MzYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42Mzg4OV0sXG4gICAgXCI4MVwiOiBbMC4xMjUsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzM2MTFdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjQ1ODRdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNjgwNTZdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNjg3NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTQ0NCwgMC4xNjE1LCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjE2MTUsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNjY2NjddLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMTcyNjEsIDAsIDAuNjY2NjddLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTU5NDIsIDAsIDAuMjg4ODldLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMDg3MTksIDAsIDAuMjg4ODldLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDc5OSwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjM1LCAwLjA5NDQ0LCAwLjA4NjE2LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAuMDA5ODEsIDAsIDAuNDgwNTZdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDMwNTcsIDAsIDAuNTE2NjddLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAuMDgzMzYsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMC4wNjc3OCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMjE3MDUsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjAxNzc4LCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NzkzNywgMC4wOTcxOCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjc5MzcsIDAuMDkxNjIsIDAsIDAuMjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MzM2LCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAuMDE3NzgsIDAsIDAuNzk0NDVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMC4wNjYxMywgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzg5LCAwLCAwLjUxNjY3XSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuMzQxNjddLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLjA3NzgsIDAsIDAuMzgzMzNdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLjA3MjI1LCAwLCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjY4MzM0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMC4wOTE2OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA4MzYsIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NzUyLCAwLCAwLjQzNDcyXSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMjY1OSwgMC4wODgyNiwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjc5MzcsIDAuMDYzODUsIDAsIDAuNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzM3NTJdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMC4wNDE2OSwgMCwgMC4yMzg4OV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuMjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA3OTksIDAsIDAuNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAuMDg0MzIsIDAsIDAuNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNjA4ODksIDAuMDg3NzYsIDAsIDAuNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuNV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjc5MzcsIDAuMDc3NzQsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNzUyXSxcbiAgICBcIjczMlwiOiBbMCwgMC42NzY1OSwgMC4wODgyNiwgMCwgMC41XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC41NDE2N10sXG4gICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAuMTI4MTYsIDAsIDAuNjY2NjddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC43MjIyMl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAuMDkwMzEsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY5NDQ0LCAwLjA0NjAzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzNlwiOiBbMCwgMC42OTQ0NCwgMC4wOTAzMSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNzIyMjJdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wODYxNiwgMCwgMC41XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDg2MTYsIDAsIDEuMF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMC4xNDIwNSwgMCwgMC41XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDAzMTYsIDAsIDAuNV1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzU4MzRdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI0NFwiOiBbMC4xMjUsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzMzMzNdLFxuICAgIFwiNDZcIjogWzAsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjU5XCI6IFswLjEyNSwgMC40NDQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MVwiOiBbLTAuMTMsIDAuMzcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjNdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTY5NDVdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjk0NDVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODc1XSxcbiAgICBcIjc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjgxXCI6IFswLjEyNSwgMC42OTQ0NCwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NDU4NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODc1XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjAyNSwgMCwgMC42NjY2N10sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjk1XCI6IFswLjM1LCAwLjA5NDQ0LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgwNTZdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NzkzNywgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjc5MzcsIDAsIDAsIDAuMjY2NjddLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ4ODg5XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjM0MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zODMzM10sXG4gICAgXCIxMTZcIjogWzAsIDAuNTcxNDMsIDAsIDAsIDAuMzYxMTFdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNjgzMzRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDM0NzJdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMyNjU5LCAwLCAwLCAwLjVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42NzkzNywgMCwgMCwgMC41XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjIzODg5XSxcbiAgICBcIjU2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC4yNjY2N10sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjMxOTQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNjA4ODksIDAsIDAsIDAuNV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjczMlwiOiBbMCwgMC42NzY1OSwgMCwgMCwgMC41XSxcbiAgICBcIjczM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDEuMF0sXG4gICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV1cbiAgfSxcbiAgXCJTY3JpcHQtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI2NVwiOiBbMCwgMC43LCAwLjIyOTI1LCAwLCAwLjgwMjUzXSxcbiAgICBcIjY2XCI6IFswLCAwLjcsIDAuMDQwODcsIDAsIDAuOTA3NTddLFxuICAgIFwiNjdcIjogWzAsIDAuNywgMC4xNjg5LCAwLCAwLjY2NjE5XSxcbiAgICBcIjY4XCI6IFswLCAwLjcsIDAuMDkzNzEsIDAsIDAuNzc0NDNdLFxuICAgIFwiNjlcIjogWzAsIDAuNywgMC4xODU4MywgMCwgMC41NjE2Ml0sXG4gICAgXCI3MFwiOiBbMCwgMC43LCAwLjEzNjM0LCAwLCAwLjg5NTQ0XSxcbiAgICBcIjcxXCI6IFswLCAwLjcsIDAuMTczMjIsIDAsIDAuNjA5NjFdLFxuICAgIFwiNzJcIjogWzAsIDAuNywgMC4yOTY5NCwgMCwgMC45NjkxOV0sXG4gICAgXCI3M1wiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjgwOTA3XSxcbiAgICBcIjc0XCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDAsIDEuMDUxNTldLFxuICAgIFwiNzVcIjogWzAsIDAuNywgMC4zMTI1OSwgMCwgMC45MTM2NF0sXG4gICAgXCI3NlwiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjg3MzczXSxcbiAgICBcIjc3XCI6IFswLCAwLjcsIDAuMTU5ODEsIDAsIDEuMDgwMzFdLFxuICAgIFwiNzhcIjogWzAsIDAuNywgMC4zNTI1LCAwLCAwLjkwMTVdLFxuICAgIFwiNzlcIjogWzAsIDAuNywgMC4wODA3OCwgMCwgMC43Mzc4N10sXG4gICAgXCI4MFwiOiBbMCwgMC43LCAwLjA4MDc4LCAwLCAxLjAxMjYyXSxcbiAgICBcIjgxXCI6IFswLCAwLjcsIDAuMDMzMDUsIDAsIDAuODgyODJdLFxuICAgIFwiODJcIjogWzAsIDAuNywgMC4wNjI1OSwgMCwgMC44NV0sXG4gICAgXCI4M1wiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjg2NzY3XSxcbiAgICBcIjg0XCI6IFswLCAwLjcsIDAuMjkwODcsIDAsIDAuNzQ2OTddLFxuICAgIFwiODVcIjogWzAsIDAuNywgMC4yNTgxNSwgMCwgMC43OTk5Nl0sXG4gICAgXCI4NlwiOiBbMCwgMC43LCAwLjI3NTIzLCAwLCAwLjYyMjA0XSxcbiAgICBcIjg3XCI6IFswLCAwLjcsIDAuMjc1MjMsIDAsIDAuODA1MzJdLFxuICAgIFwiODhcIjogWzAsIDAuNywgMC4yNjAwNiwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OVwiOiBbMCwgMC43LCAwLjI5MzksIDAsIDAuNzA5NjFdLFxuICAgIFwiOTBcIjogWzAsIDAuNywgMC4yNDAzNywgMCwgMC44MjEyXSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV1cbiAgfSxcbiAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ1ODM0XSxcbiAgICBcIjQxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ1ODM0XSxcbiAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU3Nzc4XSxcbiAgICBcIjkxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjkyXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU3Nzc4XSxcbiAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjEyM1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMjVcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzcwXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjc3MVwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODU5M1wiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NTk1XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODY1OVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzE5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODcyMVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI4NzMwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAxLjBdLFxuICAgIFwiODczOVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjg3NDFcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzQ4XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc0OVwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg4OTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5N1wiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODk2OFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk3MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTAyMTZcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTAyMTdcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTNcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTRcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTA3NThcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdXG4gIH0sXG4gIFwiU2l6ZTItUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI0MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCI0N1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44MTExMV0sXG4gICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI5MlwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44MTExMV0sXG4gICAgXCI5M1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTI1XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI3NzBcIjogWzAsIDAuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NzE5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjg3MjBcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMjc3NzhdLFxuICAgIFwiODcyMVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI4NzMwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAxLjBdLFxuICAgIFwiODc0N1wiOiBbMC44NjIyNSwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzQ4XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzQ5XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NzUwXCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg4OTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5N1wiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODk2OFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTY5XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk3MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMDIxNlwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxMDIxN1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxMDc1MlwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sXG4gICAgXCIxMDc1M1wiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sXG4gICAgXCIxMDc1NFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sXG4gICAgXCIxMDc1NlwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCIxMDc1OFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV1cbiAgfSxcbiAgXCJTaXplMy1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjQxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjczNjExXSxcbiAgICBcIjQ3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAxLjA0NDQ1XSxcbiAgICBcIjkxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjkyXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAxLjA0NDQ1XSxcbiAgICBcIjkzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyM1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sXG4gICAgXCIxMjVcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzcwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjc3MVwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAxLjBdLFxuICAgIFwiODk2OFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NzBcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk3MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sXG4gICAgXCIxMDIxN1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV1cbiAgfSxcbiAgXCJTaXplNC1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjc5MTY3XSxcbiAgICBcIjQxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjc5MTY3XSxcbiAgICBcIjQ3XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjkyXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjkzXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sXG4gICAgXCIxMjVcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzcwXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjc3MVwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODk2OFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NzBcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk3MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyMlwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjNcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjVcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI2XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEyOVwiOiBbMC45MDAwMSwgMCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMVwiOiBbMWUtMDUsIDAuOSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMyXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTE0M1wiOiBbMC44ODUwMiwgMC45MTUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiMTAyMTZcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiNTczNDRcIjogWy0wLjAwNDk5LCAwLjYwNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI1NzM0NVwiOiBbLTAuMDA0OTksIDAuNjA1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgxXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgyXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XSxcbiAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwLCAwLjQ1XVxuICB9LFxuICBcIlR5cGV3cml0ZXItUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzZcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQwXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDJcIjogWzAsIDAuNTIwODMsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQzXCI6IFstMC4wODA1NiwgMC41MzA1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDRcIjogWzAuMTM4ODksIDAuMTI1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NVwiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ2XCI6IFswLCAwLjEyNSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDdcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTlcIjogWzAuMTM4ODksIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYwXCI6IFstMC4wNTU1NiwgMC41NTU1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjFcIjogWy0wLjE5NTQ5LCAwLjQxNTYyLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MlwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgxXCI6IFswLjEzODg5LCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTJcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTVcIjogWzAuMDk1MTQsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDZcIjogWzAuMjIyMjIsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTJcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExM1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNlwiOiBbMCwgMC41NTM1OCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjFcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIzXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjRcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNVwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxODRcIjogWzAuMTk0NDUsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTY3XCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNTY1OTcsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxM1wiOiBbMCwgMC41NjU1NSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzMwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTIwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODI0MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTI1MVwiOiBbMC4xMTExMSwgMC4yMTk0NCwgMCwgMCwgMC41MjVdXG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIG1ldHJpY3MgcmVnYXJkaW5nIGZvbnRzIGFuZCBpbmRpdmlkdWFsIHN5bWJvbHMuIFRoZSBzaWdtYVxuICogYW5kIHhpIHZhcmlhYmxlcywgYXMgd2VsbCBhcyB0aGUgbWV0cmljTWFwIG1hcCBjb250YWluIGRhdGEgZXh0cmFjdGVkIGZyb21cbiAqIFRlWCwgVGVYIGZvbnQgbWV0cmljcywgYW5kIHRoZSBUVEYgZmlsZXMuIFRoZXNlIGRhdGEgYXJlIHRoZW4gZXhwb3NlZCB2aWEgdGhlXG4gKiBgbWV0cmljc2AgdmFyaWFibGUgYW5kIHRoZSBnZXRDaGFyYWN0ZXJNZXRyaWNzIGZ1bmN0aW9uLlxuICovXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlIChzaXplIGluZGV4IDUgYW5kIGhpZ2hlcjogPj05cHQpLCBzY3JpcHRzdHlsZSAoc2l6ZSBpbmRleCAzIGFuZCA0OlxuLy8gNy04cHQpLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMSBhbmQgMjogNS02cHQpLiAgVGhlc2UgYXJlXG4vLyBwcm92aWRlZCBpbiB0aGUgdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZyBzY3JpcHQ6XG4vL1xuLy8gICAgIGxhdGV4IC1pbnRlcmFjdGlvbj1ub25zdG9wbW9kZSBcXFxuLy8gICAgICdcXGRvY3VtZW50Y2xhc3N7YXJ0aWNsZX1cXHVzZXBhY2thZ2V7YW1zbWF0aH1cXGJlZ2lue2RvY3VtZW50fScgXFxcbi8vICAgICAnJGEkIFxcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcdGV4dGZvbnQyJyBcXFxuLy8gICAgICdcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHNjcmlwdGZvbnQyJyBcXFxuLy8gICAgICdcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHNjcmlwdHNjcmlwdGZvbnQyJyBcXFxuLy8gICAgICdcXHN0b3AnXG4vL1xuLy8gVGhlIG1ldHJpY3MgdGhlbXNlbHZlcyB3ZXJlIHJldHJlaXZlZCB1c2luZyB0aGUgZm9sbG93aW5nIGNvbW1hbmRzOlxuLy9cbi8vICAgICB0ZnRvcGwgY21zeTEwXG4vLyAgICAgdGZ0b3BsIGNtc3k3XG4vLyAgICAgdGZ0b3BsIGNtc3k1XG4vL1xuLy8gVGhlIG91dHB1dCBvZiBlYWNoIG9mIHRoZXNlIGNvbW1hbmRzIGlzIHF1aXRlIGxlbmd0aHkuICBUaGUgb25seSBwYXJ0IHdlXG4vLyBjYXJlIGFib3V0IGlzIHRoZSBGT05URElNRU4gc2VjdGlvbi4gRWFjaCB2YWx1ZSBpcyBtZWFzdXJlZCBpbiBFTXMuXG52YXIgc2lnbWFzQW5kWGlzID0ge1xuICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLFxuICAvLyBzaWdtYTFcbiAgc3BhY2U6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEyXG4gIHN0cmV0Y2g6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSxcbiAgLy8gc2lnbWEzXG4gIHNocmluazogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTRcbiAgeEhlaWdodDogWzAuNDMxLCAwLjQzMSwgMC40MzFdLFxuICAvLyBzaWdtYTVcbiAgcXVhZDogWzEuMDAwLCAxLjE3MSwgMS40NzJdLFxuICAvLyBzaWdtYTZcbiAgZXh0cmFTcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTdcbiAgbnVtMTogWzAuNjc3LCAwLjczMiwgMC45MjVdLFxuICAvLyBzaWdtYThcbiAgbnVtMjogWzAuMzk0LCAwLjM4NCwgMC4zODddLFxuICAvLyBzaWdtYTlcbiAgbnVtMzogWzAuNDQ0LCAwLjQ3MSwgMC41MDRdLFxuICAvLyBzaWdtYTEwXG4gIGRlbm9tMTogWzAuNjg2LCAwLjc1MiwgMS4wMjVdLFxuICAvLyBzaWdtYTExXG4gIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLFxuICAvLyBzaWdtYTEyXG4gIHN1cDE6IFswLjQxMywgMC41MDMsIDAuNTA0XSxcbiAgLy8gc2lnbWExM1xuICBzdXAyOiBbMC4zNjMsIDAuNDMxLCAwLjQwNF0sXG4gIC8vIHNpZ21hMTRcbiAgc3VwMzogWzAuMjg5LCAwLjI4NiwgMC4yOTRdLFxuICAvLyBzaWdtYTE1XG4gIHN1YjE6IFswLjE1MCwgMC4xNDMsIDAuMjAwXSxcbiAgLy8gc2lnbWExNlxuICBzdWIyOiBbMC4yNDcsIDAuMjg2LCAwLjQwMF0sXG4gIC8vIHNpZ21hMTdcbiAgc3VwRHJvcDogWzAuMzg2LCAwLjM1MywgMC40OTRdLFxuICAvLyBzaWdtYTE4XG4gIHN1YkRyb3A6IFswLjA1MCwgMC4wNzEsIDAuMTAwXSxcbiAgLy8gc2lnbWExOVxuICBkZWxpbTE6IFsyLjM5MCwgMS43MDAsIDEuOTgwXSxcbiAgLy8gc2lnbWEyMFxuICBkZWxpbTI6IFsxLjAxMCwgMS4xNTcsIDEuNDIwXSxcbiAgLy8gc2lnbWEyMVxuICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0sXG4gIC8vIHNpZ21hMjJcbiAgLy8gVGhlc2UgZm9udCBtZXRyaWNzIGFyZSBleHRyYWN0ZWQgZnJvbSBUZVggYnkgdXNpbmcgdGZ0b3BsIG9uIGNtZXgxMC50Zm07XG4gIC8vIHRoZXkgY29ycmVzcG9uZCB0byB0aGUgZm9udCBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS5cbiAgLy8gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS4gSW4gQU1TVGVYLCB0aGUgZXh0ZW5zaW9uIGZvbnRzIHNjYWxlOyB0b1xuICAvLyBtYXRjaCBjbWV4Nywgd2UnZCB1c2UgY21leDcudGZtIHZhbHVlcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHRcbiAgLy8gdmFsdWVzLlxuICBkZWZhdWx0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQ5LCAwLjA0OV0sXG4gIC8vIHhpODsgY21leDc6IDAuMDQ5XG4gIGJpZ09wU3BhY2luZzE6IFswLjExMSwgMC4xMTEsIDAuMTExXSxcbiAgLy8geGk5XG4gIGJpZ09wU3BhY2luZzI6IFswLjE2NiwgMC4xNjYsIDAuMTY2XSxcbiAgLy8geGkxMFxuICBiaWdPcFNwYWNpbmczOiBbMC4yLCAwLjIsIDAuMl0sXG4gIC8vIHhpMTFcbiAgYmlnT3BTcGFjaW5nNDogWzAuNiwgMC42MTEsIDAuNjExXSxcbiAgLy8geGkxMjsgY21leDc6IDAuNjExXG4gIGJpZ09wU3BhY2luZzU6IFswLjEsIDAuMTQzLCAwLjE0M10sXG4gIC8vIHhpMTM7IGNtZXg3OiAwLjE0M1xuICAvLyBUaGUgXFxzcXJ0IHJ1bGUgd2lkdGggaXMgdGFrZW4gZnJvbSB0aGUgaGVpZ2h0IG9mIHRoZSBzdXJkIGNoYXJhY3Rlci5cbiAgLy8gU2luY2Ugd2UgdXNlIHRoZSBzYW1lIGZvbnQgYXQgYWxsIHNpemVzLCB0aGlzIHRoaWNrbmVzcyBkb2Vzbid0IHNjYWxlLlxuICBzcXJ0UnVsZVRoaWNrbmVzczogWzAuMDQsIDAuMDQsIDAuMDRdLFxuICAvLyBUaGlzIHZhbHVlIGRldGVybWluZXMgaG93IGxhcmdlIGEgcHQgaXMsIGZvciBtZXRyaWNzIHdoaWNoIGFyZSBkZWZpbmVkXG4gIC8vIGluIHRlcm1zIG9mIHB0cy5cbiAgLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlXG4gIC8vIHZhbHVlcyBtYXRjaC5cbiAgcHRQZXJFbTogWzEwLjAsIDEwLjAsIDEwLjBdLFxuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiBhZGphY2VudCBgfGAgY29sdW1ucyBpbiBhbiBhcnJheSBkZWZpbml0aW9uLiBGcm9tXG4gIC8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLiBFcXVhbHMgMi4wIC8gcHRQZXJFbS5cbiAgZG91YmxlUnVsZVNlcDogWzAuMiwgMC4yLCAwLjJdLFxuICAvLyBUaGUgd2lkdGggb2Ygc2VwYXJhdG9yIGxpbmVzIGluIHthcnJheX0gZW52aXJvbm1lbnRzLiBGcm9tXG4gIC8vIGBcXHNob3d0aGVcXGFycmF5cnVsZXdpZHRoYCBpbiBMYVRlWC4gRXF1YWxzIDAuNCAvIHB0UGVyRW0uXG4gIGFycmF5UnVsZVdpZHRoOiBbMC4wNCwgMC4wNCwgMC4wNF0sXG4gIC8vIFR3byB2YWx1ZXMgZnJvbSBMYVRlWCBzb3VyY2UyZTpcbiAgZmJveHNlcDogWzAuMywgMC4zLCAwLjNdLFxuICAvLyAgICAgICAgMyBwdCAvIHB0UGVyRW1cbiAgZmJveHJ1bGU6IFswLjA0LCAwLjA0LCAwLjA0XSAvLyAwLjQgcHQgLyBwdFBlckVtXG5cbn07IC8vIFRoaXMgbWFwIGNvbnRhaW5zIGEgbWFwcGluZyBmcm9tIGZvbnQgbmFtZSBhbmQgY2hhcmFjdGVyIGNvZGUgdG8gY2hhcmFjdGVyXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cblxudmFyIGV4dHJhQ2hhcmFjdGVyTWFwID0ge1xuICAvLyBMYXRpbi0xXG4gICfDhSc6ICdBJyxcbiAgJ8OQJzogJ0QnLFxuICAnw54nOiAnbycsXG4gICfDpSc6ICdhJyxcbiAgJ8OwJzogJ2QnLFxuICAnw74nOiAnbycsXG4gIC8vIEN5cmlsbGljXG4gICfQkCc6ICdBJyxcbiAgJ9CRJzogJ0InLFxuICAn0JInOiAnQicsXG4gICfQkyc6ICdGJyxcbiAgJ9CUJzogJ0EnLFxuICAn0JUnOiAnRScsXG4gICfQlic6ICdLJyxcbiAgJ9CXJzogJzMnLFxuICAn0JgnOiAnTicsXG4gICfQmSc6ICdOJyxcbiAgJ9CaJzogJ0snLFxuICAn0JsnOiAnTicsXG4gICfQnCc6ICdNJyxcbiAgJ9CdJzogJ0gnLFxuICAn0J4nOiAnTycsXG4gICfQnyc6ICdOJyxcbiAgJ9CgJzogJ1AnLFxuICAn0KEnOiAnQycsXG4gICfQoic6ICdUJyxcbiAgJ9CjJzogJ3knLFxuICAn0KQnOiAnTycsXG4gICfQpSc6ICdYJyxcbiAgJ9CmJzogJ1UnLFxuICAn0KcnOiAnaCcsXG4gICfQqCc6ICdXJyxcbiAgJ9CpJzogJ1cnLFxuICAn0KonOiAnQicsXG4gICfQqyc6ICdYJyxcbiAgJ9CsJzogJ0InLFxuICAn0K0nOiAnMycsXG4gICfQric6ICdYJyxcbiAgJ9CvJzogJ1InLFxuICAn0LAnOiAnYScsXG4gICfQsSc6ICdiJyxcbiAgJ9CyJzogJ2EnLFxuICAn0LMnOiAncicsXG4gICfQtCc6ICd5JyxcbiAgJ9C1JzogJ2UnLFxuICAn0LYnOiAnbScsXG4gICfQtyc6ICdlJyxcbiAgJ9C4JzogJ24nLFxuICAn0LknOiAnbicsXG4gICfQuic6ICduJyxcbiAgJ9C7JzogJ24nLFxuICAn0LwnOiAnbScsXG4gICfQvSc6ICduJyxcbiAgJ9C+JzogJ28nLFxuICAn0L8nOiAnbicsXG4gICfRgCc6ICdwJyxcbiAgJ9GBJzogJ2MnLFxuICAn0YInOiAnbycsXG4gICfRgyc6ICd5JyxcbiAgJ9GEJzogJ2InLFxuICAn0YUnOiAneCcsXG4gICfRhic6ICduJyxcbiAgJ9GHJzogJ24nLFxuICAn0YgnOiAndycsXG4gICfRiSc6ICd3JyxcbiAgJ9GKJzogJ2EnLFxuICAn0YsnOiAnbScsXG4gICfRjCc6ICdhJyxcbiAgJ9GNJzogJ2UnLFxuICAn0Y4nOiAnbScsXG4gICfRjyc6ICdyJ1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgbmV3IGZvbnQgbWV0cmljcyB0byBkZWZhdWx0IG1ldHJpY01hcFxuICogSXQgY2FuIGFsc28gb3ZlcnJpZGUgZXhpc3RpbmcgbWV0cmljc1xuICovXG5mdW5jdGlvbiBzZXRGb250TWV0cmljcyhmb250TmFtZSwgbWV0cmljcykge1xuICBmb250TWV0cmljc0RhdGFbZm9udE5hbWVdID0gbWV0cmljcztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBsb29raW5nIHVwIGluZm9ybWF0aW9uIGluIHRoZVxuICogbWV0cmljTWFwIHRhYmxlLiBJdCB0YWtlcyBhIGNoYXJhY3RlciBhcyBhIHN0cmluZywgYW5kIGEgZm9udC5cbiAqXG4gKiBOb3RlOiB0aGUgYHdpZHRoYCBwcm9wZXJ0eSBtYXkgYmUgdW5kZWZpbmVkIGlmIGZvbnRNZXRyaWNzRGF0YS5qcyB3YXNuJ3RcbiAqIGJ1aWx0IHVzaW5nIGBNYWtlIGV4dGVuZGVkX21ldHJpY3NgLlxuICovXG5cbmZ1bmN0aW9uIGdldENoYXJhY3Rlck1ldHJpY3MoY2hhcmFjdGVyLCBmb250LCBtb2RlKSB7XG4gIGlmICghZm9udE1ldHJpY3NEYXRhW2ZvbnRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBtZXRyaWNzIG5vdCBmb3VuZCBmb3IgZm9udDogXCIgKyBmb250ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIGNoID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdW2NoXTtcblxuICBpZiAoIW1ldHJpY3MgJiYgY2hhcmFjdGVyWzBdIGluIGV4dHJhQ2hhcmFjdGVyTWFwKSB7XG4gICAgY2ggPSBleHRyYUNoYXJhY3Rlck1hcFtjaGFyYWN0ZXJbMF1dLmNoYXJDb2RlQXQoMCk7XG4gICAgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVtjaF07XG4gIH1cblxuICBpZiAoIW1ldHJpY3MgJiYgbW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgLy8gV2UgZG9uJ3QgdHlwaWNhbGx5IGhhdmUgZm9udCBtZXRyaWNzIGZvciBBc2lhbiBzY3JpcHRzLlxuICAgIC8vIEJ1dCBzaW5jZSB3ZSBzdXBwb3J0IHRoZW0gaW4gdGV4dCBtb2RlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAgIC8vIHNvbWUgc29ydCBvZiBtZXRyaWNzLlxuICAgIC8vIFNvIGlmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gYSBzY3JpcHQgd2Ugc3VwcG9ydCBidXQgd2VcbiAgICAvLyBkb24ndCBoYXZlIG1ldHJpY3MgZm9yIGl0LCBqdXN0IHVzZSB0aGUgbWV0cmljcyBmb3JcbiAgICAvLyB0aGUgTGF0aW4gY2FwaXRhbCBsZXR0ZXIgTS4gVGhpcyBpcyBjbG9zZSBlbm91Z2ggYmVjYXVzZVxuICAgIC8vIHdlIChjdXJyZW50bHkpIG9ubHkgY2FyZSBhYm91dCB0aGUgaGVpZ2h0IG9mIHRoZSBnbHB5aFxuICAgIC8vIG5vdCBpdHMgd2lkdGguXG4gICAgaWYgKHN1cHBvcnRlZENvZGVwb2ludChjaCkpIHtcbiAgICAgIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bNzddOyAvLyA3NyBpcyB0aGUgY2hhcmNvZGUgZm9yICdNJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChtZXRyaWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiBtZXRyaWNzWzBdLFxuICAgICAgaGVpZ2h0OiBtZXRyaWNzWzFdLFxuICAgICAgaXRhbGljOiBtZXRyaWNzWzJdLFxuICAgICAgc2tldzogbWV0cmljc1szXSxcbiAgICAgIHdpZHRoOiBtZXRyaWNzWzRdXG4gICAgfTtcbiAgfVxufVxudmFyIGZvbnRNZXRyaWNzQnlTaXplSW5kZXggPSB7fTtcbi8qKlxuICogR2V0IHRoZSBmb250IG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc2l6ZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRHbG9iYWxNZXRyaWNzKHNpemUpIHtcbiAgdmFyIHNpemVJbmRleDtcblxuICBpZiAoc2l6ZSA+PSA1KSB7XG4gICAgc2l6ZUluZGV4ID0gMDtcbiAgfSBlbHNlIGlmIChzaXplID49IDMpIHtcbiAgICBzaXplSW5kZXggPSAxO1xuICB9IGVsc2Uge1xuICAgIHNpemVJbmRleCA9IDI7XG4gIH1cblxuICBpZiAoIWZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XSkge1xuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdID0ge1xuICAgICAgY3NzRW1QZXJNdTogc2lnbWFzQW5kWGlzLnF1YWRbc2l6ZUluZGV4XSAvIDE4XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzaWdtYXNBbmRYaXMpIHtcbiAgICAgIGlmIChzaWdtYXNBbmRYaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBtZXRyaWNzW2tleV0gPSBzaWdtYXNBbmRYaXNba2V5XVtzaXplSW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF07XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcHRpb25zIHRoYXQgdGhlIFBhcnNlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdCB3aGlsZSBwYXJzaW5nLiBEYXRhIGlzIGhlbGQgaW4gYW4gYE9wdGlvbnNgIG9iamVjdCwgYW5kIHdoZW5cbiAqIHJlY3Vyc2luZywgYSBuZXcgYE9wdGlvbnNgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBhbmRcbiAqIGAucmVzZXRgIGZ1bmN0aW9ucy5cbiAqL1xudmFyIHNpemVTdHlsZU1hcCA9IFsvLyBFYWNoIGVsZW1lbnQgY29udGFpbnMgW3RleHRzaXplLCBzY3JpcHRzaXplLCBzY3JpcHRzY3JpcHRzaXplXS5cbi8vIFRoZSBzaXplIG1hcHBpbmdzIGFyZSB0YWtlbiBmcm9tIFRlWCB3aXRoIFxcbm9ybWFsc2l6ZT0xMHB0LlxuWzEsIDEsIDFdLCAvLyBzaXplMTogWzUsIDUsIDVdICAgICAgICAgICAgICBcXHRpbnlcblsyLCAxLCAxXSwgLy8gc2l6ZTI6IFs2LCA1LCA1XVxuWzMsIDEsIDFdLCAvLyBzaXplMzogWzcsIDUsIDVdICAgICAgICAgICAgICBcXHNjcmlwdHNpemVcbls0LCAyLCAxXSwgLy8gc2l6ZTQ6IFs4LCA2LCA1XSAgICAgICAgICAgICAgXFxmb290bm90ZXNpemVcbls1LCAyLCAxXSwgLy8gc2l6ZTU6IFs5LCA2LCA1XSAgICAgICAgICAgICAgXFxzbWFsbFxuWzYsIDMsIDFdLCAvLyBzaXplNjogWzEwLCA3LCA1XSAgICAgICAgICAgICBcXG5vcm1hbHNpemVcbls3LCA0LCAyXSwgLy8gc2l6ZTc6IFsxMiwgOCwgNl0gICAgICAgICAgICAgXFxsYXJnZVxuWzgsIDYsIDNdLCAvLyBzaXplODogWzE0LjQsIDEwLCA3XSAgICAgICAgICBcXExhcmdlXG5bOSwgNywgNl0sIC8vIHNpemU5OiBbMTcuMjgsIDEyLCAxMF0gICAgICAgIFxcTEFSR0VcblsxMCwgOCwgN10sIC8vIHNpemUxMDogWzIwLjc0LCAxNC40LCAxMl0gICAgIFxcaHVnZVxuWzExLCAxMCwgOV0gLy8gc2l6ZTExOiBbMjQuODgsIDIwLjc0LCAxNy4yOF0gXFxIVUdFXG5dO1xudmFyIHNpemVNdWx0aXBsaWVycyA9IFsvLyBmb250TWV0cmljcy5qczpnZXRHbG9iYWxNZXRyaWNzIGFsc28gdXNlcyBzaXplIGluZGV4ZXMsIHNvIGlmXG4vLyB5b3UgY2hhbmdlIHNpemUgaW5kZXhlcywgY2hhbmdlIHRoYXQgZnVuY3Rpb24uXG4wLjUsIDAuNiwgMC43LCAwLjgsIDAuOSwgMS4wLCAxLjIsIDEuNDQsIDEuNzI4LCAyLjA3NCwgMi40ODhdO1xuXG52YXIgc2l6ZUF0U3R5bGUgPSBmdW5jdGlvbiBzaXplQXRTdHlsZShzaXplLCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuc2l6ZSA8IDIgPyBzaXplIDogc2l6ZVN0eWxlTWFwW3NpemUgLSAxXVtzdHlsZS5zaXplIC0gMV07XG59OyAvLyBJbiB0aGVzZSB0eXBlcywgXCJcIiAoZW1wdHkgc3RyaW5nKSBtZWFucyBcIm5vIGNoYW5nZVwiLlxuXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBvcHRpb25zIGNsYXNzLiBJdCBjb250YWlucyB0aGUgY3VycmVudCBzdHlsZSwgc2l6ZSwgY29sb3IsXG4gKiBhbmQgZm9udC5cbiAqXG4gKiBPcHRpb25zIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC4gVG8gY3JlYXRlIGEgbmV3IE9wdGlvbnMgd2l0aFxuICogZGlmZmVyZW50IHByb3BlcnRpZXMsIGNhbGwgYSBgLmhhdmluZypgIG1ldGhvZC5cbiAqL1xuY2xhc3MgT3B0aW9ucyB7XG4gIC8vIEEgZm9udCBmYW1pbHkgYXBwbGllcyB0byBhIGdyb3VwIG9mIGZvbnRzIChpLmUuIFNhbnNTZXJpZiksIHdoaWxlIGEgZm9udFxuICAvLyByZXByZXNlbnRzIGEgc3BlY2lmaWMgZm9udCAoaS5lLiBTYW5zU2VyaWYgQm9sZCkuXG4gIC8vIFNlZTogaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIyMzUwL2RpZmZlcmVuY2UtYmV0d2Vlbi10ZXh0cm0tYW5kLW1hdGhybVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBzaXplIGluZGV4LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2xvciA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBoYW50b20gPSB2b2lkIDA7XG4gICAgdGhpcy5mb250ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2hhcGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplTXVsdGlwbGllciA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZSB8fCBPcHRpb25zLkJBU0VTSVpFO1xuICAgIHRoaXMudGV4dFNpemUgPSBkYXRhLnRleHRTaXplIHx8IHRoaXMuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSAhIWRhdGEucGhhbnRvbTtcbiAgICB0aGlzLmZvbnQgPSBkYXRhLmZvbnQgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBkYXRhLmZvbnRGYW1pbHkgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBkYXRhLmZvbnRXZWlnaHQgfHwgJyc7XG4gICAgdGhpcy5mb250U2hhcGUgPSBkYXRhLmZvbnRTaGFwZSB8fCAnJztcbiAgICB0aGlzLnNpemVNdWx0aXBsaWVyID0gc2l6ZU11bHRpcGxpZXJzW3RoaXMuc2l6ZSAtIDFdO1xuICAgIHRoaXMubWF4U2l6ZSA9IGRhdGEubWF4U2l6ZTtcbiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSBkYXRhLm1pblJ1bGVUaGlja25lc3M7XG4gICAgdGhpcy5fZm9udE1ldHJpY3MgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIFwidGhpc1wiLiAgUHJvcGVydGllc1xuICAgKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAgICovXG5cblxuICBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIHRleHRTaXplOiB0aGlzLnRleHRTaXplLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBmb250U2hhcGU6IHRoaXMuZm9udFNoYXBlLFxuICAgICAgbWF4U2l6ZTogdGhpcy5tYXhTaXplLFxuICAgICAgbWluUnVsZVRoaWNrbmVzczogdGhpcy5taW5SdWxlVGhpY2tuZXNzXG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHRlbnNpb24pIHtcbiAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS4gSWYgYHRoaXMuc3R5bGUgPT09IHN0eWxlYCxcbiAgICogcmV0dXJucyBgdGhpc2AuXG4gICAqL1xuXG5cbiAgaGF2aW5nU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAodGhpcy5zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHNpemU6IHNpemVBdFN0eWxlKHRoaXMudGV4dFNpemUsIHN0eWxlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIGNyYW1wZWQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBzdHlsZS4gSWZcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUgaXMgY3JhbXBlZCwgcmV0dXJucyBgdGhpc2AuXG4gICAqL1xuXG5cbiAgaGF2aW5nQ3JhbXBlZFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhdmluZ1N0eWxlKHRoaXMuc3R5bGUuY3JhbXAoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzaXplIGFuZCBpbiBhdCBsZWFzdCBgXFx0ZXh0c3R5bGVgLlxuICAgKiBSZXR1cm5zIGB0aGlzYCBpZiBhcHByb3ByaWF0ZS5cbiAgICovXG5cblxuICBoYXZpbmdTaXplKHNpemUpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSBzaXplICYmIHRoaXMudGV4dFNpemUgPT09IHNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogdGhpcy5zdHlsZS50ZXh0KCksXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHRleHRTaXplOiBzaXplLFxuICAgICAgICBzaXplTXVsdGlwbGllcjogc2l6ZU11bHRpcGxpZXJzW3NpemUgLSAxXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaWtlIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLmhhdmluZ1N0eWxlKHN0eWxlKWAuIElmIGBzdHlsZWAgaXMgb21pdHRlZCxcbiAgICogY2hhbmdlcyB0byBhdCBsZWFzdCBgXFx0ZXh0c3R5bGVgLlxuICAgKi9cblxuXG4gIGhhdmluZ0Jhc2VTdHlsZShzdHlsZSkge1xuICAgIHN0eWxlID0gc3R5bGUgfHwgdGhpcy5zdHlsZS50ZXh0KCk7XG4gICAgdmFyIHdhbnRTaXplID0gc2l6ZUF0U3R5bGUoT3B0aW9ucy5CQVNFU0laRSwgc3R5bGUpO1xuXG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gd2FudFNpemUgJiYgdGhpcy50ZXh0U2l6ZSA9PT0gT3B0aW9ucy5CQVNFU0laRSAmJiB0aGlzLnN0eWxlID09PSBzdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc2l6ZTogd2FudFNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlZmZlY3Qgb2Ygc2l6aW5nIGNoYW5nZXMgc3VjaCBhcyBcXEh1Z2UuXG4gICAqIEtlZXAgdGhlIGVmZmVjdCBvZiB0aGUgY3VycmVudCBzdHlsZSwgc3VjaCBhcyBcXHNjcmlwdHN0eWxlLlxuICAgKi9cblxuXG4gIGhhdmluZ0Jhc2VTaXppbmcoKSB7XG4gICAgdmFyIHNpemU7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3R5bGUuaWQpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgc2l6ZSA9IDM7IC8vIG5vcm1hbHNpemUgaW4gc2NyaXB0c3R5bGVcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICBzaXplID0gMTsgLy8gbm9ybWFsc2l6ZSBpbiBzY3JpcHRzY3JpcHRzdHlsZVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzaXplID0gNjtcbiAgICAgIC8vIG5vcm1hbHNpemUgaW4gdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBzdHlsZTogdGhpcy5zdHlsZS50ZXh0KCksXG4gICAgICBzaXplOiBzaXplXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAgICovXG5cblxuICB3aXRoQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIFwicGhhbnRvbVwiIHNldCB0byB0cnVlLlxuICAgKi9cblxuXG4gIHdpdGhQaGFudG9tKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWF0aCBmb250IG9yIG9sZCB0ZXh0IGZvbnQuXG4gICAqIEB0eXBlIHtbdHlwZV19XG4gICAqL1xuXG5cbiAgd2l0aEZvbnQoZm9udCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZW4gZm9udEZhbWlseS5cbiAgICovXG5cblxuICB3aXRoVGV4dEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuXG5cbiAgd2l0aFRleHRGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFdlaWdodCxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cblxuXG4gIHdpdGhUZXh0Rm9udFNoYXBlKGZvbnRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2hhcGUsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQ1NTIHNpemluZyBjbGFzc2VzIHJlcXVpcmVkIHRvIHN3aXRjaCBmcm9tIGVuY2xvc2luZyBvcHRpb25zXG4gICAqIGBvbGRPcHRpb25zYCB0byBgdGhpc2AuIFJldHVybnMgYW4gYXJyYXkgb2YgY2xhc3Nlcy5cbiAgICovXG5cblxuICBzaXppbmdDbGFzc2VzKG9sZE9wdGlvbnMpIHtcbiAgICBpZiAob2xkT3B0aW9ucy5zaXplICE9PSB0aGlzLnNpemUpIHtcbiAgICAgIHJldHVybiBbXCJzaXppbmdcIiwgXCJyZXNldC1zaXplXCIgKyBvbGRPcHRpb25zLnNpemUsIFwic2l6ZVwiICsgdGhpcy5zaXplXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBDU1Mgc2l6aW5nIGNsYXNzZXMgcmVxdWlyZWQgdG8gc3dpdGNoIHRvIHRoZSBiYXNlIHNpemUuIExpa2VcbiAgICogYHRoaXMuaGF2aW5nU2l6ZShCQVNFU0laRSkuc2l6aW5nQ2xhc3Nlcyh0aGlzKWAuXG4gICAqL1xuXG5cbiAgYmFzZVNpemluZ0NsYXNzZXMoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSAhPT0gT3B0aW9ucy5CQVNFU0laRSkge1xuICAgICAgcmV0dXJuIFtcInNpemluZ1wiLCBcInJlc2V0LXNpemVcIiArIHRoaXMuc2l6ZSwgXCJzaXplXCIgKyBPcHRpb25zLkJBU0VTSVpFXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmb250IG1ldHJpY3MgZm9yIHRoaXMgc2l6ZS5cbiAgICovXG5cblxuICBmb250TWV0cmljcygpIHtcbiAgICBpZiAoIXRoaXMuX2ZvbnRNZXRyaWNzKSB7XG4gICAgICB0aGlzLl9mb250TWV0cmljcyA9IGdldEdsb2JhbE1ldHJpY3ModGhpcy5zaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZm9udE1ldHJpY3M7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIENTUyBjb2xvciBvZiB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdFxuICAgKi9cblxuXG4gIGdldENvbG9yKCkge1xuICAgIGlmICh0aGlzLnBoYW50b20pIHtcbiAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICAgIH1cbiAgfVxuXG59XG5cbk9wdGlvbnMuQkFTRVNJWkUgPSA2O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIGNvbnZlcnNpb24gYmV0d2VlbiB1bml0cy4gIEluIHBhcnRpY3VsYXIsIGl0IHByb3ZpZGVzXG4gKiBjYWxjdWxhdGVTaXplIHRvIGNvbnZlcnQgb3RoZXIgdW5pdHMgaW50byBlbXMuXG4gKi9cbi8vIFRodXMsIG11bHRpcGx5aW5nIGEgbGVuZ3RoIGJ5IHRoaXMgbnVtYmVyIGNvbnZlcnRzIHRoZSBsZW5ndGggZnJvbSB1bml0c1xuLy8gaW50byBwdHMuICBEaXZpZGluZyB0aGUgcmVzdWx0IGJ5IHB0UGVyRW0gZ2l2ZXMgdGhlIG51bWJlciBvZiBlbXNcbi8vICphc3N1bWluZyogYSBmb250IHNpemUgb2YgcHRQZXJFbSAobm9ybWFsIHNpemUsIG5vcm1hbCBzdHlsZSkuXG5cbnZhciBwdFBlclVuaXQgPSB7XG4gIC8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0xhVGVYL0xlbmd0aHMgYW5kXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvODI2M1xuICBcInB0XCI6IDEsXG4gIC8vIFRlWCBwb2ludFxuICBcIm1tXCI6IDcyMjcgLyAyNTQwLFxuICAvLyBtaWxsaW1ldGVyXG4gIFwiY21cIjogNzIyNyAvIDI1NCxcbiAgLy8gY2VudGltZXRlclxuICBcImluXCI6IDcyLjI3LFxuICAvLyBpbmNoXG4gIFwiYnBcIjogODAzIC8gODAwLFxuICAvLyBiaWcgKFBvc3RTY3JpcHQpIHBvaW50c1xuICBcInBjXCI6IDEyLFxuICAvLyBwaWNhXG4gIFwiZGRcIjogMTIzOCAvIDExNTcsXG4gIC8vIGRpZG90XG4gIFwiY2NcIjogMTQ4NTYgLyAxMTU3LFxuICAvLyBjaWNlcm8gKDEyIGRpZG90KVxuICBcIm5kXCI6IDY4NSAvIDY0MixcbiAgLy8gbmV3IGRpZG90XG4gIFwibmNcIjogMTM3MCAvIDEwNyxcbiAgLy8gbmV3IGNpY2VybyAoMTIgbmV3IGRpZG90KVxuICBcInNwXCI6IDEgLyA2NTUzNixcbiAgLy8gc2NhbGVkIHBvaW50IChUZVgncyBpbnRlcm5hbCBzbWFsbGVzdCB1bml0KVxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzQxMzcxXG4gIFwicHhcIjogODAzIC8gODAwIC8vIFxccGRmcHhkaW1lbiBkZWZhdWx0cyB0byAxIGJwIGluIHBkZlRlWCBhbmQgTHVhVGVYXG5cbn07IC8vIERpY3Rpb25hcnkgb2YgcmVsYXRpdmUgdW5pdHMsIGZvciBmYXN0IHZhbGlkaXR5IHRlc3RpbmcuXG5cbnZhciByZWxhdGl2ZVVuaXQgPSB7XG4gIFwiZXhcIjogdHJ1ZSxcbiAgXCJlbVwiOiB0cnVlLFxuICBcIm11XCI6IHRydWVcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB1bml0IChlaXRoZXIgYSBzdHJpbmcgZGVmaW5pbmcgdGhlIHVuaXRcbiAqIG9yIGEgXCJzaXplXCIgcGFyc2Ugbm9kZSBjb250YWluaW5nIGEgdW5pdCBmaWVsZCkgaXMgdmFsaWQuXG4gKi9cbnZhciB2YWxpZFVuaXQgPSBmdW5jdGlvbiB2YWxpZFVuaXQodW5pdCkge1xuICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bml0ID0gdW5pdC51bml0O1xuICB9XG5cbiAgcmV0dXJuIHVuaXQgaW4gcHRQZXJVbml0IHx8IHVuaXQgaW4gcmVsYXRpdmVVbml0IHx8IHVuaXQgPT09IFwiZXhcIjtcbn07XG4vKlxuICogQ29udmVydCBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgKHdpdGggbnVtZXJpYyBcIm51bWJlclwiIGFuZCBzdHJpbmcgXCJ1bml0XCIgZmllbGRzLFxuICogYXMgcGFyc2VkIGJ5IGZ1bmN0aW9ucy5qcyBhcmdUeXBlIFwic2l6ZVwiKSBpbnRvIGEgQ1NTIGVtIHZhbHVlIGZvciB0aGVcbiAqIGN1cnJlbnQgc3R5bGUvc2NhbGUuICBgb3B0aW9uc2AgZ2l2ZXMgdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAqL1xuXG52YXIgY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBzY2FsZTtcblxuICBpZiAoc2l6ZVZhbHVlLnVuaXQgaW4gcHRQZXJVbml0KSB7XG4gICAgLy8gQWJzb2x1dGUgdW5pdHNcbiAgICBzY2FsZSA9IHB0UGVyVW5pdFtzaXplVmFsdWUudW5pdF0gLy8gQ29udmVydCB1bml0IHRvIHB0XG4gICAgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbSAvLyBDb252ZXJ0IHB0IHRvIENTUyBlbVxuICAgIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gVW5zY2FsZSB0byBtYWtlIGFic29sdXRlIHVuaXRzXG4gIH0gZWxzZSBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwibXVcIikge1xuICAgIC8vIGBtdWAgdW5pdHMgc2NhbGUgd2l0aCBzY3JpcHRzdHlsZS9zY3JpcHRzY3JpcHRzdHlsZS5cbiAgICBzY2FsZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5jc3NFbVBlck11O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyIHJlbGF0aXZlIHVuaXRzIGFsd2F5cyByZWZlciB0byB0aGUgKnRleHRzdHlsZSogZm9udFxuICAgIC8vIGluIHRoZSBjdXJyZW50IHNpemUuXG4gICAgdmFyIHVuaXRPcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAvLyBpc1RpZ2h0KCkgbWVhbnMgY3VycmVudCBzdHlsZSBpcyBzY3JpcHQvc2NyaXB0c2NyaXB0LlxuICAgICAgdW5pdE9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUudGV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0gLy8gVE9ETzogSW4gVGVYIHRoZXNlIHVuaXRzIGFyZSByZWxhdGl2ZSB0byB0aGUgcXVhZCBvZiB0aGUgY3VycmVudFxuICAgIC8vICp0ZXh0KiBmb250LCBlLmcuIGNtcjEwLiBLYVRlWCBpbnN0ZWFkIHVzZXMgdmFsdWVzIGZyb20gdGhlXG4gICAgLy8gY29tcGFyYWJseS1zaXplZCAqQ29tcHV0ZXIgTW9kZXJuIHN5bWJvbCogZm9udC4gQXQgMTBwdCwgdGhlc2VcbiAgICAvLyBtYXRjaC4gQXQgN3B0IGFuZCA1cHQsIHRoZXkgZGlmZmVyOiBjbXI3PTEuMTM4ODk0LCBjbXN5Nz0xLjE3MDY0MTtcbiAgICAvLyBjbXI1PTEuMzYxMTMzLCBjbXN5NT0xLjQ3MjI0MS4gQ29uc2lkZXIgJFxcc2NyaXB0c2l6ZSBhXFxrZXJuMWVtYiQuXG4gICAgLy8gVGVYIFxcc2hvd2xpc3RzIHNob3dzIGEga2VybiBvZiAxLjEzODg5ICogZm9udHNpemU7XG4gICAgLy8gS2FUZVggc2hvd3MgYSBrZXJuIG9mIDEuMTcxICogZm9udHNpemUuXG5cblxuICAgIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJleFwiKSB7XG4gICAgICBzY2FsZSA9IHVuaXRPcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcImVtXCIpIHtcbiAgICAgIHNjYWxlID0gdW5pdE9wdGlvbnMuZm9udE1ldHJpY3MoKS5xdWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgc2l6ZVZhbHVlLnVuaXQgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKHVuaXRPcHRpb25zICE9PSBvcHRpb25zKSB7XG4gICAgICBzY2FsZSAqPSB1bml0T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgubWluKHNpemVWYWx1ZS5udW1iZXIgKiBzY2FsZSwgb3B0aW9ucy5tYXhTaXplKTtcbn07XG4vKipcbiAqIFJvdW5kIGBuYCB0byA0IGRlY2ltYWwgcGxhY2VzLCBvciB0byB0aGUgbmVhcmVzdCAxLzEwLDAwMHRoIGVtLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC9wdWxsLzI0NjAuXG4gKi9cblxudmFyIG1ha2VFbSA9IGZ1bmN0aW9uIG1ha2VFbShuKSB7XG4gIHJldHVybiArbi50b0ZpeGVkKDQpICsgXCJlbVwiO1xufTtcblxuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICogVE9ETzogcmVmYWN0b3IgYHNwYW5gIGFuZCBgYW5jaG9yYCBpbnRvIGNvbW1vbiBzdXBlcmNsYXNzIHdoZW5cbiAqIHRhcmdldCBlbnZpcm9ubWVudHMgc3VwcG9ydCBjbGFzcyBpbmhlcml0YW5jZVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgY2xhc3NOYW1lIGJhc2VkIG9uIGEgbGlzdCBvZiBjbGFzc2VzLiBJbiBhZGRpdGlvbiB0byBqb2luaW5nXG4gKiB3aXRoIHNwYWNlcywgd2UgYWxzbyByZW1vdmUgZW1wdHkgY2xhc3Nlcy5cbiAqL1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY2xhc3Nlcykge1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoY2xzID0+IGNscykuam9pbihcIiBcIik7XG59O1xuXG52YXIgaW5pdE5vZGUgPSBmdW5jdGlvbiBpbml0Tm9kZShjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSkge1xuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLmRlcHRoID0gMDtcbiAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG4gIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2goXCJtdGlnaHRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cblxuXG52YXIgdG9Ob2RlID0gZnVuY3Rpb24gdG9Ob2RlKHRhZ05hbWUpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpOyAvLyBBcHBseSB0aGUgY2xhc3NcblxuICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7IC8vIEFwcGx5IGlubGluZSBzdHlsZXNcblxuICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzZWVtIHRvIHVuZGVyc3RhbmQgc3Bhbi5zdHlsZSdzIHR5cGUuXG4gICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgIH1cbiAgfSAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgY2hpbGRyZW4sIGFsc28gYXMgSFRNTCBub2Rlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogQ29udmVydCBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZ1xuICovXG5cblxudmFyIHRvTWFya3VwID0gZnVuY3Rpb24gdG9NYXJrdXAodGFnTmFtZSkge1xuICB2YXIgbWFya3VwID0gXCI8XCIgKyB0YWdOYW1lOyAvLyBBZGQgdGhlIGNsYXNzXG5cbiAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiICsgdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpICsgXCJcXFwiXCI7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gXCJcIjsgLy8gQWRkIHRoZSBzdHlsZXMsIGFmdGVyIGh5cGhlbmF0aW9uXG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcykge1xuICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICB9IC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuXG5cbiAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSkgKyBcIlxcXCJcIjtcbiAgICB9XG4gIH1cblxuICBtYXJrdXAgKz0gXCI+XCI7IC8vIEFkZCB0aGUgbWFya3VwIG9mIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBtYXJrdXBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICB9XG5cbiAgbWFya3VwICs9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgcmV0dXJuIG1hcmt1cDtcbn07IC8vIE1ha2luZyB0aGUgdHlwZSBiZWxvdyBleGFjdCB3aXRoIGFsbCBvcHRpb25hbCBmaWVsZHMgZG9lc24ndCB3b3JrIGR1ZSB0b1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDU4MlxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNTY4OFxuLy8gSG93ZXZlciwgc2luY2UgKmFsbCogZmllbGRzIGFyZSBvcHRpb25hbCwgJFNoYXBlPD4gd29ya3MgYXMgc3VnZ2VzdGVkIGluIDU2ODhcbi8vIGFib3ZlLlxuLy8gVGhpcyB0eXBlIGRvZXMgbm90IGluY2x1ZGUgYWxsIENTUyBwcm9wZXJ0aWVzLiBBZGRpdGlvbmFsIHByb3BlcnRpZXMgc2hvdWxkXG4vLyBiZSBhZGRlZCBhcyBuZWVkZWQuXG5cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqXG4gKiBSZXByZXNlbnRzIHR3byB0eXBlcyB3aXRoIGRpZmZlcmVudCB1c2VzOiBTdmdTcGFuIHRvIHdyYXAgYW4gU1ZHIGFuZCBEb21TcGFuXG4gKiBvdGhlcndpc2UuIFRoaXMgdHlwZXNhZmV0eSBpcyBpbXBvcnRhbnQgd2hlbiBIVE1MIGJ1aWxkZXJzIGFjY2VzcyBhIHNwYW4nc1xuICogY2hpbGRyZW4uXG4gKi9cbmNsYXNzIFNwYW4ge1xuICBjb25zdHJ1Y3RvcihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBpbml0Tm9kZS5jYWxsKHRoaXMsIGNsYXNzZXMsIG9wdGlvbnMsIHN0eWxlKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3RcbiAgICogYWxsIGJyb3dzZXJzIHN1cHBvcnQgYXR0cmlidXRlcyB0aGUgc2FtZSwgYW5kIGhhdmluZyB0b28gbWFueSBjdXN0b21cbiAgICogYXR0cmlidXRlcyBpcyBwcm9iYWJseSBiYWQuXG4gICAqL1xuXG5cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gdG9Ob2RlLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbn1cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYW4gYW5jaG9yICg8YT4pIGVsZW1lbnQgd2l0aCBhIGh5cGVybGluay4gIFNlZSBgc3BhbmBcbiAqIGZvciBmdXJ0aGVyIGRldGFpbHMuXG4gKi9cblxuY2xhc3MgQW5jaG9yIHtcbiAgY29uc3RydWN0b3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGltYWdlIGVtYmVkICg8aW1nPikgZWxlbWVudC5cbiAqL1xuXG5jbGFzcyBJbWcge1xuICBjb25zdHJ1Y3RvcihzcmMsIGFsdCwgc3R5bGUpIHtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy5jbGFzc2VzID0gW1wibW9yZFwiXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBub2RlLnNyYyA9IHRoaXMuc3JjO1xuICAgIG5vZGUuYWx0ID0gdGhpcy5hbHQ7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIm1vcmRcIjsgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxpbWcgIHNyYz0nXCIgKyB0aGlzLnNyYyArIFwiICdhbHQ9J1wiICsgdGhpcy5hbHQgKyBcIicgXCI7IC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiJy8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG59XG52YXIgaUNvbWJpbmF0aW9ucyA9IHtcbiAgJ8OuJzogJ1xcdTAxMzFcXHUwMzAyJyxcbiAgJ8OvJzogJ1xcdTAxMzFcXHUwMzA4JyxcbiAgJ8OtJzogJ1xcdTAxMzFcXHUwMzAxJyxcbiAgLy8gJ8SrJzogJ1xcdTAxMzFcXHUwMzA0JywgLy8gZW5hYmxlIHdoZW4gd2UgYWRkIEV4dGVuZGVkIExhdGluXG4gICfDrCc6ICdcXHUwMTMxXFx1MDMwMCdcbn07XG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cblxuY2xhc3MgU3ltYm9sTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIGhlaWdodCwgZGVwdGgsIGl0YWxpYywgc2tldywgd2lkdGgsIGNsYXNzZXMsIHN0eWxlKSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwdGggPSB2b2lkIDA7XG4gICAgdGhpcy5pdGFsaWMgPSB2b2lkIDA7XG4gICAgdGhpcy5za2V3ID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoIHx8IDA7XG4gICAgdGhpcy5pdGFsaWMgPSBpdGFsaWMgfHwgMDtcbiAgICB0aGlzLnNrZXcgPSBza2V3IHx8IDA7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7IC8vIE1hcmsgdGV4dCBmcm9tIG5vbi1MYXRpbiBzY3JpcHRzIHdpdGggc3BlY2lmaWMgY2xhc3NlcyBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHNwZWNpZnkgd2hpY2ggZm9udHMgdG8gdXNlLiAgVGhpcyBhbGxvd3MgdXMgdG8gcmVuZGVyIHRoZXNlXG4gICAgLy8gY2hhcmFjdGVycyB3aXRoIGEgc2VyaWYgZm9udCBpbiBzaXR1YXRpb25zIHdoZXJlIHRoZSBicm93c2VyIHdvdWxkXG4gICAgLy8gZWl0aGVyIGRlZmF1bHQgdG8gYSBzYW5zIHNlcmlmIG9yIHJlbmRlciBhIHBsYWNlaG9sZGVyIGNoYXJhY3Rlci5cbiAgICAvLyBXZSB1c2UgQ1NTIGNsYXNzIG5hbWVzIGxpa2UgY2prX2ZhbGxiYWNrLCBoYW5ndWxfZmFsbGJhY2sgYW5kXG4gICAgLy8gYnJhaG1pY19mYWxsYmFjay4gU2VlIC4vdW5pY29kZVNjcmlwdHMuanMgZm9yIHRoZSBzZXQgb2YgcG9zc2libGVcbiAgICAvLyBzY3JpcHQgbmFtZXNcblxuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRGcm9tQ29kZXBvaW50KHRoaXMudGV4dC5jaGFyQ29kZUF0KDApKTtcblxuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHNjcmlwdCArIFwiX2ZhbGxiYWNrXCIpO1xuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnRleHQpKSB7XG4gICAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgIHRoaXMudGV4dCA9IGlDb21iaW5hdGlvbnNbdGhpcy50ZXh0XTtcbiAgICB9XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dCBub2RlIG9yIHNwYW4gZnJvbSBhIHN5bWJvbCBub2RlLiBOb3RlIHRoYXQgYSBzcGFuIGlzIG9ubHlcbiAgICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgICB2YXIgc3BhbiA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHRoaXMuaXRhbGljKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwYW4gPSBzcGFuIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICBzcGFuID0gc3BhbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTsgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc2VlbSB0byB1bmRlcnN0YW5kIHNwYW4uc3R5bGUncyB0eXBlLlxuXG4gICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAgICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgIG5lZWRzU3BhbiA9IHRydWU7XG4gICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKTtcbiAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gdXRpbHMuZXNjYXBlKHRoaXMudGV4dCk7XG5cbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgICBtYXJrdXAgKz0gZXNjYXBlZDtcbiAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cbiAgfVxuXG59XG4vKipcbiAqIFNWRyBub2RlcyBhcmUgdXNlZCB0byByZW5kZXIgc3RyZXRjaHkgd2lkZSBlbGVtZW50cy5cbiAqL1xuXG5jbGFzcyBTdmdOb2RlIHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXCI7IC8vIEFwcGx5IGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPSdcIiArIHRoaXMuYXR0cmlidXRlc1thdHRyXSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L3N2Zz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmNsYXNzIFBhdGhOb2RlIHtcbiAgY29uc3RydWN0b3IocGF0aE5hbWUsIGFsdGVybmF0ZSkge1xuICAgIHRoaXMucGF0aE5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHBhdGhOYW1lO1xuICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlOyAvLyBVc2VkIG9ubHkgZm9yIFxcc3FydCwgXFxwaGFzZSwgJiB0YWxsIGRlbGltc1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIHZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgXCJwYXRoXCIpO1xuXG4gICAgaWYgKHRoaXMuYWx0ZXJuYXRlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRcIiwgdGhpcy5hbHRlcm5hdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRcIiwgcGF0aFt0aGlzLnBhdGhOYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBpZiAodGhpcy5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBcIjxwYXRoIGQ9J1wiICsgdGhpcy5hbHRlcm5hdGUgKyBcIicvPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCI8cGF0aCBkPSdcIiArIHBhdGhbdGhpcy5wYXRoTmFtZV0gKyBcIicvPlwiO1xuICAgIH1cbiAgfVxuXG59XG5jbGFzcyBMaW5lTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwibGluZVwiKTsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPGxpbmVcIjtcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPSdcIiArIHRoaXMuYXR0cmlidXRlc1thdHRyXSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIi8+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG59XG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xEb21Ob2RlKGdyb3VwKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3ltYm9sTm9kZSBidXQgZ290IFwiICsgU3RyaW5nKGdyb3VwKSArIFwiLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U3Bhbihncm91cCkge1xuICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBTcGFuKSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW48SHRtbERvbU5vZGU+IGJ1dCBnb3QgXCIgKyBTdHJpbmcoZ3JvdXApICsgXCIuXCIpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdGhyZWUgcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBmb250IChyZXF1aXJlZCk6IHRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoaXMgc3ltYm9sLiBFaXRoZXIgXCJtYWluXCIgKHRoZVxuICAgICBub3JtYWwgZm9udCksIG9yIFwiYW1zXCIgKHRoZSBhbXMgZm9udHMpLlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2FUZVgvS2FUZVgvd2lraS9FeGFtaW5pbmctVGVYI2dyb3VwLXR5cGVzXG4gKiAtIHJlcGxhY2U6IHRoZSBjaGFyYWN0ZXIgdGhhdCB0aGlzIHN5bWJvbCBvciBmdW5jdGlvbiBzaG91bGQgYmVcbiAqICAgcmVwbGFjZWQgd2l0aCAoaS5lLiBcIlxccGhpXCIgaGFzIGEgcmVwbGFjZSB2YWx1ZSBvZiBcIlxcdTAzZDVcIiwgdGhlIHBoaVxuICogICBjaGFyYWN0ZXIgaW4gdGhlIG1haW4gZm9udCkuXG4gKlxuICogVGhlIG91dGVybW9zdCBtYXAgaW4gdGhlIHRhYmxlIGluZGljYXRlcyB3aGF0IG1vZGUgdGhlIHN5bWJvbHMgc2hvdWxkIGJlXG4gKiBhY2NlcHRlZCBpbiAoZS5nLiBcIm1hdGhcIiBvciBcInRleHRcIikuXG4gKi9cbi8vIFNvbWUgb2YgdGhlc2UgaGF2ZSBhIFwiLXRva2VuXCIgc3VmZml4IHNpbmNlIHRoZXNlIGFyZSBhbHNvIHVzZWQgYXMgYFBhcnNlTm9kZWBcbi8vIHR5cGVzIGZvciByYXcgdGV4dCB0b2tlbnMsIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIGhpZ2hlci1sZXZlbFxuLy8gYFBhcnNlTm9kZWAgdHlwZXMuIFRoZXNlIGBQYXJzZU5vZGVgcyBhcmUgY29uc3RydWN0ZWQgd2l0aGluIGBQYXJzZXJgIGJ5XG4vLyBsb29raW5nIHVwIHRoZSBgc3ltYm9sc2AgbWFwLlxudmFyIEFUT01TID0ge1xuICBcImJpblwiOiAxLFxuICBcImNsb3NlXCI6IDEsXG4gIFwiaW5uZXJcIjogMSxcbiAgXCJvcGVuXCI6IDEsXG4gIFwicHVuY3RcIjogMSxcbiAgXCJyZWxcIjogMVxufTtcbnZhciBOT05fQVRPTVMgPSB7XG4gIFwiYWNjZW50LXRva2VuXCI6IDEsXG4gIFwibWF0aG9yZFwiOiAxLFxuICBcIm9wLXRva2VuXCI6IDEsXG4gIFwic3BhY2luZ1wiOiAxLFxuICBcInRleHRvcmRcIjogMVxufTtcbnZhciBzeW1ib2xzID0ge1xuICBcIm1hdGhcIjoge30sXG4gIFwidGV4dFwiOiB7fVxufTtcbi8qKiBgYWNjZXB0VW5pY29kZUNoYXIgPSB0cnVlYCBpcyBvbmx5IGFwcGxpY2FibGUgaWYgYHJlcGxhY2VgIGlzIHNldC4gKi9cblxuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lLCBhY2NlcHRVbmljb2RlQ2hhcikge1xuICBzeW1ib2xzW21vZGVdW25hbWVdID0ge1xuICAgIGZvbnQsXG4gICAgZ3JvdXAsXG4gICAgcmVwbGFjZVxuICB9O1xuXG4gIGlmIChhY2NlcHRVbmljb2RlQ2hhciAmJiByZXBsYWNlKSB7XG4gICAgc3ltYm9sc1ttb2RlXVtyZXBsYWNlXSA9IHN5bWJvbHNbbW9kZV1bbmFtZV07XG4gIH1cbn0gLy8gU29tZSBhYmJyZXZpYXRpb25zIGZvciBjb21tb25seSB1c2VkIHN0cmluZ3MuXG4vLyBUaGlzIGhlbHBzIG1pbmlmeSB0aGUgY29kZSwgYW5kIGFsc28gc3BvdHRpbmcgdHlwb3MgdXNpbmcganNoaW50LlxuLy8gbW9kZXM6XG5cbnZhciBtYXRoID0gXCJtYXRoXCI7XG52YXIgdGV4dCA9IFwidGV4dFwiOyAvLyBmb250czpcblxudmFyIG1haW4gPSBcIm1haW5cIjtcbnZhciBhbXMgPSBcImFtc1wiOyAvLyBncm91cHM6XG5cbnZhciBhY2NlbnQgPSBcImFjY2VudC10b2tlblwiO1xudmFyIGJpbiA9IFwiYmluXCI7XG52YXIgY2xvc2UgPSBcImNsb3NlXCI7XG52YXIgaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcC10b2tlblwiO1xudmFyIG9wZW4gPSBcIm9wZW5cIjtcbnZhciBwdW5jdCA9IFwicHVuY3RcIjtcbnZhciByZWwgPSBcInJlbFwiO1xudmFyIHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbnZhciB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7IC8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG4vLyBSZWxhdGlvbiBTeW1ib2xzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE1XCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTsgLy8gUHVuY3R1YXRpb25cblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTAwMmVcIiwgXCJcXFxcbGRvdHBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90cFwiKTsgLy8gTWlzYyBTeW1ib2xzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMzVcIiwgXCJcXFxcYWxlcGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjAwXCIsIFwiXFxcXGZvcmFsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMGZcIiwgXCJcXFxcaGJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDNcIiwgXCJcXFxcZXhpc3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwN1wiLCBcIlxcXFxuYWJsYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmRcIiwgXCJcXFxcZmxhdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMTNcIiwgXCJcXFxcZWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZVwiLCBcIlxcXFxuYXR1cmFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2M1wiLCBcIlxcXFxjbHVic3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMThcIiwgXCJcXFxcd3BcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZmXCIsIFwiXFxcXHNoYXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2MlwiLCBcIlxcXFxkaWFtb25kc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMWNcIiwgXCJcXFxcUmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYxXCIsIFwiXFxcXGhlYXJ0c3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIxMTFcIiwgXCJcXFxcSW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYwXCIsIFwiXFxcXHNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTdcIiwgXCJcXFxcU1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTdcIiwgXCJcXFxcU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiKTsgLy8gTWF0aCBhbmQgVGV4dFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFx0ZXh0ZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFx0ZXh0ZGFnZ2VyZGJsXCIpOyAvLyBMYXJnZSBEZWxpbWl0ZXJzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyM2IxXCIsIFwiXFxcXHJtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyM2IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjdlZlwiLCBcIlxcXFxyZ3JvdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyN2VlXCIsIFwiXFxcXGxncm91cFwiLCB0cnVlKTsgLy8gQmluYXJ5IE9wZXJhdG9yc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMDI2XCIsIFwiXFxcXEFuZFwiKTsgLy8gZnJvbSBhbXNtYXRoXG4vLyBBcnJvdyBTeW1ib2xzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNVwiLCBcIlxcXFxsb25nbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQwXCIsIFwiXFxcXExlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmOFwiLCBcIlxcXFxMb25nbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y2XCIsIFwiXFxcXGxvbmdyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjlcIiwgXCJcXFxcTG9uZ3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTRcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjdcIiwgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQ0XCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZhXCIsIFwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhNlwiLCBcIlxcXFxtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZmNcIiwgXCJcXFxcbG9uZ21hcHN0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5N1wiLCBcIlxcXFxuZWFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWE5XCIsIFwiXFxcXGhvb2tsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYWFcIiwgXCJcXFxcaG9va3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOThcIiwgXCJcXFxcc2VhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFiY1wiLCBcIlxcXFxsZWZ0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWMwXCIsIFwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk5XCIsIFwiXFxcXHN3YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmRcIiwgXCJcXFxcbGVmdGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWMxXCIsIFwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTZcIiwgXCJcXFxcbndhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjY1wiLCBcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLCB0cnVlKTsgLy8gQU1TIE5lZ2F0ZWQgQmluYXJ5IFJlbGF0aW9uc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2ZVwiLCBcIlxcXFxubGVzc1wiLCB0cnVlKTsgLy8gU3ltYm9sIG5hbWVzIHByZWNlZWRlZCBieSBcIkBcIiBlYWNoIGhhdmUgYSBjb3JyZXNwb25kaW5nIG1hY3JvLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxMFwiLCBcIlxcXFxAbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcQG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODdcIiwgXCJcXFxcbG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY4XCIsIFwiXFxcXGxuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGNcIiwgXCJcXFxcQGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU2XCIsIFwiXFxcXGxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODlcIiwgXCJcXFxcbG5hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTBcIiwgXCJcXFxcbnByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU4XCIsIFwiXFxcXHByZWNuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0MVwiLCBcIlxcXFxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMDZcIiwgXCJcXFxcQG5zaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhY1wiLCBcIlxcXFxudmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhZFwiLCBcIlxcXFxudkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlYVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWNcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGFcIiwgXCJcXFxcc3Vic2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWFcIiwgXCJcXFxcQHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFxAdmFyc3Vic2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZmXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwZlwiLCBcIlxcXFxAbmdlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGVcIiwgXCJcXFxcQG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcQGd2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOGFcIiwgXCJcXFxcZ25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4MVwiLCBcIlxcXFxuc3VjY1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMSB0byBcXG5zdWNjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyNDYgdG8gXFxzaW1uZXFxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXEBuc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5wYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFmXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmViXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWRcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE4XCIsIFwiXFxcXEBuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcc3Vwc2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMWJcIiwgXCJcXFxcQHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFxAdmFyc3Vwc2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFlXCIsIFwiXFxcXG5WZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjZcIiwgXCJcXFxcc3VjY25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxNlwiLCBcIlxcXFxAbnN1YnNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjVcIiwgXCJcXFxcdW5yaGRcIik7IC8vIEFNUyBOZWdhdGVkIEFycm93c1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YVwiLCBcIlxcXFxubGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZFwiLCBcIlxcXFxuTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2ZcIiwgXCJcXFxcblJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZVwiLCBcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIEFNUyBNaXNjXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjAzNVwiLCBcIlxcXFxiYWNrcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YjJcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViY1wiLCBcIlxcXFxibGFja3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMFwiLCBcIlxcXFxibGFja3NxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjllYlwiLCBcIlxcXFxibGFja2xvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI2MDVcIiwgXCJcXFxcYmlnc3RhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMlwiLCBcIlxcXFxzcGhlcmljYWxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIwMVwiLCBcIlxcXFxjb21wbGVtZW50XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBVK0YwIHRvIFxcbWF0aGV0aC4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXGV0aFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBmMFwiLCBcIlxcdTAwZjBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1NzFcIiwgXCJcXFxcZGlhZ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcyXCIsIFwiXFxcXGRpYWdkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWExXCIsIFwiXFxcXHNxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxCb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcRGlhbW9uZFwiKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgVStBNSB0byBcXG1hdGh5ZW4uIFdlIG1hcCB0byBBTVMgZnVuY3Rpb24gXFx5ZW5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwMGE1XCIsIFwiXFxcXHllblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTsgLy8gQU1TIEhlYnJld1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzZcIiwgXCJcXFxcYmV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzOFwiLCBcIlxcXFxkYWxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzdcIiwgXCJcXFxcZ2ltZWxcIiwgdHJ1ZSk7IC8vIEFNUyBHcmVla1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAzZGRcIiwgXCJcXFxcZGlnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNmMFwiLCBcIlxcXFx2YXJrYXBwYVwiKTsgLy8gQU1TIERlbGltaXRlcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTBjXCIsIFwiXFxcXEB1bGNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MTBcIiwgXCJcXFxcQHVyY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTE0XCIsIFwiXFxcXEBsbGNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MThcIiwgXCJcXFxcQGxyY29ybmVyXCIsIHRydWUpOyAvLyBBTVMgQmluYXJ5IFJlbGF0aW9uc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7IC8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFx0aGVyZWZvcmUgaXMgYSBtYXRob3JkIGF0b20uXG4vLyBXZSBrZXB0IHRoZSBhbXNzeW1iIGF0b20gdHlwZSwgd2hpY2ggaXMgcmVsLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTsgLy8gdW5pY29kZS1tYXRoIHNheXMgdGhhdCBcXGJlY2F1c2UgaXMgYSBtYXRob3JkIGF0b20uXG4vLyBXZSBrZXB0IHRoZSBhbXNzeW1iIGF0b20gdHlwZSwgd2hpY2ggaXMgcmVsLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNVwiLCBcIlxcXFxiZWNhdXNlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiMlwiLCBcIlxcXFxsaGRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiM1wiLCBcIlxcXFxyaGRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0MlwiLCBcIlxcXFxlcXNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJjOFwiLCBcIlxcXFxKb2luXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcRG90ZXFcIiwgdHJ1ZSk7IC8vIEFNUyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZW50ZXJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIsIHRydWUpOyAvLyBBTVMgQXJyb3dzXG4vLyBOb3RlOiB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUyIHRvIHRoZWlyIG93biBmdW5jdGlvbiBcXHJpZ2h0ZGFzaGFycm93LlxuLy8gV2UnbGwgbWFwIGl0IHRvIEFNUyBmdW5jdGlvbiBcXGRhc2hyaWdodGFycm93LiBJdCBwcm9kdWNlcyB0aGUgc2FtZSBhdG9tLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMCB0byBcXGxlZnRkYXNoYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJhIHRvIFxcYWN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiYVwiLCBcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiMFwiLCBcIlxcXFxMc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOFwiLCBcIlxcXFx1cHVwYXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmZcIiwgXCJcXFxcdXBoYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWMzXCIsIFwiXFxcXGRvd25oYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJiNlwiLCBcIlxcXFxvcmlnb2ZcIiwgdHJ1ZSk7IC8vIG5vdCBpbiBmb250XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJiN1wiLCBcIlxcXFxpbWFnZW9mXCIsIHRydWUpOyAvLyBub3QgaW4gZm9udFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJiIHRvIFxcY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJiXCIsIFwiXFxcXGNpcmNsZWFycm93cmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiMVwiLCBcIlxcXFxSc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYVwiLCBcIlxcXFxkb3duZG93bmFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJlXCIsIFwiXFxcXHVwaGFycG9vbnJpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzJcIiwgXCJcXFxcZG93bmhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRkXCIsIFwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRkXCIsIFwiXFxcXGxlYWRzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkYlwiLCBcIlxcXFxScmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJlXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXHRleHRkb2xsYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXHRleHR1bmRlcnNjb3JlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJBXCIsIFwiXFx1MDM5MVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIkJcIiwgXCJcXHUwMzkyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiRVwiLCBcIlxcdTAzOTVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MDM5NlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIkhcIiwgXCJcXHUwMzk3XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiSVwiLCBcIlxcdTAzOTlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJLXCIsIFwiXFx1MDM5QVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIk1cIiwgXCJcXHUwMzlDXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiTlwiLCBcIlxcdTAzOURcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJPXCIsIFwiXFx1MDM5RlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlBcIiwgXCJcXHUwM0ExXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiVFwiLCBcIlxcdTAzQTRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJYXCIsIFwiXFx1MDNBN1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbmVnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhY1wiLCBcIlxcXFxsbm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNFwiLCBcIlxcXFx0b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmE1XCIsIFwiXFxcXGJvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDVcIiwgXCJcXFxcZW1wdHlzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMDVcIiwgXCJcXFxcdmFybm90aGluZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjFcIiwgXCJcXFxcYWxwaGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IyXCIsIFwiXFxcXGJldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IzXCIsIFwiXFxcXGdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNFwiLCBcIlxcXFxkZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZjVcIiwgXCJcXFxcZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjZcIiwgXCJcXFxcemV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjdcIiwgXCJcXFxcZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiOFwiLCBcIlxcXFx0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjlcIiwgXCJcXFxcaW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmFcIiwgXCJcXFxca2FwcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JiXCIsIFwiXFxcXGxhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmNcIiwgXCJcXFxcbXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JkXCIsIFwiXFxcXG51XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZVwiLCBcIlxcXFx4aVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmZcIiwgXCJcXFxcb21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzBcIiwgXCJcXFxccGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MxXCIsIFwiXFxcXHJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzNcIiwgXCJcXFxcc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M0XCIsIFwiXFxcXHRhdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzVcIiwgXCJcXFxcdXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDVcIiwgXCJcXFxccGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjN1wiLCBcIlxcXFxjaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M4XCIsIFwiXFxcXHBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzlcIiwgXCJcXFxcb21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I1XCIsIFwiXFxcXHZhcmVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2QxXCIsIFwiXFxcXHZhcnRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkNlwiLCBcIlxcXFx2YXJwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZjFcIiwgXCJcXFxcdmFycmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMlwiLCBcIlxcXFx2YXJzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzZcIiwgXCJcXFxcdmFycGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiKlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiK1wiLCBcIitcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTJcIiwgXCItXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM1XCIsIFwiXFxcXGNkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMThcIiwgXCJcXFxcY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MDBmN1wiLCBcIlxcXFxkaXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwYjFcIiwgXCJcXFxccG1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZDdcIiwgXCJcXFxcdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjlcIiwgXCJcXFxcY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjJhXCIsIFwiXFxcXGN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzZXRtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFxsYW5kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXGxvclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFx3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFx2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjFhXCIsIFwiXFxcXHN1cmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyN2U4XCIsIFwiXFxcXGxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIyMjNcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyMjI1XCIsIFwiXFxcXGxWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIj9cIiwgXCI/XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIiFcIiwgXCIhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTI3ZTlcIiwgXCJcXFxccmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIyMjNcIiwgXCJcXFxccnZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjIyNVwiLCBcIlxcXFxyVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPVwiLCBcIj1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXGFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0NVwiLCBcIlxcXFxjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxnZXRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjA4XCIsIFwiXFxcXGluXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHVlMDIwXCIsIFwiXFxcXEBub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjgzXCIsIFwiXFxcXHN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4NlwiLCBcIlxcXFxzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIlxcXFxsdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXHNwYWNlXCIpOyAvLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXG5vYnJlYWtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcYWxsb3dicmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCIsXCIsIFwiLFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCI7XCIsIFwiO1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM2XCIsIFwiXFxcXHN0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHRleHRicmFjZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx0ZXh0YnJhY2VyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIntcIiwgXCJcXFxcbGJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIn1cIiwgXCJcXFxccmJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiKFwiLCBcIlxcXFxscGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCI8XCIsIFwiXFxcXHRleHRsZXNzXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIj5cIiwgXCJcXFxcdGV4dGdyZWF0ZXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwYVwiLCBcIlxcXFxsZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjMwYlwiLCBcIlxcXFxyZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyMzA4XCIsIFwiXFxcXGxjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMDlcIiwgXCJcXFxccmNlaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyM1wiLCBcIlxcXFx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifFwiLCBcIlxcXFx0ZXh0YmFyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcdGV4dGJhcmRibFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXHRleHRiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJeXCIsIFwiXFxcXHRleHRhc2NpaWNpcmN1bVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmZcIiwgXCJcXFxcb2lpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIzMFwiLCBcIlxcXFxvaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwNlwiLCBcIlxcXFxiaWdzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXHNtYWxsaW50XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcdGV4dGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbWF0aGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxsZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmVmXCIsIFwiXFxcXEBjZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2YXJ2ZG90c1wiKTsgLy8gXFx2ZG90cyBpcyBhIG1hY3JvXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTIwZDdcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxtYXRocmluZ1wiKTsgLy8gXFxpbWF0aCBhbmQgXFxqbWF0aCBzaG91bGQgYmUgaW52YXJpYW50IHRvIFxcbWF0aHJtLCBcXG1hdGhiZiwgZXRjLiwgc28gdXNlIFBVQVxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHVlMTMxXCIsIFwiXFxcXEBpbWF0aFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdWUyMzdcIiwgXCJcXFxcQGptYXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcdTAxMzFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMjM3XCIsIFwiXFx1MDIzN1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZGZcIiwgXCJcXFxcc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGU2XCIsIFwiXFxcXGFlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDE1M1wiLCBcIlxcXFxvZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZjhcIiwgXCJcXFxcb1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYzZcIiwgXCJcXFxcQUVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTUyXCIsIFwiXFxcXE9FXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBkOFwiLCBcIlxcXFxPXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXCdcIik7IC8vIGFjdXRlXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzZcIiwgXCJcXFxcXlwiKTsgLy8gY2lyY3VtZmxleFxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZGNcIiwgXCJcXFxcflwiKTsgLy8gdGlsZGVcblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZDhcIiwgXCJcXFxcdVwiKTsgLy8gYnJldmVcblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXC5cIik7IC8vIGRvdCBhYm92ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZGFcIiwgXCJcXFxcclwiKTsgLy8gcmluZyBhYm92ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzdcIiwgXCJcXFxcdlwiKTsgLy8gY2Fyb25cblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhcmVzaXNcblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRkXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTI1ZWZcIiwgXCJcXFxcdGV4dGNpcmNsZWRcIik7IC8vIFxcYmlnY2lyYyBnbHlwaFxuLy8gVGhlc2UgbGlnYXR1cmVzIGFyZSBkZXRlY3RlZCBhbmQgY3JlYXRlZCBpbiBQYXJzZXIuanMncyBgZm9ybUxpZ2F0dXJlc2AuXG5cbnZhciBsaWdhdHVyZXMgPSB7XG4gIFwiLS1cIjogdHJ1ZSxcbiAgXCItLS1cIjogdHJ1ZSxcbiAgXCJgYFwiOiB0cnVlLFxuICBcIicnXCI6IHRydWVcbn07XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIlxcXFx0ZXh0ZW1kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiXFxcXHRleHRxdW90ZWRibGxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiJydcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpOyAvLyAgXFxkZWdyZWUgZnJvbSBnZW5zeW1iIHBhY2thZ2VcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXGRlZ3JlZVwiKTsgLy8gXFx0ZXh0ZGVncmVlIGZyb20gaW5wdXRlbmMgcGFja2FnZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXHRleHRkZWdyZWVcIiwgdHJ1ZSk7IC8vIFRPRE86IEluIExhVGVYLCBcXHBvdW5kcyBjYW4gZ2VuZXJhdGUgYSBkaWZmZXJlbnQgY2hhcmFjdGVyIGluIHRleHQgYW5kIG1hdGhcbi8vIG1vZGUsIGJ1dCBhbW9uZyBvdXIgZm9udHMsIG9ubHkgTWFpbi1SZWd1bGFyIGRlZmluZXMgdGhpcyBjaGFyYWN0ZXIgXCIxNjNcIi5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpOyAvLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5cbnZhciBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBjaCA9IG1hdGhUZXh0U3ltYm9scy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufSAvLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZVxuXG5cbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rXFxcIjs6Py8uLFwiO1xuXG5mb3IgKHZhciBfaSA9IDA7IF9pIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBfaSsrKSB7XG4gIHZhciBfY2ggPSB0ZXh0U3ltYm9scy5jaGFyQXQoX2kpO1xuXG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gsIF9jaCk7XG59IC8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlLCBhbmQgbWF0aG9yZHMgaW4gbWF0aCBtb2RlXG5cblxudmFyIGxldHRlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcblxuZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGV0dGVycy5sZW5ndGg7IF9pMisrKSB7XG4gIHZhciBfY2gyID0gbGV0dGVycy5jaGFyQXQoX2kyKTtcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMiwgX2NoMik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gyLCBfY2gyKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTsgLy8gYmxhY2tib2FyZCBib2xkXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiQ1wiLCBcIlxcdTIxMDJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIkhcIiwgXCJcXHUyMTBEXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJIXCIsIFwiXFx1MjEwRFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiTlwiLCBcIlxcdTIxMTVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiUFwiLCBcIlxcdTIxMTlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlFcIiwgXCJcXHUyMTFBXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJRXCIsIFwiXFx1MjExQVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiUlwiLCBcIlxcdTIxMURcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiWlwiLCBcIlxcdTIxMjRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gaXRhbGljIGgsIFBsYW5jayBjb25zdGFudFxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbi8vIFNvbWUgZWRpdG9ycyBkbyBub3QgZGVhbCB3ZWxsIHdpdGggd2lkZSBjaGFyYWN0ZXJzLiBTbyBkb24ndCB3cml0ZSB0aGVcbi8vIHN0cmluZyBpbnRvIHRoaXMgZmlsZS4gSW5zdGVhZCwgY3JlYXRlIHRoZSBzdHJpbmcgZnJvbSB0aGUgc3Vycm9nYXRlIHBhaXIuXG5cbnZhciB3aWRlQ2hhciA9IFwiXCI7XG5cbmZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldHRlcnMubGVuZ3RoOyBfaTMrKykge1xuICB2YXIgX2NoMyA9IGxldHRlcnMuY2hhckF0KF9pMyk7IC8vIFRoZSBoZXggbnVtYmVycyBpbiB0aGUgbmV4dCBsaW5lIGFyZSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAvLyAweEQ4MzUgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIGZvciBhbGwgbGV0dGVycyBpbiB0aGUgcmFuZ2Ugd2Ugc3VwcG9ydC5cbiAgLy8gMHhEQzAwIGlzIHRoZSBsb3cgc3Vycm9nYXRlIGZvciBib2xkIEEuXG5cblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMDAgKyBfaTMpOyAvLyBBLVogYS16IGJvbGRcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMzQgKyBfaTMpOyAvLyBBLVogYS16IGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REM2OCArIF9pMyk7IC8vIEEtWiBhLXogYm9sZCBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMDQgKyBfaTMpOyAvLyBBLVogYS16IEZyYWN0dXJcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREQTAgKyBfaTMpOyAvLyBBLVogYS16IHNhbnMtc2VyaWZcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERERDQgKyBfaTMpOyAvLyBBLVogYS16IHNhbnMgYm9sZFxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REUwOCArIF9pMyk7IC8vIEEtWiBhLXogc2FucyBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERFNzAgKyBfaTMpOyAvLyBBLVogYS16IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG5cbiAgaWYgKF9pMyA8IDI2KSB7XG4gICAgLy8gS2FUZVggZm9udHMgaGF2ZSBvbmx5IGNhcGl0YWwgbGV0dGVycyBmb3IgYmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQuXG4gICAgLy8gU2VlIGV4Y2VwdGlvbiBmb3IgayBiZWxvdy5cbiAgICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMzggKyBfaTMpOyAvLyBBLVogZG91YmxlIHN0cnVja1xuXG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICAgIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REM5QyArIF9pMyk7IC8vIEEtWiBzY3JpcHRcblxuICAgIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgfSAvLyBUT0RPOiBBZGQgYm9sZCBzY3JpcHQgd2hlbiBpdCBpcyBzdXBwb3J0ZWQgYnkgYSBLYVRlWCBmb250LlxuXG59IC8vIFwia1wiIGlzIHRoZSBvbmx5IGRvdWJsZSBzdHJ1Y2sgbG93ZXIgY2FzZSBsZXR0ZXIgaW4gdGhlIEthVGVYIGZvbnRzLlxuXG5cbndpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQ1Qyk7IC8vIGsgZG91YmxlIHN0cnVja1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJrXCIsIHdpZGVDaGFyKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcImtcIiwgd2lkZUNoYXIpOyAvLyBOZXh0LCBzb21lIHdpZGUgY2hhcmFjdGVyIG51bWVyYWxzXG5cbmZvciAodmFyIF9pNCA9IDA7IF9pNCA8IDEwOyBfaTQrKykge1xuICB2YXIgX2NoNCA9IF9pNC50b1N0cmluZygpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REZDRSArIF9pNCk7IC8vIDAtOSBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkUyICsgX2k0KTsgLy8gMC05IHNhbnMgc2VyaWZcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRUMgKyBfaTQpOyAvLyAwLTkgYm9sZCBzYW5zXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkY2ICsgX2k0KTsgLy8gMC05IG1vbm9zcGFjZVxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2g0LCB3aWRlQ2hhcik7XG59IC8vIFdlIGFkZCB0aGVzZSBMYXRpbi0xIGxldHRlcnMgYXMgc3ltYm9scyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksXG4vLyBidXQgdGhleSBhcmUgbm90IGFjdHVhbGx5IGluIHRoZSBmb250LCBub3IgYXJlIHRoZXkgc3VwcG9ydGVkIGJ5IHRoZVxuLy8gVW5pY29kZSBhY2NlbnQgbWVjaGFuaXNtLCBzbyB0aGV5IGZhbGwgYmFjayB0byBUaW1lcyBmb250IGFuZCBsb29rIHVnbHkuXG4vLyBUT0RPKGVkZW1haW5lKTogRml4IHRoaXMuXG5cblxudmFyIGV4dHJhTGF0aW4gPSBcIlxcdTAwZDBcXHUwMGRlXFx1MDBmZVwiO1xuXG5mb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBleHRyYUxhdGluLmxlbmd0aDsgX2k1KyspIHtcbiAgdmFyIF9jaDUgPSBleHRyYUxhdGluLmNoYXJBdChfaTUpO1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2g1LCBfY2g1KTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDUsIF9jaDUpO1xufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzdXBwb3J0IGZvciBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbiAqIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbiAqXG4gKiBGdW5jdGlvbiB3aWRlQ2hhcmFjdGVyRm9udCB0YWtlcyBhIHdpZGUgY2hhcmFjdGVyIGFzIGlucHV0IGFuZCByZXR1cm5zXG4gKiB0aGUgZm9udCBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gcmVuZGVyIGl0IHByb3Blcmx5LlxuICovXG4vKipcbiAqIERhdGEgYmVsb3cgaXMgZnJvbSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbiAqIFRoYXQgZG9jdW1lbnQgc29ydHMgY2hhcmFjdGVycyBpbnRvIGdyb3VwcyBieSBmb250IHR5cGUsIHNheSBib2xkIG9yIGl0YWxpYy5cbiAqXG4gKiBJbiB0aGUgYXJyYXlzIGJlbG93LCBlYWNoIHN1YmFycmF5IGNvbnNpc3RzIHRocmVlIGVsZW1lbnRzOlxuICogICAgICAqIFRoZSBDU1MgY2xhc3Mgb2YgdGhhdCBncm91cCB3aGVuIGluIG1hdGggbW9kZS5cbiAqICAgICAgKiBUaGUgQ1NTIGNsYXNzIG9mIHRoYXQgZ3JvdXAgd2hlbiBpbiB0ZXh0IG1vZGUuXG4gKiAgICAgICogVGhlIGZvbnQgbmFtZSwgc28gdGhhdCBLYVRlWCBjYW4gZ2V0IGZvbnQgbWV0cmljcy5cbiAqL1xuXG52YXIgd2lkZUxhdGluTGV0dGVyRGF0YSA9IFtbXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIEEtWiBib2xkIHVwcmlnaHRcbltcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gYS16IGJvbGQgdXByaWdodFxuW1wibWF0aG5vcm1hbFwiLCBcInRleHRpdFwiLCBcIk1hdGgtSXRhbGljXCJdLCAvLyBBLVogaXRhbGljXG5bXCJtYXRobm9ybWFsXCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBBLVogYm9sZCBpdGFsaWNcbltcImJvbGRzeW1ib2xcIiwgXCJib2xkc3ltYm9sXCIsIFwiTWFpbi1Cb2xkSXRhbGljXCJdLCAvLyBhLXogYm9sZCBpdGFsaWNcbi8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuXG4vLyBUaGlzIGFsaWducyB3aXRoIHVuaWNvZGUtbWF0aCBhbmQgbWF0aCBmb250cyAoZXhjZXB0IENhbWJyaWEgTWF0aCkuXG5bXCJtYXRoc2NyXCIsIFwidGV4dHNjclwiLCBcIlNjcmlwdC1SZWd1bGFyXCJdLCAvLyBBLVogc2NyaXB0XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBzY3JpcHQuICBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBzY3JpcHQuIE5vIGZvbnRcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBGcmFrdHVyXG5bXCJtYXRoZnJha1wiLCBcInRleHRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogRnJha3R1clxuW1wibWF0aGJiXCIsIFwidGV4dGJiXCIsIFwiQU1TLVJlZ3VsYXJcIl0sIC8vIEEtWiBkb3VibGUtc3RydWNrXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gayBkb3VibGUtc3RydWNrXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIEZyYWt0dXIgTm8gZm9udCBtZXRyaWNzXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIEZyYWt0dXIuICAgTm8gZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyBBLVogc2Fucy1zZXJpZlxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIGEteiBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBBLVogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyBhLXogYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gQS1aIGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJtYXRoaXRzZlwiLCBcInRleHRpdHNmXCIsIFwiU2Fuc1NlcmlmLUl0YWxpY1wiXSwgLy8gYS16IGl0YWxpYyBzYW5zLXNlcmlmXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIEEtWiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIGl0YWxpYyBzYW5zLiBObyBmb250XG5bXCJtYXRodHRcIiwgXCJ0ZXh0dHRcIiwgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIl0sIC8vIEEtWiBtb25vc3BhY2VcbltcIm1hdGh0dFwiLCBcInRleHR0dFwiLCBcIlR5cGV3cml0ZXItUmVndWxhclwiXSAvLyBhLXogbW9ub3NwYWNlXG5dO1xudmFyIHdpZGVOdW1lcmFsRGF0YSA9IFtbXCJtYXRoYmZcIiwgXCJ0ZXh0YmZcIiwgXCJNYWluLUJvbGRcIl0sIC8vIDAtOSBib2xkXG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIDAtOSBkb3VibGUtc3RydWNrLiBObyBLYVRlWCBmb250LlxuW1wibWF0aHNmXCIsIFwidGV4dHNmXCIsIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIl0sIC8vIDAtOSBzYW5zLXNlcmlmXG5bXCJtYXRoYm9sZHNmXCIsIFwidGV4dGJvbGRzZlwiLCBcIlNhbnNTZXJpZi1Cb2xkXCJdLCAvLyAwLTkgYm9sZCBzYW5zLXNlcmlmXG5bXCJtYXRodHRcIiwgXCJ0ZXh0dHRcIiwgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIl0gLy8gMC05IG1vbm9zcGFjZVxuXTtcbnZhciB3aWRlQ2hhcmFjdGVyRm9udCA9IGZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250KHdpZGVDaGFyLCBtb2RlKSB7XG4gIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBjb2RlUG9pbnRBdCgpLiBTbyB3b3JrIHdpdGggdGhlIHN1cnJvZ2F0ZSBwYWlyLlxuICB2YXIgSCA9IHdpZGVDaGFyLmNoYXJDb2RlQXQoMCk7IC8vIGhpZ2ggc3Vycm9nYXRlXG5cbiAgdmFyIEwgPSB3aWRlQ2hhci5jaGFyQ29kZUF0KDEpOyAvLyBsb3cgc3Vycm9nYXRlXG5cbiAgdmFyIGNvZGVQb2ludCA9IChIIC0gMHhEODAwKSAqIDB4NDAwICsgKEwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgdmFyIGogPSBtb2RlID09PSBcIm1hdGhcIiA/IDAgOiAxOyAvLyBjb2x1bW4gaW5kZXggZm9yIENTUyBjbGFzcy5cblxuICBpZiAoMHgxRDQwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDZBNCkge1xuICAgIC8vIHdpZGVMYXRpbkxldHRlckRhdGEgY29udGFpbnMgZXhhY3RseSAyNiBjaGFycyBvbiBlYWNoIHJvdy5cbiAgICAvLyBTbyB3ZSBjYW4gY2FsY3VsYXRlIHRoZSByZWxldmFudCByb3cuIE5vIHRyYXZlcnNlIG5lY2Vzc2FyeS5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKGNvZGVQb2ludCAtIDB4MUQ0MDApIC8gMjYpO1xuICAgIHJldHVybiBbd2lkZUxhdGluTGV0dGVyRGF0YVtpXVsyXSwgd2lkZUxhdGluTGV0dGVyRGF0YVtpXVtqXV07XG4gIH0gZWxzZSBpZiAoMHgxRDdDRSA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUQ3RkYpIHtcbiAgICAvLyBOdW1lcmFscywgdGVuIHBlciByb3cuXG4gICAgdmFyIF9pID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMHgxRDdDRSkgLyAxMCk7XG5cbiAgICByZXR1cm4gW3dpZGVOdW1lcmFsRGF0YVtfaV1bMl0sIHdpZGVOdW1lcmFsRGF0YVtfaV1bal1dO1xuICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PT0gMHgxRDZBNSB8fCBjb2RlUG9pbnQgPT09IDB4MUQ2QTYpIHtcbiAgICAvLyBkb3RsZXNzIGkgb3IgalxuICAgIHJldHVybiBbd2lkZUxhdGluTGV0dGVyRGF0YVswXVsyXSwgd2lkZUxhdGluTGV0dGVyRGF0YVswXVtqXV07XG4gIH0gZWxzZSBpZiAoMHgxRDZBNiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDFEN0NFKSB7XG4gICAgLy8gR3JlZWsgbGV0dGVycy4gTm90IHN1cHBvcnRlZCwgeWV0LlxuICAgIHJldHVybiBbXCJcIiwgXCJcIl07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBhbnkgd2lkZSBjaGFyYWN0ZXJzIG91dHNpZGUgMUQ0MDDigJMxRDdGRi5cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoYXJhY3RlcjogXCIgKyB3aWRlQ2hhcik7XG4gIH1cbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgZ2l2ZW4gc3ltYm9sIGluIGZvbnRNZXRyaWNzLCBhZnRlciBhcHBseWluZyBhbnkgc3ltYm9sXG4gKiByZXBsYWNlbWVudHMgZGVmaW5lZCBpbiBzeW1ib2wuanNcbiAqL1xudmFyIGxvb2t1cFN5bWJvbCA9IGZ1bmN0aW9uIGxvb2t1cFN5bWJvbCh2YWx1ZSwgLy8gVE9ETygjOTYzKTogVXNlIGEgdW5pb24gdHlwZSBmb3IgdGhpcy5cbmZvbnROYW1lLCBtb2RlKSB7XG4gIC8vIFJlcGxhY2UgdGhlIHZhbHVlIHdpdGggaXRzIHJlcGxhY2VkIHZhbHVlIGZyb20gc3ltYm9sLmpzXG4gIGlmIChzeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbWV0cmljczogZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udE5hbWUsIG1vZGUpXG4gIH07XG59O1xuLyoqXG4gKiBNYWtlcyBhIHN5bWJvbE5vZGUgYWZ0ZXIgdHJhbnNsYXRpb24gdmlhIHRoZSBsaXN0IG9mIHN5bWJvbHMgaW4gc3ltYm9scy5qcy5cbiAqIENvcnJlY3RseSBwdWxscyBvdXQgbWV0cmljcyBmb3IgdGhlIGNoYXJhY3RlciwgYW5kIG9wdGlvbmFsbHkgdGFrZXMgYSBsaXN0IG9mXG4gKiBjbGFzc2VzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBub2RlLlxuICpcbiAqIFRPRE86IG1ha2UgYXJndW1lbnQgb3JkZXIgY2xvc2VyIHRvIG1ha2VTcGFuXG4gKiBUT0RPOiBhZGQgYSBzZXBhcmF0ZSBhcmd1bWVudCBmb3IgbWF0aCBjbGFzcyAoZS5nLiBgbW9wYCwgYG1iaW5gKSwgd2hpY2hcbiAqIHNob3VsZCBpZiBwcmVzZW50IGNvbWUgZmlyc3QgaW4gYGNsYXNzZXNgLlxuICogVE9ETygjOTUzKTogTWFrZSBgb3B0aW9uc2AgbWFuZGF0b3J5IGFuZCBhbHdheXMgcGFzcyBpdCBpbi5cbiAqL1xuXG5cbnZhciBtYWtlU3ltYm9sID0gZnVuY3Rpb24gbWFrZVN5bWJvbCh2YWx1ZSwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgdmFyIGxvb2t1cCA9IGxvb2t1cFN5bWJvbCh2YWx1ZSwgZm9udE5hbWUsIG1vZGUpO1xuICB2YXIgbWV0cmljcyA9IGxvb2t1cC5tZXRyaWNzO1xuICB2YWx1ZSA9IGxvb2t1cC52YWx1ZTtcbiAgdmFyIHN5bWJvbE5vZGU7XG5cbiAgaWYgKG1ldHJpY3MpIHtcbiAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJ0ZXh0XCIgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmZvbnQgPT09IFwibWF0aGl0XCIpIHtcbiAgICAgIGl0YWxpYyA9IDA7XG4gICAgfVxuXG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsIG1ldHJpY3Mud2lkdGgsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZW1pbHkpOiBGaWd1cmUgb3V0IGEgZ29vZCB3YXkgdG8gb25seSBwcmludCB0aGlzIGluIGRldmVsb3BtZW50XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTm8gY2hhcmFjdGVyIG1ldHJpY3MgXCIgKyAoXCJmb3IgJ1wiICsgdmFsdWUgKyBcIicgaW4gc3R5bGUgJ1wiICsgZm9udE5hbWUgKyBcIicgYW5kIG1vZGUgJ1wiICsgbW9kZSArIFwiJ1wiKSk7XG4gICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc3ltYm9sTm9kZS5tYXhGb250U2l6ZSA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IG9wdGlvbnMuZ2V0Q29sb3IoKTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgc3ltYm9sTm9kZS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW1ib2xOb2RlO1xufTtcbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gTWFpbi1SZWd1bGFyIG9yIEFNUy1SZWd1bGFyLlxuICogVXNlZCBmb3IgcmVsLCBiaW4sIG9wZW4sIGNsb3NlLCBpbm5lciwgYW5kIHB1bmN0LlxuICovXG5cblxudmFyIG1hdGhzeW0gPSBmdW5jdGlvbiBtYXRoc3ltKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gW107XG4gIH1cblxuICAvLyBEZWNpZGUgd2hhdCBmb250IHRvIHJlbmRlciB0aGUgc3ltYm9sIGluIGJ5IGl0cyBlbnRyeSBpbiB0aGUgc3ltYm9sc1xuICAvLyB0YWJsZS5cbiAgLy8gSGF2ZSBhIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiB0aGUgdmFsdWUgPSBcXCBiZWNhdXNlIHRoZSBcXCBpcyB1c2VkIGFzIGFcbiAgLy8gdGV4dG9yZCBpbiB1bnN1cHBvcnRlZCBjb21tYW5kIGVycm9ycyBidXQgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHJlZ3VsYXJcbiAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgLy8gdGFibGUgZm9yIHRleHQsIGFzIHdlbGwgYXMgYSBzcGVjaWFsIGNhc2UgZm9yIGJvbGRzeW1ib2wgYmVjYXVzZSBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYm9sZCArIGFuZCAtXG4gIGlmIChvcHRpb25zLmZvbnQgPT09IFwiYm9sZHN5bWJvbFwiICYmIGxvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYWluLUJvbGRcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIk1haW4tQm9sZFwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRoYmZcIl0pKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICByZXR1cm4gbWFrZVN5bWJvbCh2YWx1ZSwgXCJNYWluLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgfVxufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgdHdvIGZvbnQgbmFtZXMgKE1haW4tQm9sZCBhbmQgTWF0aC1Cb2xkSXRhbGljKSBhbmRcbiAqIGNvcnJlc3BvbmRpbmcgc3R5bGUgdGFncyAobWF0aGJmIG9yIGJvbGRzeW1ib2wpIHRvIHVzZSBmb3IgZm9udCBcImJvbGRzeW1ib2xcIixcbiAqIGRlcGVuZGluZyBvbiB0aGUgc3ltYm9sLiAgVXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBmb250TWFwIGZvciBmb250XG4gKiBcImJvbGRzeW1ib2xcIi5cbiAqL1xuXG5cbnZhciBib2xkc3ltYm9sID0gZnVuY3Rpb24gYm9sZHN5bWJvbCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSkge1xuICBpZiAodHlwZSAhPT0gXCJ0ZXh0b3JkXCIgJiYgbG9va3VwU3ltYm9sKHZhbHVlLCBcIk1hdGgtQm9sZEl0YWxpY1wiLCBtb2RlKS5tZXRyaWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnROYW1lOiBcIk1hdGgtQm9sZEl0YWxpY1wiLFxuICAgICAgZm9udENsYXNzOiBcImJvbGRzeW1ib2xcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gU29tZSBnbHlwaHMgZG8gbm90IGV4aXN0IGluIE1hdGgtQm9sZEl0YWxpYyBzbyB3ZSBuZWVkIHRvIHVzZVxuICAgIC8vIE1haW4tQm9sZCBpbnN0ZWFkLlxuICAgIHJldHVybiB7XG4gICAgICBmb250TmFtZTogXCJNYWluLUJvbGRcIixcbiAgICAgIGZvbnRDbGFzczogXCJtYXRoYmZcIlxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIE1ha2VzIGVpdGhlciBhIG1hdGhvcmQgb3IgdGV4dG9yZCBpbiB0aGUgY29ycmVjdCBmb250IGFuZCBjb2xvci5cbiAqL1xuXG5cbnZhciBtYWtlT3JkID0gZnVuY3Rpb24gbWFrZU9yZChncm91cCwgb3B0aW9ucywgdHlwZSkge1xuICB2YXIgbW9kZSA9IGdyb3VwLm1vZGU7XG4gIHZhciB0ZXh0ID0gZ3JvdXAudGV4dDtcbiAgdmFyIGNsYXNzZXMgPSBbXCJtb3JkXCJdOyAvLyBNYXRoIG1vZGUgb3IgT2xkIGZvbnQgKGkuZS4gXFxybSlcblxuICB2YXIgaXNGb250ID0gbW9kZSA9PT0gXCJtYXRoXCIgfHwgbW9kZSA9PT0gXCJ0ZXh0XCIgJiYgb3B0aW9ucy5mb250O1xuICB2YXIgZm9udE9yRmFtaWx5ID0gaXNGb250ID8gb3B0aW9ucy5mb250IDogb3B0aW9ucy5mb250RmFtaWx5O1xuXG4gIGlmICh0ZXh0LmNoYXJDb2RlQXQoMCkgPT09IDB4RDgzNSkge1xuICAgIC8vIHN1cnJvZ2F0ZSBwYWlycyBnZXQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgICB2YXIgW3dpZGVGb250TmFtZSwgd2lkZUZvbnRDbGFzc10gPSB3aWRlQ2hhcmFjdGVyRm9udCh0ZXh0LCBtb2RlKTtcbiAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCB3aWRlRm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KHdpZGVGb250Q2xhc3MpKTtcbiAgfSBlbHNlIGlmIChmb250T3JGYW1pbHkpIHtcbiAgICB2YXIgZm9udE5hbWU7XG4gICAgdmFyIGZvbnRDbGFzc2VzO1xuXG4gICAgaWYgKGZvbnRPckZhbWlseSA9PT0gXCJib2xkc3ltYm9sXCIpIHtcbiAgICAgIHZhciBmb250RGF0YSA9IGJvbGRzeW1ib2wodGV4dCwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSk7XG4gICAgICBmb250TmFtZSA9IGZvbnREYXRhLmZvbnROYW1lO1xuICAgICAgZm9udENsYXNzZXMgPSBbZm9udERhdGEuZm9udENsYXNzXTtcbiAgICB9IGVsc2UgaWYgKGlzRm9udCkge1xuICAgICAgZm9udE5hbWUgPSBmb250TWFwW2ZvbnRPckZhbWlseV0uZm9udE5hbWU7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250T3JGYW1pbHldO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnRPckZhbWlseSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250T3JGYW1pbHksIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGVdO1xuICAgIH1cblxuICAgIGlmIChsb29rdXBTeW1ib2wodGV4dCwgZm9udE5hbWUsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250Q2xhc3NlcykpO1xuICAgIH0gZWxzZSBpZiAobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIGZvbnROYW1lLnN1YnN0cigwLCAxMCkgPT09IFwiVHlwZXdyaXRlclwiKSB7XG4gICAgICAvLyBEZWNvbnN0cnVjdCBsaWdhdHVyZXMgaW4gbW9ub3NwYWNlIGZvbnRzIChcXHRleHR0dCwgXFx0dCkuXG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2gobWFrZVN5bWJvbCh0ZXh0W2ldLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoZm9udENsYXNzZXMpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWtlRnJhZ21lbnQocGFydHMpO1xuICAgIH1cbiAgfSAvLyBNYWtlcyBhIHN5bWJvbCBpbiB0aGUgZGVmYXVsdCBmb250IGZvciBtYXRob3JkcyBhbmQgdGV4dG9yZHMuXG5cblxuICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBcIk1hdGgtSXRhbGljXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhub3JtYWxcIl0pKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgIHZhciBmb250ID0gc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLmZvbnQ7XG5cbiAgICBpZiAoZm9udCA9PT0gXCJhbXNcIikge1xuICAgICAgdmFyIF9mb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKFwiYW1zcm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG5cbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIF9mb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoXCJhbXNybVwiLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKSk7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIm1haW5cIiB8fCAhZm9udCkge1xuICAgICAgdmFyIF9mb250TmFtZTIgPSByZXRyaWV2ZVRleHRGb250TmFtZShcInRleHRybVwiLCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTtcblxuICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgX2ZvbnROYW1lMiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQob3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb250cyBhZGRlZCBieSBwbHVnaW5zXG4gICAgICB2YXIgX2ZvbnROYW1lMyA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnQsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpOyAvLyBXZSBhZGQgZm9udCBuYW1lIGFzIGEgY3NzIGNsYXNzXG5cblxuICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgX2ZvbnROYW1lMywgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoX2ZvbnROYW1lMywgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1ha2VPcmRcIik7XG4gIH1cbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdWJzZXF1ZW50IHN5bWJvbE5vZGVzIGhhdmUgdGhlIHNhbWUgY2xhc3Nlcywgc2tldywgbWF4Rm9udCxcbiAqIGFuZCBzdHlsZXMuXG4gKi9cblxuXG52YXIgY2FuQ29tYmluZSA9IChwcmV2LCBuZXh0KSA9PiB7XG4gIGlmIChjcmVhdGVDbGFzcyhwcmV2LmNsYXNzZXMpICE9PSBjcmVhdGVDbGFzcyhuZXh0LmNsYXNzZXMpIHx8IHByZXYuc2tldyAhPT0gbmV4dC5za2V3IHx8IHByZXYubWF4Rm9udFNpemUgIT09IG5leHQubWF4Rm9udFNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgcHJldiBhbmQgbmV4dCBib3RoIGFyZSBqdXN0IFwibWJpblwicyBvciBcIm1vcmRcInMgd2UgZG9uJ3QgY29tYmluZSB0aGVtXG4gIC8vIHNvIHRoYXQgdGhlIHByb3BlciBzcGFjaW5nIGNhbiBiZSBwcmVzZXJ2ZWQuXG5cblxuICBpZiAocHJldi5jbGFzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBjbHMgPSBwcmV2LmNsYXNzZXNbMF07XG5cbiAgICBpZiAoY2xzID09PSBcIm1iaW5cIiB8fCBjbHMgPT09IFwibW9yZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gcHJldi5zdHlsZSkge1xuICAgIGlmIChwcmV2LnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSAmJiBwcmV2LnN0eWxlW3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtzdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfc3R5bGUgaW4gbmV4dC5zdHlsZSkge1xuICAgIGlmIChuZXh0LnN0eWxlLmhhc093blByb3BlcnR5KF9zdHlsZSkgJiYgcHJldi5zdHlsZVtfc3R5bGVdICE9PSBuZXh0LnN0eWxlW19zdHlsZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIENvbWJpbmUgY29uc2VjdXRpdmUgZG9tVHJlZS5zeW1ib2xOb2RlcyBpbnRvIGEgc2luZ2xlIHN5bWJvbE5vZGUuXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIGFyZ3VtZW50LlxuICovXG5cblxudmFyIHRyeUNvbWJpbmVDaGFycyA9IGNoYXJzID0+IHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgcHJldiA9IGNoYXJzW2ldO1xuICAgIHZhciBuZXh0ID0gY2hhcnNbaSArIDFdO1xuXG4gICAgaWYgKHByZXYgaW5zdGFuY2VvZiBTeW1ib2xOb2RlICYmIG5leHQgaW5zdGFuY2VvZiBTeW1ib2xOb2RlICYmIGNhbkNvbWJpbmUocHJldiwgbmV4dCkpIHtcbiAgICAgIHByZXYudGV4dCArPSBuZXh0LnRleHQ7XG4gICAgICBwcmV2LmhlaWdodCA9IE1hdGgubWF4KHByZXYuaGVpZ2h0LCBuZXh0LmhlaWdodCk7XG4gICAgICBwcmV2LmRlcHRoID0gTWF0aC5tYXgocHJldi5kZXB0aCwgbmV4dC5kZXB0aCk7IC8vIFVzZSB0aGUgbGFzdCBjaGFyYWN0ZXIncyBpdGFsaWMgY29ycmVjdGlvbiBzaW5jZSB3ZSB1c2VcbiAgICAgIC8vIGl0IHRvIGFkZCBwYWRkaW5nIHRvIHRoZSByaWdodCBvZiB0aGUgc3BhbiBjcmVhdGVkIGZyb21cbiAgICAgIC8vIHRoZSBjb21iaW5lZCBjaGFyYWN0ZXJzLlxuXG4gICAgICBwcmV2Lml0YWxpYyA9IG5leHQuaXRhbGljO1xuICAgICAgY2hhcnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hhcnM7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cblxuXG52YXIgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4gPSBmdW5jdGlvbiBzaXplRWxlbWVudEZyb21DaGlsZHJlbihlbGVtKSB7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgbWF4Rm9udFNpemUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGVsZW0uY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gY2hpbGQuZGVwdGg7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgIG1heEZvbnRTaXplID0gY2hpbGQubWF4Rm9udFNpemU7XG4gICAgfVxuICB9XG5cbiAgZWxlbS5oZWlnaHQgPSBoZWlnaHQ7XG4gIGVsZW0uZGVwdGggPSBkZXB0aDtcbiAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcbi8qKlxuICogTWFrZXMgYSBzcGFuIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2xhc3NlcywgbGlzdCBvZiBjaGlsZHJlbiwgYW5kIG9wdGlvbnMuXG4gKlxuICogVE9ETygjOTUzKTogRW5zdXJlIHRoYXQgYG9wdGlvbnNgIGlzIGFsd2F5cyBwcm92aWRlZCAoY3VycmVudGx5IHNvbWUgY2FsbFxuICogc2l0ZXMgZG9uJ3QgcGFzcyBpdCkgYW5kIG1ha2UgdGhlIHR5cGUgYmVsb3cgbWFuZGF0b3J5LlxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xuXG5cbnZhciBtYWtlU3BhbiQyID0gZnVuY3Rpb24gbWFrZVNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKSB7XG4gIHZhciBzcGFuID0gbmV3IFNwYW4oY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oc3Bhbik7XG4gIHJldHVybiBzcGFuO1xufTsgLy8gU1ZHIG9uZSBpcyBzaW1wbGVyIC0tIGRvZXNuJ3QgcmVxdWlyZSBoZWlnaHQsIGRlcHRoLCBtYXgtZm9udCBzZXR0aW5nLlxuLy8gVGhpcyBpcyBhbHNvIGEgc2VwYXJhdGUgbWV0aG9kIGZvciB0eXBlc2FmZXR5LlxuXG5cbnZhciBtYWtlU3ZnU3BhbiA9IChjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpID0+IG5ldyBTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSk7XG5cbnZhciBtYWtlTGluZVNwYW4gPSBmdW5jdGlvbiBtYWtlTGluZVNwYW4oY2xhc3NOYW1lLCBvcHRpb25zLCB0aGlja25lc3MpIHtcbiAgdmFyIGxpbmUgPSBtYWtlU3BhbiQyKFtjbGFzc05hbWVdLCBbXSwgb3B0aW9ucyk7XG4gIGxpbmUuaGVpZ2h0ID0gTWF0aC5tYXgodGhpY2tuZXNzIHx8IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcywgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzKTtcbiAgbGluZS5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IG1ha2VFbShsaW5lLmhlaWdodCk7XG4gIGxpbmUubWF4Rm9udFNpemUgPSAxLjA7XG4gIHJldHVybiBsaW5lO1xufTtcbi8qKlxuICogTWFrZXMgYW4gYW5jaG9yIHdpdGggdGhlIGdpdmVuIGhyZWYsIGxpc3Qgb2YgY2xhc3NlcywgbGlzdCBvZiBjaGlsZHJlbixcbiAqIGFuZCBvcHRpb25zLlxuICovXG5cblxudmFyIG1ha2VBbmNob3IgPSBmdW5jdGlvbiBtYWtlQW5jaG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIHZhciBhbmNob3IgPSBuZXcgQW5jaG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oYW5jaG9yKTtcbiAgcmV0dXJuIGFuY2hvcjtcbn07XG4vKipcbiAqIE1ha2VzIGEgZG9jdW1lbnQgZnJhZ21lbnQgd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbnZhciBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbiBtYWtlRnJhZ21lbnQoY2hpbGRyZW4pIHtcbiAgdmFyIGZyYWdtZW50ID0gbmV3IERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuICBzaXplRWxlbWVudEZyb21DaGlsZHJlbihmcmFnbWVudCk7XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcbiAqIFdyYXBzIGdyb3VwIGluIGEgc3BhbiBpZiBpdCdzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIGFsbG93aW5nIHRvIGFwcGx5IGNsYXNzZXNcbiAqIGFuZCBzdHlsZXNcbiAqL1xuXG5cbnZhciB3cmFwRnJhZ21lbnQgPSBmdW5jdGlvbiB3cmFwRnJhZ21lbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgIHJldHVybiBtYWtlU3BhbiQyKFtdLCBbZ3JvdXBdLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBncm91cDtcbn07IC8vIFRoZXNlIGFyZSBleGFjdCBvYmplY3QgdHlwZXMgdG8gY2F0Y2ggdHlwb3MgaW4gdGhlIG5hbWVzIG9mIHRoZSBvcHRpb25hbCBmaWVsZHMuXG5cblxuLy8gQ29tcHV0ZXMgdGhlIHVwZGF0ZWQgYGNoaWxkcmVuYCBsaXN0IGFuZCB0aGUgb3ZlcmFsbCBkZXB0aC5cbi8vXG4vLyBUaGlzIGhlbHBlciBmdW5jdGlvbiBmb3IgbWFrZVZMaXN0IG1ha2VzIGl0IGVhc2llciB0byBlbmZvcmNlIHR5cGUgc2FmZXR5IGJ5XG4vLyBhbGxvd2luZyBlYXJseSBleGl0cyAocmV0dXJucykgaW4gdGhlIGxvZ2ljLlxudmFyIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aCA9IGZ1bmN0aW9uIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICB2YXIgb2xkQ2hpbGRyZW4gPSBwYXJhbXMuY2hpbGRyZW47XG4gICAgdmFyIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTsgLy8gQWRkIGluIGtlcm5zIHRvIHRoZSBsaXN0IG9mIHBhcmFtcy5jaGlsZHJlbiB0byBnZXQgZWFjaCBlbGVtZW50IHRvIGJlXG4gICAgLy8gc2hpZnRlZCB0byB0aGUgY29ycmVjdCBzcGVjaWZpZWQgc2hpZnRcblxuICAgIHZhciBfZGVwdGggPSAtb2xkQ2hpbGRyZW5bMF0uc2hpZnQgLSBvbGRDaGlsZHJlblswXS5lbGVtLmRlcHRoO1xuXG4gICAgdmFyIGN1cnJQb3MgPSBfZGVwdGg7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLSBvbGRDaGlsZHJlbltpXS5lbGVtLmRlcHRoO1xuICAgICAgdmFyIHNpemUgPSBkaWZmIC0gKG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmhlaWdodCArIG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmRlcHRoKTtcbiAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZVxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlbi5wdXNoKG9sZENoaWxkcmVuW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBkZXB0aDogX2RlcHRoXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkZXB0aDtcblxuICBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJ0b3BcIikge1xuICAgIC8vIFdlIGFsd2F5cyBzdGFydCBhdCB0aGUgYm90dG9tLCBzbyBjYWxjdWxhdGUgdGhlIGJvdHRvbSBieSBhZGRpbmcgdXBcbiAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgdmFyIGJvdHRvbSA9IHBhcmFtcy5wb3NpdGlvbkRhdGE7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcGFyYW1zLmNoaWxkcmVuLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNoaWxkID0gcGFyYW1zLmNoaWxkcmVuW19pXTtcbiAgICAgIGJvdHRvbSAtPSBjaGlsZC50eXBlID09PSBcImtlcm5cIiA/IGNoaWxkLnNpemUgOiBjaGlsZC5lbGVtLmhlaWdodCArIGNoaWxkLmVsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgZGVwdGggPSBib3R0b207XG4gIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJib3R0b21cIikge1xuICAgIGRlcHRoID0gLXBhcmFtcy5wb3NpdGlvbkRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBwYXJhbXMuY2hpbGRyZW5bMF07XG5cbiAgICBpZiAoZmlyc3RDaGlsZC50eXBlICE9PSBcImVsZW1cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBjaGlsZCBtdXN0IGhhdmUgdHlwZSBcImVsZW1cIi4nKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJzaGlmdFwiKSB7XG4gICAgICBkZXB0aCA9IC1maXJzdENoaWxkLmVsZW0uZGVwdGggLSBwYXJhbXMucG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgIGRlcHRoID0gLWZpcnN0Q2hpbGQuZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwb3NpdGlvblR5cGUgXCIgKyBwYXJhbXMucG9zaXRpb25UeXBlICsgXCIuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hpbGRyZW46IHBhcmFtcy5jaGlsZHJlbixcbiAgICBkZXB0aFxuICB9O1xufTtcbi8qKlxuICogTWFrZXMgYSB2ZXJ0aWNhbCBsaXN0IGJ5IHN0YWNraW5nIGVsZW1lbnRzIGFuZCBrZXJucyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAqIEFsbG93cyBmb3IgbWFueSBkaWZmZXJlbnQgd2F5cyBvZiBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbmluZyBtZXRob2QuXG4gKlxuICogU2VlIFZMaXN0UGFyYW0gZG9jdW1lbnRhdGlvbiBhYm92ZS5cbiAqL1xuXG5cbnZhciBtYWtlVkxpc3QgPSBmdW5jdGlvbiBtYWtlVkxpc3QocGFyYW1zLCBvcHRpb25zKSB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVwdGhcbiAgfSA9IGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aChwYXJhbXMpOyAvLyBDcmVhdGUgYSBzdHJ1dCB0aGF0IGlzIHRhbGxlciB0aGFuIGFueSBsaXN0IGl0ZW0uIFRoZSBzdHJ1dCBpcyBhZGRlZCB0b1xuICAvLyBlYWNoIGl0ZW0sIHdoZXJlIGl0IHdpbGwgZGV0ZXJtaW5lIHRoZSBpdGVtJ3MgYmFzZWxpbmUuIFNpbmNlIGl0IGhhc1xuICAvLyBgb3ZlcmZsb3c6aGlkZGVuYCwgdGhlIHN0cnV0J3MgdG9wIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBsaW5lIGJveCdzXG4gIC8vIHRvcCBlZGdlIGFuZCB0aGUgc3RydXQncyBib3R0b20gZWRnZSB3aWxsIHNpdCBvbiB0aGUgaXRlbSdzIGJhc2VsaW5lLFxuICAvLyB3aXRoIG5vIGFkZGl0aW9uYWwgbGluZS1oZWlnaHQgc3BhY2luZy4gVGhpcyBhbGxvd3MgdGhlIGl0ZW0gYmFzZWxpbmUgdG9cbiAgLy8gYmUgcG9zaXRpb25lZCBwcmVjaXNlbHkgd2l0aG91dCB3b3JyeWluZyBhYm91dCBmb250IGFzY2VudCBhbmRcbiAgLy8gbGluZS1oZWlnaHQuXG5cbiAgdmFyIHBzdHJ1dFNpemUgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmIChjaGlsZC50eXBlID09PSBcImVsZW1cIikge1xuICAgICAgdmFyIGVsZW0gPSBjaGlsZC5lbGVtO1xuICAgICAgcHN0cnV0U2l6ZSA9IE1hdGgubWF4KHBzdHJ1dFNpemUsIGVsZW0ubWF4Rm9udFNpemUsIGVsZW0uaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBwc3RydXRTaXplICs9IDI7XG4gIHZhciBwc3RydXQgPSBtYWtlU3BhbiQyKFtcInBzdHJ1dFwiXSwgW10pO1xuICBwc3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKHBzdHJ1dFNpemUpOyAvLyBDcmVhdGUgYSBuZXcgbGlzdCBvZiBhY3R1YWwgY2hpbGRyZW4gYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuXG4gIHZhciByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgdmFyIG1pblBvcyA9IGRlcHRoO1xuICB2YXIgbWF4UG9zID0gZGVwdGg7XG4gIHZhciBjdXJyUG9zID0gZGVwdGg7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbltfaTJdO1xuXG4gICAgaWYgKF9jaGlsZC50eXBlID09PSBcImtlcm5cIikge1xuICAgICAgY3VyclBvcyArPSBfY2hpbGQuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9lbGVtID0gX2NoaWxkLmVsZW07XG4gICAgICB2YXIgY2xhc3NlcyA9IF9jaGlsZC53cmFwcGVyQ2xhc3NlcyB8fCBbXTtcbiAgICAgIHZhciBzdHlsZSA9IF9jaGlsZC53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICB2YXIgY2hpbGRXcmFwID0gbWFrZVNwYW4kMihjbGFzc2VzLCBbcHN0cnV0LCBfZWxlbV0sIHVuZGVmaW5lZCwgc3R5bGUpO1xuICAgICAgY2hpbGRXcmFwLnN0eWxlLnRvcCA9IG1ha2VFbSgtcHN0cnV0U2l6ZSAtIGN1cnJQb3MgLSBfZWxlbS5kZXB0aCk7XG5cbiAgICAgIGlmIChfY2hpbGQubWFyZ2luTGVmdCkge1xuICAgICAgICBjaGlsZFdyYXAuc3R5bGUubWFyZ2luTGVmdCA9IF9jaGlsZC5tYXJnaW5MZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NoaWxkLm1hcmdpblJpZ2h0KSB7XG4gICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5SaWdodCA9IF9jaGlsZC5tYXJnaW5SaWdodDtcbiAgICAgIH1cblxuICAgICAgcmVhbENoaWxkcmVuLnB1c2goY2hpbGRXcmFwKTtcbiAgICAgIGN1cnJQb3MgKz0gX2VsZW0uaGVpZ2h0ICsgX2VsZW0uZGVwdGg7XG4gICAgfVxuXG4gICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBjdXJyUG9zKTtcbiAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIGN1cnJQb3MpO1xuICB9IC8vIFRoZSB2bGlzdCBjb250ZW50cyBnbyBpbiBhIHRhYmxlLWNlbGwgd2l0aCBgdmVydGljYWwtYWxpZ246Ym90dG9tYC5cbiAgLy8gVGhpcyBjZWxsJ3MgYm90dG9tIGVkZ2Ugd2lsbCBkZXRlcm1pbmUgdGhlIGNvbnRhaW5pbmcgdGFibGUncyBiYXNlbGluZVxuICAvLyB3aXRob3V0IG92ZXJseSBleHBhbmRpbmcgdGhlIGNvbnRhaW5pbmcgbGluZS1ib3guXG5cblxuICB2YXIgdmxpc3QgPSBtYWtlU3BhbiQyKFtcInZsaXN0XCJdLCByZWFsQ2hpbGRyZW4pO1xuICB2bGlzdC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0obWF4UG9zKTsgLy8gQSBzZWNvbmQgcm93IGlzIHVzZWQgaWYgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgdmxpc3QncyBkZXB0aC5cblxuICB2YXIgcm93cztcblxuICBpZiAobWluUG9zIDwgMCkge1xuICAgIC8vIFdlIHdpbGwgZGVmaW5lIGRlcHRoIGluIGFuIGVtcHR5IHNwYW4gd2l0aCBkaXNwbGF5OiB0YWJsZS1jZWxsLlxuICAgIC8vIEl0IHNob3VsZCByZW5kZXIgd2l0aCB0aGUgaGVpZ2h0IHRoYXQgd2UgZGVmaW5lLiBCdXQgQ2hyb21lLCBpblxuICAgIC8vIGNvbnRlbnRlZGl0YWJsZSBtb2RlIG9ubHksIHRyZWF0cyB0aGF0IHNwYW4gYXMgaWYgaXQgY29udGFpbnMgc29tZVxuICAgIC8vIHRleHQgY29udGVudC4gQW5kIHRoYXQgbWluLWhlaWdodCBvdmVyLXJpZGVzIG91ciBkZXNpcmVkIGhlaWdodC5cbiAgICAvLyBTbyB3ZSBwdXQgYW5vdGhlciBlbXB0eSBzcGFuIGluc2lkZSB0aGUgZGVwdGggc3RydXQgc3Bhbi5cbiAgICB2YXIgZW1wdHlTcGFuID0gbWFrZVNwYW4kMihbXSwgW10pO1xuICAgIHZhciBkZXB0aFN0cnV0ID0gbWFrZVNwYW4kMihbXCJ2bGlzdFwiXSwgW2VtcHR5U3Bhbl0pO1xuICAgIGRlcHRoU3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKC1taW5Qb3MpOyAvLyBTYWZhcmkgd2FudHMgdGhlIGZpcnN0IHJvdyB0byBoYXZlIGlubGluZSBjb250ZW50OyBvdGhlcndpc2UgaXRcbiAgICAvLyBwdXRzIHRoZSBib3R0b20gb2YgdGhlICpzZWNvbmQqIHJvdyBvbiB0aGUgYmFzZWxpbmUuXG5cbiAgICB2YXIgdG9wU3RydXQgPSBtYWtlU3BhbiQyKFtcInZsaXN0LXNcIl0sIFtuZXcgU3ltYm9sTm9kZShcIlxcdTIwMGJcIildKTtcbiAgICByb3dzID0gW21ha2VTcGFuJDIoW1widmxpc3QtclwiXSwgW3ZsaXN0LCB0b3BTdHJ1dF0pLCBtYWtlU3BhbiQyKFtcInZsaXN0LXJcIl0sIFtkZXB0aFN0cnV0XSldO1xuICB9IGVsc2Uge1xuICAgIHJvd3MgPSBbbWFrZVNwYW4kMihbXCJ2bGlzdC1yXCJdLCBbdmxpc3RdKV07XG4gIH1cblxuICB2YXIgdnRhYmxlID0gbWFrZVNwYW4kMihbXCJ2bGlzdC10XCJdLCByb3dzKTtcblxuICBpZiAocm93cy5sZW5ndGggPT09IDIpIHtcbiAgICB2dGFibGUuY2xhc3Nlcy5wdXNoKFwidmxpc3QtdDJcIik7XG4gIH1cblxuICB2dGFibGUuaGVpZ2h0ID0gbWF4UG9zO1xuICB2dGFibGUuZGVwdGggPSAtbWluUG9zO1xuICByZXR1cm4gdnRhYmxlO1xufTsgLy8gR2x1ZSBpcyBhIGNvbmNlcHQgZnJvbSBUZVggd2hpY2ggaXMgYSBmbGV4aWJsZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIGluXG4vLyBlaXRoZXIgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGxpc3QuIEluIEthVGVYLCBhdCBsZWFzdCBmb3Igbm93LCBpdCdzXG4vLyBzdGF0aWMgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpbiBhIGhvcml6b250YWwgbGF5b3V0LlxuXG5cbnZhciBtYWtlR2x1ZSA9IChtZWFzdXJlbWVudCwgb3B0aW9ucykgPT4ge1xuICAvLyBNYWtlIGFuIGVtcHR5IHNwYW4gZm9yIHRoZSBzcGFjZVxuICB2YXIgcnVsZSA9IG1ha2VTcGFuJDIoW1wibXNwYWNlXCJdLCBbXSwgb3B0aW9ucyk7XG4gIHZhciBzaXplID0gY2FsY3VsYXRlU2l6ZShtZWFzdXJlbWVudCwgb3B0aW9ucyk7XG4gIHJ1bGUuc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0oc2l6ZSk7XG4gIHJldHVybiBydWxlO1xufTsgLy8gVGFrZXMgZm9udCBvcHRpb25zLCBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZm9udExvb2t1cCBuYW1lXG5cblxudmFyIHJldHJpZXZlVGV4dEZvbnROYW1lID0gZnVuY3Rpb24gcmV0cmlldmVUZXh0Rm9udE5hbWUoZm9udEZhbWlseSwgZm9udFdlaWdodCwgZm9udFNoYXBlKSB7XG4gIHZhciBiYXNlRm9udE5hbWUgPSBcIlwiO1xuXG4gIHN3aXRjaCAoZm9udEZhbWlseSkge1xuICAgIGNhc2UgXCJhbXNybVwiOlxuICAgICAgYmFzZUZvbnROYW1lID0gXCJBTVNcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRleHRybVwiOlxuICAgICAgYmFzZUZvbnROYW1lID0gXCJNYWluXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0c2ZcIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiU2Fuc1NlcmlmXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0dHRcIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiVHlwZXdyaXRlclwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYmFzZUZvbnROYW1lID0gZm9udEZhbWlseTtcbiAgICAvLyB1c2UgZm9udHMgYWRkZWQgYnkgYSBwbHVnaW5cbiAgfVxuXG4gIHZhciBmb250U3R5bGVzTmFtZTtcblxuICBpZiAoZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIiAmJiBmb250U2hhcGUgPT09IFwidGV4dGl0XCIpIHtcbiAgICBmb250U3R5bGVzTmFtZSA9IFwiQm9sZEl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICBmb250U3R5bGVzTmFtZSA9IFwiQm9sZFwiO1xuICB9IGVsc2UgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGl0XCIpIHtcbiAgICBmb250U3R5bGVzTmFtZSA9IFwiSXRhbGljXCI7XG4gIH0gZWxzZSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIlJlZ3VsYXJcIjtcbiAgfVxuXG4gIHJldHVybiBiYXNlRm9udE5hbWUgKyBcIi1cIiArIGZvbnRTdHlsZXNOYW1lO1xufTtcbi8qKlxuICogTWFwcyBUZVggZm9udCBjb21tYW5kcyB0byBvYmplY3RzIGNvbnRhaW5pbmc6XG4gKiAtIHZhcmlhbnQ6IHN0cmluZyB1c2VkIGZvciBcIm1hdGh2YXJpYW50XCIgYXR0cmlidXRlIGluIGJ1aWxkTWF0aE1MLmpzXG4gKiAtIGZvbnROYW1lOiB0aGUgXCJzdHlsZVwiIHBhcmFtZXRlciB0byBmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzXG4gKi9cbi8vIEEgbWFwIGJldHdlZW4gdGV4IGZvbnQgY29tbWFuZHMgYW4gTWF0aE1MIG1hdGh2YXJpYW50IGF0dHJpYnV0ZSB2YWx1ZXNcblxuXG52YXIgZm9udE1hcCA9IHtcbiAgLy8gc3R5bGVzXG4gIFwibWF0aGJmXCI6IHtcbiAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICBmb250TmFtZTogXCJNYWluLUJvbGRcIlxuICB9LFxuICBcIm1hdGhybVwiOiB7XG4gICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICBmb250TmFtZTogXCJNYWluLVJlZ3VsYXJcIlxuICB9LFxuICBcInRleHRpdFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYWluLUl0YWxpY1wiXG4gIH0sXG4gIFwibWF0aGl0XCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1haW4tSXRhbGljXCJcbiAgfSxcbiAgXCJtYXRobm9ybWFsXCI6IHtcbiAgICB2YXJpYW50OiBcIml0YWxpY1wiLFxuICAgIGZvbnROYW1lOiBcIk1hdGgtSXRhbGljXCJcbiAgfSxcbiAgLy8gXCJib2xkc3ltYm9sXCIgaXMgbWlzc2luZyBiZWNhdXNlIHRoZXkgcmVxdWlyZSB0aGUgdXNlIG9mIG11bHRpcGxlIGZvbnRzOlxuICAvLyBNYXRoLUJvbGRJdGFsaWMgYW5kIE1haW4tQm9sZC4gIFRoaXMgaXMgaGFuZGxlZCBieSBhIHNwZWNpYWwgY2FzZSBpblxuICAvLyBtYWtlT3JkIHdoaWNoIGVuZHMgdXAgY2FsbGluZyBib2xkc3ltYm9sLlxuICAvLyBmYW1pbGllc1xuICBcIm1hdGhiYlwiOiB7XG4gICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgZm9udE5hbWU6IFwiQU1TLVJlZ3VsYXJcIlxuICB9LFxuICBcIm1hdGhjYWxcIjoge1xuICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgZm9udE5hbWU6IFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGZyYWtcIjoge1xuICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgIGZvbnROYW1lOiBcIkZyYWt0dXItUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNjclwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJTY3JpcHQtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNmXCI6IHtcbiAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICBmb250TmFtZTogXCJTYW5zU2VyaWYtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHR0XCI6IHtcbiAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgIGZvbnROYW1lOiBcIlR5cGV3cml0ZXItUmVndWxhclwiXG4gIH1cbn07XG52YXIgc3ZnRGF0YSA9IHtcbiAgLy8gICBwYXRoLCB3aWR0aCwgaGVpZ2h0XG4gIHZlYzogW1widmVjXCIsIDAuNDcxLCAwLjcxNF0sXG4gIC8vIHZhbHVlcyBmcm9tIHRoZSBmb250IGdseXBoXG4gIG9paW50U2l6ZTE6IFtcIm9paW50U2l6ZTFcIiwgMC45NTcsIDAuNDk5XSxcbiAgLy8gb3ZhbCB0byBvdmVybGF5IHRoZSBpbnRlZ3JhbmRcbiAgb2lpbnRTaXplMjogW1wib2lpbnRTaXplMlwiLCAxLjQ3MiwgMC42NTldLFxuICBvaWlpbnRTaXplMTogW1wib2lpaW50U2l6ZTFcIiwgMS4zMDQsIDAuNDk5XSxcbiAgb2lpaW50U2l6ZTI6IFtcIm9paWludFNpemUyXCIsIDEuOTgsIDAuNjU5XVxufTtcblxudmFyIHN0YXRpY1N2ZyA9IGZ1bmN0aW9uIHN0YXRpY1N2Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIHZhciBbcGF0aE5hbWUsIHdpZHRoLCBoZWlnaHRdID0gc3ZnRGF0YVt2YWx1ZV07XG4gIHZhciBwYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhOYW1lKTtcbiAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICBcIndpZHRoXCI6IG1ha2VFbSh3aWR0aCksXG4gICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgLy8gT3ZlcnJpZGUgQ1NTIHJ1bGUgYC5rYXRleCBzdmcgeyB3aWR0aDogMTAwJSB9YFxuICAgIFwic3R5bGVcIjogXCJ3aWR0aDpcIiArIG1ha2VFbSh3aWR0aCksXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgMTAwMCAqIHdpZHRoICsgXCIgXCIgKyAxMDAwICogaGVpZ2h0LFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluXCJcbiAgfSk7XG4gIHZhciBzcGFuID0gbWFrZVN2Z1NwYW4oW1wib3ZlcmxheVwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gIHNwYW4uc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBidWlsZENvbW1vbiA9IHtcbiAgZm9udE1hcCxcbiAgbWFrZVN5bWJvbCxcbiAgbWF0aHN5bSxcbiAgbWFrZVNwYW46IG1ha2VTcGFuJDIsXG4gIG1ha2VTdmdTcGFuLFxuICBtYWtlTGluZVNwYW4sXG4gIG1ha2VBbmNob3IsXG4gIG1ha2VGcmFnbWVudCxcbiAgd3JhcEZyYWdtZW50LFxuICBtYWtlVkxpc3QsXG4gIG1ha2VPcmQsXG4gIG1ha2VHbHVlLFxuICBzdGF0aWNTdmcsXG4gIHN2Z0RhdGEsXG4gIHRyeUNvbWJpbmVDaGFyc1xufTtcblxuLyoqXG4gKiBEZXNjcmliZXMgc3BhY2VzIGJldHdlZW4gZGlmZmVyZW50IGNsYXNzZXMgb2YgYXRvbXMuXG4gKi9cbnZhciB0aGluc3BhY2UgPSB7XG4gIG51bWJlcjogMyxcbiAgdW5pdDogXCJtdVwiXG59O1xudmFyIG1lZGl1bXNwYWNlID0ge1xuICBudW1iZXI6IDQsXG4gIHVuaXQ6IFwibXVcIlxufTtcbnZhciB0aGlja3NwYWNlID0ge1xuICBudW1iZXI6IDUsXG4gIHVuaXQ6IFwibXVcIlxufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG5cbi8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3IgZGlzcGxheSBhbmQgdGV4dCBzdHlsZXNcbnZhciBzcGFjaW5ncyA9IHtcbiAgbW9yZDoge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbW9wOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbWJpbjoge1xuICAgIG1vcmQ6IG1lZGl1bXNwYWNlLFxuICAgIG1vcDogbWVkaXVtc3BhY2UsXG4gICAgbW9wZW46IG1lZGl1bXNwYWNlLFxuICAgIG1pbm5lcjogbWVkaXVtc3BhY2VcbiAgfSxcbiAgbXJlbDoge1xuICAgIG1vcmQ6IHRoaWNrc3BhY2UsXG4gICAgbW9wOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpY2tzcGFjZVxuICB9LFxuICBtb3Blbjoge30sXG4gIG1jbG9zZToge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbXB1bmN0OiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaW5zcGFjZSxcbiAgICBtY2xvc2U6IHRoaW5zcGFjZSxcbiAgICBtcHVuY3Q6IHRoaW5zcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtaW5uZXI6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpbnNwYWNlLFxuICAgIG1wdW5jdDogdGhpbnNwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH1cbn07IC8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHQgc3R5bGVzXG5cbnZhciB0aWdodFNwYWNpbmdzID0ge1xuICBtb3JkOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbW9wOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1iaW46IHt9LFxuICBtcmVsOiB7fSxcbiAgbW9wZW46IHt9LFxuICBtY2xvc2U6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtcHVuY3Q6IHt9LFxuICBtaW5uZXI6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9XG59O1xuXG4vKiogQ29udGV4dCBwcm92aWRlZCB0byBmdW5jdGlvbiBoYW5kbGVycyBmb3IgZXJyb3IgbWVzc2FnZXMuICovXG4vLyBOb3RlOiByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgcmV0dXJuIHR5cGUgdW5pb24gd2lsbCBjYXVzZSBhIGZsb3cgZXJyb3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzM2NjMuXG4vLyBNb3JlIGdlbmVyYWwgdmVyc2lvbiBvZiBgSHRtbEJ1aWxkZXJgIGZvciBub2RlcyAoZS5nLiBcXHN1bSwgYWNjZW50IHR5cGVzKVxuLy8gd2hvc2UgcHJlc2VuY2UgaW1wYWN0cyBzdXBlci9zdWJzY3JpcHRpbmcuIEluIHRoaXMgY2FzZSwgUGFyc2VOb2RlPFwic3Vwc3ViXCI+XG4vLyBkZWxlZ2F0ZXMgaXRzIEhUTUwgYnVpbGRpbmcgdG8gdGhlIEh0bWxCdWlsZGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlc2Ugbm9kZXMuXG5cbi8qKlxuICogRmluYWwgZnVuY3Rpb24gc3BlYyBmb3IgdXNlIGF0IHBhcnNlIHRpbWUuXG4gKiBUaGlzIGlzIGFsbW9zdCBpZGVudGljYWwgdG8gYEZ1bmN0aW9uUHJvcFNwZWNgLCBleGNlcHQgaXRcbiAqIDEuIGluY2x1ZGVzIHRoZSBmdW5jdGlvbiBoYW5kbGVyLCBhbmRcbiAqIDIuIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgZXhjZXB0IGFyZ1R5cGVzLlxuICogSXQgaXMgZ2VuZXJhdGVkIGJ5IGBkZWZpbmVGdW5jdGlvbigpYCBiZWxvdy5cbiAqL1xuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGZ1bmN0aW9ucy5cbiAqIGBmdW5jdGlvbnMuanNgIGp1c3QgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5LlxuICovXG52YXIgX2Z1bmN0aW9ucyA9IHt9O1xuLyoqXG4gKiBBbGwgSFRNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbnZhciBfaHRtbEdyb3VwQnVpbGRlcnMgPSB7fTtcbi8qKlxuICogQWxsIE1hdGhNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbnZhciBfbWF0aG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb24oX3JlZikge1xuICB2YXIge1xuICAgIHR5cGUsXG4gICAgbmFtZXMsXG4gICAgcHJvcHMsXG4gICAgaGFuZGxlcixcbiAgICBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0gPSBfcmVmO1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZnVuY3Rpb25zXG4gIHZhciBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyxcbiAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6ICEhcHJvcHMuYWxsb3dlZEluQXJndW1lbnQsXG4gICAgYWxsb3dlZEluVGV4dDogISFwcm9wcy5hbGxvd2VkSW5UZXh0LFxuICAgIGFsbG93ZWRJbk1hdGg6IHByb3BzLmFsbG93ZWRJbk1hdGggPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5hbGxvd2VkSW5NYXRoLFxuICAgIG51bU9wdGlvbmFsQXJnczogcHJvcHMubnVtT3B0aW9uYWxBcmdzIHx8IDAsXG4gICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgcHJpbWl0aXZlOiAhIXByb3BzLnByaW1pdGl2ZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9mdW5jdGlvbnNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKGh0bWxCdWlsZGVyKSB7XG4gICAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgICB9XG5cbiAgICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBVc2UgdGhpcyB0byByZWdpc3RlciBvbmx5IHRoZSBIVE1MIGFuZCBNYXRoTUwgYnVpbGRlcnMgZm9yIGEgZnVuY3Rpb24gKGUuZy5cbiAqIGlmIHRoZSBmdW5jdGlvbidzIFBhcnNlTm9kZSBpcyBnZW5lcmF0ZWQgaW4gUGFyc2VyLmpzIHJhdGhlciB0aGFuIHZpYSBhXG4gKiBzdGFuZC1hbG9uZSBoYW5kbGVyIHByb3ZpZGVkIHRvIGBkZWZpbmVGdW5jdGlvbmApLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoX3JlZjIpIHtcbiAgdmFyIHtcbiAgICB0eXBlLFxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSA9IF9yZWYyO1xuICBkZWZpbmVGdW5jdGlvbih7XG4gICAgdHlwZSxcbiAgICBuYW1lczogW10sXG4gICAgcHJvcHM6IHtcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9LFxuXG4gICAgaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC4nKTtcbiAgICB9LFxuXG4gICAgaHRtbEJ1aWxkZXIsXG4gICAgbWF0aG1sQnVpbGRlclxuICB9KTtcbn1cbnZhciBub3JtYWxpemVBcmd1bWVudCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50KGFyZykge1xuICByZXR1cm4gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPT09IDEgPyBhcmcuYm9keVswXSA6IGFyZztcbn07IC8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xuXG52YXIgb3JkYXJndW1lbnQgPSBmdW5jdGlvbiBvcmRhcmd1bWVudChhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgPyBhcmcuYm9keSA6IFthcmddO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgZG9lcyB0aGUgbWFpbiB3b3JrIG9mIGJ1aWxkaW5nIGEgZG9tVHJlZSBzdHJ1Y3R1cmUgZnJvbSBhIHBhcnNlXG4gKiB0cmVlLiBUaGUgZW50cnkgcG9pbnQgaXMgdGhlIGBidWlsZEhUTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUuXG4gKiBUaGVuLCB0aGUgYnVpbGRFeHByZXNzaW9uLCBidWlsZEdyb3VwLCBhbmQgdmFyaW91cyBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uc1xuICogYXJlIGNhbGxlZCwgdG8gcHJvZHVjZSBhIGZpbmFsIEhUTUwgdHJlZS5cbiAqL1xudmFyIG1ha2VTcGFuJDEgPSBidWlsZENvbW1vbi5tYWtlU3BhbjsgLy8gQmluYXJ5IGF0b21zIChmaXJzdCBjbGFzcyBgbWJpbmApIGNoYW5nZSBpbnRvIG9yZGluYXJ5IGF0b21zIChgbW9yZGApXG4vLyBkZXBlbmRpbmcgb24gdGhlaXIgc3Vycm91bmRpbmdzLiBTZWUgVGVYYm9vayBwZy4gNDQyLTQ0NiwgUnVsZXMgNSBhbmQgNixcbi8vIGFuZCB0aGUgdGV4dCBiZWZvcmUgUnVsZSAxOS5cblxudmFyIGJpbkxlZnRDYW5jZWxsZXIgPSBbXCJsZWZ0bW9zdFwiLCBcIm1iaW5cIiwgXCJtb3BlblwiLCBcIm1yZWxcIiwgXCJtb3BcIiwgXCJtcHVuY3RcIl07XG52YXIgYmluUmlnaHRDYW5jZWxsZXIgPSBbXCJyaWdodG1vc3RcIiwgXCJtcmVsXCIsIFwibWNsb3NlXCIsIFwibXB1bmN0XCJdO1xudmFyIHN0eWxlTWFwJDEgPSB7XG4gIFwiZGlzcGxheVwiOiBTdHlsZSQxLkRJU1BMQVksXG4gIFwidGV4dFwiOiBTdHlsZSQxLlRFWFQsXG4gIFwic2NyaXB0XCI6IFN0eWxlJDEuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufTtcbnZhciBEb21FbnVtID0ge1xuICBtb3JkOiBcIm1vcmRcIixcbiAgbW9wOiBcIm1vcFwiLFxuICBtYmluOiBcIm1iaW5cIixcbiAgbXJlbDogXCJtcmVsXCIsXG4gIG1vcGVuOiBcIm1vcGVuXCIsXG4gIG1jbG9zZTogXCJtY2xvc2VcIixcbiAgbXB1bmN0OiBcIm1wdW5jdFwiLFxuICBtaW5uZXI6IFwibWlubmVyXCJcbn07XG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkIHRoZW0gaW4gb3JkZXIsIGFuZCByZXR1cm4gYSBsaXN0IG9mIHRoZSBidWlsdFxuICogbm9kZXMuIGRvY3VtZW50RnJhZ21lbnRzIGFyZSBmbGF0dGVuZWQgaW50byB0aGVpciBjb250ZW50cywgc28gdGhlXG4gKiByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIG5vIGZyYWdtZW50cy4gYGlzUmVhbEdyb3VwYCBpcyB0cnVlIGlmIGBleHByZXNzaW9uYFxuICogaXMgYSByZWFsIGdyb3VwIChubyBhdG9tcyB3aWxsIGJlIGFkZGVkIG9uIGVpdGhlciBzaWRlKSwgYXMgb3Bwb3NlZCB0b1xuICogYSBwYXJ0aWFsIGdyb3VwIChlLmcuIG9uZSBjcmVhdGVkIGJ5IFxcY29sb3IpLiBgc3Vycm91bmRpbmdgIGlzIGFuIGFycmF5XG4gKiBjb25zaXN0aW5nIHR5cGUgb2Ygbm9kZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsZWZ0IGFuZCByaWdodC5cbiAqL1xudmFyIGJ1aWxkRXhwcmVzc2lvbiQxID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzUmVhbEdyb3VwLCBzdXJyb3VuZGluZykge1xuICBpZiAoc3Vycm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgIHN1cnJvdW5kaW5nID0gW251bGwsIG51bGxdO1xuICB9XG5cbiAgLy8gUGFyc2UgZXhwcmVzc2lvbnMgaW50byBgZ3JvdXBzYC5cbiAgdmFyIGdyb3VwcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdXRwdXQgPSBidWlsZEdyb3VwJDEoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuO1xuICAgICAgZ3JvdXBzLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgfSAvLyBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuXG5cbiAgYnVpbGRDb21tb24udHJ5Q29tYmluZUNoYXJzKGdyb3Vwcyk7IC8vIElmIGBleHByZXNzaW9uYCBpcyBhIHBhcnRpYWwgZ3JvdXAsIGxldCB0aGUgcGFyZW50IGhhbmRsZSBzcGFjaW5nc1xuICAvLyB0byBhdm9pZCBwcm9jZXNzaW5nIGdyb3VwcyBtdWx0aXBsZSB0aW1lcy5cblxuICBpZiAoIWlzUmVhbEdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIHZhciBnbHVlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBleHByZXNzaW9uWzBdO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzaXppbmdcIikge1xuICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUobm9kZS5zaXplKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHlsaW5nXCIpIHtcbiAgICAgIGdsdWVPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZU1hcCQxW25vZGUuc3R5bGVdKTtcbiAgICB9XG4gIH0gLy8gRHVtbXkgc3BhbnMgZm9yIGRldGVybWluaW5nIHNwYWNpbmdzIGJldHdlZW4gc3Vycm91bmRpbmcgYXRvbXMuXG4gIC8vIElmIGBleHByZXNzaW9uYCBoYXMgbm8gYXRvbXMgb24gdGhlIGxlZnQgb3IgcmlnaHQsIGNsYXNzIFwibGVmdG1vc3RcIlxuICAvLyBvciBcInJpZ2h0bW9zdFwiLCByZXNwZWN0aXZlbHksIGlzIHVzZWQgdG8gaW5kaWNhdGUgaXQuXG5cblxuICB2YXIgZHVtbXlQcmV2ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMF0gfHwgXCJsZWZ0bW9zdFwiXSwgW10sIG9wdGlvbnMpO1xuICB2YXIgZHVtbXlOZXh0ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMV0gfHwgXCJyaWdodG1vc3RcIl0sIFtdLCBvcHRpb25zKTsgLy8gVE9ETzogVGhlc2UgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAvLyBvZiBpdHMgYGNsYXNzZXNgIGFycmF5LiBBIGxhdGVyIGNsZWFudXAgc2hvdWxkIGVuc3VyZSB0aGlzLCBmb3JcbiAgLy8gaW5zdGFuY2UgYnkgY2hhbmdpbmcgdGhlIHNpZ25hdHVyZSBvZiBgbWFrZVNwYW5gLlxuICAvLyBCZWZvcmUgZGV0ZXJtaW5pbmcgd2hhdCBzcGFjZXMgdG8gaW5zZXJ0LCBwZXJmb3JtIGJpbiBjYW5jZWxsYXRpb24uXG4gIC8vIEJpbmFyeSBvcGVyYXRvcnMgY2hhbmdlIHRvIG9yZGluYXJ5IHN5bWJvbHMgaW4gc29tZSBjb250ZXh0cy5cblxuICB2YXIgaXNSb290ID0gaXNSZWFsR3JvdXAgPT09IFwicm9vdFwiO1xuICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMoZ3JvdXBzLCAobm9kZSwgcHJldikgPT4ge1xuICAgIHZhciBwcmV2VHlwZSA9IHByZXYuY2xhc3Nlc1swXTtcbiAgICB2YXIgdHlwZSA9IG5vZGUuY2xhc3Nlc1swXTtcblxuICAgIGlmIChwcmV2VHlwZSA9PT0gXCJtYmluXCIgJiYgdXRpbHMuY29udGFpbnMoYmluUmlnaHRDYW5jZWxsZXIsIHR5cGUpKSB7XG4gICAgICBwcmV2LmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibWJpblwiICYmIHV0aWxzLmNvbnRhaW5zKGJpbkxlZnRDYW5jZWxsZXIsIHByZXZUeXBlKSkge1xuICAgICAgbm9kZS5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG4gICAgfVxuICB9LCB7XG4gICAgbm9kZTogZHVtbXlQcmV2XG4gIH0sIGR1bW15TmV4dCwgaXNSb290KTtcbiAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKGdyb3VwcywgKG5vZGUsIHByZXYpID0+IHtcbiAgICB2YXIgcHJldlR5cGUgPSBnZXRUeXBlT2ZEb21UcmVlKHByZXYpO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZU9mRG9tVHJlZShub2RlKTsgLy8gJ210aWdodCcgaW5kaWNhdGVzIHRoYXQgdGhlIG5vZGUgaXMgc2NyaXB0IG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cblxuICAgIHZhciBzcGFjZSA9IHByZXZUeXBlICYmIHR5cGUgPyBub2RlLmhhc0NsYXNzKFwibXRpZ2h0XCIpID8gdGlnaHRTcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBzcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBudWxsO1xuXG4gICAgaWYgKHNwYWNlKSB7XG4gICAgICAvLyBJbnNlcnQgZ2x1ZSAoc3BhY2luZykgYWZ0ZXIgdGhlIGBwcmV2YC5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlR2x1ZShzcGFjZSwgZ2x1ZU9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIG5vZGU6IGR1bW15UHJldlxuICB9LCBkdW1teU5leHQsIGlzUm9vdCk7XG4gIHJldHVybiBncm91cHM7XG59OyAvLyBEZXB0aC1maXJzdCB0cmF2ZXJzZSBub24tc3BhY2UgYG5vZGVzYCwgY2FsbGluZyBgY2FsbGJhY2tgIHdpdGggdGhlIGN1cnJlbnQgYW5kXG4vLyBwcmV2aW91cyBub2RlIGFzIGFyZ3VtZW50cywgb3B0aW9uYWxseSByZXR1cm5pbmcgYSBub2RlIHRvIGluc2VydCBhZnRlciB0aGVcbi8vIHByZXZpb3VzIG5vZGUuIGBwcmV2YCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhbmQgYGluc2VydEFmdGVyYFxuLy8gZnVuY3Rpb24gdG8gaW5zZXJ0IGFmdGVyIGl0LiBgbmV4dGAgaXMgYSBub2RlIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmlnaHQuXG4vLyBVc2VkIGZvciBiaW4gY2FuY2VsbGF0aW9uIGFuZCBpbnNlcnRpbmcgc3BhY2luZ3MuXG5cbnZhciB0cmF2ZXJzZU5vblNwYWNlTm9kZXMgPSBmdW5jdGlvbiB0cmF2ZXJzZU5vblNwYWNlTm9kZXMobm9kZXMsIGNhbGxiYWNrLCBwcmV2LCBuZXh0LCBpc1Jvb3QpIHtcbiAgaWYgKG5leHQpIHtcbiAgICAvLyB0ZW1wb3JhcmlseSBhcHBlbmQgdGhlIHJpZ2h0IG5vZGUsIGlmIGV4aXN0c1xuICAgIG5vZGVzLnB1c2gobmV4dCk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHBhcnRpYWxHcm91cCA9IGNoZWNrUGFydGlhbEdyb3VwKG5vZGUpO1xuXG4gICAgaWYgKHBhcnRpYWxHcm91cCkge1xuICAgICAgLy8gUmVjdXJzaXZlIERGU1xuICAgICAgLy8gJEZsb3dGaXhNZTogbWFrZSBub2RlcyBhICRSZWFkT25seUFycmF5IGJ5IHJldHVybmluZyBhIG5ldyBhcnJheVxuICAgICAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKHBhcnRpYWxHcm91cC5jaGlsZHJlbiwgY2FsbGJhY2ssIHByZXYsIG51bGwsIGlzUm9vdCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIElnbm9yZSBleHBsaWNpdCBzcGFjZXMgKGUuZy4sIFxcOywgXFwsKSB3aGVuIGRldGVybWluaW5nIHdoYXQgaW1wbGljaXRcbiAgICAvLyBzcGFjaW5nIHNob3VsZCBnbyBiZXR3ZWVuIGF0b21zIG9mIGRpZmZlcmVudCBjbGFzc2VzXG5cblxuICAgIHZhciBub25zcGFjZSA9ICFub2RlLmhhc0NsYXNzKFwibXNwYWNlXCIpO1xuXG4gICAgaWYgKG5vbnNwYWNlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sobm9kZSwgcHJldi5ub2RlKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAocHJldi5pbnNlcnRBZnRlcikge1xuICAgICAgICAgIHByZXYuaW5zZXJ0QWZ0ZXIocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbnNlcnQgYXQgZnJvbnRcbiAgICAgICAgICBub2Rlcy51bnNoaWZ0KHJlc3VsdCk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vbnNwYWNlKSB7XG4gICAgICBwcmV2Lm5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAoaXNSb290ICYmIG5vZGUuaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICBwcmV2Lm5vZGUgPSBtYWtlU3BhbiQxKFtcImxlZnRtb3N0XCJdKTsgLy8gdHJlYXQgbGlrZSBiZWdpbm5pbmcgb2YgbGluZVxuICAgIH1cblxuICAgIHByZXYuaW5zZXJ0QWZ0ZXIgPSAoaW5kZXggPT4gbiA9PiB7XG4gICAgICBub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuKTtcbiAgICAgIGkrKztcbiAgICB9KShpKTtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbm9kZXMucG9wKCk7XG4gIH1cbn07IC8vIENoZWNrIGlmIGdpdmVuIG5vZGUgaXMgYSBwYXJ0aWFsIGdyb3VwLCBpLmUuLCBkb2VzIG5vdCBhZmZlY3Qgc3BhY2luZyBhcm91bmQuXG5cblxudmFyIGNoZWNrUGFydGlhbEdyb3VwID0gZnVuY3Rpb24gY2hlY2tQYXJ0aWFsR3JvdXAobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEFuY2hvciB8fCBub2RlIGluc3RhbmNlb2YgU3BhbiAmJiBub2RlLmhhc0NsYXNzKFwiZW5jbG9zaW5nXCIpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07IC8vIFJldHVybiB0aGUgb3V0ZXJtb3N0IG5vZGUgb2YgYSBkb21UcmVlLlxuXG5cbnZhciBnZXRPdXRlcm1vc3ROb2RlID0gZnVuY3Rpb24gZ2V0T3V0ZXJtb3N0Tm9kZShub2RlLCBzaWRlKSB7XG4gIHZhciBwYXJ0aWFsR3JvdXAgPSBjaGVja1BhcnRpYWxHcm91cChub2RlKTtcblxuICBpZiAocGFydGlhbEdyb3VwKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFydGlhbEdyb3VwLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgaWYgKHNpZGUgPT09IFwicmlnaHRcIikge1xuICAgICAgICByZXR1cm4gZ2V0T3V0ZXJtb3N0Tm9kZShjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSwgXCJyaWdodFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUoY2hpbGRyZW5bMF0sIFwibGVmdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07IC8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxuLy8gSWYgYHNpZGVgIGlzIGdpdmVuLCBpdCB3aWxsIGdldCB0aGUgdHlwZSBvZiB0aGUgb3V0ZXJtb3N0IG5vZGUgYXQgZ2l2ZW4gc2lkZS5cblxuXG52YXIgZ2V0VHlwZU9mRG9tVHJlZSA9IGZ1bmN0aW9uIGdldFR5cGVPZkRvbVRyZWUobm9kZSwgc2lkZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzaWRlKSB7XG4gICAgbm9kZSA9IGdldE91dGVybW9zdE5vZGUobm9kZSwgc2lkZSk7XG4gIH0gLy8gVGhpcyBtYWtlcyBhIGxvdCBvZiBhc3N1bXB0aW9ucyBhcyB0byB3aGVyZSB0aGUgdHlwZSBvZiBhdG9tXG4gIC8vIGFwcGVhcnMuICBXZSBzaG91bGQgZG8gYSBiZXR0ZXIgam9iIG9mIGVuZm9yY2luZyB0aGlzLlxuXG5cbiAgcmV0dXJuIERvbUVudW1bbm9kZS5jbGFzc2VzWzBdXSB8fCBudWxsO1xufTtcbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uIG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgdmFyIG1vcmVDbGFzc2VzID0gW1wibnVsbGRlbGltaXRlclwiXS5jb25jYXQob3B0aW9ucy5iYXNlU2l6aW5nQ2xhc3NlcygpKTtcbiAgcmV0dXJuIG1ha2VTcGFuJDEoY2xhc3Nlcy5jb25jYXQobW9yZUNsYXNzZXMpKTtcbn07XG4vKipcbiAqIGJ1aWxkR3JvdXAgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBncm91cCBhbmQgY2FsbHMgdGhlIGNvcnJlY3QgZ3JvdXBUeXBlXG4gKiBmdW5jdGlvbiBmb3IgaXQuIEl0IGFsc28gaGFuZGxlcyB0aGUgaW50ZXJhY3Rpb24gb2Ygc2l6ZSBhbmQgc3R5bGUgY2hhbmdlc1xuICogYmV0d2VlbiBwYXJlbnRzIGFuZCBjaGlsZHJlbi5cbiAqL1xuXG52YXIgYnVpbGRHcm91cCQxID0gZnVuY3Rpb24gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBtYWtlU3BhbiQxKCk7XG4gIH1cblxuICBpZiAoX2h0bWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIC8vICRGbG93Rml4TWVcbiAgICB2YXIgZ3JvdXBOb2RlID0gX2h0bWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTsgLy8gSWYgdGhlIHNpemUgY2hhbmdlZCBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjdXJyZW50IGdyb3VwLCBhY2NvdW50XG4gICAgLy8gZm9yIHRoYXQgc2l6ZSBkaWZmZXJlbmNlLlxuXG4gICAgaWYgKGJhc2VPcHRpb25zICYmIG9wdGlvbnMuc2l6ZSAhPT0gYmFzZU9wdGlvbnMuc2l6ZSkge1xuICAgICAgZ3JvdXBOb2RlID0gbWFrZVNwYW4kMShvcHRpb25zLnNpemluZ0NsYXNzZXMoYmFzZU9wdGlvbnMpLCBbZ3JvdXBOb2RlXSwgb3B0aW9ucyk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBiYXNlT3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIGdyb3VwTm9kZS5oZWlnaHQgKj0gbXVsdGlwbGllcjtcbiAgICAgIGdyb3VwTm9kZS5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBDb21iaW5lIGFuIGFycmF5IG9mIEhUTUwgRE9NIG5vZGVzIChlLmcuLCB0aGUgb3V0cHV0IG9mIGBidWlsZEV4cHJlc3Npb25gKVxuICogaW50byBhbiB1bmJyZWFrYWJsZSBIVE1MIG5vZGUgb2YgY2xhc3MgLmJhc2UsIHdpdGggcHJvcGVyIHN0cnV0cyB0b1xuICogZ3VhcmFudGVlIGNvcnJlY3QgdmVydGljYWwgZXh0ZW50LiAgYGJ1aWxkSFRNTGAgY2FsbHMgdGhpcyByZXBlYXRlZGx5IHRvXG4gKiBtYWtlIHVwIHRoZSBlbnRpcmUgZXhwcmVzc2lvbiBhcyBhIHNlcXVlbmNlIG9mIHVuYnJlYWthYmxlIHVuaXRzLlxuICovXG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTFVuYnJlYWthYmxlKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIC8vIENvbXB1dGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGlzIGNodW5rLlxuICB2YXIgYm9keSA9IG1ha2VTcGFuJDEoW1wiYmFzZVwiXSwgY2hpbGRyZW4sIG9wdGlvbnMpOyAvLyBBZGQgc3RydXQsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGUgdG9wIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXRcbiAgLy8gdGhlIGhlaWdodCBvZiB0aGUgZXhwcmVzc2lvbiwgYW5kIHRoZSBib3R0b20gb2YgdGhlIEhUTUwgZWxlbWVudFxuICAvLyBmYWxscyBhdCB0aGUgZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG5cbiAgdmFyIHN0cnV0ID0gbWFrZVNwYW4kMShbXCJzdHJ1dFwiXSk7XG4gIHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpO1xuXG4gIGlmIChib2R5LmRlcHRoKSB7XG4gICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtYm9keS5kZXB0aCk7XG4gIH1cblxuICBib2R5LmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpO1xuICByZXR1cm4gYm9keTtcbn1cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG5cblxuZnVuY3Rpb24gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpIHtcbiAgLy8gU3RyaXAgb2ZmIG91dGVyIHRhZyB3cmFwcGVyIGZvciBwcm9jZXNzaW5nIGJlbG93LlxuICB2YXIgdGFnID0gbnVsbDtcblxuICBpZiAodHJlZS5sZW5ndGggPT09IDEgJiYgdHJlZVswXS50eXBlID09PSBcInRhZ1wiKSB7XG4gICAgdGFnID0gdHJlZVswXS50YWc7XG4gICAgdHJlZSA9IHRyZWVbMF0uYm9keTtcbiAgfSAvLyBCdWlsZCB0aGUgZXhwcmVzc2lvbiBjb250YWluZWQgaW4gdGhlIHRyZWVcblxuXG4gIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uJDEodHJlZSwgb3B0aW9ucywgXCJyb290XCIpO1xuICB2YXIgZXFuTnVtO1xuXG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMiAmJiBleHByZXNzaW9uWzFdLmhhc0NsYXNzKFwidGFnXCIpKSB7XG4gICAgLy8gQW4gZW52aXJvbm1lbnQgd2l0aCBhdXRvbWF0aWMgZXF1YXRpb24gbnVtYmVycywgZS5nLiB7Z2F0aGVyfS5cbiAgICBlcW5OdW0gPSBleHByZXNzaW9uLnBvcCgpO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gW107IC8vIENyZWF0ZSBvbmUgYmFzZSBub2RlIGZvciBlYWNoIGNodW5rIGJldHdlZW4gcG90ZW50aWFsIGxpbmUgYnJlYWtzLlxuICAvLyBUaGUgVGVYQm9vayBbcC4xNzNdIHNheXMgXCJBIGZvcm11bGEgd2lsbCBiZSBicm9rZW4gb25seSBhZnRlciBhXG4gIC8vIHJlbGF0aW9uIHN5bWJvbCBsaWtlICQ9JCBvciAkPCQgb3IgJFxccmlnaHRhcnJvdyQsIG9yIGFmdGVyIGEgYmluYXJ5XG4gIC8vIG9wZXJhdGlvbiBzeW1ib2wgbGlrZSAkKyQgb3IgJC0kIG9yICRcXHRpbWVzJCwgd2hlcmUgdGhlIHJlbGF0aW9uIG9yXG4gIC8vIGJpbmFyeSBvcGVyYXRpb24gaXMgb24gdGhlIGBgb3V0ZXIgbGV2ZWwnJyBvZiB0aGUgZm9ybXVsYSAoaS5lLiwgbm90XG4gIC8vIGVuY2xvc2VkIGluIHsuLi59IGFuZCBub3QgcGFydCBvZiBhbiBcXG92ZXIgY29uc3RydWN0aW9uKS5cIlxuXG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICBpZiAoZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1iaW5cIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcIm1yZWxcIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcyhcImFsbG93YnJlYWtcIikpIHtcbiAgICAgIC8vIFB1dCBhbnkgcG9zdC1vcGVyYXRvciBnbHVlIG9uIHNhbWUgbGluZSBhcyBvcGVyYXRvci5cbiAgICAgIC8vIFdhdGNoIGZvciBcXG5vYnJlYWsgYWxvbmcgdGhlIHdheSwgYW5kIHN0b3AgYXQgXFxuZXdsaW5lLlxuICAgICAgdmFyIG5vYnJlYWsgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGkgPCBleHByZXNzaW9uLmxlbmd0aCAtIDEgJiYgZXhwcmVzc2lvbltpICsgMV0uaGFzQ2xhc3MoXCJtc3BhY2VcIikgJiYgIWV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIHBhcnRzLnB1c2goZXhwcmVzc2lvbltpXSk7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJub2JyZWFrXCIpKSB7XG4gICAgICAgICAgbm9icmVhayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRG9uJ3QgYWxsb3cgYnJlYWsgaWYgXFxub2JyZWFrIGFtb25nIHRoZSBwb3N0LW9wZXJhdG9yIGdsdWUuXG5cblxuICAgICAgaWYgKCFub2JyZWFrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJuZXdsaW5lXCIpKSB7XG4gICAgICAvLyBXcml0ZSB0aGUgbGluZSBleGNlcHQgdGhlIG5ld2xpbmVcbiAgICAgIHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICB9IC8vIFB1dCB0aGUgbmV3bGluZSBhdCB0aGUgdG9wIGxldmVsXG5cblxuICAgICAgY2hpbGRyZW4ucHVzaChleHByZXNzaW9uW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTtcbiAgfSAvLyBOb3csIGlmIHRoZXJlIHdhcyBhIHRhZywgYnVpbGQgaXQgdG9vIGFuZCBhcHBlbmQgaXQgYXMgYSBmaW5hbCBjaGlsZC5cblxuXG4gIHZhciB0YWdDaGlsZDtcblxuICBpZiAodGFnKSB7XG4gICAgdGFnQ2hpbGQgPSBidWlsZEhUTUxVbmJyZWFrYWJsZShidWlsZEV4cHJlc3Npb24kMSh0YWcsIG9wdGlvbnMsIHRydWUpKTtcbiAgICB0YWdDaGlsZC5jbGFzc2VzID0gW1widGFnXCJdO1xuICAgIGNoaWxkcmVuLnB1c2godGFnQ2hpbGQpO1xuICB9IGVsc2UgaWYgKGVxbk51bSkge1xuICAgIGNoaWxkcmVuLnB1c2goZXFuTnVtKTtcbiAgfVxuXG4gIHZhciBodG1sTm9kZSA9IG1ha2VTcGFuJDEoW1wia2F0ZXgtaHRtbFwiXSwgY2hpbGRyZW4pO1xuICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7IC8vIEFkanVzdCB0aGUgc3RydXQgb2YgdGhlIHRhZyB0byBiZSB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYWxsIGNoaWxkcmVuXG4gIC8vICh0aGUgaGVpZ2h0IG9mIHRoZSBlbmNsb3NpbmcgaHRtbE5vZGUpIGZvciBwcm9wZXIgdmVydGljYWwgYWxpZ25tZW50LlxuXG4gIGlmICh0YWdDaGlsZCkge1xuICAgIHZhciBzdHJ1dCA9IHRhZ0NoaWxkLmNoaWxkcmVuWzBdO1xuICAgIHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShodG1sTm9kZS5oZWlnaHQgKyBodG1sTm9kZS5kZXB0aCk7XG5cbiAgICBpZiAoaHRtbE5vZGUuZGVwdGgpIHtcbiAgICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWh0bWxOb2RlLmRlcHRoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbE5vZGU7XG59XG5cbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSBkYXRhIGFib3V0IE1hdGhNTCBub2Rlcy4gVGhpcyBpcyB0aGUgTWF0aE1MIGVxdWl2YWxlbnRcbiAqIG9mIHRoZSB0eXBlcyBpbiBkb21UcmVlLmpzLiBTaW5jZSBNYXRoTUwgaGFuZGxlcyBpdHMgb3duIHJlbmRlcmluZywgYW5kXG4gKiBzaW5jZSB3ZSdyZSBtYWlubHkgdXNpbmcgTWF0aE1MIHRvIGltcHJvdmUgYWNjZXNzaWJpbGl0eSwgd2UgZG9uJ3QgbWFuYWdlXG4gKiBhbnkgb2YgdGhlIHN0eWxpbmcgc3RhdGUgdGhhdCB0aGUgcGxhaW4gRE9NIG5vZGVzIGRvLlxuICpcbiAqIFRoZSBgdG9Ob2RlYCBhbmQgYHRvTWFya3VwYCBmdW5jdGlvbnMgd29yayBzaW1sYXJseSB0byBob3cgdGhleSBkbyBpblxuICogZG9tVHJlZS5qcywgY3JlYXRpbmcgbmFtZXNwYWNlZCBET00gbm9kZXMgYW5kIEhUTUwgdGV4dCBtYXJrdXAgcmVzcGVjdGl2ZWx5LlxuICovXG5mdW5jdGlvbiBuZXdEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZ2VuZXJhbCBwdXJwb3NlIE1hdGhNTCBub2RlIG9mIGFueSB0eXBlLiBUaGVcbiAqIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSB0eXBlIG9mIG5vZGUgdG8gY3JlYXRlIChmb3IgZXhhbXBsZSwgYFwibW9cImAgb3JcbiAqIGBcIm1zcGFjZVwiYCwgY29ycmVzcG9uZGluZyB0byBgPG1vPmAgYW5kIGA8bXNwYWNlPmAgdGFncykuXG4gKi9cblxuY2xhc3MgTWF0aE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjaGlsZHJlbiwgY2xhc3Nlcykge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4gTWF0aE1MIGRlcGVuZHMgb24gYXR0cmlidXRlcyB0byBjb252ZXkgYVxuICAgKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAgICovXG5cblxuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS5cbiAgICovXG5cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICAgKi9cblxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgdGhpcy50eXBlKTtcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPFwiICsgdGhpcy50eXBlOyAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXJrdXAgKz0gXCIgY2xhc3MgPVxcXCJcIiArIHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L1wiICsgdGhpcy50eXBlICsgXCI+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dCwgYnV0IGVzY2FwZWQuXG4gICAqL1xuXG5cbiAgdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC50b1RleHQoKSkuam9pbihcIlwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuXG5jbGFzcyBUZXh0Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAgICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBlc2NhcGVkIEhUTUwgbWFya3VwXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXNjYXBlKHRoaXMudG9UZXh0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBzdHJpbmdcbiAgICogKHJlcHJlc2VudGluZyB0aGUgdGV4dCBpdGVzZWxmKS5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhY2UsIGJ1dCBtYXkgcmVuZGVyIGFzIDxtc3BhY2UuLi4vPiBvciBhcyB0ZXh0LFxuICogZGVwZW5kaW5nIG9uIHRoZSB3aWR0aC5cbiAqL1xuXG5jbGFzcyBTcGFjZU5vZGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgU3BhY2Ugbm9kZSB3aXRoIHdpZHRoIGdpdmVuIGluIENTUyBlbXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCkge1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFyYWN0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoOyAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvV0QtTWF0aE1MMi0yMDAwMDMyOC9jaGFwdGVyNi5odG1sXG4gICAgLy8gZm9yIGEgdGFibGUgb2Ygc3BhY2UtbGlrZSBjaGFyYWN0ZXJzLiAgV2UgdXNlIFVuaWNvZGVcbiAgICAvLyByZXByZXNlbnRhdGlvbnMgaW5zdGVhZCBvZiAmTG9uZ05hbWVzOyBhcyBpdCdzIG5vdCBjbGVhciBob3cgdG9cbiAgICAvLyBtYWtlIHRoZSBsYXR0ZXIgdmlhIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLlxuXG4gICAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1Nikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMGFcIjsgLy8gJlZlcnlUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVwiOyAvLyAmVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcXHUyMDBhXCI7IC8vICZUaGlja1NwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMDU1NTYgJiYgd2lkdGggPD0gLTAuMDU1NTUpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDBhXFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMTY2NyAmJiB3aWR0aCA8PSAtMC4xNjY2KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjIyMyAmJiB3aWR0aCA8PSAtMC4yMjIyKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjA1ZlxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlTWVkaXVtU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4yNzc4ICYmIHdpZHRoIDw9IC0wLjI3NzcpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVUaGlja1NwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jaGFyYWN0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtc3BhY2VcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG1ha2VFbSh0aGlzLndpZHRoKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gXCI8bXRleHQ+XCIgKyB0aGlzLmNoYXJhY3RlciArIFwiPC9tdGV4dD5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiPG1zcGFjZSB3aWR0aD1cXFwiXCIgKyBtYWtlRW0odGhpcy53aWR0aCkgKyBcIlxcXCIvPlwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiBcIjtcbiAgICB9XG4gIH1cblxufVxuXG52YXIgbWF0aE1MVHJlZSA9IHtcbiAgTWF0aE5vZGUsXG4gIFRleHROb2RlLFxuICBTcGFjZU5vZGUsXG4gIG5ld0RvY3VtZW50RnJhZ21lbnRcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uIG1ha2VUZXh0KHRleHQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmIHRleHQuY2hhckNvZGVBdCgwKSAhPT0gMHhEODM1ICYmICEobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9udEZhbWlseSAmJiBvcHRpb25zLmZvbnRGYW1pbHkuc3Vic3RyKDQsIDIpID09PSBcInR0XCIgfHwgb3B0aW9ucy5mb250ICYmIG9wdGlvbnMuZm9udC5zdWJzdHIoNCwgMikgPT09IFwidHRcIikpKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh0ZXh0KTtcbn07XG4vKipcbiAqIFdyYXAgdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzIGluIGFuIDxtcm93PiBub2RlIGlmIG5lZWRlZCwgaS5lLixcbiAqIHVubGVzcyB0aGUgYXJyYXkgaGFzIGxlbmd0aCAxLiAgQWx3YXlzIHJldHVybnMgYSBzaW5nbGUgbm9kZS5cbiAqL1xuXG52YXIgbWFrZVJvdyA9IGZ1bmN0aW9uIG1ha2VSb3coYm9keSkge1xuICBpZiAoYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYm9keVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJvZHkpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXRoIHZhcmlhbnQgYXMgYSBzdHJpbmcgb3IgbnVsbCBpZiBub25lIGlzIHJlcXVpcmVkLlxuICovXG5cbnZhciBnZXRWYXJpYW50ID0gZnVuY3Rpb24gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykge1xuICAvLyBIYW5kbGUgXFx0ZXh0Li4uIGZvbnQgc3BlY2lmaWVycyBhcyBiZXN0IHdlIGNhbi5cbiAgLy8gTWF0aE1MIGhhcyBhIGxpbWl0ZWQgbGlzdCBvZiBhbGxvd2FibGUgbWF0aHZhcmlhbnQgc3BlY2lmaWVyczsgc2VlXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9NYXRoTUwzL2NoYXB0ZXIzLmh0bWwjcHJlc20uY29tbWF0dFxuICBpZiAob3B0aW9ucy5mb250RmFtaWx5ID09PSBcInRleHR0dFwiKSB7XG4gICAgcmV0dXJuIFwibW9ub3NwYWNlXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250RmFtaWx5ID09PSBcInRleHRzZlwiKSB7XG4gICAgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtaXRhbGljXCI7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcImJvbGQtc2Fucy1zZXJpZlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIG9wdGlvbnMuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIHJldHVybiBcImJvbGQtaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250U2hhcGUgPT09IFwidGV4dGl0XCIpIHtcbiAgICByZXR1cm4gXCJpdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkXCI7XG4gIH1cblxuICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcblxuICBpZiAoIWZvbnQgfHwgZm9udCA9PT0gXCJtYXRobm9ybWFsXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtb2RlID0gZ3JvdXAubW9kZTtcblxuICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIikge1xuICAgIHJldHVybiBcIml0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwiYm9sZHN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGdyb3VwLnR5cGUgPT09IFwidGV4dG9yZFwiID8gXCJib2xkXCIgOiBcImJvbGQtaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoYmZcIikge1xuICAgIHJldHVybiBcImJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhiYlwiKSB7XG4gICAgcmV0dXJuIFwiZG91YmxlLXN0cnVja1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aGZyYWtcIikge1xuICAgIHJldHVybiBcImZyYWt0dXJcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzY3JcIiB8fCBmb250ID09PSBcIm1hdGhjYWxcIikge1xuICAgIC8vIE1hdGhNTCBtYWtlcyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIHNjcmlwdCBhbmQgY2FsaWdyYWhwaWNcbiAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzZlwiKSB7XG4gICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIjtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gZ3JvdXAudGV4dDtcblxuICBpZiAodXRpbHMuY29udGFpbnMoW1wiXFxcXGltYXRoXCIsIFwiXFxcXGptYXRoXCJdLCB0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHZhciBmb250TmFtZSA9IGJ1aWxkQ29tbW9uLmZvbnRNYXBbZm9udF0uZm9udE5hbWU7XG5cbiAgaWYgKGdldENoYXJhY3Rlck1ldHJpY3ModGV4dCwgZm9udE5hbWUsIG1vZGUpKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLmZvbnRNYXBbZm9udF0udmFyaWFudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIG5vZGVzLCBidWlsZHMgdGhlbSwgYW5kIHJldHVybnMgYSBsaXN0IG9mIHRoZSBnZW5lcmF0ZWRcbiAqIE1hdGhNTCBub2Rlcy4gIEFsc28gY29tYmluZSBjb25zZWN1dGl2ZSA8bXRleHQ+IG91dHB1dHMgaW50byBhIHNpbmdsZVxuICogPG10ZXh0PiB0YWcuXG4gKi9cblxudmFyIGJ1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIGJ1aWxkRXhwcmVzc2lvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc09yZGdyb3VwKSB7XG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBncm91cCA9IGJ1aWxkR3JvdXAoZXhwcmVzc2lvblswXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoaXNPcmRncm91cCAmJiBncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09IFwibW9cIikge1xuICAgICAgLy8gV2hlbiBUZVggd3JpdGVycyB3YW50IHRvIHN1cHByZXNzIHNwYWNpbmcgb24gYW4gb3BlcmF0b3IsXG4gICAgICAvLyB0aGV5IG9mdGVuIHB1dCB0aGUgb3BlcmF0b3IgYnkgaXRzZWxmIGluc2lkZSBicmFjZXMuXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtncm91cF07XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gW107XG4gIHZhciBsYXN0R3JvdXA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9ncm91cCA9IGJ1aWxkR3JvdXAoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoX2dyb3VwIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgbGFzdEdyb3VwIGluc3RhbmNlb2YgTWF0aE5vZGUpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIGFkamFjZW50IDxtdGV4dD5zXG4gICAgICBpZiAoX2dyb3VwLnR5cGUgPT09ICdtdGV4dCcgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtdGV4dCcgJiYgX2dyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSA9PT0gbGFzdEdyb3VwLmdldEF0dHJpYnV0ZSgnbWF0aHZhcmlhbnQnKSkge1xuICAgICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5fZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgICBjb250aW51ZTsgLy8gQ29uY2F0ZW5hdGUgYWRqYWNlbnQgPG1uPnNcbiAgICAgIH0gZWxzZSBpZiAoX2dyb3VwLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uX2dyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIDxtbj4uLi48L21uPiBmb2xsb3dlZCBieSA8bWk+LjwvbWk+XG4gICAgICB9IGVsc2UgaWYgKF9ncm91cC50eXBlID09PSAnbWknICYmIF9ncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gX2dyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIGNoaWxkLnRleHQgPT09ICcuJykge1xuICAgICAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLl9ncm91cC5jaGlsZHJlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwLnR5cGUgPT09ICdtaScgJiYgbGFzdEdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgbGFzdENoaWxkID0gbGFzdEdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBsYXN0Q2hpbGQudGV4dCA9PT0gJ1xcdTAzMzgnICYmIChfZ3JvdXAudHlwZSA9PT0gJ21vJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21pJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21uJykpIHtcbiAgICAgICAgICB2YXIgX2NoaWxkID0gX2dyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgaWYgKF9jaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIF9jaGlsZC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXkgd2l0aCBjb21iaW5pbmcgY2hhcmFjdGVyIGxvbmcgc29saWR1c1xuICAgICAgICAgICAgX2NoaWxkLnRleHQgPSBfY2hpbGQudGV4dC5zbGljZSgwLCAxKSArIFwiXFx1MDMzOFwiICsgX2NoaWxkLnRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgICBncm91cHMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2goX2dyb3VwKTtcbiAgICBsYXN0R3JvdXAgPSBfZ3JvdXA7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBidWlsZEV4cHJlc3Npb24sIGJ1dCB3cmFwcyB0aGUgZWxlbWVudHMgaW4gYW4gPG1yb3c+XG4gKiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUuICBSZXR1cm5zIGEgc2luZ2xlIG5vZGUgaW5zdGVhZCBvZiBhbiBhcnJheS5cbiAqL1xuXG52YXIgYnVpbGRFeHByZXNzaW9uUm93ID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uUm93KGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApIHtcbiAgcmV0dXJuIG1ha2VSb3coYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApKTtcbn07XG4vKipcbiAqIFRha2VzIGEgZ3JvdXAgZnJvbSB0aGUgcGFyc2VyIGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICogb24gaXQgdG8gcHJvZHVjZSBhIE1hdGhNTCBub2RlLlxuICovXG5cbnZhciBidWlsZEdyb3VwID0gZnVuY3Rpb24gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxuXG4gIGlmIChfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgdmFyIHJlc3VsdCA9IF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xuXG5mdW5jdGlvbiBidWlsZE1hdGhNTCh0cmVlLCB0ZXhFeHByZXNzaW9uLCBvcHRpb25zLCBpc0Rpc3BsYXlNb2RlLCBmb3JNYXRobWxPbmx5KSB7XG4gIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpOyAvLyBUT0RPOiBNYWtlIGEgcGFzcyB0aHJ1IHRoZSBNYXRoTUwgc2ltaWxhciB0byBidWlsZEhUTUwudHJhdmVyc2VOb25TcGFjZU5vZGVzXG4gIC8vIGFuZCBhZGQgc3BhY2luZyBub2Rlcy4gVGhpcyBpcyBuZWNlc3Nhcnkgb25seSBhZGphY2VudCB0byBtYXRoIG9wZXJhdG9yc1xuICAvLyBsaWtlIFxcc2luIG9yIFxcbGltIG9yIHRvIHN1YnN1cCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gbWF0aCBvcGVyYXRvcnMuXG4gIC8vIE1hdGhNTCB0YWtlcyBjYXJlIG9mIHRoZSBvdGhlciBzcGFjaW5nIGlzc3Vlcy5cbiAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gIC8vIHRhZyBjb3JyZWN0bHksIHVubGVzcyBpdCdzIGEgc2luZ2xlIDxtcm93PiBvciA8bXRhYmxlPi5cblxuICB2YXIgd3JhcHBlcjtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIHV0aWxzLmNvbnRhaW5zKFtcIm1yb3dcIiwgXCJtdGFibGVcIl0sIGV4cHJlc3Npb25bMF0udHlwZSkpIHtcbiAgICB3cmFwcGVyID0gZXhwcmVzc2lvblswXTtcbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pO1xuICB9IC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuXG5cbiAgdmFyIGFubm90YXRpb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcImFubm90YXRpb25cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleEV4cHJlc3Npb24pXSk7XG4gIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcbiAgdmFyIHNlbWFudGljcyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwic2VtYW50aWNzXCIsIFt3cmFwcGVyLCBhbm5vdGF0aW9uXSk7XG4gIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcbiAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIik7XG5cbiAgaWYgKGlzRGlzcGxheU1vZGUpIHtcbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgfSAvLyBZb3UgY2FuJ3Qgc3R5bGUgPG1hdGg+IG5vZGVzLCBzbyB3ZSB3cmFwIHRoZSBub2RlIGluIGEgc3Bhbi5cbiAgLy8gTk9URTogVGhlIHNwYW4gY2xhc3MgaXMgbm90IHR5cGVkIHRvIGhhdmUgPG1hdGg+IG5vZGVzIGFzIGNoaWxkcmVuLCBhbmRcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZSBjaGlsZHJlbiB0eXBlIG1vcmUgZ2VuZXJpYyBzaW5jZSB0aGUgY2hpbGRyZW5cbiAgLy8gb2Ygc3BhbiBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSBtb3JlIGZpZWxkcyBpbiBgYnVpbGRIdG1sYCBjb250ZXh0cy5cblxuXG4gIHZhciB3cmFwcGVyQ2xhc3MgPSBmb3JNYXRobWxPbmx5ID8gXCJrYXRleFwiIDogXCJrYXRleC1tYXRobWxcIjsgLy8gJEZsb3dGaXhNZVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3Bhbihbd3JhcHBlckNsYXNzXSwgW21hdGhdKTtcbn1cblxudmFyIG9wdGlvbnNGcm9tU2V0dGluZ3MgPSBmdW5jdGlvbiBvcHRpb25zRnJvbVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucyh7XG4gICAgc3R5bGU6IHNldHRpbmdzLmRpc3BsYXlNb2RlID8gU3R5bGUkMS5ESVNQTEFZIDogU3R5bGUkMS5URVhULFxuICAgIG1heFNpemU6IHNldHRpbmdzLm1heFNpemUsXG4gICAgbWluUnVsZVRoaWNrbmVzczogc2V0dGluZ3MubWluUnVsZVRoaWNrbmVzc1xuICB9KTtcbn07XG5cbnZhciBkaXNwbGF5V3JhcCA9IGZ1bmN0aW9uIGRpc3BsYXlXcmFwKG5vZGUsIHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIHZhciBjbGFzc2VzID0gW1wia2F0ZXgtZGlzcGxheVwiXTtcblxuICAgIGlmIChzZXR0aW5ncy5sZXFubykge1xuICAgICAgY2xhc3Nlcy5wdXNoKFwibGVxbm9cIik7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLmZsZXFuKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJmbGVxblwiKTtcbiAgICB9XG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3NlcywgW25vZGVdKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIGJ1aWxkVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncykge1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpO1xuICB2YXIga2F0ZXhOb2RlO1xuXG4gIGlmIChzZXR0aW5ncy5vdXRwdXQgPT09IFwibWF0aG1sXCIpIHtcbiAgICByZXR1cm4gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIHRydWUpO1xuICB9IGVsc2UgaWYgKHNldHRpbmdzLm91dHB1dCA9PT0gXCJodG1sXCIpIHtcbiAgICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG4gICAga2F0ZXhOb2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXhcIl0sIFtodG1sTm9kZV0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIGZhbHNlKTtcblxuICAgIHZhciBfaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG5cbiAgICBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW21hdGhNTE5vZGUsIF9odG1sTm9kZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpO1xufTtcbnZhciBidWlsZEhUTUxUcmVlID0gZnVuY3Rpb24gYnVpbGRIVE1MVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncykge1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpO1xuICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7XG4gIHZhciBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW2h0bWxOb2RlXSk7XG4gIHJldHVybiBkaXNwbGF5V3JhcChrYXRleE5vZGUsIHNldHRpbmdzKTtcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgdG8gYnVpbGRNYXRoTUwuanMgYW5kIGJ1aWxkSFRNTC5qc1xuICogZm9yIHN0cmV0Y2h5IHdpZGUgZWxlbWVudHMgcmVuZGVyZWQgZnJvbSBTVkcgZmlsZXNcbiAqIGFuZCBvdGhlciBDU1MgdHJpY2tlcnkuXG4gKi9cbnZhciBzdHJldGNoeUNvZGVQb2ludCA9IHtcbiAgd2lkZWhhdDogXCJeXCIsXG4gIHdpZGVjaGVjazogXCLLh1wiLFxuICB3aWRldGlsZGU6IFwiflwiLFxuICB1dGlsZGU6IFwiflwiLFxuICBvdmVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgdW5kZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB4bGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgb3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB4cmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVyYnJhY2U6IFwiXFx1MjNkZlwiLFxuICBvdmVyYnJhY2U6IFwiXFx1MjNkZVwiLFxuICBvdmVyZ3JvdXA6IFwiXFx1MjNlMFwiLFxuICB1bmRlcmdyb3VwOiBcIlxcdTIzZTFcIixcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHhsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIE92ZXJyaWdodGFycm93OiBcIlxcdTIxZDJcIixcbiAgeFJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICBvdmVybGVmdGhhcnBvb246IFwiXFx1MjFiY1wiLFxuICB4bGVmdGhhcnBvb251cDogXCJcXHUyMWJjXCIsXG4gIG92ZXJyaWdodGhhcnBvb246IFwiXFx1MjFjMFwiLFxuICB4cmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICB4TGVmdGFycm93OiBcIlxcdTIxZDBcIixcbiAgeExlZnRyaWdodGFycm93OiBcIlxcdTIxZDRcIixcbiAgeGhvb2tsZWZ0YXJyb3c6IFwiXFx1MjFhOVwiLFxuICB4aG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFhYVwiLFxuICB4bWFwc3RvOiBcIlxcdTIxYTZcIixcbiAgeHJpZ2h0aGFycG9vbmRvd246IFwiXFx1MjFjMVwiLFxuICB4bGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgeHJpZ2h0bGVmdGhhcnBvb25zOiBcIlxcdTIxY2NcIixcbiAgeGxlZnRyaWdodGhhcnBvb25zOiBcIlxcdTIxY2JcIixcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFwiXFx1MjE5ZVwiLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFhMFwiLFxuICB4bG9uZ2VxdWFsOiBcIj1cIixcbiAgeHRvZnJvbTogXCJcXHUyMWM0XCIsXG4gIHhyaWdodGxlZnRhcnJvd3M6IFwiXFx1MjFjNFwiLFxuICB4cmlnaHRlcXVpbGlicml1bTogXCJcXHUyMWNjXCIsXG4gIC8vIE5vdCBhIHBlcmZlY3QgbWF0Y2guXG4gIHhsZWZ0ZXF1aWxpYnJpdW06IFwiXFx1MjFjYlwiLFxuICAvLyBOb25lIGJldHRlciBhdmFpbGFibGUuXG4gIFwiXFxcXGNkcmlnaHRhcnJvd1wiOiBcIlxcdTIxOTJcIixcbiAgXCJcXFxcY2RsZWZ0YXJyb3dcIjogXCJcXHUyMTkwXCIsXG4gIFwiXFxcXGNkbG9uZ2VxdWFsXCI6IFwiPVwiXG59O1xuXG52YXIgbWF0aE1Mbm9kZSA9IGZ1bmN0aW9uIG1hdGhNTG5vZGUobGFiZWwpIHtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShzdHJldGNoeUNvZGVQb2ludFtsYWJlbC5yZXBsYWNlKC9eXFxcXC8sICcnKV0pXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gbm9kZTtcbn07IC8vIE1hbnkgb2YgdGhlIEthVGVYIFNWRyBpbWFnZXMgaGF2ZSBiZWVuIGFkYXB0ZWQgZnJvbSBnbHlwaHMgaW4gS2FUZVggZm9udHMuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgRGVzaWduIFNjaWVuY2UsIEluYy4gKDx3d3cubWF0aGpheC5vcmc+KVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgS2hhbiBBY2FkZW15ICg8d3d3LmtoYW5hY2FkZW15Lm9yZz4pXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgU0lMIE9wZW4gRm9udCBMaWNlbnNlLCBWZXJzaW9uIDEuMS5cbi8vIFNlZSBcXG5odHRwOi8vc2NyaXB0cy5zaWwub3JnL09GTFxuLy8gVmVyeSBMb25nIFNWR3Ncbi8vICAgIE1hbnkgb2YgdGhlIEthVGVYIHN0cmV0Y2h5IHdpZGUgZWxlbWVudHMgdXNlIGEgbG9uZyBTVkcgaW1hZ2UgYW5kIGFuXG4vLyAgICBvdmVyZmxvdzogaGlkZGVuIHRhY3RpYyB0byBhY2hpZXZlIGEgc3RyZXRjaHkgaW1hZ2Ugd2hpbGUgYXZvaWRpbmdcbi8vICAgIGRpc3RvcnRpb24gb2YgYXJyb3doZWFkcyBvciBicmFjZSBjb3JuZXJzLlxuLy8gICAgVGhlIFNWRyB0eXBpY2FsbHkgY29udGFpbnMgYSB2ZXJ5IGxvbmcgKDQwMCBlbSkgYXJyb3cuXG4vLyAgICBUaGUgU1ZHIGlzIGluIGEgY29udGFpbmVyIHNwYW4gdGhhdCBoYXMgb3ZlcmZsb3c6IGhpZGRlbiwgc28gdGhlIHNwYW5cbi8vICAgIGFjdHMgbGlrZSBhIHdpbmRvdyB0aGF0IGV4cG9zZXMgb25seSBwYXJ0IG9mIHRoZSAgU1ZHLlxuLy8gICAgVGhlIFNWRyBhbHdheXMgaGFzIGEgbG9uZ2VyLCB0aGlubmVyIGFzcGVjdCByYXRpbyB0aGFuIHRoZSBjb250YWluZXIgc3Bhbi5cbi8vICAgIEFmdGVyIHRoZSBTVkcgZmlsbHMgMTAwJSBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgc3Bhbixcbi8vICAgIHRoZXJlIGlzIGEgbG9uZyBhcnJvdyBzaGFmdCBsZWZ0IG92ZXIuIFRoYXQgbGVmdC1vdmVyIHNoYWZ0IGlzIG5vdCBzaG93bi5cbi8vICAgIEluc3RlYWQsIGl0IGlzIHNsaWNlZCBvZmYgYmVjYXVzZSB0aGUgc3BhbidzIENTUyBoYXMgb3ZlcmZsb3c6IGhpZGRlbi5cbi8vICAgIFRodXMsIHRoZSByZWFkZXIgc2VlcyBhbiBhcnJvdyB0aGF0IG1hdGNoZXMgdGhlIHN1YmplY3QgbWF0dGVyIHdpZHRoXG4vLyAgICB3aXRob3V0IGRpc3RvcnRpb24uXG4vLyAgICBTb21lIGZ1bmN0aW9ucywgc3VjaCBhcyBcXGNhbmNlbCwgbmVlZCB0byB2YXJ5IHRoZWlyIGFzcGVjdCByYXRpby4gVGhlc2Vcbi8vICAgIGZ1bmN0aW9ucyBkbyBub3QgZ2V0IHRoZSBvdmVyZmxvdyBTVkcgdHJlYXRtZW50LlxuLy8gU2Vjb25kIEJydXNoIFN0cm9rZVxuLy8gICAgTG93IHJlc29sdXRpb24gbW9uaXRvcnMgc3RydWdnbGUgdG8gZGlzcGxheSBpbWFnZXMgaW4gZmluZSBkZXRhaWwuXG4vLyAgICBTbyBicm93c2VycyBhcHBseSBhbnRpLWFsaWFzaW5nLiBBIGxvbmcgc3RyYWlnaHQgYXJyb3cgc2hhZnQgdGhlcmVmb3JlXG4vLyAgICB3aWxsIHNvbWV0aW1lcyBhcHBlYXIgYXMgaWYgaXQgaGFzIGEgYmx1cnJlZCBlZGdlLlxuLy8gICAgVG8gbWl0aWdhdGUgdGhpcywgdGhlc2UgU1ZHIGZpbGVzIGNvbnRhaW4gYSBzZWNvbmQgXCJicnVzaC1zdHJva2VcIiBvbiB0aGVcbi8vICAgIGFycm93IHNoYWZ0cy4gVGhhdCBpcywgYSBzZWNvbmQgbG9uZyB0aGluIHJlY3Rhbmd1bGFyIFNWRyBwYXRoIGhhcyBiZWVuXG4vLyAgICB3cml0dGVuIGRpcmVjdGx5IG9uIHRvcCBvZiBlYWNoIGFycm93IHNoYWZ0LiBUaGlzIHJlaW5mb3JjZW1lbnQgY2F1c2VzXG4vLyAgICBzb21lIG9mIHRoZSBzY3JlZW4gcGl4ZWxzIHRvIGRpc3BsYXkgYXMgYmxhY2sgaW5zdGVhZCBvZiB0aGUgYW50aS1hbGlhc2VkXG4vLyAgICBncmF5IHBpeGVsIHRoYXQgYSAgc2luZ2xlIHBhdGggd291bGQgZ2VuZXJhdGUuIFNvIHdlIGdldCBhcnJvdyBzaGFmdHNcbi8vICAgIHdob3NlIGVkZ2VzIGFwcGVhciB0byBiZSBzaGFycGVyLlxuLy8gSW4gdGhlIGthdGV4SW1hZ2VzRGF0YSBvYmplY3QganVzdCBiZWxvdywgdGhlIGRpbWVuc2lvbnMgYWxsXG4vLyBjb3JyZXNwb25kIHRvIHBhdGggZ2VvbWV0cnkgaW5zaWRlIHRoZSByZWxldmFudCBTVkcuXG4vLyBGb3IgZXhhbXBsZSwgXFxvdmVycmlnaHRhcnJvdyB1c2VzIHRoZSBzYW1lIGFycm93aGVhZCBhcyBnbHlwaCBVKzIxOTJcbi8vIGZyb20gdGhlIEthVGVYIE1haW4gZm9udC4gVGhlIHNjYWxpbmcgZmFjdG9yIGlzIDEwMDAuXG4vLyBUaGF0IGlzLCBpbnNpZGUgdGhlIGZvbnQsIHRoYXQgYXJyb3doZWFkIGlzIDUyMiB1bml0cyB0YWxsLCB3aGljaFxuLy8gY29ycmVzcG9uZHMgdG8gMC41MjIgZW0gaW5zaWRlIHRoZSBkb2N1bWVudC5cblxuXG52YXIga2F0ZXhJbWFnZXNEYXRhID0ge1xuICAvLyAgIHBhdGgocyksIG1pbldpZHRoLCBoZWlnaHQsIGFsaWduXG4gIG92ZXJyaWdodGFycm93OiBbW1wicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgb3ZlcmxlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgdW5kZXJyaWdodGFycm93OiBbW1wicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgdW5kZXJsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIl0sIDAuODg4LCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIHhyaWdodGFycm93OiBbW1wicmlnaHRhcnJvd1wiXSwgMS40NjksIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgXCJcXFxcY2RyaWdodGFycm93XCI6IFtbXCJyaWdodGFycm93XCJdLCAzLjAsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgLy8gQ0QgbWlud3dpZHRoMi41cGNcbiAgeGxlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiXSwgMS40NjksIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgXCJcXFxcY2RsZWZ0YXJyb3dcIjogW1tcImxlZnRhcnJvd1wiXSwgMy4wLCA1MjIsIFwieE1pbllNaW5cIl0sXG4gIE92ZXJyaWdodGFycm93OiBbW1wiZG91YmxlcmlnaHRhcnJvd1wiXSwgMC44ODgsIDU2MCwgXCJ4TWF4WU1pblwiXSxcbiAgeFJpZ2h0YXJyb3c6IFtbXCJkb3VibGVyaWdodGFycm93XCJdLCAxLjUyNiwgNTYwLCBcInhNYXhZTWluXCJdLFxuICB4TGVmdGFycm93OiBbW1wiZG91YmxlbGVmdGFycm93XCJdLCAxLjUyNiwgNTYwLCBcInhNaW5ZTWluXCJdLFxuICBvdmVybGVmdGhhcnBvb246IFtbXCJsZWZ0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeGxlZnRoYXJwb29udXA6IFtbXCJsZWZ0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeGxlZnRoYXJwb29uZG93bjogW1tcImxlZnRoYXJwb29uZG93blwiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgb3ZlcnJpZ2h0aGFycG9vbjogW1tcInJpZ2h0aGFycG9vblwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeHJpZ2h0aGFycG9vbnVwOiBbW1wicmlnaHRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4cmlnaHRoYXJwb29uZG93bjogW1tcInJpZ2h0aGFycG9vbmRvd25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhsb25nZXF1YWw6IFtbXCJsb25nZXF1YWxcIl0sIDAuODg4LCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIFwiXFxcXGNkbG9uZ2VxdWFsXCI6IFtbXCJsb25nZXF1YWxcIl0sIDMuMCwgMzM0LCBcInhNaW5ZTWluXCJdLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogW1tcInR3b2hlYWRsZWZ0YXJyb3dcIl0sIDAuODg4LCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogW1tcInR3b2hlYWRyaWdodGFycm93XCJdLCAwLjg4OCwgMzM0LCBcInhNYXhZTWluXCJdLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyXSxcbiAgb3ZlcmJyYWNlOiBbW1wibGVmdGJyYWNlXCIsIFwibWlkYnJhY2VcIiwgXCJyaWdodGJyYWNlXCJdLCAxLjYsIDU0OF0sXG4gIHVuZGVyYnJhY2U6IFtbXCJsZWZ0YnJhY2V1bmRlclwiLCBcIm1pZGJyYWNldW5kZXJcIiwgXCJyaWdodGJyYWNldW5kZXJcIl0sIDEuNiwgNTQ4XSxcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjJdLFxuICB4bGVmdHJpZ2h0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93XCJdLCAxLjc1LCA1MjJdLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFtbXCJkb3VibGVsZWZ0YXJyb3dcIiwgXCJkb3VibGVyaWdodGFycm93XCJdLCAxLjc1LCA1NjBdLFxuICB4cmlnaHRsZWZ0aGFycG9vbnM6IFtbXCJsZWZ0aGFycG9vbmRvd25wbHVzXCIsIFwicmlnaHRoYXJwb29ucGx1c1wiXSwgMS43NSwgNzE2XSxcbiAgeGxlZnRyaWdodGhhcnBvb25zOiBbW1wibGVmdGhhcnBvb25wbHVzXCIsIFwicmlnaHRoYXJwb29uZG93bnBsdXNcIl0sIDEuNzUsIDcxNl0sXG4gIHhob29rbGVmdGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRob29rXCJdLCAxLjA4LCA1MjJdLFxuICB4aG9va3JpZ2h0YXJyb3c6IFtbXCJsZWZ0aG9va1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuMDgsIDUyMl0sXG4gIG92ZXJsaW5lc2VnbWVudDogW1tcImxlZnRsaW5lc2VnbWVudFwiLCBcInJpZ2h0bGluZXNlZ21lbnRcIl0sIDAuODg4LCA1MjJdLFxuICB1bmRlcmxpbmVzZWdtZW50OiBbW1wibGVmdGxpbmVzZWdtZW50XCIsIFwicmlnaHRsaW5lc2VnbWVudFwiXSwgMC44ODgsIDUyMl0sXG4gIG92ZXJncm91cDogW1tcImxlZnRncm91cFwiLCBcInJpZ2h0Z3JvdXBcIl0sIDAuODg4LCAzNDJdLFxuICB1bmRlcmdyb3VwOiBbW1wibGVmdGdyb3VwdW5kZXJcIiwgXCJyaWdodGdyb3VwdW5kZXJcIl0sIDAuODg4LCAzNDJdLFxuICB4bWFwc3RvOiBbW1wibGVmdG1hcHN0b1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuNSwgNTIyXSxcbiAgeHRvZnJvbTogW1tcImxlZnRUb0Zyb21cIiwgXCJyaWdodFRvRnJvbVwiXSwgMS43NSwgNTI4XSxcbiAgLy8gVGhlIG5leHQgdGhyZWUgYXJyb3dzIGFyZSBmcm9tIHRoZSBtaGNoZW0gcGFja2FnZS5cbiAgLy8gSW4gbWhjaGVtLnN0eSwgbWluLWxlbmd0aCBpcyAyLjBlbS4gQnV0IHRoZXNlIGFycm93cyBtaWdodCBhcHBlYXIgaW4gdGhlXG4gIC8vIGRvY3VtZW50IGFzIFxceHJpZ2h0YXJyb3cgb3IgXFx4cmlnaHRsZWZ0aGFycG9vbnMuIFRob3NlIGhhdmVcbiAgLy8gbWluLWxlbmd0aCA9IDEuNzVlbSwgc28gd2Ugc2V0IG1pbi1sZW5ndGggb24gdGhlc2UgbmV4dCB0aHJlZSB0byBtYXRjaC5cbiAgeHJpZ2h0bGVmdGFycm93czogW1tcImJhcmFib3ZlbGVmdGFycm93XCIsIFwicmlnaHRhcnJvd2Fib3ZlYmFyXCJdLCAxLjc1LCA5MDFdLFxuICB4cmlnaHRlcXVpbGlicml1bTogW1tcImJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vblwiLCBcInJpZ2h0aGFycG9vbmFib3Zlc2hvcnRiYXJcIl0sIDEuNzUsIDcxNl0sXG4gIHhsZWZ0ZXF1aWxpYnJpdW06IFtbXCJzaG9ydGJhcmFib3ZlbGVmdGhhcnBvb25cIiwgXCJzaG9ydHJpZ2h0aGFycG9vbmFib3ZlYmFyXCJdLCAxLjc1LCA3MTZdXG59O1xuXG52YXIgZ3JvdXBMZW5ndGggPSBmdW5jdGlvbiBncm91cExlbmd0aChhcmcpIHtcbiAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICByZXR1cm4gYXJnLmJvZHkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59O1xuXG52YXIgc3ZnU3BhbiA9IGZ1bmN0aW9uIHN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc3BhbiB3aXRoIGlubGluZSBTVkcgZm9yIHRoZSBlbGVtZW50LlxuICBmdW5jdGlvbiBidWlsZFN2Z1NwYW5fKCkge1xuICAgIHZhciB2aWV3Qm94V2lkdGggPSA0MDAwMDA7IC8vIGRlZmF1bHRcblxuICAgIHZhciBsYWJlbCA9IGdyb3VwLmxhYmVsLnN1YnN0cigxKTtcblxuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJ3aWRlaGF0XCIsIFwid2lkZWNoZWNrXCIsIFwid2lkZXRpbGRlXCIsIFwidXRpbGRlXCJdLCBsYWJlbCkpIHtcbiAgICAgIC8vIEVhY2ggdHlwZSBpbiB0aGUgYGlmYCBzdGF0ZW1lbnQgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRoZSBQYXJzZU5vZGVcbiAgICAgIC8vIHR5cGVzIGJlbG93LiBUaGlzIG5hcnJvd2luZyBpcyByZXF1aXJlZCB0byBhY2Nlc3MgYGdycC5iYXNlYC5cbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHZhciBncnAgPSBncm91cDsgLy8gVGhlcmUgYXJlIGZvdXIgU1ZHIGltYWdlcyBhdmFpbGFibGUgZm9yIGVhY2ggZnVuY3Rpb24uXG4gICAgICAvLyBDaG9vc2UgYSB0YWxsZXIgaW1hZ2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICB2YXIgbnVtQ2hhcnMgPSBncm91cExlbmd0aChncnAuYmFzZSk7XG4gICAgICB2YXIgdmlld0JveEhlaWdodDtcbiAgICAgIHZhciBwYXRoTmFtZTtcblxuICAgICAgdmFyIF9oZWlnaHQ7XG5cbiAgICAgIGlmIChudW1DaGFycyA+IDUpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSBcIndpZGVoYXRcIiB8fCBsYWJlbCA9PT0gXCJ3aWRlY2hlY2tcIikge1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSA0MjA7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gMjM2NDtcbiAgICAgICAgICBfaGVpZ2h0ID0gMC40MjtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgXCI0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDMxMjtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzQwO1xuICAgICAgICAgIF9oZWlnaHQgPSAwLjM0O1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZTRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltZ0luZGV4ID0gWzEsIDEsIDIsIDIsIDMsIDNdW251bUNoYXJzXTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IFwid2lkZWhhdFwiIHx8IGxhYmVsID09PSBcIndpZGVjaGVja1wiKSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDEwNjIsIDIzNjQsIDIzNjQsIDIzNjRdW2ltZ0luZGV4XTtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gWzAsIDIzOSwgMzAwLCAzNjAsIDQyMF1baW1nSW5kZXhdO1xuICAgICAgICAgIF9oZWlnaHQgPSBbMCwgMC4yNCwgMC4zLCAwLjMsIDAuMzYsIDAuNDJdW2ltZ0luZGV4XTtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgaW1nSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDYwMCwgMTAzMywgMjMzOSwgMjM0MF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjYwLCAyODYsIDMwNiwgMzEyXVtpbWdJbmRleF07XG4gICAgICAgICAgX2hlaWdodCA9IFswLCAwLjI2LCAwLjI4NiwgMC4zLCAwLjMwNiwgMC4zNF1baW1nSW5kZXhdO1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZVwiICsgaW1nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aE5vZGUocGF0aE5hbWUpO1xuICAgICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKF9oZWlnaHQpLFxuICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcIm5vbmVcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNwYW5zID0gW107XG4gICAgICB2YXIgZGF0YSA9IGthdGV4SW1hZ2VzRGF0YVtsYWJlbF07XG4gICAgICB2YXIgW3BhdGhzLCBfbWluV2lkdGgsIF92aWV3Qm94SGVpZ2h0XSA9IGRhdGE7XG5cbiAgICAgIHZhciBfaGVpZ2h0MiA9IF92aWV3Qm94SGVpZ2h0IC8gMTAwMDtcblxuICAgICAgdmFyIG51bVN2Z0NoaWxkcmVuID0gcGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIHdpZHRoQ2xhc3NlcztcbiAgICAgIHZhciBhbGlnbnM7XG5cbiAgICAgIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lOiBBbGwgdGhlc2UgY2FzZXMgbXVzdCBiZSBvZiB0aGUgNC10dXBsZSB0eXBlLlxuICAgICAgICB2YXIgYWxpZ24xID0gZGF0YVszXTtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGlkZS10YWlsXCJdO1xuICAgICAgICBhbGlnbnMgPSBbYWxpZ24xXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDIpIHtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGFsZmFycm93LWxlZnRcIiwgXCJoYWxmYXJyb3ctcmlnaHRcIl07XG4gICAgICAgIGFsaWducyA9IFtcInhNaW5ZTWluXCIsIFwieE1heFlNaW5cIl07XG4gICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAzKSB7XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImJyYWNlLWxlZnRcIiwgXCJicmFjZS1jZW50ZXJcIiwgXCJicmFjZS1yaWdodFwiXTtcbiAgICAgICAgYWxpZ25zID0gW1wieE1pbllNaW5cIiwgXCJ4TWlkWU1pblwiLCBcInhNYXhZTWluXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycmVjdCBrYXRleEltYWdlc0RhdGEgb3IgdXBkYXRlIGNvZGUgaGVyZSB0byBzdXBwb3J0XFxuICAgICAgICAgICAgICAgICAgICBcIiArIG51bVN2Z0NoaWxkcmVuICsgXCIgY2hpbGRyZW4uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVN2Z0NoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgdmFyIF9wYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhzW2ldKTtcblxuICAgICAgICB2YXIgX3N2Z05vZGUgPSBuZXcgU3ZnTm9kZShbX3BhdGhdLCB7XG4gICAgICAgICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKF9oZWlnaHQyKSxcbiAgICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIF92aWV3Qm94SGVpZ2h0LFxuICAgICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBhbGlnbnNbaV0gKyBcIiBzbGljZVwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFt3aWR0aENsYXNzZXNbaV1dLCBbX3N2Z05vZGVdLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhbjogX3NwYW4sXG4gICAgICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0MlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKF9oZWlnaHQyKTtcbiAgICAgICAgICBzcGFucy5wdXNoKF9zcGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiXSwgc3BhbnMsIG9wdGlvbnMpLFxuICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IF9oZWlnaHQyXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBidWlsZFN2Z1NwYW5fKClcblxuXG4gIHZhciB7XG4gICAgc3BhbixcbiAgICBtaW5XaWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGJ1aWxkU3ZnU3Bhbl8oKTsgLy8gTm90ZSB0aGF0IHdlIGFyZSByZXR1cm5pbmcgc3Bhbi5kZXB0aCA9IDAuXG4gIC8vIEFueSBhZGp1c3RtZW50cyByZWxhdGl2ZSB0byB0aGUgYmFzZWxpbmUgbXVzdCBiZSBkb25lIGluIGJ1aWxkSFRNTC5cblxuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaGVpZ2h0KTtcblxuICBpZiAobWluV2lkdGggPiAwKSB7XG4gICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IG1ha2VFbShtaW5XaWR0aCk7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBlbmNsb3NlU3BhbiA9IGZ1bmN0aW9uIGVuY2xvc2VTcGFuKGlubmVyLCBsYWJlbCwgdG9wUGFkLCBib3R0b21QYWQsIG9wdGlvbnMpIHtcbiAgLy8gUmV0dXJuIGFuIGltYWdlIHNwYW4gZm9yIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgXFxmYm94LCBvciBcXGFuZ2xcbiAgdmFyIGltZztcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyB0b3BQYWQgKyBib3R0b21QYWQ7XG5cbiAgaWYgKC9mYm94fGNvbG9yfGFuZ2wvLnRlc3QobGFiZWwpKSB7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIiwgbGFiZWxdLCBbXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAobGFiZWwgPT09IFwiZmJveFwiKSB7XG4gICAgICB2YXIgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBvciBcXHhjYW5jZWxcbiAgICAvLyBTaW5jZSBcXGNhbmNlbCdzIFNWRyBpcyBpbmxpbmUgYW5kIGl0IG9taXRzIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSxcbiAgICAvLyBpdHMgc3Ryb2tlLXdpZHRoIHdpbGwgbm90IHZhcnkgd2l0aCBzcGFuIGFyZWEuXG4gICAgdmFyIGxpbmVzID0gW107XG5cbiAgICBpZiAoL15bYnhdY2FuY2VsJC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVOb2RlKHtcbiAgICAgICAgXCJ4MVwiOiBcIjBcIixcbiAgICAgICAgXCJ5MVwiOiBcIjBcIixcbiAgICAgICAgXCJ4MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ5MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwLjA0NmVtXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoL154P2NhbmNlbCQvLnRlc3QobGFiZWwpKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lTm9kZSh7XG4gICAgICAgIFwieDFcIjogXCIwXCIsXG4gICAgICAgIFwieTFcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieDJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieTJcIjogXCIwXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMC4wNDZlbVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShsaW5lcywge1xuICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbSh0b3RhbEhlaWdodClcbiAgICB9KTtcbiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgfVxuXG4gIGltZy5oZWlnaHQgPSB0b3RhbEhlaWdodDtcbiAgaW1nLnN0eWxlLmhlaWdodCA9IG1ha2VFbSh0b3RhbEhlaWdodCk7XG4gIHJldHVybiBpbWc7XG59O1xuXG52YXIgc3RyZXRjaHkgPSB7XG4gIGVuY2xvc2VTcGFuLFxuICBtYXRoTUxub2RlLFxuICBzdmdTcGFuXG59O1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgbm9kZSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmV0dXJucyBpdCB3aXRoIHN0cmljdGVyXG4gKiB0eXBpbmcuIFRocm93cyBpZiB0aGUgbm9kZSdzIHR5cGUgZG9lcyBub3QgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGVUeXBlKG5vZGUsIHR5cGUpIHtcbiAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUgb2YgdHlwZSBcIiArIHR5cGUgKyBcIiwgYnV0IGdvdCBcIiArIChub2RlID8gXCJub2RlIG9mIHR5cGUgXCIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTtcbiAgfSAvLyAkRmxvd0ZpeE1lLCA+PTAuMTI1XG5cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgdmFyIHR5cGVkTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IFwiICsgKG5vZGUgPyBcIm5vZGUgb2YgdHlwZSBcIiArIG5vZGUudHlwZSA6IFN0cmluZyhub2RlKSkpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSBcImF0b21cIiB8fCBOT05fQVRPTVMuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKSkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJhY2NlbnRcIiwgYnV0XG4vLyBhbHNvIFwic3Vwc3ViXCIgc2luY2UgYW4gYWNjZW50IGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxudmFyIGh0bWxCdWlsZGVyJGEgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgdmFyIGJhc2U7XG4gIHZhciBncm91cDtcbiAgdmFyIHN1cFN1Ykdyb3VwO1xuXG4gIGlmIChncnAgJiYgZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAvLyBzdWJzY3JpcHRzLCB0aGUgc3Vwc3ViIHdpbGwgZGVmZXIgdG8gdXMuIEluIHBhcnRpY3VsYXIsIHdlIHdhbnRcbiAgICAvLyB0byBhdHRhY2ggdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyB0byB0aGUgaW5uZXIgYm9keSAoc29cbiAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgLy8gYWZmZWN0ZWQgYnkgdGhlIGhlaWdodCBvZiB0aGUgYWNjZW50KS4gV2UgYWNjb21wbGlzaCB0aGlzIGJ5XG4gICAgLy8gc3RpY2tpbmcgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBpbnRvIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIsIGFuZFxuICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG4gICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcImFjY2VudFwiKTsgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuXG4gICAgYmFzZSA9IGdyb3VwLmJhc2U7IC8vIFN0aWNrIHRoZSBjaGFyYWN0ZXIgYm94IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiBncm91cFxuXG4gICAgZ3JwLmJhc2UgPSBiYXNlOyAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgIC8vIHJlc3VsdC5cblxuICAgIHN1cFN1Ykdyb3VwID0gYXNzZXJ0U3BhbihidWlsZEdyb3VwJDEoZ3JwLCBvcHRpb25zKSk7IC8vIHJlc2V0IG9yaWdpbmFsIGJhc2VcblxuICAgIGdycC5iYXNlID0gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiYWNjZW50XCIpO1xuICAgIGJhc2UgPSBncm91cC5iYXNlO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShiYXNlLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRG9lcyB0aGUgYWNjZW50IG5lZWQgdG8gc2hpZnQgZm9yIHRoZSBza2V3IG9mIGEgY2hhcmFjdGVyP1xuXG4gIHZhciBtdXN0U2hpZnQgPSBncm91cC5pc1NoaWZ0eSAmJiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlKTsgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgLy8gbnVjbGV1cyBpcyBub3QgYSBzaW5nbGUgY2hhcmFjdGVyLCBsZXQgcyA9IDA7IG90aGVyd2lzZSBzZXQgcyB0byB0aGVcbiAgLy8ga2VybiBhbW91bnQgZm9yIHRoZSBudWNsZXVzIGZvbGxvd2VkIGJ5IHRoZSBcXHNrZXdjaGFyIG9mIGl0cyBmb250LlwiXG4gIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgLy8gYW5kIHRoZSBza2V3Y2hhci5cblxuICB2YXIgc2tldyA9IDA7XG5cbiAgaWYgKG11c3RTaGlmdCkge1xuICAgIC8vIElmIHRoZSBiYXNlIGlzIGEgY2hhcmFjdGVyIGJveCwgdGhlbiB3ZSB3YW50IHRoZSBza2V3IG9mIHRoZVxuICAgIC8vIGlubmVybW9zdCBjaGFyYWN0ZXIuIFRvIGRvIHRoYXQsIHdlIGZpbmQgdGhlIGlubmVybW9zdCBjaGFyYWN0ZXI6XG4gICAgdmFyIGJhc2VDaGFyID0gdXRpbHMuZ2V0QmFzZUVsZW0oYmFzZSk7IC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG5cbiAgICB2YXIgYmFzZUdyb3VwID0gYnVpbGRHcm91cCQxKGJhc2VDaGFyLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cblxuICAgIHNrZXcgPSBhc3NlcnRTeW1ib2xEb21Ob2RlKGJhc2VHcm91cCkuc2tldzsgLy8gTm90ZSB0aGF0IHdlIG5vdyB0aHJvdyBhd2F5IGJhc2VHcm91cCwgYmVjYXVzZSB0aGUgbGF5ZXJzIHdlXG4gICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgIC8vIHdlIGNhbid0IGdldCByaWQgb2YuXG4gICAgLy8gVE9ETyhlbWlseSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGdldCB0aGUgc2tld1xuICB9XG5cbiAgdmFyIGFjY2VudEJlbG93ID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXGNcIjsgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuXG4gIHZhciBjbGVhcmFuY2UgPSBhY2NlbnRCZWxvdyA/IGJvZHkuaGVpZ2h0ICsgYm9keS5kZXB0aCA6IE1hdGgubWluKGJvZHkuaGVpZ2h0LCBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodCk7IC8vIEJ1aWxkIHRoZSBhY2NlbnRcblxuICB2YXIgYWNjZW50Qm9keTtcblxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICB2YXIgYWNjZW50O1xuICAgIHZhciB3aWR0aDtcblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdmVjXCIpIHtcbiAgICAgIC8vIEJlZm9yZSB2ZXJzaW9uIDAuOSwgXFx2ZWMgdXNlZCB0aGUgY29tYmluaW5nIGZvbnQgZ2x5cGggVSsyMEQ3LlxuICAgICAgLy8gQnV0IGJyb3dzZXJzLCBlc3BlY2lhbGx5IFNhZmFyaSwgYXJlIG5vdCBjb25zaXN0ZW50IGluIGhvdyB0aGV5XG4gICAgICAvLyByZW5kZXIgY29tYmluaW5nIGNoYXJhY3RlcnMgd2hlbiBub3QgcHJlY2VkZWQgYnkgYSBjaGFyYWN0ZXIuXG4gICAgICAvLyBTbyBub3cgd2UgdXNlIGFuIFNWRy5cbiAgICAgIC8vIElmIFNhZmFyaSByZWZvcm1zLCB3ZSBzaG91bGQgY29uc2lkZXIgcmV2ZXJ0aW5nIHRvIHRoZSBnbHlwaC5cbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhcInZlY1wiLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoID0gYnVpbGRDb21tb24uc3ZnRGF0YS52ZWNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoe1xuICAgICAgICBtb2RlOiBncm91cC5tb2RlLFxuICAgICAgICB0ZXh0OiBncm91cC5sYWJlbFxuICAgICAgfSwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYWNjZW50ID0gYXNzZXJ0U3ltYm9sRG9tTm9kZShhY2NlbnQpOyAvLyBSZW1vdmUgdGhlIGl0YWxpYyBjb3JyZWN0aW9uIG9mIHRoZSBhY2NlbnQsIGJlY2F1c2UgaXQgb25seSBzZXJ2ZXMgdG9cbiAgICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG5cbiAgICAgIGFjY2VudC5pdGFsaWMgPSAwO1xuICAgICAgd2lkdGggPSBhY2NlbnQud2lkdGg7XG5cbiAgICAgIGlmIChhY2NlbnRCZWxvdykge1xuICAgICAgICBjbGVhcmFuY2UgKz0gYWNjZW50LmRlcHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhY2NlbnQtYm9keVwiXSwgW2FjY2VudF0pOyAvLyBcIkZ1bGxcIiBhY2NlbnRzIGV4cGFuZCB0aGUgd2lkdGggb2YgdGhlIHJlc3VsdGluZyBzeW1ib2wgdG8gYmVcbiAgICAvLyBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIGFjY2VudCwgYW5kIG92ZXJsYXAgZGlyZWN0bHkgb250byB0aGVcbiAgICAvLyBjaGFyYWN0ZXIgd2l0aG91dCBhbnkgdmVydGljYWwgb2Zmc2V0LlxuXG4gICAgdmFyIGFjY2VudEZ1bGwgPSBncm91cC5sYWJlbCA9PT0gXCJcXFxcdGV4dGNpcmNsZWRcIjtcblxuICAgIGlmIChhY2NlbnRGdWxsKSB7XG4gICAgICBhY2NlbnRCb2R5LmNsYXNzZXMucHVzaCgnYWNjZW50LWZ1bGwnKTtcbiAgICAgIGNsZWFyYW5jZSA9IGJvZHkuaGVpZ2h0O1xuICAgIH0gLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LlxuXG5cbiAgICB2YXIgbGVmdCA9IHNrZXc7IC8vIENTUyBkZWZpbmVzIGAua2F0ZXggLmFjY2VudCAuYWNjZW50LWJvZHk6bm90KC5hY2NlbnQtZnVsbCkgeyB3aWR0aDogMCB9YFxuICAgIC8vIHNvIHRoYXQgdGhlIGFjY2VudCBkb2Vzbid0IGNvbnRyaWJ1dGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAgICAvLyBXZSBuZWVkIHRvIHNoaWZ0IHRoZSBjaGFyYWN0ZXIgYnkgaXRzIHdpZHRoIChlZmZlY3RpdmVseSBoYWxmXG4gICAgLy8gaXRzIHdpZHRoKSB0byBjb21wZW5zYXRlLlxuXG4gICAgaWYgKCFhY2NlbnRGdWxsKSB7XG4gICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5LnN0eWxlLmxlZnQgPSBtYWtlRW0obGVmdCk7IC8vIFxcdGV4dGNpcmNsZWQgdXNlcyB0aGUgXFxiaWdjaXJjIGdseXBoLCBzbyBpdCBuZWVkcyBzb21lXG4gICAgLy8gdmVydGljYWwgYWRqdXN0bWVudCB0byBtYXRjaCBMYVRlWC5cblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdGV4dGNpcmNsZWRcIikge1xuICAgICAgYWNjZW50Qm9keS5zdHlsZS50b3AgPSBcIi4yZW1cIjtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IC1jbGVhcmFuY2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keSxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXSxcbiAgICAgICAgd3JhcHBlclN0eWxlOiBza2V3ID4gMCA/IHtcbiAgICAgICAgICB3aWR0aDogXCJjYWxjKDEwMCUgLSBcIiArIG1ha2VFbSgyICogc2tldykgKyBcIilcIixcbiAgICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oMiAqIHNrZXcpXG4gICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgYWNjZW50V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnRcIl0sIFthY2NlbnRCb2R5XSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gSGVyZSwgd2UgcmVwbGFjZSB0aGUgXCJiYXNlXCIgY2hpbGQgb2YgdGhlIHN1cHN1YiB3aXRoIG91ciBuZXdseVxuICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgc3VwU3ViR3JvdXAuY2hpbGRyZW5bMF0gPSBhY2NlbnRXcmFwOyAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAvLyBhY2NlbnQsIHdlIG1hbnVhbGx5IHJlY2FsY3VsYXRlIGhlaWdodC5cblxuICAgIHN1cFN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBTdWJHcm91cC5oZWlnaHQpOyAvLyBBY2NlbnRzIHNob3VsZCBhbHdheXMgYmUgb3JkcywgZXZlbiB3aGVuIHRoZWlyIGlubmFyZHMgYXJlIG5vdC5cblxuICAgIHN1cFN1Ykdyb3VwLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICByZXR1cm4gc3VwU3ViR3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFjY2VudFdyYXA7XG4gIH1cbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDkgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5ID8gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCkgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWCA9IG5ldyBSZWdFeHAoW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCJdLm1hcChhY2NlbnQgPT4gXCJcXFxcXCIgKyBhY2NlbnQpLmpvaW4oXCJ8XCIpKTsgLy8gQWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIiwgXCJcXFxcY2hlY2tcIiwgXCJcXFxcaGF0XCIsIFwiXFxcXHZlY1wiLCBcIlxcXFxkb3RcIiwgXCJcXFxcbWF0aHJpbmdcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXG92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0YXJyb3dcIiwgXCJcXFxcT3ZlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsIFwiXFxcXG92ZXJncm91cFwiLCBcIlxcXFxvdmVybGluZXNlZ21lbnRcIiwgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsIFwiXFxcXG92ZXJyaWdodGhhcnBvb25cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIHZhciBiYXNlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgdmFyIGlzU3RyZXRjaHkgPSAhTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWC50ZXN0KGNvbnRleHQuZnVuY05hbWUpO1xuICAgIHZhciBpc1NoaWZ0eSA9ICFpc1N0cmV0Y2h5IHx8IGNvbnRleHQuZnVuY05hbWUgPT09IFwiXFxcXHdpZGVoYXRcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRldGlsZGVcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlY2hlY2tcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGlzU3RyZXRjaHksXG4gICAgICBpc1NoaWZ0eTogaXNTaGlmdHksXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJGEsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7IC8vIFRleHQtbW9kZSBhY2NlbnRzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFwnXCIsIFwiXFxcXGBcIiwgXCJcXFxcXlwiLCBcIlxcXFx+XCIsIFwiXFxcXD1cIiwgXCJcXFxcdVwiLCBcIlxcXFwuXCIsICdcXFxcXCInLCBcIlxcXFxjXCIsIFwiXFxcXHJcIiwgXCJcXFxcSFwiLCBcIlxcXFx2XCIsIFwiXFxcXHRleHRjaXJjbGVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlLFxuICAgIC8vIHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07XG4gICAgdmFyIG1vZGUgPSBjb250ZXh0LnBhcnNlci5tb2RlO1xuXG4gICAgaWYgKG1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0QWNjZW50c1wiLCBcIkxhVGVYJ3MgYWNjZW50IFwiICsgY29udGV4dC5mdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gdGV4dCBtb2RlXCIpO1xuICAgICAgbW9kZSA9IFwidGV4dFwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkYSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsZWZ0YXJyb3dcIiwgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsIFwiXFxcXHVuZGVybGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJncm91cFwiLCBcIlxcXFx1bmRlcmxpbmVzZWdtZW50XCIsIFwiXFxcXHV0aWxkZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJhc2UgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gVHJlYXQgdW5kZXIgYWNjZW50cyBtdWNoIGxpa2UgdW5kZXJsaW5lcy5cbiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBvcHRpb25zKTtcbiAgICB2YXIgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHZhciBrZXJuID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXHV0aWxkZVwiID8gMC4xMiA6IDA7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGlubmVyR3JvdXAuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBrZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiYWNjZW50dW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIEhlbHBlciBmdW5jdGlvblxudmFyIHBhZGRlZE5vZGUgPSBncm91cCA9PiB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGdyb3VwID8gW2dyb3VwXSA6IFtdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIiswLjZlbVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjNlbVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ4QXJyb3dcIixcbiAgbmFtZXM6IFtcIlxcXFx4bGVmdGFycm93XCIsIFwiXFxcXHhyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0YXJyb3dcIiwgXCJcXFxceFJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx4aG9va2xlZnRhcnJvd1wiLCBcIlxcXFx4aG9va3JpZ2h0YXJyb3dcIiwgXCJcXFxceG1hcHN0b1wiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiLCBcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLCBcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIiwgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsIFwiXFxcXHhsb25nZXF1YWxcIiwgXCJcXFxceHR3b2hlYWRyaWdodGFycm93XCIsIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsIFwiXFxcXHh0b2Zyb21cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgdG8gc3VwcG9ydCB0aGUgbWhjaGVtIGV4dGVuc2lvbi5cbiAgLy8gRGlyZWN0IHVzZSBvZiB0aGVzZSBmdW5jdGlvbnMgaXMgZGlzY291cmFnZWQgYW5kIG1heSBicmVhayBzb21lZGF5LlxuICBcIlxcXFx4cmlnaHRsZWZ0YXJyb3dzXCIsIFwiXFxcXHhyaWdodGVxdWlsaWJyaXVtXCIsIFwiXFxcXHhsZWZ0ZXF1aWxpYnJpdW1cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IHRoZSB7Q0R9IGVudmlyb25tZW50LlxuICBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLCBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ4QXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICAvLyBGbG93IGlzIHVuYWJsZSB0byBjb3JyZWN0bHkgaW5mZXIgdGhlIHR5cGUgb2YgYGdyb3VwYCwgZXZlbiB0aG91Z2ggaXQnc1xuICAvLyB1bmFtaWJpZ3VvdXNseSBkZXRlcm1pbmVkIGZyb20gdGhlIHBhc3NlZC1pbiBgdHlwZWAgYWJvdmUuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsgLy8gQnVpbGQgdGhlIGFyZ3VtZW50IGdyb3VwcyBpbiB0aGUgYXBwcm9wcmlhdGUgc3R5bGUuXG4gICAgLy8gUmVmOiBhbXNtYXRoLmR0eDogICBcXGhib3h7JFxcc2NyaXB0c3R5bGVcXG1rZXJuIzNtdXsjNn1cXG1rZXJuIzRtdSR9JVxuICAgIC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gICAgLy8gdGhlbSBpbiBhIHNwYW4uXG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgIHZhciB1cHBlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdmFyIGFycm93UHJlZml4ID0gZ3JvdXAubGFiZWwuc2xpY2UoMCwgMikgPT09IFwiXFxcXHhcIiA/IFwieFwiIDogXCJjZFwiO1xuICAgIHVwcGVyR3JvdXAuY2xhc3Nlcy5wdXNoKGFycm93UHJlZml4ICsgXCItYXJyb3ctcGFkXCIpO1xuICAgIHZhciBsb3dlckdyb3VwO1xuXG4gICAgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICAvLyBCdWlsZCB0aGUgbG93ZXIgZ3JvdXBcbiAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgIGxvd2VyR3JvdXAgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cCQxKGdyb3VwLmJlbG93LCBuZXdPcHRpb25zLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICBsb3dlckdyb3VwLmNsYXNzZXMucHVzaChhcnJvd1ByZWZpeCArIFwiLWFycm93LXBhZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyb3dCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7IC8vIFJlIHNoaWZ0OiBOb3RlIHRoYXQgc3RyZXRjaHkuc3ZnU3BhbiByZXR1cm5lZCBhcnJvd0JvZHkuZGVwdGggPSAwLlxuICAgIC8vIFRoZSBwb2ludCB3ZSB3YW50IG9uIHRoZSBtYXRoIGF4aXMgaXMgYXQgMC41ICogYXJyb3dCb2R5LmhlaWdodC5cblxuICAgIHZhciBhcnJvd1NoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICsgMC41ICogYXJyb3dCb2R5LmhlaWdodDsgLy8gMiBtdSBrZXJuLiBSZWY6IGFtc21hdGguZHR4OiAjN1xcaWYwIzJcXGVsc2VcXG1rZXJuIzJtdVxcZmlcblxuICAgIHZhciB1cHBlclNoaWZ0ID0gLW9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0IC0gMC41ICogYXJyb3dCb2R5LmhlaWdodCAtIDAuMTExOyAvLyAwLjExMSBlbSA9IDIgbXVcblxuICAgIGlmICh1cHBlckdyb3VwLmRlcHRoID4gMC4yNSB8fCBncm91cC5sYWJlbCA9PT0gXCJcXFxceGxlZnRlcXVpbGlicml1bVwiKSB7XG4gICAgICB1cHBlclNoaWZ0IC09IHVwcGVyR3JvdXAuZGVwdGg7IC8vIHNoaWZ0IHVwIGlmIGRlcHRoIGVuY3JvYWNoZXNcbiAgICB9IC8vIEdlbmVyYXRlIHRoZSB2bGlzdFxuXG5cbiAgICB2YXIgdmxpc3Q7XG5cbiAgICBpZiAobG93ZXJHcm91cCkge1xuICAgICAgdmFyIGxvd2VyU2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKyBsb3dlckdyb3VwLmhlaWdodCArIDAuNSAqIGFycm93Qm9keS5oZWlnaHQgKyAwLjExMTtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiB1cHBlclNoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksXG4gICAgICAgICAgc2hpZnQ6IGFycm93U2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGxvd2VyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IGxvd2VyU2hpZnRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdXBwZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogdXBwZXJTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYXJyb3dCb2R5LFxuICAgICAgICAgIHNoaWZ0OiBhcnJvd1NoaWZ0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMV0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtcmVsXCIsIFwieC1hcnJvd1wiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBhcnJvd05vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgICBhcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBncm91cC5sYWJlbC5jaGFyQXQoMCkgPT09IFwieFwiID8gXCIxLjc1ZW1cIiA6IFwiMy4wZW1cIik7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAuYm9keSkge1xuICAgICAgdmFyIHVwcGVyTm9kZSA9IHBhZGRlZE5vZGUoYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSk7XG5cbiAgICAgIGlmIChncm91cC5iZWxvdykge1xuICAgICAgICB2YXIgbG93ZXJOb2RlID0gcGFkZGVkTm9kZShidWlsZEdyb3VwKGdyb3VwLmJlbG93LCBvcHRpb25zKSk7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlcm92ZXJcIiwgW2Fycm93Tm9kZSwgbG93ZXJOb2RlLCB1cHBlck5vZGVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFthcnJvd05vZGUsIHVwcGVyTm9kZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAuYmVsb3cpIHtcbiAgICAgIHZhciBfbG93ZXJOb2RlID0gcGFkZGVkTm9kZShidWlsZEdyb3VwKGdyb3VwLmJlbG93LCBvcHRpb25zKSk7XG5cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYXJyb3dOb2RlLCBfbG93ZXJOb2RlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIC8vIFBhcnNlci5qcyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnQuXG4gICAgICBub2RlID0gcGFkZGVkTm9kZSgpO1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgbm9kZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG52YXIgY2RBcnJvd0Z1bmN0aW9uTmFtZSA9IHtcbiAgXCI+XCI6IFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIixcbiAgXCI8XCI6IFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLFxuICBcIj1cIjogXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCIsXG4gIFwiQVwiOiBcIlxcXFx1cGFycm93XCIsXG4gIFwiVlwiOiBcIlxcXFxkb3duYXJyb3dcIixcbiAgXCJ8XCI6IFwiXFxcXFZlcnRcIixcbiAgXCIuXCI6IFwibm8gYXJyb3dcIlxufTtcblxudmFyIG5ld0NlbGwgPSAoKSA9PiB7XG4gIC8vIENyZWF0ZSBhbiBlbXB0eSBjZWxsLCB0byBiZSBmaWxsZWQgYmVsb3cgd2l0aCBwYXJzZSBub2Rlcy5cbiAgLy8gVGhlIHBhcnNlVHJlZSBmcm9tIHRoaXMgbW9kdWxlIG11c3QgYmUgY29uc3RydWN0ZWQgbGlrZSB0aGVcbiAgLy8gb25lIGNyZWF0ZWQgYnkgcGFyc2VBcnJheSgpLCBzbyBhbiBlbXB0eSBDRCBjZWxsIG11c3RcbiAgLy8gYmUgYSBQYXJzZU5vZGU8XCJzdHlsaW5nXCI+LiBBbmQgQ0QgaXMgYWx3YXlzIGRpc3BsYXlzdHlsZS5cbiAgLy8gU28gdGhlc2UgdmFsdWVzIGFyZSBmaXhlZCBhbmQgZmxvdyBjYW4gZG8gaW1wbGljaXQgdHlwaW5nLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgIGJvZHk6IFtdLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIHN0eWxlOiBcImRpc3BsYXlcIlxuICB9O1xufTtcblxudmFyIGlzU3RhcnRPZkFycm93ID0gbm9kZSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dG9yZFwiICYmIG5vZGUudGV4dCA9PT0gXCJAXCI7XG59O1xuXG52YXIgaXNMYWJlbEVuZCA9IChub2RlLCBlbmRDaGFyKSA9PiB7XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwiYXRvbVwiKSAmJiBub2RlLnRleHQgPT09IGVuZENoYXI7XG59O1xuXG5mdW5jdGlvbiBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGEgcGFyc2UgdHJlZSBvZiBhbiBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgLy8gVGhpcyBhY3RzIGluIGEgd2F5IHNpbWlsYXIgdG8gYSBtYWNybyBleHBhbnNpb24uXG4gIHZhciBmdW5jTmFtZSA9IGNkQXJyb3dGdW5jdGlvbk5hbWVbYXJyb3dDaGFyXTtcblxuICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RyaWdodGFycm93XCI6XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbGFiZWxzWzBdXSwgW2xhYmVsc1sxXV0pO1xuXG4gICAgY2FzZSBcIlxcXFx1cGFycm93XCI6XG4gICAgY2FzZSBcIlxcXFxkb3duYXJyb3dcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIGxlZnRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbGVmdFwiLCBbbGFiZWxzWzBdXSwgW10pO1xuICAgICAgICB2YXIgYmFyZUFycm93ID0ge1xuICAgICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICAgIHRleHQ6IGZ1bmNOYW1lLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGZhbWlseTogXCJyZWxcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2l6ZWRBcnJvdyA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcQmlnXCIsIFtiYXJlQXJyb3ddLCBbXSk7XG4gICAgICAgIHZhciByaWdodExhYmVsID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RyaWdodFwiLCBbbGFiZWxzWzFdXSwgW10pO1xuICAgICAgICB2YXIgYXJyb3dHcm91cCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgYm9keTogW2xlZnRMYWJlbCwgc2l6ZWRBcnJvdywgcmlnaHRMYWJlbF1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcGFyZW50XCIsIFthcnJvd0dyb3VwXSwgW10pO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLCBbXSwgW10pO1xuXG4gICAgY2FzZSBcIlxcXFxWZXJ0XCI6XG4gICAgICB7XG4gICAgICAgIHZhciBhcnJvdyA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICB0ZXh0OiBcIlxcXFxWZXJ0XCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcQmlnXCIsIFthcnJvd10sIFtdKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgdGV4dDogXCIgXCIsXG4gICAgICAgIG1vZGU6IFwibWF0aFwiXG4gICAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0QocGFyc2VyKSB7XG4gIC8vIEdldCB0aGUgYXJyYXkncyBwYXJzZSBub2RlcyB3aXRoIFxcXFwgdGVtcG9yYXJpbHkgbWFwcGVkIHRvIFxcY3IuXG4gIHZhciBwYXJzZWRSb3dzID0gW107XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3JcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIC8vIEdldCB0aGUgcGFyc2Ugbm9kZXMgZm9yIHRoZSBuZXh0IHJvdy5cbiAgICBwYXJzZWRSb3dzLnB1c2gocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJcXFxcXFxcXFwiKSk7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIHZhciBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICAgIGlmIChuZXh0ID09PSBcIiZcIiB8fCBuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgaWYgKHBhcnNlZFJvd3NbcGFyc2VkUm93cy5sZW5ndGggLSAxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkUm93cy5wb3AoKTsgLy8gZmluYWwgcm93IGVuZGVkIGluIFxcXFxcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvdyA9IFtdO1xuICB2YXIgYm9keSA9IFtyb3ddOyAvLyBMb29wIHRocnUgdGhlIHBhcnNlIG5vZGVzLiBDb2xsZWN0IHRoZW0gaW50byBjZWxscyBhbmQgYXJyb3dzLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkUm93cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFN0YXJ0IGEgbmV3IHJvdy5cbiAgICB2YXIgcm93Tm9kZXMgPSBwYXJzZWRSb3dzW2ldOyAvLyBDcmVhdGUgdGhlIGZpcnN0IGNlbGwuXG5cbiAgICB2YXIgY2VsbCA9IG5ld0NlbGwoKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Tm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICghaXNTdGFydE9mQXJyb3cocm93Tm9kZXNbal0pKSB7XG4gICAgICAgIC8vIElmIGEgcGFyc2VOb2RlIGlzIG5vdCBhbiBhcnJvdywgaXQgZ29lcyBpbnRvIGEgY2VsbC5cbiAgICAgICAgY2VsbC5ib2R5LnB1c2gocm93Tm9kZXNbal0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFyc2Ugbm9kZSBqIGlzIGFuIFwiQFwiLCB0aGUgc3RhcnQgb2YgYW4gYXJyb3cuXG4gICAgICAgIC8vIEJlZm9yZSBzdGFydGluZyBvbiB0aGUgYXJyb3csIHB1c2ggdGhlIGNlbGwgaW50byBgcm93YC5cbiAgICAgICAgcm93LnB1c2goY2VsbCk7IC8vIE5vdyBjb2xsZWN0IHBhcnNlTm9kZXMgaW50byBhbiBhcnJvdy5cbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBhZnRlciBcIkBcIiBkZWZpbmVzIHRoZSBhcnJvdyB0eXBlLlxuXG4gICAgICAgIGogKz0gMTtcbiAgICAgICAgdmFyIGFycm93Q2hhciA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKHJvd05vZGVzW2pdKS50ZXh0OyAvLyBDcmVhdGUgdHdvIGVtcHR5IGxhYmVsIG5vZGVzLiBXZSBtYXkgb3IgbWF5IG5vdCB1c2UgdGhlbS5cblxuICAgICAgICB2YXIgbGFiZWxzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBsYWJlbHNbMF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxhYmVsc1sxXSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTsgLy8gUHJvY2VzcyB0aGUgYXJyb3cuXG5cbiAgICAgICAgaWYgKFwiPXwuXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIDsgZWxzZSBpZiAoXCI8PkFWXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIHtcbiAgICAgICAgICAvLyBGb3VyIGFycm93cywgYEA+Pj5gLCBgQDw8PGAsIGBAQUFBYCwgYW5kIGBAVlZWYCwgZWFjaCB0YWtlXG4gICAgICAgICAgLy8gdHdvIG9wdGlvbmFsIGxhYmVscy4gRS5nLiB0aGUgcmlnaHQtcG9pbnQgYXJyb3cgc3ludGF4IGlzXG4gICAgICAgICAgLy8gcmVhbGx5OiAgQD57b3B0aW9uYWwgbGFiZWx9PntvcHRpb25hbCBsYWJlbH0+XG4gICAgICAgICAgLy8gQ29sbGVjdCBwYXJzZU5vZGVzIGludG8gbGFiZWxzLlxuICAgICAgICAgIGZvciAodmFyIGxhYmVsTnVtID0gMDsgbGFiZWxOdW0gPCAyOyBsYWJlbE51bSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5MYWJlbCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IHJvd05vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChpc0xhYmVsRW5kKHJvd05vZGVzW2tdLCBhcnJvd0NoYXIpKSB7XG4gICAgICAgICAgICAgICAgaW5MYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGogPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzU3RhcnRPZkFycm93KHJvd05vZGVzW2tdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsIHJvd05vZGVzW2tdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhYmVsc1tsYWJlbE51bV0uYm9keS5wdXNoKHJvd05vZGVzW2tdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluTGFiZWwpIHtcbiAgICAgICAgICAgICAgLy8gaXNMYWJlbEVuZCBuZXZlciByZXR1cm5lZCBhIHRydWUuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsIHJvd05vZGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBvbmUgb2YgXFxcIjw+QVY9fC5cXFwiIGFmdGVyIEBcIiwgcm93Tm9kZXNbal0pO1xuICAgICAgICB9IC8vIE5vdyBqb2luIHRoZSBhcnJvdyB0byBpdHMgbGFiZWxzLlxuXG5cbiAgICAgICAgdmFyIGFycm93ID0gY2RBcnJvdyhhcnJvd0NoYXIsIGxhYmVscywgcGFyc2VyKTsgLy8gV3JhcCB0aGUgYXJyb3cgaW4gIFBhcnNlTm9kZTxcInN0eWxpbmdcIj4uXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBtYXRjaCBwYXJzZUFycmF5KCkgYmVoYXZpb3IuXG5cbiAgICAgICAgdmFyIHdyYXBwZWRBcnJvdyA9IHtcbiAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICBib2R5OiBbYXJyb3ddLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIHN0eWxlOiBcImRpc3BsYXlcIiAvLyBDRCBpcyBhbHdheXMgZGlzcGxheXN0eWxlLlxuXG4gICAgICAgIH07XG4gICAgICAgIHJvdy5wdXNoKHdyYXBwZWRBcnJvdyk7IC8vIEluIENEJ3Mgc3ludGF4LCBjZWxscyBhcmUgaW1wbGljaXQuIFRoYXQgaXMsIGV2ZXJ5dGhpbmcgdGhhdFxuICAgICAgICAvLyBpcyBub3QgYW4gYXJyb3cgZ2V0cyBjb2xsZWN0ZWQgaW50byBhIGNlbGwuIFNvIGNyZWF0ZSBhbiBlbXB0eVxuICAgICAgICAvLyBjZWxsIG5vdy4gSXQgd2lsbCBjb2xsZWN0IHVwY29taW5nIHBhcnNlTm9kZXMuXG5cbiAgICAgICAgY2VsbCA9IG5ld0NlbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgIC8vIEV2ZW4tbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiBjZWxsLCBhcnJvdywgY2VsbCwgYXJyb3csIC4uLiBjZWxsXG4gICAgICAvLyBUaGUgbGFzdCBjZWxsIGlzIG5vdCB5ZXQgcHVzaGVkIGludG8gYHJvd2AsIHNvOlxuICAgICAgcm93LnB1c2goY2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9kZC1udW1iZXJlZCByb3dzIGNvbnNpc3Qgb2Y6IHZlcnQgYXJyb3csIGVtcHR5IGNlbGwsIC4uLiB2ZXJ0IGFycm93XG4gICAgICAvLyBSZW1vdmUgdGhlIGVtcHR5IGNlbGwgdGhhdCB3YXMgcGxhY2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYHJvd2AuXG4gICAgICByb3cuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByb3cgPSBbXTtcbiAgICBib2R5LnB1c2gocm93KTtcbiAgfSAvLyBFbmQgcm93IGdyb3VwXG5cblxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7IC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXFxcXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBkZWZpbmUgY29sdW1uIHNlcGFyYXRpb24uXG5cbiAgdmFyIGNvbHMgPSBuZXcgQXJyYXkoYm9keVswXS5sZW5ndGgpLmZpbGwoe1xuICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICBhbGlnbjogXCJjXCIsXG4gICAgcHJlZ2FwOiAwLjI1LFxuICAgIC8vIENEIHBhY2thZ2Ugc2V0cyBcXGVuc2tpcCBiZXR3ZWVuIGNvbHVtbnMuXG4gICAgcG9zdGdhcDogMC4yNSAvLyBTbyBwcmUgYW5kIHBvc3QgZWFjaCBnZXQgaGFsZiBhbiBcXGVuc2tpcCwgaS5lLiAwLjI1ZW0uXG5cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHksXG4gICAgYXJyYXlzdHJldGNoOiAxLFxuICAgIGFkZEpvdDogdHJ1ZSxcbiAgICByb3dHYXBzOiBbbnVsbF0sXG4gICAgY29scyxcbiAgICBjb2xTZXBhcmF0aW9uVHlwZTogXCJDRFwiLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KGJvZHkubGVuZ3RoICsgMSkuZmlsbChbXSlcbiAgfTtcbn0gLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXG4vLyBUaGV5IGFyZSBoZXJlIG9ubHkgZm9yIGludGVybmFsIHVzZSBieSB0aGUge0NEfSBlbnZpcm9ubWVudCBpbiBwbGFjaW5nIGxhYmVsc1xuLy8gbmV4dCB0byB2ZXJ0aWNhbCBhcnJvd3MuXG4vLyBXZSBkb24ndCBuZWVkIGFueSBzdWNoIGZ1bmN0aW9ucyBmb3IgaG9yaXpvbnRhbCBhcnJvd3MgYmVjYXVzZSB3ZSBjYW4gcmV1c2Vcbi8vIHRoZSBmdW5jdGlvbmFsaXR5IHRoYXQgYWxyZWFkeSBleGlzdHMgZm9yIGV4dGVuc2libGUgYXJyb3dzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZGxlZnRcIiwgXCJcXFxcXFxcXGNkcmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNkbGFiZWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2lkZTogZnVuY05hbWUuc2xpY2UoNCksXG4gICAgICBsYWJlbDogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS5zdXAoKSk7XG4gICAgdmFyIGxhYmVsID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5sYWJlbCwgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIGxhYmVsLmNsYXNzZXMucHVzaChcImNkLWxhYmVsLVwiICsgZ3JvdXAuc2lkZSk7XG4gICAgbGFiZWwuc3R5bGUuYm90dG9tID0gbWFrZUVtKDAuOCAtIGxhYmVsLmRlcHRoKTsgLy8gWmVybyBvdXQgbGFiZWwgaGVpZ2h0ICYgZGVwdGgsIHNvIHZlcnRpY2FsIGFsaWduIG9mIGFycm93IGlzIHNldFxuICAgIC8vIGJ5IHRoZSBhcnJvdyBoZWlnaHQsIG5vdCBieSB0aGUgbGFiZWwuXG5cbiAgICBsYWJlbC5oZWlnaHQgPSAwO1xuICAgIGxhYmVsLmRlcHRoID0gMDtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYnVpbGRHcm91cChncm91cC5sYWJlbCwgb3B0aW9ucyldKTtcbiAgICBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbbGFiZWxdKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBcIik7XG5cbiAgICBpZiAoZ3JvdXAuc2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIi0xd2lkdGhcIik7XG4gICAgfSAvLyBXZSBoYXZlIHRvIGd1ZXNzIGF0IHZlcnRpY2FsIGFsaWdubWVudC4gV2Uga25vdyB0aGUgYXJyb3cgaXMgMS44ZW0gdGFsbCxcbiAgICAvLyBCdXQgd2UgZG9uJ3Qga25vdyB0aGUgaGVpZ2h0IG9yIGRlcHRoIG9mIHRoZSBsYWJlbC5cblxuXG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBcIjAuN2VtXCIpO1xuICAgIGxhYmVsID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW2xhYmVsXSk7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwiZmFsc2VcIik7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICAgIHJldHVybiBsYWJlbDtcbiAgfVxuXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjZGxhYmVscGFyZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGNkcGFyZW50XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZGxhYmVscGFyZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZyYWdtZW50OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFdyYXAgdGhlIHZlcnRpY2FsIGFycm93IGFuZCBpdHMgbGFiZWxzLlxuICAgIC8vIFRoZSBwYXJlbnQgZ2V0cyBwb3NpdGlvbjogcmVsYXRpdmUuIFRoZSBjaGlsZCBnZXRzIHBvc2l0aW9uOiBhYnNvbHV0ZS5cbiAgICAvLyBTbyBDU1MgY2FuIGxvY2F0ZSB0aGUgbGFiZWwgY29ycmVjdGx5LlxuICAgIHZhciBwYXJlbnQgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cCQxKGdyb3VwLmZyYWdtZW50LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgcGFyZW50LmNsYXNzZXMucHVzaChcImNkLXZlcnQtYXJyb3dcIik7XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYnVpbGRHcm91cChncm91cC5mcmFnbWVudCwgb3B0aW9ucyldKTtcbiAgfVxuXG59KTtcblxuLy8gezEyM30gYW5kIGNvbnZlcnRzIGludG8gc3ltYm9sIHdpdGggY29kZSAxMjMuICBJdCBpcyB1c2VkIGJ5IHRoZSAqbWFjcm8qXG4vLyBcXGNoYXIgZGVmaW5lZCBpbiBtYWNyb3MuanMuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGNoYXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBhcmcgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgIHZhciBncm91cCA9IGFyZy5ib2R5O1xuICAgIHZhciBudW1iZXIgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBhc3NlcnROb2RlVHlwZShncm91cFtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgbnVtYmVyICs9IG5vZGUudGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KG51bWJlcik7XG4gICAgdmFyIHRleHQ7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXEBjaGFyIGhhcyBub24tbnVtZXJpYyBhcmd1bWVudCBcIiArIG51bWJlcik7IC8vIElmIHdlIGRyb3AgSUUgc3VwcG9ydCwgdGhlIGZvbGxvd2luZyBjb2RlIGNvdWxkIGJlIHJlcGxhY2VkIHdpdGhcbiAgICAgIC8vIHRleHQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKVxuICAgIH0gZWxzZSBpZiAoY29kZSA8IDAgfHwgY29kZSA+PSAweDEwZmZmZikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcQGNoYXIgd2l0aCBpbnZhbGlkIGNvZGUgcG9pbnQgXCIgKyBudW1iZXIpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICAgIHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW50byBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgICB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHRleHQ6IHRleHRcbiAgICB9O1xuICB9XG5cbn0pO1xuXG52YXIgaHRtbEJ1aWxkZXIkOSA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvciksIGZhbHNlKTsgLy8gXFxjb2xvciBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAvLyBUbyBhY2NvbXBsaXNoIHRoaXMsIHdlIHdyYXAgdGhlIHJlc3VsdHMgaW4gYSBmcmFnbWVudCwgc28gdGhlIGlubmVyXG4gIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gIC8vIGV4YW1wbGUsIGBcXGNvbG9ye3JlZH17MiArfSAzYCBoYXMgdGhlIHNhbWUgc3BhY2luZyBhcyBgMiArIDNgXG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciQ4ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvcikpO1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIGlubmVyKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoY29sb3JcIiwgZ3JvdXAuY29sb3IpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXHRleHRjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwib3JpZ2luYWxcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3IsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDksXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFxjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBicmVha09uVG9rZW5UZXh0XG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7IC8vIFNldCBtYWNybyBcXGN1cnJlbnRAY29sb3IgaW4gY3VycmVudCBuYW1lc3BhY2UgdG8gc3RvcmUgdGhlIGN1cnJlbnRcbiAgICAvLyBjb2xvciwgbWltaWNraW5nIHRoZSBiZWhhdmlvciBvZiBjb2xvci5zdHkuXG4gICAgLy8gVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBqdXN0IHRvIGNvcnJlY3RseSBjb2xvciBhIFxccmlnaHRcbiAgICAvLyB0aGF0IGZvbGxvd3MgYSBcXGNvbG9yIGNvbW1hbmQuXG5cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3VycmVudEBjb2xvclwiLCBjb2xvcik7IC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keSB0aGF0IHNob3VsZCBiZSBjb2xvcmVkLlxuXG4gICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDksXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbi8vIFJvdyBicmVha3Mgd2l0aGluIHRhYnVsYXIgZW52aXJvbm1lbnRzLCBhbmQgbGluZSBicmVha3MgYXQgdG9wIGxldmVsXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjclwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgc2l6ZSA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIG5ld0xpbmUgPSAhcGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlIHx8ICFwYXJzZXIuc2V0dGluZ3MudXNlU3RyaWN0QmVoYXZpb3IoXCJuZXdMaW5lSW5EaXNwbGF5TW9kZVwiLCBcIkluIExhVGVYLCBcXFxcXFxcXCBvciBcXFxcbmV3bGluZSBcIiArIFwiZG9lcyBub3RoaW5nIGluIGRpc3BsYXkgbW9kZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuZXdMaW5lLFxuICAgICAgc2l6ZTogc2l6ZSAmJiBhc3NlcnROb2RlVHlwZShzaXplLCBcInNpemVcIikudmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYnVpbGRlcnMgYXJlIGNhbGxlZCBvbmx5IGF0IHRoZSB0b3AgbGV2ZWwsXG4gIC8vIG5vdCB3aXRoaW4gdGFidWxhci9hcnJheSBlbnZpcm9ubWVudHMuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3BhY2VcIl0sIFtdLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBzcGFuLmNsYXNzZXMucHVzaChcIm5ld2xpbmVcIik7XG5cbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luVG9wID0gbWFrZUVtKGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuXG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZWJyZWFrXCIsIFwibmV3bGluZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnNpemUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgb3B0aW9ucykpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxudmFyIGdsb2JhbE1hcCA9IHtcbiAgXCJcXFxcZ2xvYmFsXCI6IFwiXFxcXGdsb2JhbFwiLFxuICBcIlxcXFxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXFxcXFxnbG9iYWxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXGRlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGdkZWZcIjogXCJcXFxcZ2RlZlwiLFxuICBcIlxcXFxlZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxceGRlZlwiOiBcIlxcXFx4ZGVmXCIsXG4gIFwiXFxcXGxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIsXG4gIFwiXFxcXGZ1dHVyZWxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCJcbn07XG5cbnZhciBjaGVja0NvbnRyb2xTZXF1ZW5jZSA9IHRvayA9PiB7XG4gIHZhciBuYW1lID0gdG9rLnRleHQ7XG5cbiAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn07XG5cbnZhciBnZXRSSFMgPSBwYXJzZXIgPT4ge1xuICB2YXIgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gIGlmICh0b2sudGV4dCA9PT0gXCI9XCIpIHtcbiAgICAvLyBjb25zdW1lIG9wdGlvbmFsIGVxdWFsc1xuICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICAgIGlmICh0b2sudGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIC8vIGNvbnN1bWUgb25lIG9wdGlvbmFsIHNwYWNlXG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvaztcbn07XG5cbnZhciBsZXRDb21tYW5kID0gKHBhcnNlciwgbmFtZSwgdG9rLCBnbG9iYWwpID0+IHtcbiAgdmFyIG1hY3JvID0gcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KHRvay50ZXh0KTtcblxuICBpZiAobWFjcm8gPT0gbnVsbCkge1xuICAgIC8vIGRvbid0IGV4cGFuZCBpdCBsYXRlciBldmVuIGlmIGEgbWFjcm8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGRlZmluZWRcbiAgICAvLyBlLmcuLCBcXGxldFxcZm9vPVxcZnJhYyBcXGRlZlxcZnJhY3tcXHJlbGF4fSBcXGZyYWMxMlxuICAgIHRvay5ub2V4cGFuZCA9IHRydWU7XG4gICAgbWFjcm8gPSB7XG4gICAgICB0b2tlbnM6IFt0b2tdLFxuICAgICAgbnVtQXJnczogMCxcbiAgICAgIC8vIHJlcHJvZHVjZSB0aGUgc2FtZSBiZWhhdmlvciBpbiBleHBhbnNpb25cbiAgICAgIHVuZXhwYW5kYWJsZTogIXBhcnNlci5ndWxsZXQuaXNFeHBhbmRhYmxlKHRvay50ZXh0KVxuICAgIH07XG4gIH1cblxuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwgbWFjcm8sIGdsb2JhbCk7XG59OyAvLyA8YXNzaWdubWVudD4gLT4gPG5vbi1tYWNybyBhc3NpZ25tZW50Pnw8bWFjcm8gYXNzaWdubWVudD5cbi8vIDxub24tbWFjcm8gYXNzaWdubWVudD4gLT4gPHNpbXBsZSBhc3NpZ25tZW50PnxcXGdsb2JhbDxub24tbWFjcm8gYXNzaWdubWVudD5cbi8vIDxtYWNybyBhc3NpZ25tZW50PiAtPiA8ZGVmaW5pdGlvbj58PHByZWZpeD48bWFjcm8gYXNzaWdubWVudD5cbi8vIDxwcmVmaXg+IC0+IFxcZ2xvYmFsfFxcbG9uZ3xcXG91dGVyXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2xvYmFsXCIsIFwiXFxcXGxvbmdcIiwgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIHZhciB0b2tlbiA9IHBhcnNlci5mZXRjaCgpO1xuXG4gICAgaWYgKGdsb2JhbE1hcFt0b2tlbi50ZXh0XSkge1xuICAgICAgLy8gS2FUZVggZG9lc24ndCBoYXZlIFxccGFyLCBzbyBpZ25vcmUgXFxsb25nXG4gICAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGdsb2JhbFwiIHx8IGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiKSB7XG4gICAgICAgIHRva2VuLnRleHQgPSBnbG9iYWxNYXBbdG9rZW4udGV4dF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImludGVybmFsXCIpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB0b2tlbiBhZnRlciBtYWNybyBwcmVmaXhcIiwgdG9rZW4pO1xuICB9XG5cbn0pOyAvLyBCYXNpYyBzdXBwb3J0IGZvciBtYWNybyBkZWZpbml0aW9uczogXFxkZWYsIFxcZ2RlZiwgXFxlZGVmLCBcXHhkZWZcbi8vIDxkZWZpbml0aW9uPiAtPiA8ZGVmPjxjb250cm9sIHNlcXVlbmNlPjxkZWZpbml0aW9uIHRleHQ+XG4vLyA8ZGVmPiAtPiBcXGRlZnxcXGdkZWZ8XFxlZGVmfFxceGRlZlxuLy8gPGRlZmluaXRpb24gdGV4dD4gLT4gPHBhcmFtZXRlciB0ZXh0PjxsZWZ0IGJyYWNlPjxiYWxhbmNlZCB0ZXh0PjxyaWdodCBicmFjZT5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGVmXCIsIFwiXFxcXGdkZWZcIiwgXCJcXFxcZWRlZlwiLCBcIlxcXFx4ZGVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgdmFyIG5hbWUgPSB0b2sudGV4dDtcblxuICAgIGlmICgvXig/OltcXFxce30kJiNeX118RU9GKSQvLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gICAgfVxuXG4gICAgdmFyIG51bUFyZ3MgPSAwO1xuICAgIHZhciBpbnNlcnQ7XG4gICAgdmFyIGRlbGltaXRlcnMgPSBbW11dOyAvLyA8cGFyYW1ldGVyIHRleHQ+IGNvbnRhaW5zIG5vIGJyYWNlc1xuXG4gICAgd2hpbGUgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCJ7XCIpIHtcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAvLyBJZiB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgPHBhcmFtZXRlciB0ZXh0PiBpcyAjLCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgIyBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB7LCBUZVggd2lsbCBiZWhhdmUgYXMgaWYgdGhlIHtcbiAgICAgICAgLy8gaGFkIGJlZW4gaW5zZXJ0ZWQgYXQgdGhlIHJpZ2h0IGVuZCBvZiBib3RoIHRoZSBwYXJhbWV0ZXIgdGV4dFxuICAgICAgICAvLyBhbmQgdGhlIHJlcGxhY2VtZW50IHRleHQuXG4gICAgICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKTtcbiAgICAgICAgICBkZWxpbWl0ZXJzW251bUFyZ3NdLnB1c2goXCJ7XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIEEgcGFyYW1ldGVyLCB0aGUgZmlyc3QgYXBwZWFyYW5jZSBvZiAjIG11c3QgYmUgZm9sbG93ZWQgYnkgMSxcbiAgICAgICAgLy8gdGhlIG5leHQgYnkgMiwgYW5kIHNvIG9uOyB1cCB0byBuaW5lICPigJlzIGFyZSBhbGxvd2VkXG5cblxuICAgICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG5cbiAgICAgICAgaWYgKCEvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbnVtYmVyIFxcXCJcIiArIHRvay50ZXh0ICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHRvay50ZXh0KSAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkFyZ3VtZW50IG51bWJlciBcXFwiXCIgKyB0b2sudGV4dCArIFwiXFxcIiBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBudW1BcmdzKys7XG4gICAgICAgIGRlbGltaXRlcnMucHVzaChbXSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBtYWNybyBkZWZpbml0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKHRvay50ZXh0KTtcbiAgICAgIH1cbiAgICB9IC8vIHJlcGxhY2VtZW50IHRleHQsIGVuY2xvc2VkIGluICd7JyBhbmQgJ30nIGFuZCBwcm9wZXJseSBuZXN0ZWRcblxuXG4gICAgdmFyIHtcbiAgICAgIHRva2Vuc1xuICAgIH0gPSBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVBcmcoKTtcblxuICAgIGlmIChpbnNlcnQpIHtcbiAgICAgIHRva2Vucy51bnNoaWZ0KGluc2VydCk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxlZGVmXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXHhkZWZcIikge1xuICAgICAgdG9rZW5zID0gcGFyc2VyLmd1bGxldC5leHBhbmRUb2tlbnModG9rZW5zKTtcbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIG9yZGVyXG4gICAgfSAvLyBGaW5hbCBhcmcgaXMgdGhlIGV4cGFuc2lvbiBvZiB0aGUgbWFjcm9cblxuXG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KG5hbWUsIHtcbiAgICAgIHRva2VucyxcbiAgICAgIG51bUFyZ3MsXG4gICAgICBkZWxpbWl0ZXJzXG4gICAgfSwgZnVuY05hbWUgPT09IGdsb2JhbE1hcFtmdW5jTmFtZV0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cblxufSk7IC8vIDxzaW1wbGUgYXNzaWdubWVudD4gLT4gPGxldCBhc3NpZ25tZW50PlxuLy8gPGxldCBhc3NpZ25tZW50PiAtPiBcXGZ1dHVyZWxldDxjb250cm9sIHNlcXVlbmNlPjx0b2tlbj48dG9rZW4+XG4vLyAgICAgfCBcXGxldDxjb250cm9sIHNlcXVlbmNlPjxlcXVhbHM+PG9uZSBvcHRpb25hbCBzcGFjZT48dG9rZW4+XG4vLyA8ZXF1YWxzPiAtPiA8b3B0aW9uYWwgc3BhY2VzPnw8b3B0aW9uYWwgc3BhY2VzPj1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcbGV0XCIsIFwiXFxcXFxcXFxnbG9iYWxsZXRcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMztcbiAgICB2YXIgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgcGFyc2VyLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG4gICAgdmFyIHRvayA9IGdldFJIUyhwYXJzZXIpO1xuICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cblxufSk7IC8vIHJlZjogaHR0cHM6Ly93d3cudHVnLm9yZy9UVUdib2F0L3RiMDktMy90YjIyYmVjaHRvbHNoZWltLnBkZlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxmdXR1cmVsZXRcIiwgXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIHZhciBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICB2YXIgbWlkZGxlID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIHZhciB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIik7XG4gICAgcGFyc2VyLmd1bGxldC5wdXNoVG9rZW4odG9rKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbihtaWRkbGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cblxufSk7XG5cbi8qKlxuICogVGhpcyBmaWxlIGRlYWxzIHdpdGggY3JlYXRpbmcgZGVsaW1pdGVycyBvZiB2YXJpb3VzIHNpemVzLiBUaGUgVGVYYm9va1xuICogZGlzY3Vzc2VzIHRoZXNlIHJvdXRpbmVzIG9uIHBhZ2UgNDQxLTQ0MiwgaW4gdGhlIFwiQW5vdGhlciBzdWJyb3V0aW5lIHNldHMgYm94XG4gKiB4IHRvIGEgc3BlY2lmaWVkIHZhcmlhYmxlIGRlbGltaXRlclwiIHBhcmFncmFwaC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgbWFpbiByb3V0aW5lcyBoZXJlLiBgbWFrZVNtYWxsRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRoZVxuICogbm9ybWFsIGZvbnQsIGJ1dCBpbiBlaXRoZXIgdGV4dCwgc2NyaXB0LCBvciBzY3JpcHRzY3JpcHQgc3R5bGUuXG4gKiBgbWFrZUxhcmdlRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluIHRleHRzdHlsZSwgYnV0IGluIG9uZSBvZiB0aGUgU2l6ZTEsXG4gKiBTaXplMiwgU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBgbWFrZVN0YWNrZWREZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgb3V0IG9mXG4gKiBzbWFsbGVyIHBpZWNlcyB0aGF0IGFyZSBzdGFja2VkIG9uIHRvcCBvZiBvbmUgYW5vdGhlci5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHRha2UgYSBwYXJhbWV0ZXIgYGNlbnRlcmAsIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIGRlbGltaXRlclxuICogc2hvdWxkIGJlIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcy5cbiAqXG4gKiBUaGVuLCB0aGVyZSBhcmUgdGhyZWUgZXhwb3NlZCBmdW5jdGlvbnMuIGBzaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBpblxuICogb25lIG9mIHRoZSBnaXZlbiBzaXplcy4gVGhpcyBpcyB1c2VkIGZvciB0aGluZ3MgbGlrZSBgXFxiaWdsYC5cbiAqIGBjdXN0b21TaXplZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciB3aXRoIGEgZ2l2ZW4gdG90YWwgaGVpZ2h0K2RlcHRoLiBJdCBpc1xuICogY2FsbGVkIGluIHBsYWNlcyBsaWtlIGBcXHNxcnRgLiBgbGVmdFJpZ2h0RGVsaW1gIG1ha2VzIGFuIGFwcHJvcHJpYXRlXG4gKiBkZWxpbWl0ZXIgd2hpY2ggc3Vycm91bmRzIGFuIGV4cHJlc3Npb24gb2YgYSBnaXZlbiBoZWlnaHQgYW4gZGVwdGguIEl0IGlzXG4gKiB1c2VkIGluIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGdldE1ldHJpY3MgPSBmdW5jdGlvbiBnZXRNZXRyaWNzKHN5bWJvbCwgZm9udCwgbW9kZSkge1xuICB2YXIgcmVwbGFjZSA9IHN5bWJvbHMubWF0aFtzeW1ib2xdICYmIHN5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2U7XG4gIHZhciBtZXRyaWNzID0gZ2V0Q2hhcmFjdGVyTWV0cmljcyhyZXBsYWNlIHx8IHN5bWJvbCwgZm9udCwgbW9kZSk7XG5cbiAgaWYgKCFtZXRyaWNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc3ltYm9sIFwiICsgc3ltYm9sICsgXCIgYW5kIGZvbnQgc2l6ZSBcIiArIGZvbnQgKyBcIi5cIik7XG4gIH1cblxuICByZXR1cm4gbWV0cmljcztcbn07XG4vKipcbiAqIFB1dHMgYSBkZWxpbWl0ZXIgc3BhbiBpbiBhIGdpdmVuIHN0eWxlLCBhbmQgYWRkcyBhcHByb3ByaWF0ZSBoZWlnaHQsIGRlcHRoLFxuICogYW5kIG1heEZvbnRTaXplcy5cbiAqL1xuXG5cbnZhciBzdHlsZVdyYXAgPSBmdW5jdGlvbiBzdHlsZVdyYXAoZGVsaW0sIHRvU3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZSh0b1N0eWxlKTtcbiAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbZGVsaW1dLCBvcHRpb25zKTtcbiAgdmFyIGRlbGltU2l6ZU11bHRpcGxpZXIgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5oZWlnaHQgKj0gZGVsaW1TaXplTXVsdGlwbGllcjtcbiAgc3Bhbi5kZXB0aCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyO1xuICBzcGFuLm1heEZvbnRTaXplID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgcmV0dXJuIHNwYW47XG59O1xuXG52YXIgY2VudGVyU3BhbiA9IGZ1bmN0aW9uIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3R5bGUpIHtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzdHlsZSk7XG4gIHZhciBzaGlmdCA9ICgxIC0gb3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIpICogb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG4gIHNwYW4uY2xhc3Nlcy5wdXNoKFwiZGVsaW1jZW50ZXJcIik7XG4gIHNwYW4uc3R5bGUudG9wID0gbWFrZUVtKHNoaWZ0KTtcbiAgc3Bhbi5oZWlnaHQgLT0gc2hpZnQ7XG4gIHNwYW4uZGVwdGggKz0gc2hpZnQ7XG59O1xuLyoqXG4gKiBNYWtlcyBhIHNtYWxsIGRlbGltaXRlci4gVGhpcyBpcyBhIGRlbGltaXRlciB0aGF0IGNvbWVzIGluIHRoZSBNYWluLVJlZ3VsYXJcbiAqIGZvbnQsIGJ1dCBpcyByZXN0eWxlZCB0byBlaXRoZXIgYmUgaW4gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgb3JcbiAqIHNjcmlwdHNjcmlwdHN0eWxlLlxuICovXG5cblxudmFyIG1ha2VTbWFsbERlbGltID0gZnVuY3Rpb24gbWFrZVNtYWxsRGVsaW0oZGVsaW0sIHN0eWxlLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcbiAgdmFyIHNwYW4gPSBzdHlsZVdyYXAodGV4dCwgc3R5bGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjZW50ZXJTcGFuKHNwYW4sIG9wdGlvbnMsIHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogQnVpbGRzIGEgc3ltYm9sIGluIHRoZSBnaXZlbiBmb250IHNpemUgKG5vdGUgc2l6ZSBpcyBhbiBpbnRlZ2VyKVxuICovXG5cblxudmFyIG1hdGhybVNpemUgPSBmdW5jdGlvbiBtYXRocm1TaXplKHZhbHVlLCBzaXplLCBtb2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG5cblxudmFyIG1ha2VMYXJnZURlbGltID0gZnVuY3Rpb24gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICB2YXIgaW5uZXIgPSBtYXRocm1TaXplKGRlbGltLCBzaXplLCBtb2RlLCBvcHRpb25zKTtcbiAgdmFyIHNwYW4gPSBzdHlsZVdyYXAoYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJzaXplXCIgKyBzaXplXSwgW2lubmVyXSwgb3B0aW9ucyksIFN0eWxlJDEuVEVYVCwgb3B0aW9ucywgY2xhc3Nlcyk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgU3R5bGUkMS5URVhUKTtcbiAgfVxuXG4gIHJldHVybiBzcGFuO1xufTtcbi8qKlxuICogTWFrZSBhIHNwYW4gZnJvbSBhIGZvbnQgZ2x5cGggd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC5cbiAqIFRoaXMgaXMgdXNlZCBpbiBtYWtlU3RhY2tlZERlbGltIHRvIG1ha2UgdGhlIHN0YWNraW5nIHBpZWNlcyBmb3IgdGhlIGRlbGltaXRlci5cbiAqL1xuXG5cbnZhciBtYWtlR2x5cGhTcGFuID0gZnVuY3Rpb24gbWFrZUdseXBoU3BhbihzeW1ib2wsIGZvbnQsIG1vZGUpIHtcbiAgdmFyIHNpemVDbGFzczsgLy8gQXBwbHkgdGhlIGNvcnJlY3QgQ1NTIGNsYXNzIHRvIGNob29zZSB0aGUgcmlnaHQgZm9udC5cblxuICBpZiAoZm9udCA9PT0gXCJTaXplMS1SZWd1bGFyXCIpIHtcbiAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikgKi9cbiAgICB7XG4gICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gIHZhciBjb3JuZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ2lubmVyXCIsIHNpemVDbGFzc10sIFtidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkQ29tbW9uLm1ha2VTeW1ib2woc3ltYm9sLCBmb250LCBtb2RlKV0pXSk7IC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gIC8vIGluIHRoZSBhcHByb3ByaWF0ZSB0YWcgdGhhdCBWTGlzdCB1c2VzLlxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbGVtXCIsXG4gICAgZWxlbTogY29ybmVyXG4gIH07XG59O1xuXG52YXIgbWFrZUlubmVyID0gZnVuY3Rpb24gbWFrZUlubmVyKGNoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc3BhbiB3aXRoIGlubGluZSBTVkcgZm9yIHRoZSBpbm5lciBwYXJ0IG9mIGEgdGFsbCBzdGFja2VkIGRlbGltaXRlci5cbiAgdmFyIHdpZHRoID0gZm9udE1ldHJpY3NEYXRhWydTaXplNC1SZWd1bGFyJ11bY2guY2hhckNvZGVBdCgwKV0gPyBmb250TWV0cmljc0RhdGFbJ1NpemU0LVJlZ3VsYXInXVtjaC5jaGFyQ29kZUF0KDApXVs0XSA6IGZvbnRNZXRyaWNzRGF0YVsnU2l6ZTEtUmVndWxhciddW2NoLmNoYXJDb2RlQXQoMCldWzRdO1xuICB2YXIgcGF0aCA9IG5ldyBQYXRoTm9kZShcImlubmVyXCIsIGlubmVyUGF0aChjaCwgTWF0aC5yb3VuZCgxMDAwICogaGVpZ2h0KSkpO1xuICB2YXIgc3ZnTm9kZSA9IG5ldyBTdmdOb2RlKFtwYXRoXSwge1xuICAgIFwid2lkdGhcIjogbWFrZUVtKHdpZHRoKSxcbiAgICBcImhlaWdodFwiOiBtYWtlRW0oaGVpZ2h0KSxcbiAgICAvLyBPdmVycmlkZSBDU1MgcnVsZSBgLmthdGV4IHN2ZyB7IHdpZHRoOiAxMDAlIH1gXG4gICAgXCJzdHlsZVwiOiBcIndpZHRoOlwiICsgbWFrZUVtKHdpZHRoKSxcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyAxMDAwICogd2lkdGggKyBcIiBcIiArIE1hdGgucm91bmQoMTAwMCAqIGhlaWdodCksXG4gICAgXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IFwieE1pbllNaW5cIlxuICB9KTtcbiAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gIHNwYW4uc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgIGVsZW06IHNwYW5cbiAgfTtcbn07IC8vIEhlbHBlcnMgZm9yIG1ha2VTdGFja2VkRGVsaW1cblxuXG52YXIgbGFwSW5FbXMgPSAwLjAwODtcbnZhciBsYXAgPSB7XG4gIHR5cGU6IFwia2VyblwiLFxuICBzaXplOiAtMSAqIGxhcEluRW1zXG59O1xudmFyIHZlcnRzID0gW1wifFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFx2ZXJ0XCJdO1xudmFyIGRvdWJsZVZlcnRzID0gW1wiXFxcXHxcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIiwgXCJcXFxcVmVydFwiXTtcbi8qKlxuICogTWFrZSBhIHN0YWNrZWQgZGVsaW1pdGVyIG91dCBvZiBhIGdpdmVuIGRlbGltaXRlciwgd2l0aCB0aGUgdG90YWwgaGVpZ2h0IGF0XG4gKiBsZWFzdCBgaGVpZ2h0VG90YWxgLiBUaGlzIHJvdXRpbmUgaXMgbWVudGlvbmVkIG9uIHBhZ2UgNDQyIG9mIHRoZSBUZVhib29rLlxuICovXG5cbnZhciBtYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24gbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgaGVpZ2h0VG90YWwsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gIC8vIGJvdHRvbS5cbiAgdmFyIHRvcDtcbiAgdmFyIG1pZGRsZTtcbiAgdmFyIHJlcGVhdDtcbiAgdmFyIGJvdHRvbTtcbiAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gIG1pZGRsZSA9IG51bGw7IC8vIEFsc28ga2VlcCB0cmFjayBvZiB3aGF0IGZvbnQgdGhlIGRlbGltaXRlcnMgYXJlIGluXG5cbiAgdmFyIGZvbnQgPSBcIlNpemUxLVJlZ3VsYXJcIjsgLy8gV2Ugc2V0IHRoZSBwYXJ0cyBhbmQgZm9udCBiYXNlZCBvbiB0aGUgc3ltYm9sLiBOb3RlIHRoYXQgd2UgdXNlXG4gIC8vICdcXHUyM2QwJyBpbnN0ZWFkIG9mICd8JyBhbmQgJ1xcdTIwMTYnIGluc3RlYWQgb2YgJ1xcXFx8JyBmb3IgdGhlXG4gIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuXG4gIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2QwXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjNkMFwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcdXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNkMFwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxVcGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXERvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHZlcnRzLCBkZWxpbSkpIHtcbiAgICByZXBlYXQgPSBcIlxcdTIyMjNcIjtcbiAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhkb3VibGVWZXJ0cywgZGVsaW0pKSB7XG4gICAgcmVwZWF0ID0gXCJcXHUyMjI1XCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiW1wiIHx8IGRlbGltID09PSBcIlxcXFxsYnJhY2tcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhMlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhM1wiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJdXCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFja1wiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2E1XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E2XCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsZmxvb3JcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzBhXCIpIHtcbiAgICByZXBlYXQgPSB0b3AgPSBcIlxcdTIzYTJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxjZWlsXCIgfHwgZGVsaW0gPT09IFwiXFx1MjMwOFwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2EyXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyZmxvb3JcIiB8fCBkZWxpbSA9PT0gXCJcXHUyMzBiXCIpIHtcbiAgICByZXBlYXQgPSB0b3AgPSBcIlxcdTIzYTVcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJjZWlsXCIgfHwgZGVsaW0gPT09IFwiXFx1MjMwOVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2E1XCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHBhcmVuXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzOWNcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzOWRcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiKVwiIHx8IGRlbGltID09PSBcIlxcXFxycGFyZW5cIikge1xuICAgIHRvcCA9IFwiXFx1MjM5ZVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjM5ZlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhMFwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxce1wiIHx8IGRlbGltID09PSBcIlxcXFxsYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhN1wiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcfVwiIHx8IGRlbGltID09PSBcIlxcXFxyYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhY1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlZVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyZ3JvdXBcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2VmXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IwXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTdcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IxXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gLy8gR2V0IHRoZSBtZXRyaWNzIG9mIHRoZSBmb3VyIHNlY3Rpb25zXG5cblxuICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250LCBtb2RlKTtcbiAgdmFyIHRvcEhlaWdodFRvdGFsID0gdG9wTWV0cmljcy5oZWlnaHQgKyB0b3BNZXRyaWNzLmRlcHRoO1xuICB2YXIgcmVwZWF0TWV0cmljcyA9IGdldE1ldHJpY3MocmVwZWF0LCBmb250LCBtb2RlKTtcbiAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICB2YXIgYm90dG9tTWV0cmljcyA9IGdldE1ldHJpY3MoYm90dG9tLCBmb250LCBtb2RlKTtcbiAgdmFyIGJvdHRvbUhlaWdodFRvdGFsID0gYm90dG9tTWV0cmljcy5oZWlnaHQgKyBib3R0b21NZXRyaWNzLmRlcHRoO1xuICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICB2YXIgbWlkZGxlRmFjdG9yID0gMTtcblxuICBpZiAobWlkZGxlICE9PSBudWxsKSB7XG4gICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCwgbW9kZSk7XG4gICAgbWlkZGxlSGVpZ2h0VG90YWwgPSBtaWRkbGVNZXRyaWNzLmhlaWdodCArIG1pZGRsZU1ldHJpY3MuZGVwdGg7XG4gICAgbWlkZGxlRmFjdG9yID0gMjsgLy8gcmVwZWF0IHN5bW1ldHJpY2FsbHkgYWJvdmUgYW5kIGJlbG93IG1pZGRsZVxuICB9IC8vIENhbGN1YXRlIHRoZSBtaW5pbWFsIGhlaWdodCB0aGF0IHRoZSBkZWxpbWl0ZXIgY2FuIGhhdmUuXG4gIC8vIEl0IGlzIGF0IGxlYXN0IHRoZSBzaXplIG9mIHRoZSB0b3AsIGJvdHRvbSwgYW5kIG9wdGlvbmFsIG1pZGRsZSBjb21iaW5lZC5cblxuXG4gIHZhciBtaW5IZWlnaHQgPSB0b3BIZWlnaHRUb3RhbCArIGJvdHRvbUhlaWdodFRvdGFsICsgbWlkZGxlSGVpZ2h0VG90YWw7IC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG5cbiAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChoZWlnaHRUb3RhbCAtIG1pbkhlaWdodCkgLyAobWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWwpKSk7IC8vIENvbXB1dGUgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZGVsaW1pdGVyIGluY2x1ZGluZyBhbGwgdGhlIHN5bWJvbHNcblxuICB2YXIgcmVhbEhlaWdodFRvdGFsID0gbWluSGVpZ2h0ICsgcmVwZWF0Q291bnQgKiBtaWRkbGVGYWN0b3IgKiByZXBlYXRIZWlnaHRUb3RhbDsgLy8gVGhlIGNlbnRlciBvZiB0aGUgZGVsaW1pdGVyIGlzIHBsYWNlZCBhdCB0aGUgY2VudGVyIG9mIHRoZSBheGlzLiBOb3RlXG4gIC8vIHRoYXQgaW4gdGhpcyBjb250ZXh0LCBcImNlbnRlclwiIG1lYW5zIHRoYXQgdGhlIGRlbGltaXRlciBzaG91bGQgYmVcbiAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAvLyBjZW50ZXJlZCBhcm91bmQgdGhlIGF4aXMgaW4gdGV4dHN0eWxlLlxuXG4gIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgfSAvLyBDYWxjdWxhdGUgdGhlIGRlcHRoXG5cblxuICB2YXIgZGVwdGggPSByZWFsSGVpZ2h0VG90YWwgLyAyIC0gYXhpc0hlaWdodDsgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuICAvLyBLZWVwIGEgbGlzdCBvZiB0aGUgcGllY2VzIG9mIHRoZSBzdGFja2VkIGRlbGltaXRlclxuXG4gIHZhciBzdGFjayA9IFtdOyAvLyBBZGQgdGhlIGJvdHRvbSBzeW1ib2xcblxuICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4oYm90dG9tLCBmb250LCBtb2RlKSk7XG4gIHN0YWNrLnB1c2gobGFwKTsgLy8gb3ZlcmxhcFxuXG4gIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgbWlkZGxlIHNlY3Rpb24gd2lsbCBiZSBhbiBTVkcuIE1ha2UgaXQgYW4gZXh0cmEgMC4wMTZlbSB0YWxsLlxuICAgIC8vIFdlJ2xsIG92ZXJsYXAgYnkgMC4wMDhlbSBhdCB0b3AgYW5kIGJvdHRvbS5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSByZWFsSGVpZ2h0VG90YWwgLSB0b3BIZWlnaHRUb3RhbCAtIGJvdHRvbUhlaWdodFRvdGFsICsgMiAqIGxhcEluRW1zO1xuICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgaW5uZXJIZWlnaHQsIG9wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgIC8vIHNlY3Rpb25zXG4gICAgdmFyIF9pbm5lckhlaWdodCA9IChyZWFsSGVpZ2h0VG90YWwgLSB0b3BIZWlnaHRUb3RhbCAtIGJvdHRvbUhlaWdodFRvdGFsIC0gbWlkZGxlSGVpZ2h0VG90YWwpIC8gMiArIDIgKiBsYXBJbkVtcztcblxuICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgX2lubmVySGVpZ2h0LCBvcHRpb25zKSk7IC8vIE5vdyBpbnNlcnQgdGhlIG1pZGRsZSBvZiB0aGUgYnJhY2UuXG5cbiAgICBzdGFjay5wdXNoKGxhcCk7XG4gICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKG1pZGRsZSwgZm9udCwgbW9kZSkpO1xuICAgIHN0YWNrLnB1c2gobGFwKTtcbiAgICBzdGFjay5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIF9pbm5lckhlaWdodCwgb3B0aW9ucykpO1xuICB9IC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuXG5cbiAgc3RhY2sucHVzaChsYXApO1xuICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4odG9wLCBmb250LCBtb2RlKSk7IC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoU3R5bGUkMS5URVhUKTtcbiAgdmFyIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgcG9zaXRpb25EYXRhOiBkZXB0aCxcbiAgICBjaGlsZHJlbjogc3RhY2tcbiAgfSwgbmV3T3B0aW9ucyk7XG4gIHJldHVybiBzdHlsZVdyYXAoYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJtdWx0XCJdLCBbaW5uZXJdLCBuZXdPcHRpb25zKSwgU3R5bGUkMS5URVhULCBvcHRpb25zLCBjbGFzc2VzKTtcbn07IC8vIEFsbCBzdXJkcyBoYXZlIDAuMDhlbSBwYWRkaW5nIGFib3ZlIHRoZSB2aW5pY3VsdW0gaW5zaWRlIHRoZSBTVkcuXG4vLyBUaGF0IGtlZXBzIGJyb3dzZXIgc3BhbiBoZWlnaHQgcm91bmRpbmcgZXJyb3IgZnJvbSBwaW5jaGluZyB0aGUgbGluZS5cblxuXG52YXIgdmJQYWQgPSA4MDsgLy8gcGFkZGluZyBhYm92ZSB0aGUgc3VyZCwgbWVhc3VyZWQgaW5zaWRlIHRoZSB2aWV3Qm94LlxuXG52YXIgZW1QYWQgPSAwLjA4OyAvLyBwYWRkaW5nLCBpbiBlbXMsIG1lYXN1cmVkIGluIHRoZSBkb2N1bWVudC5cblxudmFyIHNxcnRTdmcgPSBmdW5jdGlvbiBzcXJ0U3ZnKHNxcnROYW1lLCBoZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluaWN1bHVtLCBvcHRpb25zKSB7XG4gIHZhciBwYXRoID0gc3FydFBhdGgoc3FydE5hbWUsIGV4dHJhVmluaWN1bHVtLCB2aWV3Qm94SGVpZ2h0KTtcbiAgdmFyIHBhdGhOb2RlID0gbmV3IFBhdGhOb2RlKHNxcnROYW1lLCBwYXRoKTtcbiAgdmFyIHN2ZyA9IG5ldyBTdmdOb2RlKFtwYXRoTm9kZV0sIHtcbiAgICAvLyBOb3RlOiAxMDAwOjEgcmF0aW8gb2Ygdmlld0JveCB0byBkb2N1bWVudCBlbSB3aWR0aC5cbiAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICBcImhlaWdodFwiOiBtYWtlRW0oaGVpZ2h0KSxcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgNDAwMDAwIFwiICsgdmlld0JveEhlaWdodCxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pbiBzbGljZVwiXG4gIH0pO1xuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW1wiaGlkZS10YWlsXCJdLCBbc3ZnXSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBNYWtlIGEgc3FydCBpbWFnZSBvZiB0aGUgZ2l2ZW4gaGVpZ2h0LFxuICovXG5cblxudmFyIG1ha2VTcXJ0SW1hZ2UgPSBmdW5jdGlvbiBtYWtlU3FydEltYWdlKGhlaWdodCwgb3B0aW9ucykge1xuICAvLyBEZWZpbmUgYSBuZXdPcHRpb25zIHRoYXQgcmVtb3ZlcyB0aGUgZWZmZWN0IG9mIHNpemUgY2hhbmdlcyBzdWNoIGFzIFxcSHVnZS5cbiAgLy8gV2UgZG9uJ3QgcGljayBkaWZmZXJlbnQgYSBoZWlnaHQgc3VyZCBmb3IgXFxIdWdlLiBGb3IgaXQsIHdlIHNjYWxlIHVwLlxuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVNpemluZygpOyAvLyBQaWNrIHRoZSBkZXNpcmVkIHN1cmQgZ2x5cGggZnJvbSBhIHNlcXVlbmNlIG9mIHN1cmRzLlxuXG4gIHZhciBkZWxpbSA9IHRyYXZlcnNlU2VxdWVuY2UoXCJcXFxcc3VyZFwiLCBoZWlnaHQgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyLCBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2UsIG5ld09wdGlvbnMpO1xuICB2YXIgc2l6ZU11bHRpcGxpZXIgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBkZWZhdWx0XG4gIC8vIFRoZSBzdGFuZGFyZCBzcXJ0IFNWR3MgZWFjaCBoYXZlIGEgMC4wNGVtIHRoaWNrIHZpbmljdWx1bS5cbiAgLy8gSWYgU2V0dGluZ3MubWluUnVsZVRoaWNrbmVzcyBpcyBsYXJnZXIgdGhhbiB0aGF0LCB3ZSBhZGQgZXh0cmFWaW5pY3VsdW0uXG5cbiAgdmFyIGV4dHJhVmluaWN1bHVtID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC0gb3B0aW9ucy5mb250TWV0cmljcygpLnNxcnRSdWxlVGhpY2tuZXNzKTsgLy8gQ3JlYXRlIGEgc3BhbiBjb250YWluaW5nIGFuIFNWRyBpbWFnZSBvZiBhIHNxcnQgc3ltYm9sLlxuXG4gIHZhciBzcGFuO1xuICB2YXIgc3BhbkhlaWdodCA9IDA7XG4gIHZhciB0ZXhIZWlnaHQgPSAwO1xuICB2YXIgdmlld0JveEhlaWdodCA9IDA7XG4gIHZhciBhZHZhbmNlV2lkdGg7IC8vIFdlIGNyZWF0ZSB2aWV3Qm94ZXMgd2l0aCA4MCB1bml0cyBvZiBcInBhZGRpbmdcIiBhYm92ZSBlYWNoIHN1cmQuXG4gIC8vIFRoZW4gYnJvd3NlciByb3VuZGluZyBlcnJvciBvbiB0aGUgcGFyZW50IHNwYW4gaGVpZ2h0IHdpbGwgbm90XG4gIC8vIGVuY3JvYWNoIG9uIHRoZSBpbmsgb2YgdGhlIHZpbmljdWx1bS4gQnV0IHRoYXQgcGFkZGluZyBpcyBub3RcbiAgLy8gaW5jbHVkZWQgaW4gdGhlIFRlWC1saWtlIGBoZWlnaHRgIHVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mXG4gIC8vIHZlcnRpY2FsIGFsaWdubWVudC4gU28gdGV4SGVpZ2h0ID0gc3Bhbi5oZWlnaHQgPCBzcGFuLnN0eWxlLmhlaWdodC5cblxuICBpZiAoZGVsaW0udHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgLy8gR2V0IGFuIFNWRyB0aGF0IGlzIGRlcml2ZWQgZnJvbSBnbHlwaCBVKzIyMUEgaW4gZm9udCBLYVRlWC1NYWluLlxuICAgIC8vIDEwMDAgdW5pdCBub3JtYWwgZ2x5cGggaGVpZ2h0LlxuICAgIHZpZXdCb3hIZWlnaHQgPSAxMDAwICsgMTAwMCAqIGV4dHJhVmluaWN1bHVtICsgdmJQYWQ7XG5cbiAgICBpZiAoaGVpZ2h0IDwgMS4wKSB7XG4gICAgICBzaXplTXVsdGlwbGllciA9IDEuMDsgLy8gbWltaWMgYSBcXHRleHRmb250IHJhZGljYWxcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDEuNCkge1xuICAgICAgc2l6ZU11bHRpcGxpZXIgPSAwLjc7IC8vIG1pbWljIGEgXFxzY3JpcHRmb250IHJhZGljYWxcbiAgICB9XG5cbiAgICBzcGFuSGVpZ2h0ID0gKDEuMCArIGV4dHJhVmluaWN1bHVtICsgZW1QYWQpIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgdGV4SGVpZ2h0ID0gKDEuMDAgKyBleHRyYVZpbmljdWx1bSkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRNYWluXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluaWN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIwLjg1M2VtXCI7XG4gICAgYWR2YW5jZVdpZHRoID0gMC44MzMgLyBzaXplTXVsdGlwbGllcjsgLy8gZnJvbSB0aGUgZm9udC5cbiAgfSBlbHNlIGlmIChkZWxpbS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICAvLyBUaGVzZSBTVkdzIGNvbWUgZnJvbSBmb250czogS2FUZVhfU2l6ZTEsIF9TaXplMiwgZXRjLlxuICAgIHZpZXdCb3hIZWlnaHQgPSAoMTAwMCArIHZiUGFkKSAqIHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXTtcbiAgICB0ZXhIZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5pY3VsdW0pIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbkhlaWdodCA9IChzaXplVG9NYXhIZWlnaHRbZGVsaW0uc2l6ZV0gKyBleHRyYVZpbmljdWx1bSArIGVtUGFkKSAvIHNpemVNdWx0aXBsaWVyO1xuICAgIHNwYW4gPSBzcXJ0U3ZnKFwic3FydFNpemVcIiArIGRlbGltLnNpemUsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluaWN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIxLjAyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjAgLyBzaXplTXVsdGlwbGllcjsgLy8gMS4wIGZyb20gdGhlIGZvbnQuXG4gIH0gZWxzZSB7XG4gICAgLy8gVGFsbCBzcXJ0LiBJbiBUZVgsIHRoaXMgd291bGQgYmUgc3RhY2tlZCB1c2luZyBtdWx0aXBsZSBnbHlwaHMuXG4gICAgLy8gV2UnbGwgdXNlIGEgc2luZ2xlIFNWRyB0byBhY2NvbXBsaXNoIHRoZSBzYW1lIHRoaW5nLlxuICAgIHNwYW5IZWlnaHQgPSBoZWlnaHQgKyBleHRyYVZpbmljdWx1bSArIGVtUGFkO1xuICAgIHRleEhlaWdodCA9IGhlaWdodCArIGV4dHJhVmluaWN1bHVtO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDEwMDAgKiBoZWlnaHQgKyBleHRyYVZpbmljdWx1bSkgKyB2YlBhZDtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRUYWxsXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluaWN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIwLjc0MmVtXCI7XG4gICAgYWR2YW5jZVdpZHRoID0gMS4wNTY7XG4gIH1cblxuICBzcGFuLmhlaWdodCA9IHRleEhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oc3BhbkhlaWdodCk7XG4gIHJldHVybiB7XG4gICAgc3BhbixcbiAgICBhZHZhbmNlV2lkdGgsXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhY3R1YWwgbGluZSB3aWR0aC5cbiAgICAvLyBUaGlzIGFjdHVhbGx5IHNob3VsZCBkZXBlbmQgb24gdGhlIGNob3NlbiBmb250IC0tIGUuZy4gXFxib2xkbWF0aFxuICAgIC8vIHNob3VsZCB1c2UgdGhlIHRoaWNrZXIgc3VyZCBzeW1ib2xzIGZyb20gZS5nLiBLYVRlWF9NYWluLUJvbGQsIGFuZFxuICAgIC8vIGhhdmUgdGhpY2tlciBydWxlcy5cbiAgICBydWxlV2lkdGg6IChvcHRpb25zLmZvbnRNZXRyaWNzKCkuc3FydFJ1bGVUaGlja25lc3MgKyBleHRyYVZpbmljdWx1bSkgKiBzaXplTXVsdGlwbGllclxuICB9O1xufTsgLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcblxuXG52YXIgc3RhY2tMYXJnZURlbGltaXRlcnMgPSBbXCIoXCIsIFwiXFxcXGxwYXJlblwiLCBcIilcIiwgXCJcXFxccnBhcmVuXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCBcIlxcXFx7XCIsIFwiXFxcXGxicmFjZVwiLCBcIlxcXFx9XCIsIFwiXFxcXHJicmFjZVwiLCBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFx1MjMwYVwiLCBcIlxcdTIzMGJcIiwgXCJcXFxcbGNlaWxcIiwgXCJcXFxccmNlaWxcIiwgXCJcXHUyMzA4XCIsIFwiXFx1MjMwOVwiLCBcIlxcXFxzdXJkXCJdOyAvLyBkZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrXG5cbnZhciBzdGFja0Fsd2F5c0RlbGltaXRlcnMgPSBbXCJcXFxcdXBhcnJvd1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBhcnJvd1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgXCJ8XCIsIFwiXFxcXHxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFxWZXJ0XCIsIFwiXFxcXGx2ZXJ0XCIsIFwiXFxcXHJ2ZXJ0XCIsIFwiXFxcXGxWZXJ0XCIsIFwiXFxcXHJWZXJ0XCIsIFwiXFxcXGxncm91cFwiLCBcIlxcXFxyZ3JvdXBcIiwgXCJcXHUyN2VlXCIsIFwiXFx1MjdlZlwiLCBcIlxcXFxsbW91c3RhY2hlXCIsIFwiXFxcXHJtb3VzdGFjaGVcIiwgXCJcXHUyM2IwXCIsIFwiXFx1MjNiMVwiXTsgLy8gYW5kIGRlbGltaXRlcnMgdGhhdCBuZXZlciBzdGFja1xuXG52YXIgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIl07IC8vIE1ldHJpY3Mgb2YgdGhlIGRpZmZlcmVudCBzaXplcy4gRm91bmQgYnkgbG9va2luZyBhdCBUZVgncyBvdXRwdXQgb2Zcbi8vICRcXGJpZ2x8IC8vIFxcQmlnbHwgXFxiaWdnbHwgXFxCaWdnbHwgXFxzaG93bGlzdHMkXG4vLyBVc2VkIHRvIGNyZWF0ZSBzdGFja2VkIGRlbGltaXRlcnMgb2YgYXBwcm9wcmlhdGUgc2l6ZXMgaW4gbWFrZVNpemVkRGVsaW0uXG5cbnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBkZWxpbWl0ZXIgb2YgYSBzcGVjaWZpYyBzaXplLCB3aGVyZSBgc2l6ZWAgaXMgMSwgMiwgMywgb3IgNC5cbiAqL1xuXG52YXIgbWFrZVNpemVkRGVsaW0gPSBmdW5jdGlvbiBtYWtlU2l6ZWREZWxpbShkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAvLyA8IGFuZCA+IHR1cm4gaW50byBcXGxhbmdsZSBhbmQgXFxyYW5nbGUgaW4gZGVsaW1pdGVyc1xuICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZThcIikge1xuICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZTlcIikge1xuICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gIH0gLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG5cblxuICBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tMYXJnZURlbGltaXRlcnMsIGRlbGltKSB8fCB1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgcmV0dXJuIG1ha2VMYXJnZURlbGltKGRlbGltLCBzaXplLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tBbHdheXNEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICByZXR1cm4gbWFrZVN0YWNrZWREZWxpbShkZWxpbSwgc2l6ZVRvTWF4SGVpZ2h0W3NpemVdLCBmYWxzZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbGxlZ2FsIGRlbGltaXRlcjogJ1wiICsgZGVsaW0gKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIFRoZXJlIGFyZSB0aHJlZSBkaWZmZXJlbnQgc2VxdWVuY2VzIG9mIGRlbGltaXRlciBzaXplcyB0aGF0IHRoZSBkZWxpbWl0ZXJzXG4gKiBmb2xsb3cgZGVwZW5kaW5nIG9uIHRoZSBraW5kIG9mIGRlbGltaXRlci4gVGhpcyBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgY3VzdG9tXG4gKiBzaXplZCBkZWxpbWl0ZXJzIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNyZWF0ZSBhIHNtYWxsLCBsYXJnZSwgb3Igc3RhY2tlZFxuICogZGVsaW1pdGVyLlxuICpcbiAqIEluIHJlYWwgVGVYLCB0aGVzZSBzZXF1ZW5jZXMgYXJlbid0IGV4cGxpY2l0bHkgZGVmaW5lZCwgYnV0IGFyZSBpbnN0ZWFkXG4gKiBkZWZpbmVkIGluc2lkZSB0aGUgZm9udCBtZXRyaWNzLiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZSBzZXF1ZW5jZXMgdGhhdFxuICogYXJlIHBvc3NpYmxlIGZvciB0aGUgZGVsaW1pdGVycyB0aGF0IFRlWCBkZWZpbmVzLCBpdCBpcyBlYXNpZXIgdG8ganVzdCBlbmNvZGVcbiAqIHRoZW0gZXhwbGljaXRseSBoZXJlLlxuICovXG5cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbe1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlRFWFRcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAxXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMlxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDNcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiA0XG59XTsgLy8gRGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFjayB0cnkgdGhlIHNtYWxsIGRlbGltaXRlcnMgZmlyc3QsIHRoZW4gc3RhY2tcblxudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2UgPSBbe1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlRFWFRcbn0sIHtcbiAgdHlwZTogXCJzdGFja1wiXG59XTsgLy8gRGVsaW1pdGVycyB0aGF0IHN0YWNrIHdoZW4gbGFyZ2UgdHJ5IHRoZSBzbWFsbCBhbmQgdGhlbiBsYXJnZSBkZWxpbWl0ZXJzLCBhbmRcbi8vIHN0YWNrIGFmdGVyd2FyZHNcblxudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IFN0eWxlJDEuU0NSSVBUU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IFN0eWxlJDEuU0NSSVBUXG59LCB7XG4gIHR5cGU6IFwic21hbGxcIixcbiAgc3R5bGU6IFN0eWxlJDEuVEVYVFxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDFcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAyXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogM1xufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDRcbn0sIHtcbiAgdHlwZTogXCJzdGFja1wiXG59XTtcbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqIFRPRE8oIzk2MykgVXNlIG1vcmUgc3BlY2lmaWMgZm9udCBmYW1pbHkgcmV0dXJuIHR5cGUgb25jZSB0aGF0IGlzIGludHJvZHVjZWQuXG4gKi9cblxudmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uIGRlbGltVHlwZVRvRm9udCh0eXBlKSB7XG4gIGlmICh0eXBlLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHJldHVybiBcIk1haW4tUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKHR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIFwiU2l6ZVwiICsgdHlwZS5zaXplICsgXCItUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKHR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgcmV0dXJuIFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFkZCBzdXBwb3J0IGZvciBkZWxpbSB0eXBlICdcIiArIHR5cGUudHlwZSArIFwiJyBoZXJlLlwiKTtcbiAgfVxufTtcbi8qKlxuICogVHJhdmVyc2UgYSBzZXF1ZW5jZSBvZiB0eXBlcyBvZiBkZWxpbWl0ZXJzIHRvIGRlY2lkZSB3aGF0IGtpbmQgb2YgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgYSBkZWxpbWl0ZXIgb2YgdGhlIGdpdmVuIGhlaWdodCtkZXB0aC5cbiAqL1xuXG5cbnZhciB0cmF2ZXJzZVNlcXVlbmNlID0gZnVuY3Rpb24gdHJhdmVyc2VTZXF1ZW5jZShkZWxpbSwgaGVpZ2h0LCBzZXF1ZW5jZSwgb3B0aW9ucykge1xuICAvLyBIZXJlLCB3ZSBjaG9vc2UgdGhlIGluZGV4IHdlIHNob3VsZCBzdGFydCBhdCBpbiB0aGUgc2VxdWVuY2VzLiBJbiBzbWFsbGVyXG4gIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgLy8gaW4gdGhlIHNlcXVlbmNlLiBUaHVzLCBzY3JpcHRzY3JpcHQgc3RhcnRzIGF0IGluZGV4IDMtMz0wLCBzY3JpcHQgc3RhcnRzXG4gIC8vIGF0IGluZGV4IDMtMj0xLCB0ZXh0IHN0YXJ0cyBhdCAzLTE9MiwgYW5kIGRpc3BsYXkgc3RhcnRzIGF0IG1pbigyLDMtMCk9MlxuICB2YXIgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIHRoZSBsYXN0IGRlbGltaXRlciwgc28gd2UganVzdCBicmVhayB0aGUgbG9vcCBub3cuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbWV0cmljcyA9IGdldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSksIFwibWF0aFwiKTtcbiAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7IC8vIFNtYWxsIGRlbGltaXRlcnMgYXJlIHNjYWxlZCBkb3duIHZlcnNpb25zIG9mIHRoZSBzYW1lIGZvbnQsIHNvIHdlXG4gICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgaWYgKHNlcXVlbmNlW2ldLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzZXF1ZW5jZVtpXS5zdHlsZSk7XG4gICAgICBoZWlnaHREZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG5cblxuICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCByZXR1cm4gdGhlIGxhc3Qgc2VxdWVuY2UgZWxlbWVudC5cblxuXG4gIHJldHVybiBzZXF1ZW5jZVtzZXF1ZW5jZS5sZW5ndGggLSAxXTtcbn07XG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgb2YgYSBnaXZlbiBoZWlnaHQrZGVwdGgsIHdpdGggb3B0aW9uYWwgY2VudGVyaW5nLiBIZXJlLCB3ZVxuICogdHJhdmVyc2UgdGhlIHNlcXVlbmNlcywgYW5kIGNyZWF0ZSBhIGRlbGltaXRlciB0aGF0IHRoZSBzZXF1ZW5jZSB0ZWxscyB1cyB0by5cbiAqL1xuXG5cbnZhciBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIG1ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZThcIikge1xuICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiIHx8IGRlbGltID09PSBcIlxcdTI3ZTlcIikge1xuICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gIH0gLy8gRGVjaWRlIHdoYXQgc2VxdWVuY2UgdG8gdXNlXG5cblxuICB2YXIgc2VxdWVuY2U7XG5cbiAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICBzZXF1ZW5jZSA9IHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gZWxzZSB7XG4gICAgc2VxdWVuY2UgPSBzdGFja0Fsd2F5c0RlbGltaXRlclNlcXVlbmNlO1xuICB9IC8vIExvb2sgdGhyb3VnaCB0aGUgc2VxdWVuY2VcblxuXG4gIHZhciBkZWxpbVR5cGUgPSB0cmF2ZXJzZVNlcXVlbmNlKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKTsgLy8gR2V0IHRoZSBkZWxpbWl0ZXIgZnJvbSBmb250IGdseXBocy5cbiAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIGZ1bmN0aW9uLlxuXG4gIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIHJldHVybiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gIH0gZWxzZVxuICAgIC8qIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJzdGFja1wiKSAqL1xuICAgIHtcbiAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG4gICAgfVxufTtcbi8qKlxuICogTWFrZSBhIGRlbGltaXRlciBmb3IgdXNlIHdpdGggYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YCwgZ2l2ZW4gYSBoZWlnaHQgYW5kIGRlcHRoXG4gKiBvZiBhbiBleHByZXNzaW9uIHRoYXQgdGhlIGRlbGltaXRlcnMgc3Vycm91bmQuXG4gKi9cblxuXG52YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24gbWFrZUxlZnRSaWdodERlbGltKGRlbGltLCBoZWlnaHQsIGRlcHRoLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIC8vIFdlIGFsd2F5cyBjZW50ZXIgXFxsZWZ0L1xccmlnaHQgZGVsaW1pdGVycywgc28gdGhlIGF4aXMgaXMgYWx3YXlzIHNoaWZ0ZWRcbiAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCAqIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG5cbiAgdmFyIGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgdmFyIGRlbGltaXRlckV4dGVuZCA9IDUuMCAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICB2YXIgbWF4RGlzdEZyb21BeGlzID0gTWF0aC5tYXgoaGVpZ2h0IC0gYXhpc0hlaWdodCwgZGVwdGggKyBheGlzSGVpZ2h0KTtcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLCAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTsgLy8gRmluYWxseSwgd2UgZGVmZXIgdG8gYG1ha2VDdXN0b21TaXplZERlbGltYCB3aXRoIG91ciBjYWxjdWxhdGVkIHRvdGFsXG4gIC8vIGhlaWdodFxuXG4gIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xufTtcblxudmFyIGRlbGltaXRlciA9IHtcbiAgc3FydEltYWdlOiBtYWtlU3FydEltYWdlLFxuICBzaXplZERlbGltOiBtYWtlU2l6ZWREZWxpbSxcbiAgc2l6ZVRvTWF4SGVpZ2h0OiBzaXplVG9NYXhIZWlnaHQsXG4gIGN1c3RvbVNpemVkRGVsaW06IG1ha2VDdXN0b21TaXplZERlbGltLFxuICBsZWZ0UmlnaHREZWxpbTogbWFrZUxlZnRSaWdodERlbGltXG59O1xuXG4vLyBFeHRyYSBkYXRhIG5lZWRlZCBmb3IgdGhlIGRlbGltaXRlciBoYW5kbGVyIGRvd24gYmVsb3dcbnZhciBkZWxpbWl0ZXJTaXplcyA9IHtcbiAgXCJcXFxcYmlnbFwiOiB7XG4gICAgbWNsYXNzOiBcIm1vcGVuXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiA0XG4gIH0sXG4gIFwiXFxcXGJpZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogM1xuICB9LFxuICBcIlxcXFxCaWdnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogNFxuICB9XG59O1xudmFyIGRlbGltaXRlcnMgPSBbXCIoXCIsIFwiXFxcXGxwYXJlblwiLCBcIilcIiwgXCJcXFxccnBhcmVuXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCBcIlxcXFx7XCIsIFwiXFxcXGxicmFjZVwiLCBcIlxcXFx9XCIsIFwiXFxcXHJicmFjZVwiLCBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFx1MjMwYVwiLCBcIlxcdTIzMGJcIiwgXCJcXFxcbGNlaWxcIiwgXCJcXFxccmNlaWxcIiwgXCJcXHUyMzA4XCIsIFwiXFx1MjMwOVwiLCBcIjxcIiwgXCI+XCIsIFwiXFxcXGxhbmdsZVwiLCBcIlxcdTI3ZThcIiwgXCJcXFxccmFuZ2xlXCIsIFwiXFx1MjdlOVwiLCBcIlxcXFxsdFwiLCBcIlxcXFxndFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFx1MjdlZVwiLCBcIlxcdTI3ZWZcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIFwiXFx1MjNiMFwiLCBcIlxcdTIzYjFcIiwgXCIvXCIsIFwiXFxcXGJhY2tzbGFzaFwiLCBcInxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFx8XCIsIFwiXFxcXFZlcnRcIiwgXCJcXFxcdXBhcnJvd1wiLCBcIlxcXFxVcGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgXCIuXCJdO1xuXG4vLyBEZWxpbWl0ZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBjaGVja0RlbGltaXRlcihkZWxpbSwgY29udGV4dCkge1xuICB2YXIgc3ltRGVsaW0gPSBjaGVja1N5bWJvbE5vZGVUeXBlKGRlbGltKTtcblxuICBpZiAoc3ltRGVsaW0gJiYgdXRpbHMuY29udGFpbnMoZGVsaW1pdGVycywgc3ltRGVsaW0udGV4dCkpIHtcbiAgICByZXR1cm4gc3ltRGVsaW07XG4gIH0gZWxzZSBpZiAoc3ltRGVsaW0pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgZGVsaW1pdGVyICdcIiArIHN5bURlbGltLnRleHQgKyBcIicgYWZ0ZXIgJ1wiICsgY29udGV4dC5mdW5jTmFtZSArIFwiJ1wiLCBkZWxpbSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGRlbGltaXRlciB0eXBlICdcIiArIGRlbGltLnR5cGUgKyBcIidcIiwgZGVsaW0pO1xuICB9XG59XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICBuYW1lczogW1wiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLCBcIlxcXFxiaWdyXCIsIFwiXFxcXEJpZ3JcIiwgXCJcXFxcYmlnZ3JcIiwgXCJcXFxcQmlnZ3JcIiwgXCJcXFxcYmlnbVwiLCBcIlxcXFxCaWdtXCIsIFwiXFxcXGJpZ2dtXCIsIFwiXFxcXEJpZ2dtXCIsIFwiXFxcXGJpZ1wiLCBcIlxcXFxCaWdcIiwgXCJcXFxcYmlnZ1wiLCBcIlxcXFxCaWdnXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgc2l6ZTogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0uc2l6ZSxcbiAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKGdyb3VwLmRlbGltID09PSBcIi5cIikge1xuICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBzdGlsbCBjb3VudCBhcyBlbGVtZW50cywgZXZlbiB0aG91Z2ggdGhleSBkb24ndFxuICAgICAgLy8gc2hvdyBhbnl0aGluZy5cbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSk7XG4gICAgfSAvLyBVc2UgZGVsaW1pdGVyLnNpemVkRGVsaW0gdG8gZ2VuZXJhdGUgdGhlIGRlbGltaXRlci5cblxuXG4gICAgcmV0dXJuIGRlbGltaXRlci5zaXplZERlbGltKGdyb3VwLmRlbGltLCBncm91cC5zaXplLCBvcHRpb25zLCBncm91cC5tb2RlLCBbZ3JvdXAubWNsYXNzXSk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IGdyb3VwID0+IHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC5kZWxpbSAhPT0gXCIuXCIpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgY2hpbGRyZW4pO1xuXG4gICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBkZWxpbXNpemluZyBmdW5jdGlvbnMgYWN0IGFzIGZlbmNlcywgYW5kIHRoZXlcbiAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXhwbGljaXRseSBkaXNhYmxlIGZlbmNpbmcgaWYgaXQncyBub3QgYSBmZW5jZSwgdG8gb3ZlcnJpZGUgdGhlXG4gICAgICAvLyBkZWZhdWx0cy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB2YXIgc2l6ZSA9IG1ha2VFbShkZWxpbWl0ZXIuc2l6ZVRvTWF4SGVpZ2h0W2dyb3VwLnNpemVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1pbnNpemVcIiwgc2l6ZSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXhzaXplXCIsIHNpemUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0UGFyc2VkKGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZzogVGhlIGxlZnRyaWdodCBQYXJzZU5vZGUgd2Fzbid0IGZ1bGx5IHBhcnNlZC5cIik7XG4gIH1cbn1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICBuYW1lczogW1wiXFxcXHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgLy8gXFxsZWZ0IGNhc2UgYmVsb3cgdHJpZ2dlcnMgcGFyc2luZyBvZiBcXHJpZ2h0IGluXG4gICAgLy8gICBgY29uc3QgcmlnaHQgPSBwYXJzZXIucGFyc2VGdW5jdGlvbigpO2BcbiAgICAvLyB1c2VzIHRoaXMgcmV0dXJuIHZhbHVlLlxuICAgIHZhciBjb2xvciA9IGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIik7XG5cbiAgICBpZiAoY29sb3IgJiYgdHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxjdXJyZW50QGNvbG9yIHNldCB0byBub24tc3RyaW5nIGluIFxcXFxyaWdodFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHQtcmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBkZWxpbTogY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCkudGV4dCxcbiAgICAgIGNvbG9yIC8vIHVuZGVmaW5lZCBpZiBub3Qgc2V0IHZpYSBcXGNvbG9yXG5cbiAgICB9O1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgbmFtZXM6IFtcIlxcXFxsZWZ0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG4gICAgdmFyIHBhcnNlciA9IGNvbnRleHQucGFyc2VyOyAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcblxuICAgICsrcGFyc2VyLmxlZnRyaWdodERlcHRoOyAvLyBwYXJzZUV4cHJlc3Npb24gc3RvcHMgYmVmb3JlICdcXFxccmlnaHQnXG5cbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgIC0tcGFyc2VyLmxlZnRyaWdodERlcHRoOyAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuXG4gICAgcGFyc2VyLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgdmFyIHJpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJsZWZ0cmlnaHQtcmlnaHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBsZWZ0OiBkZWxpbS50ZXh0LFxuICAgICAgcmlnaHQ6IHJpZ2h0LmRlbGltLFxuICAgICAgcmlnaHRDb2xvcjogcmlnaHQuY29sb3JcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTsgLy8gQnVpbGQgdGhlIGlubmVyIGV4cHJlc3Npb25cblxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUsIFtcIm1vcGVuXCIsIFwibWNsb3NlXCJdKTtcbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7IC8vIENhbGN1bGF0ZSBpdHMgaGVpZ2h0IGFuZCBkZXB0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAoaW5uZXJbaV0uaXNNaWRkbGUpIHtcbiAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgIGlubmVyRGVwdGggPSBNYXRoLm1heChpbm5lcltpXS5kZXB0aCwgaW5uZXJEZXB0aCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgc2l6ZSBvZiBkZWxpbWl0ZXJzIGlzIHRoZSBzYW1lLCByZWdhcmRsZXNzIG9mIHdoYXQgc3R5bGUgd2UgYXJlXG4gICAgLy8gaW4uIFRodXMsIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgdGhlIHNpemUgb2YgZGVsaW1pdGVyIHdlIG5lZWQgYXJvdW5kXG4gICAgLy8gYSBncm91cCwgd2Ugc2NhbGUgZG93biB0aGUgaW5uZXIgc2l6ZSBiYXNlZCBvbiB0aGUgc2l6ZS5cblxuXG4gICAgaW5uZXJIZWlnaHQgKj0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICBpbm5lckRlcHRoICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIGxlZnREZWxpbTtcblxuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBpbiBcXGxlZnQgYW5kIFxccmlnaHQgbWFrZSBudWxsIGRlbGltaXRlciBzcGFjZXMuXG4gICAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAvLyBkZWxpbWl0ZXIuXG4gICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1vcGVuXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG5cblxuICAgIGlubmVyLnVuc2hpZnQobGVmdERlbGltKTsgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG5cbiAgICBpZiAoaGFkTWlkZGxlKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgaW5uZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtaWRkbGVEZWxpbSA9IGlubmVyW19pXTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIFNlZSBjb21tZW50IGluXG4gICAgICAgIC8vIFwibWlkZGxlXCIncyBodG1sQnVpbGRlci5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgIHZhciBpc01pZGRsZSA9IG1pZGRsZURlbGltLmlzTWlkZGxlO1xuXG4gICAgICAgIGlmIChpc01pZGRsZSkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgaW5uZXJbX2ldID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGlzTWlkZGxlLmRlbGltLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07IC8vIFNhbWUgZm9yIHRoZSByaWdodCBkZWxpbWl0ZXIsIGJ1dCB1c2luZyBjb2xvciBzcGVjaWZpZWQgYnkgXFxjb2xvclxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ID09PSBcIi5cIikge1xuICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2xvck9wdGlvbnMgPSBncm91cC5yaWdodENvbG9yID8gb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAucmlnaHRDb2xvcikgOiBvcHRpb25zO1xuICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShncm91cC5yaWdodCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIGNvbG9yT3B0aW9ucywgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgICB9IC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuXG5cbiAgICBpbm5lci5wdXNoKHJpZ2h0RGVsaW0pO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtaW5uZXJcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAubGVmdCAhPT0gXCIuXCIpIHtcbiAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxlZnQsIGdyb3VwLm1vZGUpXSk7XG4gICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICBpbm5lci51bnNoaWZ0KGxlZnROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAucmlnaHQgIT09IFwiLlwiKSB7XG4gICAgICB2YXIgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAucmlnaHQsIGdyb3VwLm1vZGUpXSk7XG4gICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICBpZiAoZ3JvdXAucmlnaHRDb2xvcikge1xuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGNvbG9yXCIsIGdyb3VwLnJpZ2h0Q29sb3IpO1xuICAgICAgfVxuXG4gICAgICBpbm5lci5wdXNoKHJpZ2h0Tm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VSb3coaW5uZXIpO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtaWRkbGVcIixcbiAgbmFtZXM6IFtcIlxcXFxtaWRkbGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICB2YXIgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcblxuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXG1pZGRsZSB3aXRob3V0IHByZWNlZGluZyBcXFxcbGVmdFwiLCBkZWxpbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWlkZGxlXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIG1pZGRsZURlbGltO1xuXG4gICAgaWYgKGdyb3VwLmRlbGltID09PSBcIi5cIikge1xuICAgICAgbWlkZGxlRGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZURlbGltID0gZGVsaW1pdGVyLnNpemVkRGVsaW0oZ3JvdXAuZGVsaW0sIDEsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtdKTtcbiAgICAgIHZhciBpc01pZGRsZSA9IHtcbiAgICAgICAgZGVsaW06IGdyb3VwLmRlbGltLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9OyAvLyBQcm9wZXJ0eSBgaXNNaWRkbGVgIG5vdCBkZWZpbmVkIG9uIGBzcGFuYC4gSXQgaXMgb25seSB1c2VkIGluXG4gICAgICAvLyB0aGlzIGZpbGUgYWJvdmUuXG4gICAgICAvLyBUT0RPOiBGaXggdGhpcyB2aW9sYXRpb24gb2YgdGhlIGBzcGFuYCB0eXBlIGFuZCBwb3NzaWJseSByZW5hbWVcbiAgICAgIC8vIHRoaW5ncyBzaW5jZSBgaXNNaWRkbGVgIHNvdW5kcyBsaWtlIGEgYm9vbGVhbiwgYnV0IGlzIGEgc3RydWN0LlxuICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBtaWRkbGVEZWxpbS5pc01pZGRsZSA9IGlzTWlkZGxlO1xuICAgIH1cblxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gQSBGaXJlZm94IFxcbWlkZGxlIHdpbGwgc3RyZWNoIGEgY2hhcmFjdGVyIHZlcnRpY2FsbHkgb25seSBpZiBpdFxuICAgIC8vIGlzIGluIHRoZSBmZW5jZSBwYXJ0IG9mIHRoZSBvcGVyYXRvciBkaWN0aW9uYXJ5IGF0OlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9NYXRoTUwzL2FwcGVuZGl4Yy5odG1sLlxuICAgIC8vIFNvIHdlIG5lZWQgdG8gYXZvaWQgVSsyMjIzIGFuZCB1c2UgcGxhaW4gXCJ8XCIgaW5zdGVhZC5cbiAgICB2YXIgdGV4dE5vZGUgPSBncm91cC5kZWxpbSA9PT0gXCJcXFxcdmVydFwiIHx8IGdyb3VwLmRlbGltID09PSBcInxcIiA/IG1ha2VUZXh0KFwifFwiLCBcInRleHRcIikgOiBtYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSk7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0Tm9kZV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpOyAvLyBNYXRoTUwgZ2l2ZXMgNS8xOGVtIHNwYWNpbmcgdG8gZWFjaCA8bW8+IGVsZW1lbnQuXG4gICAgLy8gXFxtaWRkbGUgc2hvdWxkIGdldCBkZWxpbWl0ZXIgc3BhY2luZyBpbnN0ZWFkLlxuXG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gIH1cbn0pO1xuXG52YXIgaHRtbEJ1aWxkZXIkOCA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBcXHhjYW5jZWwsIFxcc291dCwgXFxmYm94LCBcXGNvbG9yYm94LCBcXGZjb2xvcmJveCwgXFxwaGFzZVxuICAvLyBTb21lIGdyb3VwcyBjYW4gcmV0dXJuIGRvY3VtZW50IGZyYWdtZW50cy4gIEhhbmRsZSB0aG9zZSBieSB3cmFwcGluZ1xuICAvLyB0aGVtIGluIGEgc3Bhbi5cbiAgdmFyIGlubmVyID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gIHZhciBsYWJlbCA9IGdyb3VwLmxhYmVsLnN1YnN0cigxKTtcbiAgdmFyIHNjYWxlID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgdmFyIGltZztcbiAgdmFyIGltZ1NoaWZ0ID0gMDsgLy8gSW4gdGhlIExhVGVYIGNhbmNlbCBwYWNrYWdlLCBsaW5lIGdlb21ldHJ5IGlzIHNsaWdodGx5IGRpZmZlcmVudFxuICAvLyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc3ViamVjdCBpcyB3aWRlciB0aGFuIGl0IGlzIHRhbGwsIG9yIHZpY2UgdmVyc2EuXG4gIC8vIFdlIGRvbid0IGtub3cgdGhlIHdpZHRoIG9mIGEgZ3JvdXAsIHNvIGFzIGEgcHJveHksIHdlIHRlc3QgaWZcbiAgLy8gdGhlIHN1YmplY3QgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLiBUaGlzIGNhcHR1cmVzIG1vc3Qgb2YgdGhlXG4gIC8vIHN1YmplY3RzIHRoYXQgc2hvdWxkIGdldCB0aGUgXCJ0YWxsXCIgdHJlYXRtZW50LlxuXG4gIHZhciBpc1NpbmdsZUNoYXIgPSB1dGlscy5pc0NoYXJhY3RlckJveChncm91cC5ib2R5KTtcblxuICBpZiAobGFiZWwgPT09IFwic291dFwiKSB7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIiwgXCJzb3V0XCJdKTtcbiAgICBpbWcuaGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC8gc2NhbGU7XG4gICAgaW1nU2hpZnQgPSAtMC41ICogb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gIH0gZWxzZSBpZiAobGFiZWwgPT09IFwicGhhc2VcIikge1xuICAgIC8vIFNldCBhIGNvdXBsZSBvZiBkaW1lbnNpb25zIGZyb20gdGhlIHN0ZWlubWV0eiBwYWNrYWdlLlxuICAgIHZhciBsaW5lV2VpZ2h0ID0gY2FsY3VsYXRlU2l6ZSh7XG4gICAgICBudW1iZXI6IDAuNixcbiAgICAgIHVuaXQ6IFwicHRcIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHZhciBjbGVhcmFuY2UgPSBjYWxjdWxhdGVTaXplKHtcbiAgICAgIG51bWJlcjogMC4zNSxcbiAgICAgIHVuaXQ6IFwiZXhcIlxuICAgIH0sIG9wdGlvbnMpOyAvLyBQcmV2ZW50IHNpemUgY2hhbmdlcyBsaWtlIFxcSHVnZSBmcm9tIGFmZmVjdGluZyBsaW5lIHRoaWNrbmVzc1xuXG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTaXppbmcoKTtcbiAgICBzY2FsZSA9IHNjYWxlIC8gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB2YXIgYW5nbGVIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVXZWlnaHQgKyBjbGVhcmFuY2U7IC8vIFJlc2VydmUgYSBsZWZ0IHBhZCBmb3IgdGhlIGFuZ2xlLlxuXG4gICAgaW5uZXIuc3R5bGUucGFkZGluZ0xlZnQgPSBtYWtlRW0oYW5nbGVIZWlnaHQgLyAyICsgbGluZVdlaWdodCk7IC8vIENyZWF0ZSBhbiBTVkdcblxuICAgIHZhciB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5mbG9vcigxMDAwICogYW5nbGVIZWlnaHQgKiBzY2FsZSk7XG4gICAgdmFyIHBhdGggPSBwaGFzZVBhdGgodmlld0JveEhlaWdodCk7XG4gICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbbmV3IFBhdGhOb2RlKFwicGhhc2VcIiwgcGF0aCldLCB7XG4gICAgICBcIndpZHRoXCI6IFwiNDAwZW1cIixcbiAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbSh2aWV3Qm94SGVpZ2h0IC8gMTAwMCksXG4gICAgICBcInZpZXdCb3hcIjogXCIwIDAgNDAwMDAwIFwiICsgdmlld0JveEhlaWdodCxcbiAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluIHNsaWNlXCJcbiAgICB9KTsgLy8gV3JhcCBpdCBpbiBhIHNwYW4gd2l0aCBvdmVyZmxvdzogaGlkZGVuLlxuXG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVN2Z1NwYW4oW1wiaGlkZS10YWlsXCJdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICAgIGltZy5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oYW5nbGVIZWlnaHQpO1xuICAgIGltZ1NoaWZ0ID0gaW5uZXIuZGVwdGggKyBsaW5lV2VpZ2h0ICsgY2xlYXJhbmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZCBob3Jpem9udGFsIHBhZGRpbmdcbiAgICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGlmICghaXNTaW5nbGVDaGFyKSB7XG4gICAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImNhbmNlbC1wYWRcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIpIHtcbiAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImFuZ2xwYWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlubmVyLmNsYXNzZXMucHVzaChcImJveHBhZFwiKTtcbiAgICB9IC8vIEFkZCB2ZXJ0aWNhbCBwYWRkaW5nXG5cblxuICAgIHZhciB0b3BQYWQgPSAwO1xuICAgIHZhciBib3R0b21QYWQgPSAwO1xuICAgIHZhciBydWxlVGhpY2tuZXNzID0gMDsgLy8gcmVmOiBjYW5jZWwgcGFja2FnZTogXFxhZHZhbmNlXFx0b3RhbGhlaWdodDJcXHBAICUgXCIrMlwiXG5cbiAgICBpZiAoL2JveC8udGVzdChsYWJlbCkpIHtcbiAgICAgIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsIC8vIGRlZmF1bHRcbiAgICAgIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyBVc2VyIG92ZXJyaWRlLlxuICAgICAgKTtcbiAgICAgIHRvcFBhZCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICsgKGxhYmVsID09PSBcImNvbG9yYm94XCIgPyAwIDogcnVsZVRoaWNrbmVzcyk7XG4gICAgICBib3R0b21QYWQgPSB0b3BQYWQ7XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIpIHtcbiAgICAgIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyk7XG4gICAgICB0b3BQYWQgPSA0ICogcnVsZVRoaWNrbmVzczsgLy8gZ2FwID0gMyDDlyBsaW5lLCBwbHVzIHRoZSBsaW5lIGl0c2VsZi5cblxuICAgICAgYm90dG9tUGFkID0gTWF0aC5tYXgoMCwgMC4yNSAtIGlubmVyLmRlcHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wUGFkID0gaXNTaW5nbGVDaGFyID8gMC4yIDogMDtcbiAgICAgIGJvdHRvbVBhZCA9IHRvcFBhZDtcbiAgICB9XG5cbiAgICBpbWcgPSBzdHJldGNoeS5lbmNsb3NlU3Bhbihpbm5lciwgbGFiZWwsIHRvcFBhZCwgYm90dG9tUGFkLCBvcHRpb25zKTtcblxuICAgIGlmICgvZmJveHxib3hlZHxmY29sb3Jib3gvLnRlc3QobGFiZWwpKSB7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyV2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7XG4gICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gXCJhbmdsXCIgJiYgcnVsZVRoaWNrbmVzcyAhPT0gMC4wNDkpIHtcbiAgICAgIGltZy5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICAgIGltZy5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpO1xuICAgIH1cblxuICAgIGltZ1NoaWZ0ID0gaW5uZXIuZGVwdGggKyBib3R0b21QYWQ7XG5cbiAgICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JvdXAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICBpZiAoZ3JvdXAuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgaW1nLnN0eWxlLmJvcmRlckNvbG9yID0gZ3JvdXAuYm9yZGVyQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHZsaXN0O1xuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogWy8vIFB1dCB0aGUgY29sb3IgYmFja2dyb3VuZCBiZWhpbmQgaW5uZXI7XG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWcsXG4gICAgICAgIHNoaWZ0OiBpbWdTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjbGFzc2VzID0gL2NhbmNlbHxwaGFzZS8udGVzdChsYWJlbCkgPyBbXCJzdmctYWxpZ25cIl0gOiBbXTtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogWy8vIFdyaXRlIHRoZSBcXGNhbmNlbCBzdHJva2Ugb24gdG9wIG9mIGlubmVyLlxuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWcsXG4gICAgICAgIHNoaWZ0OiBpbWdTaGlmdCxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IGNsYXNzZXNcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkpIHtcbiAgICAvLyBUaGUgY2FuY2VsIHBhY2thZ2UgZG9jdW1lbnRhdGlvbiBzYXlzIHRoYXQgY2FuY2VsIGxpbmVzIGFkZCB0aGVpciBoZWlnaHRcbiAgICAvLyB0byB0aGUgZXhwcmVzc2lvbiwgYnV0IHRlc3RzIHNob3cgdGhhdCBpc24ndCBob3cgaXQgYWN0dWFsbHkgd29ya3MuXG4gICAgdmxpc3QuaGVpZ2h0ID0gaW5uZXIuaGVpZ2h0O1xuICAgIHZsaXN0LmRlcHRoID0gaW5uZXIuZGVwdGg7XG4gIH1cblxuICBpZiAoL2NhbmNlbC8udGVzdChsYWJlbCkgJiYgIWlzU2luZ2xlQ2hhcikge1xuICAgIC8vIGNhbmNlbCBkb2VzIG5vdCBjcmVhdGUgaG9yaXogc3BhY2UgZm9yIGl0cyBsaW5lIGV4dGVuc2lvbi5cbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcImNhbmNlbC1sYXBcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIG1hdGhtbEJ1aWxkZXIkNyA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgZmJveHNlcCA9IDA7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAubGFiZWwuaW5kZXhPZihcImNvbG9yYm94XCIpID4gLTEgPyBcIm1wYWRkZWRcIiA6IFwibWVuY2xvc2VcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICBzd2l0Y2ggKGdyb3VwLmxhYmVsKSB7XG4gICAgY2FzZSBcIlxcXFxjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ1cGRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGJjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxccGhhc2VcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJwaGFzb3JhbmdsZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxzb3V0XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiaG9yaXpvbnRhbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxmYm94XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGFuZ2xcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJhY3R1YXJpYWxcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcZmNvbG9yYm94XCI6XG4gICAgY2FzZSBcIlxcXFxjb2xvcmJveFwiOlxuICAgICAgLy8gPG1lbmNsb3NlPiBkb2Vzbid0IGhhdmUgYSBnb29kIG5vdGF0aW9uIG9wdGlvbi4gU28gdXNlIDxtcGFkZGVkPlxuICAgICAgLy8gaW5zdGVhZC4gU2V0IHNvbWUgYXR0cmlidXRlcyB0aGF0IGNvbWUgaW5jbHVkZWQgd2l0aCA8bWVuY2xvc2U+LlxuICAgICAgZmJveHNlcCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICogb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiK1wiICsgMiAqIGZib3hzZXAgKyBcInB0XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIrXCIgKyAyICogZmJveHNlcCArIFwicHRcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBmYm94c2VwICsgXCJwdFwiKTsgLy9cblxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGZib3hzZXAgKyBcInB0XCIpO1xuXG4gICAgICBpZiAoZ3JvdXAubGFiZWwgPT09IFwiXFxcXGZjb2xvcmJveFwiKSB7XG4gICAgICAgIHZhciB0aGsgPSBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsIC8vIGRlZmF1bHRcbiAgICAgICAgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzIC8vIHVzZXIgb3ZlcnJpZGVcbiAgICAgICAgKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjogXCIgKyB0aGsgKyBcImVtIHNvbGlkIFwiICsgU3RyaW5nKGdyb3VwLmJvcmRlckNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFx4Y2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZSBkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGdyb3VwLmJhY2tncm91bmRDb2xvcik7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yO1xuICAgIHZhciBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkOCxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJjb2xvclwiLCBcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYyLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciBib3JkZXJDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkOCxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxmYm94XCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2FuY2VsXCIsIFwiXFxcXGJjYW5jZWxcIiwgXCJcXFxceGNhbmNlbFwiLCBcIlxcXFxzb3V0XCIsIFwiXFxcXHBoYXNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0LCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ4LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxhbmdsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY1LCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmNTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxhbmdsXCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBgZW52aXJvbm1lbnRzLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBlbnZpcm9ubWVudHMuanNgLlxuICovXG52YXIgX2Vudmlyb25tZW50cyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQoX3JlZikge1xuICB2YXIge1xuICAgIHR5cGUsXG4gICAgbmFtZXMsXG4gICAgcHJvcHMsXG4gICAgaGFuZGxlcixcbiAgICBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0gPSBfcmVmO1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZW52aXJvbm1lbnRzLlxuICB2YXIgZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MgfHwgMCxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDAsXG4gICAgaGFuZGxlclxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBUT0RPOiBUaGUgdmFsdWUgdHlwZSBvZiBfZW52aXJvbm1lbnRzIHNob3VsZCBiZSBhIHR5cGUgdW5pb24gb2YgYWxsXG4gICAgLy8gcG9zc2libGUgYEVudlNwZWM8PmAgcG9zc2liaWxpdGllcyBpbnN0ZWFkIG9mIGBFbnZTcGVjPCo+YCwgd2hpY2ggaXNcbiAgICAvLyBhbiBleGlzdGVudGlhbCB0eXBlLlxuICAgIF9lbnZpcm9ubWVudHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuXG4gIGlmIChodG1sQnVpbGRlcikge1xuICAgIF9odG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IGh0bWxCdWlsZGVyO1xuICB9XG5cbiAgaWYgKG1hdGhtbEJ1aWxkZXIpIHtcbiAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBnbG9iYWwvYnVpbHQtaW4gbWFjcm9zLlxuICogYG1hY3Jvcy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgbWFjcm9zLmpzYC5cbiAqL1xudmFyIF9tYWNyb3MgPSB7fTsgLy8gVGhpcyBmdW5jdGlvbiBtaWdodCBvbmUgZGF5IGFjY2VwdCBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IGFuZCBkbyBtb3JlIHRoaW5ncy5cblxuZnVuY3Rpb24gZGVmaW5lTWFjcm8obmFtZSwgYm9keSkge1xuICBfbWFjcm9zW25hbWVdID0gYm9keTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0SExpbmVzKHBhcnNlcikge1xuICAvLyBSZXR1cm4gYW4gYXJyYXkuIFRoZSBhcnJheSBsZW5ndGggPSBudW1iZXIgb2YgaGxpbmVzLlxuICAvLyBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHRlbGxzIGlmIHRoZSBsaW5lIGlzIGRhc2hlZC5cbiAgdmFyIGhsaW5lSW5mbyA9IFtdO1xuICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICB2YXIgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICB3aGlsZSAobnh0ID09PSBcIlxcXFxobGluZVwiIHx8IG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIGhsaW5lSW5mby5wdXNoKG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuXG4gIHJldHVybiBobGluZUluZm87XG59XG5cbnZhciB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dCA9IGNvbnRleHQgPT4ge1xuICB2YXIgc2V0dGluZ3MgPSBjb250ZXh0LnBhcnNlci5zZXR0aW5ncztcblxuICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJ7XCIgKyBjb250ZXh0LmVudk5hbWUgKyBcIn0gY2FuIGJlIHVzZWQgb25seSBpblwiICsgXCIgZGlzcGxheSBtb2RlLlwiKTtcbiAgfVxufTsgLy8gYXV0b1RhZyAoYW4gYXJndW1lbnQgdG8gcGFyc2VBcnJheSkgY2FuIGJlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XG4vLyAqIHVuZGVmaW5lZDogUmVndWxhciAobm90LXRvcC1sZXZlbCkgYXJyYXk7IG5vIHRhZ3Mgb24gZWFjaCByb3dcbi8vICogdHJ1ZTogQXV0b21hdGljIGVxdWF0aW9uIG51bWJlcmluZywgb3ZlcnJpZGFibGUgYnkgXFx0YWdcbi8vICogZmFsc2U6IFRhZ3MgYWxsb3dlZCBvbiBlYWNoIHJvdywgYnV0IG5vIGF1dG9tYXRpYyBudW1iZXJpbmdcbi8vIFRoaXMgZnVuY3Rpb24gKmRvZXNuJ3QqIHdvcmsgd2l0aCB0aGUgXCJzcGxpdFwiIGVudmlyb25tZW50IG5hbWUuXG5cblxuZnVuY3Rpb24gZ2V0QXV0b1RhZyhuYW1lKSB7XG4gIGlmIChuYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbmFtZS5pbmRleE9mKFwiKlwiKSA9PT0gLTE7XG4gIH0gLy8gcmV0dXJuIHVuZGVmaW5lZDtcblxufVxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLiAgSWYgZ2l2ZW4gYW4gb3B0aW9uYWwgYXJndW1lbnQgc3R5bGVcbiAqIChcInRleHRcIiwgXCJkaXNwbGF5XCIsIGV0Yy4pLCB0aGVuIGVhY2ggY2VsbCBpcyBjYXN0IGludG8gdGhhdCBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXkocGFyc2VyLCBfcmVmLCBzdHlsZSkge1xuICB2YXIge1xuICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXIsXG4gICAgYWRkSm90LFxuICAgIGNvbHMsXG4gICAgYXJyYXlzdHJldGNoLFxuICAgIGNvbFNlcGFyYXRpb25UeXBlLFxuICAgIGF1dG9UYWcsXG4gICAgc2luZ2xlUm93LFxuICAgIGVtcHR5U2luZ2xlUm93LFxuICAgIG1heE51bUNvbHMsXG4gICAgbGVxbm9cbiAgfSA9IF9yZWY7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gIGlmICghc2luZ2xlUm93KSB7XG4gICAgLy8gXFxjciBpcyBlcXVpdmFsZW50IHRvIFxcXFwgd2l0aG91dCB0aGUgb3B0aW9uYWwgc2l6ZSBhcmd1bWVudCAoc2VlIGJlbG93KVxuICAgIC8vIFRPRE86IHByb3ZpZGUgaGVscGZ1bCBlcnJvciB3aGVuIFxcY3IgaXMgdXNlZCBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIH0gLy8gR2V0IGN1cnJlbnQgYXJyYXlzdHJldGNoIGlmIGl0J3Mgbm90IHNldCBieSB0aGUgZW52aXJvbm1lbnRcblxuXG4gIGlmICghYXJyYXlzdHJldGNoKSB7XG4gICAgdmFyIHN0cmV0Y2ggPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZE1hY3JvQXNUZXh0KFwiXFxcXGFycmF5c3RyZXRjaFwiKTtcblxuICAgIGlmIChzdHJldGNoID09IG51bGwpIHtcbiAgICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAgIGFycmF5c3RyZXRjaCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5c3RyZXRjaCA9IHBhcnNlRmxvYXQoc3RyZXRjaCk7XG5cbiAgICAgIGlmICghYXJyYXlzdHJldGNoIHx8IGFycmF5c3RyZXRjaCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIFxcXFxhcnJheXN0cmV0Y2g6IFwiICsgc3RyZXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFN0YXJ0IGdyb3VwIGZvciBmaXJzdCBjZWxsXG5cblxuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgdmFyIHJvdyA9IFtdO1xuICB2YXIgYm9keSA9IFtyb3ddO1xuICB2YXIgcm93R2FwcyA9IFtdO1xuICB2YXIgaExpbmVzQmVmb3JlUm93ID0gW107XG4gIHZhciB0YWdzID0gYXV0b1RhZyAhPSBudWxsID8gW10gOiB1bmRlZmluZWQ7IC8vIGFtc21hdGggdXNlcyBcXGdsb2JhbFxcQGVxbnN3dHJ1ZSBhbmQgXFxnbG9iYWxcXEBlcW5zd2ZhbHNlIHRvIHJlcHJlc2VudFxuICAvLyB3aGV0aGVyIHRoaXMgcm93IHNob3VsZCBoYXZlIGFuIGVxdWF0aW9uIG51bWJlci4gIFNpbXVsYXRlIHRoaXMgd2l0aFxuICAvLyBhIFxcQGVxbnN3IG1hY3JvIHNldCB0byAxIG9yIDAuXG5cbiAgZnVuY3Rpb24gYmVnaW5Sb3coKSB7XG4gICAgaWYgKGF1dG9UYWcpIHtcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxAZXFuc3dcIiwgXCIxXCIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFJvdygpIHtcbiAgICBpZiAodGFncykge1xuICAgICAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICAgICAgdGFncy5wdXNoKHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pKTtcbiAgICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGRmQHRhZ1wiLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFncy5wdXNoKEJvb2xlYW4oYXV0b1RhZykgJiYgcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXEBlcW5zd1wiKSA9PT0gXCIxXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJlZ2luUm93KCk7IC8vIFRlc3QgZm9yIFxcaGxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgYXJyYXkuXG5cbiAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAvLyBQYXJzZSBlYWNoIGNlbGwgaW4gaXRzIG93biBncm91cCAobmFtZXNwYWNlKVxuICAgIHZhciBjZWxsID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgc2luZ2xlUm93ID8gXCJcXFxcZW5kXCIgOiBcIlxcXFxcXFxcXCIpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICBjZWxsID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBjZWxsXG4gICAgfTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2VsbCA9IHtcbiAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgYm9keTogW2NlbGxdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIHZhciBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcblxuICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgaWYgKG1heE51bUNvbHMgJiYgcm93Lmxlbmd0aCA9PT0gbWF4TnVtQ29scykge1xuICAgICAgICBpZiAoc2luZ2xlUm93IHx8IGNvbFNlcGFyYXRpb25UeXBlKSB7XG4gICAgICAgICAgLy8ge2VxdWF0aW9ufSBvciB7c3BsaXR9XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gbWFueSB0YWIgY2hhcmFjdGVyczogJlwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB7YXJyYXl9IGVudmlyb25tZW50XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInRleHRFbnZcIiwgXCJUb28gZmV3IGNvbHVtbnMgXCIgKyBcInNwZWNpZmllZCBpbiB0aGUge2FycmF5fSBjb2x1bW4gYXJndW1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgZW5kUm93KCk7IC8vIEFycmF5cyB0ZXJtaW5hdGUgbmV3bGluZXMgd2l0aCBgXFxjcmNyYCB3aGljaCBjb25zdW1lcyBhIGBcXGNyYCBpZlxuICAgICAgLy8gdGhlIGxhc3QgbGluZSBpcyBlbXB0eS4gIEhvd2V2ZXIsIEFNUyBlbnZpcm9ubWVudHMga2VlcCB0aGVcbiAgICAgIC8vIGVtcHR5IHJvdyBpZiBpdCdzIHRoZSBvbmx5IG9uZS5cbiAgICAgIC8vIE5PVEU6IEN1cnJlbnRseSwgYGNlbGxgIGlzIHRoZSBsYXN0IGl0ZW0gYWRkZWQgaW50byBgcm93YC5cblxuICAgICAgaWYgKHJvdy5sZW5ndGggPT09IDEgJiYgY2VsbC50eXBlID09PSBcInN0eWxpbmdcIiAmJiBjZWxsLmJvZHlbMF0uYm9keS5sZW5ndGggPT09IDAgJiYgKGJvZHkubGVuZ3RoID4gMSB8fCAhZW1wdHlTaW5nbGVSb3cpKSB7XG4gICAgICAgIGJvZHkucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoTGluZXNCZWZvcmVSb3cubGVuZ3RoIDwgYm9keS5sZW5ndGggKyAxKSB7XG4gICAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICB2YXIgc2l6ZSA9IHZvaWQgMDsgLy8gXFxkZWZcXExldEB7XFxsZXRcXFxcXFxtYXRoQGNyfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3J7Li4uXFxtYXRoQGNyQH1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQHtcXG5ld0BpZm5leHRjaGFyW1xcbWF0aEBjckBAe1xcbWF0aEBjckBAW1xcekBdfX1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBbIzFdey4uLlxcbWF0aEBjckBAQC4uLn1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBAe1xcY3J9XG5cbiAgICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwiIFwiKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJvd0dhcHMucHVzaChzaXplID8gc2l6ZS52YWx1ZSA6IG51bGwpO1xuICAgICAgZW5kUm93KCk7IC8vIGNoZWNrIGZvciBcXGhsaW5lKHMpIGZvbGxvd2luZyB0aGUgcm93IHNlcGFyYXRvclxuXG4gICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG4gICAgICByb3cgPSBbXTtcbiAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgYmVnaW5Sb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfSAvLyBFbmQgY2VsbCBncm91cFxuXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxjclxuXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgYWRkSm90LFxuICAgIGFycmF5c3RyZXRjaCxcbiAgICBib2R5LFxuICAgIGNvbHMsXG4gICAgcm93R2FwcyxcbiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyLFxuICAgIGhMaW5lc0JlZm9yZVJvdyxcbiAgICBjb2xTZXBhcmF0aW9uVHlwZSxcbiAgICB0YWdzLFxuICAgIGxlcW5vXG4gIH07XG59IC8vIERlY2lkZXMgb24gYSBzdHlsZSBmb3IgY2VsbHMgaW4gYW4gYXJyYXkgYWNjb3JkaW5nIHRvIHdoZXRoZXIgdGhlIGdpdmVuXG4vLyBlbnZpcm9ubWVudCBuYW1lIHN0YXJ0cyB3aXRoIHRoZSBsZXR0ZXIgJ2QnLlxuXG5cbmZ1bmN0aW9uIGRDZWxsU3R5bGUoZW52TmFtZSkge1xuICBpZiAoZW52TmFtZS5zdWJzdHIoMCwgMSkgPT09IFwiZFwiKSB7XG4gICAgcmV0dXJuIFwiZGlzcGxheVwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcInRleHRcIjtcbiAgfVxufVxuXG52YXIgaHRtbEJ1aWxkZXIkNyA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciByO1xuICB2YXIgYztcbiAgdmFyIG5yID0gZ3JvdXAuYm9keS5sZW5ndGg7XG4gIHZhciBoTGluZXNCZWZvcmVSb3cgPSBncm91cC5oTGluZXNCZWZvcmVSb3c7XG4gIHZhciBuYyA9IDA7XG4gIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTtcbiAgdmFyIGhsaW5lcyA9IFtdO1xuICB2YXIgcnVsZVRoaWNrbmVzcyA9IE1hdGgubWF4KCAvLyBGcm9tIExhVGVYIFxcc2hvd3RoZVxcYXJyYXlydWxld2lkdGguIEVxdWFscyAwLjA0IGVtLlxuICBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXJyYXlSdWxlV2lkdGgsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyBVc2VyIG92ZXJyaWRlLlxuICApOyAvLyBIb3Jpem9udGFsIHNwYWNpbmdcblxuICB2YXIgcHQgPSAxIC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsgLy8gZGVmYXVsdCB2YWx1ZSwgaS5lLiBcXGFycmF5Y29sc2VwIGluIGFydGljbGUuY2xzXG5cbiAgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlICYmIGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAvLyBXZSdyZSBpbiBhIHtzbWFsbG1hdHJpeH0uIERlZmF1bHQgY29sdW1uIHNwYWNlIGlzIFxcdGhpY2tzcGFjZSxcbiAgICAvLyBpLmUuIDUvMThlbSA9IDAuMjc3OGVtLCBwZXIgYW1zbWF0aC5kdHggZm9yIHtzbWFsbG1hdHJpeH0uXG4gICAgLy8gQnV0IHRoYXQgbmVlZHMgYWRqdXN0bWVudCBiZWNhdXNlIExhVGVYIGFwcGxpZXMgXFxzY3JpcHRzdHlsZSB0byB0aGVcbiAgICAvLyBlbnRpcmUgYXJyYXksIGluY2x1ZGluZyB0aGUgY29sc3BhY2UsIGJ1dCB0aGlzIGZ1bmN0aW9uIGFwcGxpZXNcbiAgICAvLyBcXHNjcmlwdHN0eWxlIG9ubHkgaW5zaWRlIGVhY2ggZWxlbWVudC5cbiAgICB2YXIgbG9jYWxNdWx0aXBsaWVyID0gb3B0aW9ucy5oYXZpbmdTdHlsZShTdHlsZSQxLlNDUklQVCkuc2l6ZU11bHRpcGxpZXI7XG4gICAgYXJyYXljb2xzZXAgPSAwLjI3NzggKiAobG9jYWxNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcik7XG4gIH0gLy8gVmVydGljYWwgc3BhY2luZ1xuXG5cbiAgdmFyIGJhc2VsaW5lc2tpcCA9IGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcIkNEXCIgPyBjYWxjdWxhdGVTaXplKHtcbiAgICBudW1iZXI6IDMsXG4gICAgdW5pdDogXCJleFwiXG4gIH0sIG9wdGlvbnMpIDogMTIgKiBwdDsgLy8gc2VlIHNpemUxMC5jbG9cbiAgLy8gRGVmYXVsdCBcXGpvdCBmcm9tIGx0bWF0aC5kdHhcbiAgLy8gVE9ETyhlZGVtYWluZSk6IGFsbG93IG92ZXJyaWRpbmcgXFxqb3QgdmlhIFxcc2V0bGVuZ3RoICgjNjg3KVxuXG4gIHZhciBqb3QgPSAzICogcHQ7XG4gIHZhciBhcnJheXNraXAgPSBncm91cC5hcnJheXN0cmV0Y2ggKiBiYXNlbGluZXNraXA7XG4gIHZhciBhcnN0cnV0SGVpZ2h0ID0gMC43ICogYXJyYXlza2lwOyAvLyBcXHN0cnV0Ym94IGluIGx0ZnNzdHJjLmR0eCBhbmRcblxuICB2YXIgYXJzdHJ1dERlcHRoID0gMC4zICogYXJyYXlza2lwOyAvLyBcXEBhcnN0cnV0Ym94IGluIGx0dGFiLmR0eFxuXG4gIHZhciB0b3RhbEhlaWdodCA9IDA7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpIGF0IHRoZSB0b3Agb2YgdGhlIGFycmF5LCBpZiBhbnkuXG5cbiAgZnVuY3Rpb24gc2V0SExpbmVQb3MoaGxpbmVzSW5HYXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhsaW5lc0luR2FwLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gMC4yNTtcbiAgICAgIH1cblxuICAgICAgaGxpbmVzLnB1c2goe1xuICAgICAgICBwb3M6IHRvdGFsSGVpZ2h0LFxuICAgICAgICBpc0Rhc2hlZDogaGxpbmVzSW5HYXBbaV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldEhMaW5lUG9zKGhMaW5lc0JlZm9yZVJvd1swXSk7XG5cbiAgZm9yIChyID0gMDsgciA8IGdyb3VwLmJvZHkubGVuZ3RoOyArK3IpIHtcbiAgICB2YXIgaW5yb3cgPSBncm91cC5ib2R5W3JdO1xuICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcblxuICAgIHZhciBkZXB0aCA9IGFyc3RydXREZXB0aDsgLy8gdG8gZWFjaCB0b3cgKHZpYSB0aGUgdGVtcGxhdGUpXG5cbiAgICBpZiAobmMgPCBpbnJvdy5sZW5ndGgpIHtcbiAgICAgIG5jID0gaW5yb3cubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBvdXRyb3cgPSBuZXcgQXJyYXkoaW5yb3cubGVuZ3RoKTtcblxuICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgdmFyIGVsdCA9IGJ1aWxkR3JvdXAkMShpbnJvd1tjXSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChkZXB0aCA8IGVsdC5kZXB0aCkge1xuICAgICAgICBkZXB0aCA9IGVsdC5kZXB0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlaWdodCA8IGVsdC5oZWlnaHQpIHtcbiAgICAgICAgaGVpZ2h0ID0gZWx0LmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgb3V0cm93W2NdID0gZWx0O1xuICAgIH1cblxuICAgIHZhciByb3dHYXAgPSBncm91cC5yb3dHYXBzW3JdO1xuICAgIHZhciBnYXAgPSAwO1xuXG4gICAgaWYgKHJvd0dhcCkge1xuICAgICAgZ2FwID0gY2FsY3VsYXRlU2l6ZShyb3dHYXAsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZ2FwID4gMCkge1xuICAgICAgICAvLyBcXEBhcmdhcnJheWNyXG4gICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG5cbiAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgZGVwdGggPSBnYXA7IC8vIFxcQHhhcmdhcnJheWNyXG4gICAgICAgIH1cblxuICAgICAgICBnYXAgPSAwO1xuICAgICAgfVxuICAgIH0gLy8gSW4gQU1TIG11bHRpbGluZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBhbGlnbmVkIGFuZCBnYXRoZXJlZCwgcm93c1xuICAgIC8vIGNvcnJlc3BvbmQgdG8gbGluZXMgdGhhdCBoYXZlIGFkZGl0aW9uYWwgXFxqb3QgYWRkZWQgdG8gdGhlXG4gICAgLy8gXFxiYXNlbGluZXNraXAgdmlhIFxcb3BlbnVwLlxuXG5cbiAgICBpZiAoZ3JvdXAuYWRkSm90KSB7XG4gICAgICBkZXB0aCArPSBqb3Q7XG4gICAgfVxuXG4gICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICBvdXRyb3cuZGVwdGggPSBkZXB0aDtcbiAgICB0b3RhbEhlaWdodCArPSBoZWlnaHQ7XG4gICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgIHRvdGFsSGVpZ2h0ICs9IGRlcHRoICsgZ2FwOyAvLyBcXEB5YXJnYXJyYXljclxuXG4gICAgYm9keVtyXSA9IG91dHJvdzsgLy8gU2V0IGEgcG9zaXRpb24gZm9yIFxcaGxpbmUocyksIGlmIGFueS5cblxuICAgIHNldEhMaW5lUG9zKGhMaW5lc0JlZm9yZVJvd1tyICsgMV0pO1xuICB9XG5cbiAgdmFyIG9mZnNldCA9IHRvdGFsSGVpZ2h0IC8gMiArIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuICB2YXIgY29sRGVzY3JpcHRpb25zID0gZ3JvdXAuY29scyB8fCBbXTtcbiAgdmFyIGNvbHMgPSBbXTtcbiAgdmFyIGNvbFNlcDtcbiAgdmFyIGNvbERlc2NyTnVtO1xuICB2YXIgdGFnU3BhbnMgPSBbXTtcblxuICBpZiAoZ3JvdXAudGFncyAmJiBncm91cC50YWdzLnNvbWUodGFnID0+IHRhZykpIHtcbiAgICAvLyBBbiBlbnZpcm9ubWVudCB3aXRoIG1hbnVhbCB0YWdzIGFuZC9vciBhdXRvbWF0aWMgZXF1YXRpb24gbnVtYmVycy5cbiAgICAvLyBDcmVhdGUgbm9kZShzKSwgdGhlIGxhdHRlciBvZiB3aGljaCB0cmlnZ2VyIENTUyBjb3VudGVyIGluY3JlbWVudC5cbiAgICBmb3IgKHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgdmFyIHJ3ID0gYm9keVtyXTtcbiAgICAgIHZhciBzaGlmdCA9IHJ3LnBvcyAtIG9mZnNldDtcbiAgICAgIHZhciB0YWcgPSBncm91cC50YWdzW3JdO1xuICAgICAgdmFyIHRhZ1NwYW4gPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0YWcgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXV0b21hdGljIG51bWJlcmluZ1xuICAgICAgICB0YWdTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZXFuLW51bVwiXSwgW10sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFxcbm9udW1iZXIvXFxub3RhZyBvciBzdGFycmVkIGVudmlyb25tZW50XG4gICAgICAgIHRhZ1NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW10sIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFudWFsIFxcdGFnXG4gICAgICAgIHRhZ1NwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgYnVpbGRFeHByZXNzaW9uJDEodGFnLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRhZ1NwYW4uZGVwdGggPSBydy5kZXB0aDtcbiAgICAgIHRhZ1NwYW4uaGVpZ2h0ID0gcncuaGVpZ2h0O1xuICAgICAgdGFnU3BhbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiB0YWdTcGFuLFxuICAgICAgICBzaGlmdFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwOyAvLyBDb250aW51ZSB3aGlsZSBlaXRoZXIgdGhlcmUgYXJlIG1vcmUgY29sdW1ucyBvciBtb3JlIGNvbHVtblxuICAvLyBkZXNjcmlwdGlvbnMsIHNvIHRyYWlsaW5nIHNlcGFyYXRvcnMgZG9uJ3QgZ2V0IGxvc3QuXG4gIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7ICsrYywgKytjb2xEZXNjck51bSkge1xuICAgIHZhciBjb2xEZXNjciA9IGNvbERlc2NyaXB0aW9uc1tjb2xEZXNjck51bV0gfHwge307XG4gICAgdmFyIGZpcnN0U2VwYXJhdG9yID0gdHJ1ZTtcblxuICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gbWFrZUVtKG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kb3VibGVSdWxlU2VwKTtcbiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwifFwiIHx8IGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCI6XCIpIHtcbiAgICAgICAgdmFyIGxpbmVUeXBlID0gY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIiA/IFwic29saWRcIiA6IFwiZGFzaGVkXCI7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ2ZXJ0aWNhbC1zZXBhcmF0b3JcIl0sIFtdLCBvcHRpb25zKTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmhlaWdodCA9IG1ha2VFbSh0b3RhbEhlaWdodCk7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRTdHlsZSA9IGxpbmVUeXBlO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUubWFyZ2luID0gXCIwIFwiICsgbWFrZUVtKC1ydWxlVGhpY2tuZXNzIC8gMik7XG5cbiAgICAgICAgdmFyIF9zaGlmdCA9IHRvdGFsSGVpZ2h0IC0gb2Zmc2V0O1xuXG4gICAgICAgIGlmIChfc2hpZnQpIHtcbiAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtX3NoaWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHMucHVzaChzZXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHNlcGFyYXRvciB0eXBlOiBcIiArIGNvbERlc2NyLnNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIGNvbERlc2NyTnVtKys7XG4gICAgICBjb2xEZXNjciA9IGNvbERlc2NyaXB0aW9uc1tjb2xEZXNjck51bV0gfHwge307XG4gICAgICBmaXJzdFNlcGFyYXRvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjID49IG5jKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgc2Vwd2lkdGggPSB2b2lkIDA7XG5cbiAgICBpZiAoYyA+IDAgfHwgZ3JvdXAuaHNraXBCZWZvcmVBbmRBZnRlcikge1xuICAgICAgc2Vwd2lkdGggPSB1dGlscy5kZWZsdChjb2xEZXNjci5wcmVnYXAsIGFycmF5Y29sc2VwKTtcblxuICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShzZXB3aWR0aCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb2wgPSBbXTtcblxuICAgIGZvciAociA9IDA7IHIgPCBucjsgKytyKSB7XG4gICAgICB2YXIgcm93ID0gYm9keVtyXTtcbiAgICAgIHZhciBlbGVtID0gcm93W2NdO1xuXG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfc2hpZnQyID0gcm93LnBvcyAtIG9mZnNldDtcblxuICAgICAgZWxlbS5kZXB0aCA9IHJvdy5kZXB0aDtcbiAgICAgIGVsZW0uaGVpZ2h0ID0gcm93LmhlaWdodDtcbiAgICAgIGNvbC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgIHNoaWZ0OiBfc2hpZnQyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb2wgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IGNvbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLCBbY29sXSk7XG4gICAgY29scy5wdXNoKGNvbCk7XG5cbiAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcblxuICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShzZXB3aWR0aCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtdGFibGVcIl0sIGNvbHMpOyAvLyBBZGQgXFxobGluZShzKSwgaWYgYW55LlxuXG4gIGlmIChobGluZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiaGxpbmVcIiwgb3B0aW9ucywgcnVsZVRoaWNrbmVzcyk7XG4gICAgdmFyIGRhc2hlcyA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhkYXNobGluZVwiLCBvcHRpb25zLCBydWxlVGhpY2tuZXNzKTtcbiAgICB2YXIgdkxpc3RFbGVtcyA9IFt7XG4gICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgIGVsZW06IGJvZHksXG4gICAgICBzaGlmdDogMFxuICAgIH1dO1xuXG4gICAgd2hpbGUgKGhsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaGxpbmUgPSBobGluZXMucG9wKCk7XG4gICAgICB2YXIgbGluZVNoaWZ0ID0gaGxpbmUucG9zIC0gb2Zmc2V0O1xuXG4gICAgICBpZiAoaGxpbmUuaXNEYXNoZWQpIHtcbiAgICAgICAgdkxpc3RFbGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBkYXNoZXMsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbGluZSxcbiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IHZMaXN0RWxlbXNcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0YWdTcGFucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW2JvZHldLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXFuTnVtQ29sID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiB0YWdTcGFuc1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGVxbk51bUNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInRhZ1wiXSwgW2Vxbk51bUNvbF0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoW2JvZHksIGVxbk51bUNvbF0pO1xuICB9XG59O1xuXG52YXIgYWxpZ25NYXAgPSB7XG4gIGM6IFwiY2VudGVyIFwiLFxuICBsOiBcImxlZnQgXCIsXG4gIHI6IFwicmlnaHQgXCJcbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDYgPSBmdW5jdGlvbiBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciB0YmwgPSBbXTtcbiAgdmFyIGdsdWUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSwgW1wibXRyLWdsdWVcIl0pO1xuICB2YXIgdGFnID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIFtcIm1tbC1lcW4tbnVtXCJdKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcncgPSBncm91cC5ib2R5W2ldO1xuICAgIHZhciByb3cgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcncubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJvdy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEdyb3VwKHJ3W2pdLCBvcHRpb25zKV0pKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudGFncyAmJiBncm91cC50YWdzW2ldKSB7XG4gICAgICByb3cudW5zaGlmdChnbHVlKTtcbiAgICAgIHJvdy5wdXNoKGdsdWUpO1xuXG4gICAgICBpZiAoZ3JvdXAubGVxbm8pIHtcbiAgICAgICAgcm93LnVuc2hpZnQodGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGJsLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgcm93KSk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCB0YmwpOyAvLyBTZXQgY29sdW1uIGFsaWdubWVudCwgcm93IHNwYWNpbmcsIGNvbHVtbiBzcGFjaW5nLCBhbmRcbiAgLy8gYXJyYXkgbGluZXMgYnkgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSB0YWJsZSBlbGVtZW50LlxuICAvLyBTZXQgdGhlIHJvdyBzcGFjaW5nLiBJbiBNYXRoTUwsIHdlIHNwZWNpZnkgYSBnYXAgZGlzdGFuY2UuXG4gIC8vIFdlIGRvIG5vdCB1c2Ugcm93R2FwW10gYmVjYXVzZSBNYXRoTUwgYXV0b21hdGljYWxseSBpbmNyZWFzZXNcbiAgLy8gY2VsbCBoZWlnaHQgd2l0aCB0aGUgaGVpZ2h0L2RlcHRoIG9mIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gIC8vIExhVGVYIFxcYXJyYXlzdHJldGNoIG11bHRpcGxpZXMgdGhlIHJvdyBiYXNlbGluZS10by1iYXNlbGluZSBkaXN0YW5jZS5cbiAgLy8gV2Ugc2ltdWxhdGUgdGhpcyBieSBhZGRpbmcgKGFycmF5c3RyZXRjaCAtIDEpZW0gdG8gdGhlIGdhcC4gVGhpc1xuICAvLyBkb2VzIGEgcmVhc29uYWJsZSBqb2Igb2YgYWRqdXN0aW5nIGFycmF5cyBjb250YWluaW5nIDEgZW0gdGFsbCBjb250ZW50LlxuICAvLyBUaGUgMC4xNiBhbmQgMC4wOSB2YWx1ZXMgYXJlIGZvdW5kIGVtcHJpY2FsbHkuIFRoZXkgcHJvZHVjZSBhbiBhcnJheVxuICAvLyBzaW1pbGFyIHRvIExhVGVYIGFuZCBpbiB3aGljaCBjb250ZW50IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIFxcaGluZXMuXG5cbiAgdmFyIGdhcCA9IGdyb3VwLmFycmF5c3RyZXRjaCA9PT0gMC41ID8gMC4xIC8vIHtzbWFsbG1hdHJpeH0sIHtzdWJhcnJheX1cbiAgOiAwLjE2ICsgZ3JvdXAuYXJyYXlzdHJldGNoIC0gMSArIChncm91cC5hZGRKb3QgPyAwLjA5IDogMCk7XG4gIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgbWFrZUVtKGdhcCkpOyAvLyBNYXRoTUwgdGFibGUgbGluZXMgZ28gb25seSBiZXR3ZWVuIGNlbGxzLlxuICAvLyBUbyBwbGFjZSBhIGxpbmUgb24gYW4gZWRnZSB3ZSdsbCB1c2UgPG1lbmNsb3NlPiwgaWYgbmVjZXNzYXJ5LlxuXG4gIHZhciBtZW5jbG9zZSA9IFwiXCI7XG4gIHZhciBhbGlnbiA9IFwiXCI7XG5cbiAgaWYgKGdyb3VwLmNvbHMgJiYgZ3JvdXAuY29scy5sZW5ndGggPiAwKSB7XG4gICAgLy8gRmluZCBjb2x1bW4gYWxpZ25tZW50LCBjb2x1bW4gc3BhY2luZywgYW5kICB2ZXJ0aWNhbCBsaW5lcy5cbiAgICB2YXIgY29scyA9IGdyb3VwLmNvbHM7XG4gICAgdmFyIGNvbHVtbkxpbmVzID0gXCJcIjtcbiAgICB2YXIgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgIHZhciBpU3RhcnQgPSAwO1xuICAgIHZhciBpRW5kID0gY29scy5sZW5ndGg7XG5cbiAgICBpZiAoY29sc1swXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcInRvcCBcIjtcbiAgICAgIGlTdGFydCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbY29scy5sZW5ndGggLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcImJvdHRvbSBcIjtcbiAgICAgIGlFbmQgLT0gMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IGlTdGFydDsgX2kgPCBpRW5kOyBfaSsrKSB7XG4gICAgICBpZiAoY29sc1tfaV0udHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgICAgIGFsaWduICs9IGFsaWduTWFwW2NvbHNbX2ldLmFsaWduXTtcblxuICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikge1xuICAgICAgICAgIGNvbHVtbkxpbmVzICs9IFwibm9uZSBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjb2xzW19pXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBjb2xzW19pXS5zZXBhcmF0b3IgPT09IFwifFwiID8gXCJzb2xpZCBcIiA6IFwiZGFzaGVkIFwiO1xuICAgICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIGFsaWduLnRyaW0oKSk7XG5cbiAgICBpZiAoL1tzZF0vLnRlc3QoY29sdW1uTGluZXMpKSB7XG4gICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5saW5lc1wiLCBjb2x1bW5MaW5lcy50cmltKCkpO1xuICAgIH1cbiAgfSAvLyBTZXQgY29sdW1uIHNwYWNpbmcuXG5cblxuICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgIHZhciBfY29scyA9IGdyb3VwLmNvbHMgfHwgW107XG5cbiAgICB2YXIgc3BhY2luZyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCBfY29scy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBzcGFjaW5nICs9IF9pMiAlIDIgPyBcIjBlbSBcIiA6IFwiMWVtIFwiO1xuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgc3BhY2luZy50cmltKCkpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcImFsaWduYXRcIiB8fCBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJnYXRoZXJcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwZW1cIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwLjI3NzhlbVwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJDRFwiKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBcIjAuNWVtXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIxZW1cIik7XG4gIH0gLy8gQWRkcmVzcyBcXGhsaW5lIGFuZCBcXGhkYXNobGluZVxuXG5cbiAgdmFyIHJvd0xpbmVzID0gXCJcIjtcbiAgdmFyIGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbWVuY2xvc2UgKz0gaGxpbmVzWzBdLmxlbmd0aCA+IDAgPyBcImxlZnQgXCIgOiBcIlwiO1xuICBtZW5jbG9zZSArPSBobGluZXNbaGxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgPyBcInJpZ2h0IFwiIDogXCJcIjtcblxuICBmb3IgKHZhciBfaTMgPSAxOyBfaTMgPCBobGluZXMubGVuZ3RoIC0gMTsgX2kzKyspIHtcbiAgICByb3dMaW5lcyArPSBobGluZXNbX2kzXS5sZW5ndGggPT09IDAgPyBcIm5vbmUgXCIgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBhIHNpbmdsZSBsaW5lIGJldHdlZW4gcm93cy4gUmVhZCBvbmUgZWxlbWVudC5cbiAgICA6IGhsaW5lc1tfaTNdWzBdID8gXCJkYXNoZWQgXCIgOiBcInNvbGlkIFwiO1xuICB9XG5cbiAgaWYgKC9bc2RdLy50ZXN0KHJvd0xpbmVzKSkge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd2xpbmVzXCIsIHJvd0xpbmVzLnRyaW0oKSk7XG4gIH1cblxuICBpZiAobWVuY2xvc2UgIT09IFwiXCIpIHtcbiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWVuY2xvc2VcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgbWVuY2xvc2UudHJpbSgpKTtcbiAgfVxuXG4gIGlmIChncm91cC5hcnJheXN0cmV0Y2ggJiYgZ3JvdXAuYXJyYXlzdHJldGNoIDwgMSkge1xuICAgIC8vIEEgc21hbGwgYXJyYXkuIFdyYXAgaW4gc2NyaXB0c3R5bGUgc28gcm93IGdhcCBpcyBub3QgdG9vIGxhcmdlLlxuICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTsgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFsaWduLCBhbGlnbiosIGFsaWduZWQsIGFsaWduYXQsIGFsaWduYXQqLCBhbGlnbmVkYXQuXG5cblxudmFyIGFsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24gYWxpZ25lZEhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICBpZiAoY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIHZhciBjb2xzID0gW107XG4gIHZhciBzZXBhcmF0aW9uVHlwZSA9IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiYXRcIikgPiAtMSA/IFwiYWxpZ25hdFwiIDogXCJhbGlnblwiO1xuICB2YXIgaXNTcGxpdCA9IGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiO1xuICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwge1xuICAgIGNvbHMsXG4gICAgYWRkSm90OiB0cnVlLFxuICAgIGF1dG9UYWc6IGlzU3BsaXQgPyB1bmRlZmluZWQgOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgY29sU2VwYXJhdGlvblR5cGU6IHNlcGFyYXRpb25UeXBlLFxuICAgIG1heE51bUNvbHM6IGlzU3BsaXQgPyAyIDogdW5kZWZpbmVkLFxuICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICB9LCBcImRpc3BsYXlcIik7IC8vIERldGVybWluaW5nIG51bWJlciBvZiBjb2x1bW5zLlxuICAvLyAxLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ2l2ZW4sIHdlIHVzZSBpdCBhcyBhIG51bWJlciBvZiBjb2x1bW5zLFxuICAvLyAgICBhbmQgbWFrZXMgc3VyZSB0aGF0IGVhY2ggcm93IGRvZXNuJ3QgZXhjZWVkIHRoYXQgbnVtYmVyLlxuICAvLyAyLiBPdGhlcndpc2UsIGp1c3QgY291bnQgbnVtYmVyIG9mIGNvbHVtbnMgPSBtYXhpbXVtIG51bWJlclxuICAvLyAgICBvZiBjZWxscyBpbiBlYWNoIHJvdyAoXCJhbGlnbmVkXCIgbW9kZSAtLSBpc0FsaWduZWQgd2lsbCBiZSB0cnVlKS5cbiAgLy9cbiAgLy8gQXQgdGhlIHNhbWUgdGltZSwgcHJlcGVuZCBlbXB0eSBncm91cCB7fSBhdCBiZWdpbm5pbmcgb2YgZXZlcnkgc2Vjb25kXG4gIC8vIGNlbGwgaW4gZWFjaCByb3cgKHN0YXJ0aW5nIHdpdGggc2Vjb25kIGNlbGwpIHNvIHRoYXQgb3BlcmF0b3JzIGJlY29tZVxuICAvLyBiaW5hcnkuICBUaGlzIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIGFtc21hdGgncyBcXHN0YXJ0QGFsaWduZWQuXG5cbiAgdmFyIG51bU1hdGhzO1xuICB2YXIgbnVtQ29scyA9IDA7XG4gIHZhciBlbXB0eUdyb3VwID0ge1xuICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgYm9keTogW11cbiAgfTtcblxuICBpZiAoYXJnc1swXSAmJiBhcmdzWzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIHZhciBhcmcwID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc1swXS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0uYm9keVtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYXJnMCArPSB0ZXh0b3JkLnRleHQ7XG4gICAgfVxuXG4gICAgbnVtTWF0aHMgPSBOdW1iZXIoYXJnMCk7XG4gICAgbnVtQ29scyA9IG51bU1hdGhzICogMjtcbiAgfVxuXG4gIHZhciBpc0FsaWduZWQgPSAhbnVtQ29scztcbiAgcmVzLmJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgcm93Lmxlbmd0aDsgX2k0ICs9IDIpIHtcbiAgICAgIC8vIE1vZGlmeSBvcmRncm91cCBub2RlIHdpdGhpbiBzdHlsaW5nIG5vZGVcbiAgICAgIHZhciBzdHlsaW5nID0gYXNzZXJ0Tm9kZVR5cGUocm93W19pNF0sIFwic3R5bGluZ1wiKTtcbiAgICAgIHZhciBvcmRncm91cCA9IGFzc2VydE5vZGVUeXBlKHN0eWxpbmcuYm9keVswXSwgXCJvcmRncm91cFwiKTtcbiAgICAgIG9yZGdyb3VwLmJvZHkudW5zaGlmdChlbXB0eUdyb3VwKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQWxpZ25lZCkge1xuICAgICAgLy8gQ2FzZSAxXG4gICAgICB2YXIgY3VyTWF0aHMgPSByb3cubGVuZ3RoIC8gMjtcblxuICAgICAgaWYgKG51bU1hdGhzIDwgY3VyTWF0aHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gbWFueSBtYXRoIGluIGEgcm93OiBcIiArIChcImV4cGVjdGVkIFwiICsgbnVtTWF0aHMgKyBcIiwgYnV0IGdvdCBcIiArIGN1ck1hdGhzKSwgcm93WzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAvLyBDYXNlIDJcbiAgICAgIG51bUNvbHMgPSByb3cubGVuZ3RoO1xuICAgIH1cbiAgfSk7IC8vIEFkanVzdGluZyBhbGlnbm1lbnQuXG4gIC8vIEluIGFsaWduZWQgbW9kZSwgd2UgYWRkIG9uZSBcXHFxdWFkIGJldHdlZW4gY29sdW1ucztcbiAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBub3RoaW5nLlxuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bUNvbHM7ICsrX2k1KSB7XG4gICAgdmFyIGFsaWduID0gXCJyXCI7XG4gICAgdmFyIHByZWdhcCA9IDA7XG5cbiAgICBpZiAoX2k1ICUgMiA9PT0gMSkge1xuICAgICAgYWxpZ24gPSBcImxcIjtcbiAgICB9IGVsc2UgaWYgKF9pNSA+IDAgJiYgaXNBbGlnbmVkKSB7XG4gICAgICAvLyBcImFsaWduZWRcIiBtb2RlLlxuICAgICAgcHJlZ2FwID0gMTsgLy8gYWRkIG9uZSBcXHF1YWRcbiAgICB9XG5cbiAgICBjb2xzW19pNV0gPSB7XG4gICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBwcmVnYXA6IHByZWdhcCxcbiAgICAgIHBvc3RnYXA6IDBcbiAgICB9O1xuICB9XG5cbiAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gaXNBbGlnbmVkID8gXCJhbGlnblwiIDogXCJhbGlnbmF0XCI7XG4gIHJldHVybiByZXM7XG59OyAvLyBBcnJheXMgYXJlIHBhcnQgb2YgTGFUZVgsIGRlZmluZWQgaW4gbHR0YWIuZHR4IHNvIGl0cyBkb2N1bWVudGF0aW9uXG4vLyBpcyBwYXJ0IG9mIHRoZSBzb3VyY2UyZS5wZGYgZmlsZSBvZiBMYVRlWDJlIHNvdXJjZSBkb2N1bWVudGF0aW9uLlxuLy8ge2RhcnJheX0gaXMgYW4ge2FycmF5fSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBuY2NtYXRoLnN0eS5cblxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFycmF5XCIsIFwiZGFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuICAgIHZhciByZXMgPSB7XG4gICAgICBjb2xzLFxuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogdHJ1ZSxcbiAgICAgIC8vIFxcQHByZWFtYmxlIGluIGx0dGFiLmR0eFxuICAgICAgbWF4TnVtQ29sczogY29scy5sZW5ndGhcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7IC8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGRzIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cbi8vIFRoZSBtYXRodG9vbHMgcGFja2FnZSBhZGRzIHN0YXJyZWQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgZW52aXJvbm1lbnRzLlxuLy8gVGhlc2UgaGF2ZSBhbiBvcHRpb25hbCBhcmd1bWVudCB0byBjaG9vc2UgbGVmdHxjZW50ZXJ8cmlnaHQganVzdGlmaWNhdGlvbi5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtYXRyaXhcIiwgXCJwbWF0cml4XCIsIFwiYm1hdHJpeFwiLCBcIkJtYXRyaXhcIiwgXCJ2bWF0cml4XCIsIFwiVm1hdHJpeFwiLCBcIm1hdHJpeCpcIiwgXCJwbWF0cml4KlwiLCBcImJtYXRyaXgqXCIsIFwiQm1hdHJpeCpcIiwgXCJ2bWF0cml4KlwiLCBcIlZtYXRyaXgqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgIFwibWF0cml4XCI6IG51bGwsXG4gICAgICBcInBtYXRyaXhcIjogW1wiKFwiLCBcIilcIl0sXG4gICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICBcIkJtYXRyaXhcIjogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSxcbiAgICAgIFwidm1hdHJpeFwiOiBbXCJ8XCIsIFwifFwiXSxcbiAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWUucmVwbGFjZShcIipcIiwgXCJcIildOyAvLyBcXGhza2lwIC1cXGFycmF5Y29sc2VwIGluIGFtc21hdGhcblxuICAgIHZhciBjb2xBbGlnbiA9IFwiY1wiO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBjb2xBbGlnblxuICAgICAgfV1cbiAgICB9O1xuXG4gICAgaWYgKGNvbnRleHQuZW52TmFtZS5jaGFyQXQoY29udGV4dC5lbnZOYW1lLmxlbmd0aCAtIDEpID09PSBcIipcIikge1xuICAgICAgLy8gSXQncyBvbmUgb2YgdGhlIG1hdGh0b29scyBzdGFycmVkIGZ1bmN0aW9ucy5cbiAgICAgIC8vIFBhcnNlIHRoZSBvcHRpb25hbCBhbGlnbm1lbnQgYXJndW1lbnQuXG4gICAgICB2YXIgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgICBpZiAocGFyc2VyLmZldGNoKCkudGV4dCA9PT0gXCJbXCIpIHtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgY29sQWxpZ24gPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY29sQWxpZ24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgbCBvciBjIG9yIHJcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBwYXJzZXIuZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGF5bG9hZC5jb2xzID0gW3tcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNvbEFsaWduXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpOyAvLyBQb3B1bGF0ZSBjb2xzIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbiBhbGlnbm1lbnQgc3BlY3MuXG5cbiAgICB2YXIgbnVtQ29scyA9IE1hdGgubWF4KDAsIC4uLnJlcy5ib2R5Lm1hcChyb3cgPT4gcm93Lmxlbmd0aCkpO1xuICAgIHJlcy5jb2xzID0gbmV3IEFycmF5KG51bUNvbHMpLmZpbGwoe1xuICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgYWxpZ246IGNvbEFsaWduXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlbGltaXRlcnMgPyB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV0sXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWQgLy8gXFxyaWdodCB1bmluZmx1ZW5jZWQgYnkgXFxjb2xvciBpbiBhcnJheVxuXG4gICAgfSA6IHJlcztcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNyxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInNjcmlwdFwiKTtcbiAgICByZXMuY29sU2VwYXJhdGlvblR5cGUgPSBcInNtYWxsXCI7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNyxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic3ViYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFBhcnNpbmcgb2Yge3N1YmFycmF5fSBpcyBzaW1pbGFyIHRvIHthcnJheX1cbiAgICB2YXIgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgdmFyIGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICB2YXIgY29scyA9IGNvbGFsaWduLm1hcChmdW5jdGlvbiAobmRlKSB7XG4gICAgICB2YXIgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICB2YXIgY2EgPSBub2RlLnRleHQ7IC8vIHtzdWJhcnJheX0gb25seSByZWNvZ25pemVzIFwibFwiICYgXCJjXCJcblxuICAgICAgaWYgKFwibGNcIi5pbmRleE9mKGNhKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNhXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IGZhbHNlLFxuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJzY3JpcHRcIik7XG5cbiAgICBpZiAocmVzLmJvZHkubGVuZ3RoID4gMCAmJiByZXMuYm9keVswXS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7IC8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcXGFycmF5c3RyZXRjaHsxLjJ9JVxuLy8gXFxsZWZ0XFx7XFxiZWdpbnthcnJheX17QHt9bEB7XFxxdWFkfWxAe319IOKApiBcXGVuZHthcnJheX1cXHJpZ2h0LlxuLy8ge2RjYXNlc30gaXMgYSB7Y2FzZXN9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG1hdGh0b29scy5zdHkuXG4vLyB7cmNhc2VzfSBpcyBhbm90aGVyIG1hdGh0b29scyBlbnZpcm9ubWVudC4gSXQncyBicmFjZSBpcyBvbiB0aGUgcmlnaHQgc2lkZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJjYXNlc1wiLCBcImRjYXNlc1wiLCBcInJjYXNlc1wiLCBcImRyY2FzZXNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImxcIixcbiAgICAgICAgcHJlZ2FwOiAwLFxuICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAvLyBGb3Igbm93IHdlIHVzZSB0aGUgbWV0cmljcyBmb3IgVEVYVCBzdHlsZSB3aGljaCBpcyB3aGF0IHdlIHdlcmVcbiAgICAgICAgLy8gZG9pbmcgYmVmb3JlLiAgQmVmb3JlIGF0dGVtcHRpbmcgdG8gZ2V0IHRoZSBjdXJyZW50IHN0eWxlIHdlXG4gICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgIHBvc3RnYXA6IDEuMFxuICAgICAgICAvKiAxZW0gcXVhZCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwibFwiLFxuICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgIHBvc3RnYXA6IDBcbiAgICAgIH1dXG4gICAgfTtcbiAgICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgZENlbGxTdHlsZShjb250ZXh0LmVudk5hbWUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICAgIGJvZHk6IFtyZXNdLFxuICAgICAgbGVmdDogY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJyXCIpID4gLTEgPyBcIi5cIiA6IFwiXFxcXHtcIixcbiAgICAgIHJpZ2h0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiXFxcXH1cIiA6IFwiLlwiLFxuICAgICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNyxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTsgLy8gSW4gdGhlIGFsaWduIGVudmlyb25tZW50LCBvbmUgdXNlcyBhbXBlcnNhbmRzLCAmLCB0byBzcGVjaWZ5IG51bWJlciBvZlxuLy8gY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIHRvIGxvY2F0ZSBzcGFjaW5nIGJldHdlZW4gZWFjaCBjb2x1bW4uXG4vLyBhbGlnbiBnZXRzIGF1dG9tYXRpYyBudW1iZXJpbmcuIGFsaWduKiBhbmQgYWxpZ25lZCBkbyBub3QuXG4vLyBUaGUgYWxpZ25lZGF0IGVudmlyb25tZW50IGNhbiBiZSB1c2VkIGluIG1hdGggbW9kZS5cbi8vIE5vdGUgdGhhdCB3ZSBhc3N1bWUgXFxub21hbGxpbmVza2lwbGltaXQgdG8gYmUgemVybyxcbi8vIHNvIHRoYXQgXFxzdHJ1dEAgaXMgdGhlIHNhbWUgYXMgXFxzdHJ1dC5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnblwiLCBcImFsaWduKlwiLCBcImFsaWduZWRcIiwgXCJzcGxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNyxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTsgLy8gQSBnYXRoZXJlZCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFycmF5IGVudmlyb25tZW50IHdpdGggb25lIGNlbnRlcmVkXG4vLyBjb2x1bW4sIGJ1dCB3aGVyZSByb3dzIGFyZSBjb25zaWRlcmVkIGxpbmVzIHNvIGdldCBcXGpvdCBsaW5lIHNwYWNpbmdcbi8vIGFuZCBjb250ZW50cyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImdhdGhlcmVkXCIsIFwiZ2F0aGVyXCIsIFwiZ2F0aGVyKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcImdhdGhlclwiLCBcImdhdGhlcipcIl0sIGNvbnRleHQuZW52TmFtZSkpIHtcbiAgICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImNcIlxuICAgICAgfV0sXG4gICAgICBhZGRKb3Q6IHRydWUsXG4gICAgICBjb2xTZXBhcmF0aW9uVHlwZTogXCJnYXRoZXJcIixcbiAgICAgIGF1dG9UYWc6IGdldEF1dG9UYWcoY29udGV4dC5lbnZOYW1lKSxcbiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7IC8vIGFsaWduYXQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhbGlnbiBlbnZpcm9ubWVudCwgYnV0IG9uZSBtdXN0IGV4cGxpY2l0bHlcbi8vIHNwZWNpZnkgbWF4aW11bSBudW1iZXIgb2YgY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIGNhbiBhZGp1c3Qgc3BhY2luZyBiZXR3ZWVuXG4vLyBlYWNoIGNvbHVtbnMuXG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25hdFwiLCBcImFsaWduYXQqXCIsIFwiYWxpZ25lZGF0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogYWxpZ25lZEhhbmRsZXIsXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ3LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDZcbn0pO1xuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJlcXVhdGlvblwiLCBcImVxdWF0aW9uKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGF1dG9UYWc6IGdldEF1dG9UYWcoY29udGV4dC5lbnZOYW1lKSxcbiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgICAgc2luZ2xlUm93OiB0cnVlLFxuICAgICAgbWF4TnVtQ29sczogMSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ3LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDZcbn0pO1xuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJDRFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlQ0QoY29udGV4dC5wYXJzZXIpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ3LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDZcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm9udW1iZXJcIiwgXCJcXFxcZ2RlZlxcXFxAZXFuc3d7MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxub3RhZ1wiLCBcIlxcXFxub251bWJlclwiKTsgLy8gQ2F0Y2ggXFxobGluZSBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhpcyBpcy5cbiAgbmFtZXM6IFtcIlxcXFxobGluZVwiLCBcIlxcXFxoZGFzaGxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihjb250ZXh0LmZ1bmNOYW1lICsgXCIgdmFsaWQgb25seSB3aXRoaW4gYXJyYXkgZW52aXJvbm1lbnRcIik7XG4gIH1cblxufSk7XG5cbnZhciBlbnZpcm9ubWVudHMgPSBfZW52aXJvbm1lbnRzO1xuXG4vLyBkZWZpbmVFbnZpcm9ubWVudCBkZWZpbml0aW9ucy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYmVnaW5cIiwgXCJcXFxcZW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgbmFtZUdyb3VwID0gYXJnc1swXTtcblxuICAgIGlmIChuYW1lR3JvdXAudHlwZSAhPT0gXCJvcmRncm91cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgZW52aXJvbm1lbnQgbmFtZVwiLCBuYW1lR3JvdXApO1xuICAgIH1cblxuICAgIHZhciBlbnZOYW1lID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVudk5hbWUgKz0gYXNzZXJ0Tm9kZVR5cGUobmFtZUdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKS50ZXh0O1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgLy8gYmVnaW4uLi5lbmQgaXMgc2ltaWxhciB0byBsZWZ0Li4ucmlnaHRcbiAgICAgIGlmICghZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm8gc3VjaCBlbnZpcm9ubWVudDogXCIgKyBlbnZOYW1lLCBuYW1lR3JvdXApO1xuICAgICAgfSAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgIC8vIGJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBiZWdpbiBhbmQgZW5kIG1ldGhvZHMgdXNpbmcgcHJvcGVydGllcy5cblxuXG4gICAgICB2YXIgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXJnczogX2FyZ3MsXG4gICAgICAgIG9wdEFyZ3NcbiAgICAgIH0gPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGVudk5hbWUsXG4gICAgICAgIHBhcnNlclxuICAgICAgfTtcbiAgICAgIHZhciByZXN1bHQgPSBlbnYuaGFuZGxlcihjb250ZXh0LCBfYXJncywgb3B0QXJncyk7XG4gICAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICB2YXIgZW5kTmFtZVRva2VuID0gcGFyc2VyLm5leHRUb2tlbjtcbiAgICAgIHZhciBlbmQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImVudmlyb25tZW50XCIpO1xuXG4gICAgICBpZiAoZW5kLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJNaXNtYXRjaDogXFxcXGJlZ2lue1wiICsgZW52TmFtZSArIFwifSBtYXRjaGVkIGJ5IFxcXFxlbmR7XCIgKyBlbmQubmFtZSArIFwifVwiLCBlbmROYW1lVG9rZW4pO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lLCBcImVudmlyb25tZW50XCIgaGFuZGxlciByZXR1cm5zIGFuIGVudmlyb25tZW50IFBhcnNlTm9kZVxuXG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZW52TmFtZSxcbiAgICAgIG5hbWVHcm91cFxuICAgIH07XG4gIH1cblxufSk7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG5mdW5jdGlvbiBodG1sQnVpbGRlciQ2KGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWF0aG1sQnVpbGRlciQ1KGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBub2RlO1xuICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgaW5uZXIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3JkXCIpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibWlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgaW5uZXIpO1xuICAgIH0gLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG5cblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyZW1cIjsgLy8gbWVkaXVtIHNwYWNlXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMjJlbVwiO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMTdlbVwiOyAvLyB0aGluc3BhY2VcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4wNTU2ZW1cIjsgLy8gMSBtdSBpcyB0aGUgbW9zdCBsaWtlbHkgb3B0aW9uXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy53aWR0aCA9IFwiKzAuMTExMWVtXCI7XG4gICAgfSAvLyBNYXRoTUwgPG1vPiBkZWZhdWx0IHNwYWNlIGlzIDUvMTggZW0sIHNvIDxtcmVsPiBuZWVkcyBubyBhY3Rpb24uXG4gICAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NYXRoTUwvRWxlbWVudC9tb1xuXG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9yZFwiLCBcIlxcXFxtYXRoYmluXCIsIFwiXFxcXG1hdGhyZWxcIiwgXCJcXFxcbWF0aG9wZW5cIiwgXCJcXFxcbWF0aGNsb3NlXCIsIFwiXFxcXG1hdGhwdW5jdFwiLCBcIlxcXFxtYXRoaW5uZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogXCJtXCIgKyBmdW5jTmFtZS5zdWJzdHIoNSksXG4gICAgICAvLyBUT0RPKGtldmluYik6IGRvbid0IHByZWZpeCB3aXRoICdtJ1xuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ2LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xudmFyIGJpbnJlbENsYXNzID0gYXJnID0+IHtcbiAgLy8gXFxiaW5yZWxAIHNwYWNpbmcgdmFyaWVzIHdpdGggKGJpbnxyZWx8b3JkKSBvZiB0aGUgYXRvbSBpbiB0aGUgYXJndW1lbnQuXG4gIC8vIChieSByZW5kZXJpbmcgc2VwYXJhdGVseSBhbmQgd2l0aCB7fXMgYmVmb3JlIGFuZCBhZnRlciwgYW5kIG1lYXN1cmluZ1xuICAvLyB0aGUgY2hhbmdlIGluIHNwYWNpbmcpLiAgV2UnbGwgZG8gcm91Z2hseSB0aGUgc2FtZSBieSBkZXRlY3RpbmcgdGhlXG4gIC8vIGF0b20gdHlwZSBkaXJlY3RseS5cbiAgdmFyIGF0b20gPSBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiICYmIGFyZy5ib2R5Lmxlbmd0aCA/IGFyZy5ib2R5WzBdIDogYXJnO1xuXG4gIGlmIChhdG9tLnR5cGUgPT09IFwiYXRvbVwiICYmIChhdG9tLmZhbWlseSA9PT0gXCJiaW5cIiB8fCBhdG9tLmZhbWlseSA9PT0gXCJyZWxcIikpIHtcbiAgICByZXR1cm4gXCJtXCIgKyBhdG9tLmZhbWlseTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJtb3JkXCI7XG4gIH1cbn07IC8vIFxcQGJpbnJlbHt4fXt5fSByZW5kZXJzIGxpa2UgeSBidXQgYXMgbWJpbi9tcmVsL21vcmQgaWYgeCBpcyBtYmluL21yZWwvbW9yZC5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBcXGJpbnJlbEB7eH1cXGJpbnJlbEBAe3l9IGluIEFNU1RlWC5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXEBiaW5yZWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goYXJnc1sxXSlcbiAgICB9O1xuICB9XG5cbn0pOyAvLyBCdWlsZCBhIHJlbGF0aW9uIG9yIHN0YWNrZWQgb3AgYnkgcGxhY2luZyBvbmUgc3ltYm9sIG9uIHRvcCBvZiBhbm90aGVyXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxzdGFja3JlbFwiLCBcIlxcXFxvdmVyc2V0XCIsIFwiXFxcXHVuZGVyc2V0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYzO1xuICAgIHZhciBiYXNlQXJnID0gYXJnc1sxXTtcbiAgICB2YXIgc2hpZnRlZEFyZyA9IGFyZ3NbMF07XG4gICAgdmFyIG1jbGFzcztcblxuICAgIGlmIChmdW5jTmFtZSAhPT0gXCJcXFxcc3RhY2tyZWxcIikge1xuICAgICAgLy8gTGFUZVggYXBwbGllcyBcXGJpbnJlbCBzcGFjaW5nIHRvIFxcb3ZlcnNldCBhbmQgXFx1bmRlcnNldC5cbiAgICAgIG1jbGFzcyA9IGJpbnJlbENsYXNzKGJhc2VBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtY2xhc3MgPSBcIm1yZWxcIjsgLy8gZm9yIFxcc3RhY2tyZWxcbiAgICB9XG5cbiAgICB2YXIgYmFzZU9wID0ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogYmFzZUFyZy5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzQmFzZVNoaWZ0OiBmdW5jTmFtZSAhPT0gXCJcXFxcc3RhY2tyZWxcIixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJhc2VBcmcpXG4gICAgfTtcbiAgICB2YXIgc3Vwc3ViID0ge1xuICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgIG1vZGU6IHNoaWZ0ZWRBcmcubW9kZSxcbiAgICAgIGJhc2U6IGJhc2VPcCxcbiAgICAgIHN1cDogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBudWxsIDogc2hpZnRlZEFyZyxcbiAgICAgIHN1YjogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBzaGlmdGVkQXJnIDogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzcyxcbiAgICAgIGJvZHk6IFtzdXBzdWJdLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KHN1cHN1YilcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ2LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG4vLyBUT0RPKGtldmluYik6IGltcGxlbWVudCBcXFxcc2wgYW5kIFxcXFxzY1xuXG52YXIgaHRtbEJ1aWxkZXIkNSA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoRm9udChmb250KTtcbiAgcmV0dXJuIGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDQgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGZvbnQgPSBncm91cC5mb250O1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZEdyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xufTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICBcIlxcXFxCYmJcIjogXCJcXFxcbWF0aGJiXCIsXG4gIFwiXFxcXGJvbGRcIjogXCJcXFxcbWF0aGJmXCIsXG4gIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIixcbiAgXCJcXFxcYm1cIjogXCJcXFxcYm9sZHN5bWJvbFwiXG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFsvLyBzdHlsZXMsIGV4Y2VwdCBcXGJvbGRzeW1ib2wgZGVmaW5lZCBiZWxvd1xuICBcIlxcXFxtYXRocm1cIiwgXCJcXFxcbWF0aGl0XCIsIFwiXFxcXG1hdGhiZlwiLCBcIlxcXFxtYXRobm9ybWFsXCIsIC8vIGZhbWlsaWVzXG4gIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsIFwiXFxcXG1hdGh0dFwiLCAvLyBhbGlhc2VzLCBleGNlcHQgXFxibSBkZWZpbmVkIGJlbG93XG4gIFwiXFxcXEJiYlwiLCBcIlxcXFxib2xkXCIsIFwiXFxcXGZyYWtcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBib2R5ID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgdmFyIGZ1bmMgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmdW5jIGluIGZvbnRBbGlhc2VzKSB7XG4gICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ1LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDRcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXGJvbGRzeW1ib2xcIiwgXCJcXFxcYm1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJCb3ggPSB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KTsgLy8gYW1zYnN5LnN0eSdzIFxcYm9sZHN5bWJvbCB1c2VzIFxcYmlucmVsIHNwYWNpbmcgdG8gaW5oZXJpdCB0aGVcbiAgICAvLyBhcmd1bWVudCdzIGJpbnxyZWx8b3JkIHN0YXR1c1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYm9keSksXG4gICAgICBib2R5OiBbe1xuICAgICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGZvbnQ6IFwiYm9sZHN5bWJvbFwiLFxuICAgICAgICBib2R5XG4gICAgICB9XSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiBpc0NoYXJhY3RlckJveFxuICAgIH07XG4gIH1cbn0pOyAvLyBPbGQgZm9udCBjaGFuZ2luZyBmdW5jdGlvbnNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxybVwiLCBcIlxcXFxzZlwiLCBcIlxcXFx0dFwiLCBcIlxcXFxiZlwiLCBcIlxcXFxpdFwiLCBcIlxcXFxjYWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMywgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIGJyZWFrT25Ub2tlblRleHRcbiAgICB9ID0gX3JlZjM7XG4gICAgdmFyIHtcbiAgICAgIG1vZGVcbiAgICB9ID0gcGFyc2VyO1xuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICB2YXIgc3R5bGUgPSBcIm1hdGhcIiArIGZ1bmNOYW1lLnNsaWNlKDEpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBmb250OiBzdHlsZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgYm9keVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ1LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDRcbn0pO1xuXG52YXIgYWRqdXN0U3R5bGUgPSAoc2l6ZSwgb3JpZ2luYWxTdHlsZSkgPT4ge1xuICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdGhpcyBmcmFjdGlvbiBzaG91bGQgYmUgaW4gYmFzZWQgb24gdGhlXG4gIC8vIGZ1bmN0aW9uIHVzZWRcbiAgdmFyIHN0eWxlID0gb3JpZ2luYWxTdHlsZTtcblxuICBpZiAoc2l6ZSA9PT0gXCJkaXNwbGF5XCIpIHtcbiAgICAvLyBHZXQgZGlzcGxheSBzdHlsZSBhcyBhIGRlZmF1bHQuXG4gICAgLy8gSWYgaW5jb21pbmcgc3R5bGUgaXMgc3ViL3N1cCwgdXNlIHN0eWxlLnRleHQoKSB0byBnZXQgY29ycmVjdCBzaXplLlxuICAgIHN0eWxlID0gc3R5bGUuaWQgPj0gU3R5bGUkMS5TQ1JJUFQuaWQgPyBzdHlsZS50ZXh0KCkgOiBTdHlsZSQxLkRJU1BMQVk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJ0ZXh0XCIgJiYgc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUpIHtcbiAgICAvLyBXZSdyZSBpbiBhIFxcdGZyYWMgYnV0IGluY29taW5nIHN0eWxlIGlzIGRpc3BsYXlzdHlsZSwgc286XG4gICAgc3R5bGUgPSBTdHlsZSQxLlRFWFQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJzY3JpcHRcIikge1xuICAgIHN0eWxlID0gU3R5bGUkMS5TQ1JJUFQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gXCJzY3JpcHRzY3JpcHRcIikge1xuICAgIHN0eWxlID0gU3R5bGUkMS5TQ1JJUFRTQ1JJUFQ7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgaHRtbEJ1aWxkZXIkNCA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAvLyBGcmFjdGlvbnMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZXMgNDQ0LTQ0NSwgcnVsZXMgMTUoYS1lKS5cbiAgdmFyIHN0eWxlID0gYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG4gIHZhciBuc3R5bGUgPSBzdHlsZS5mcmFjTnVtKCk7XG4gIHZhciBkc3R5bGUgPSBzdHlsZS5mcmFjRGVuKCk7XG4gIHZhciBuZXdPcHRpb25zO1xuICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuc3R5bGUpO1xuICB2YXIgbnVtZXJtID0gYnVpbGRHcm91cCQxKGdyb3VwLm51bWVyLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICBpZiAoZ3JvdXAuY29udGludWVkKSB7XG4gICAgLy8gXFxjZnJhYyBpbnNlcnRzIGEgXFxzdHJ1dCBpbnRvIHRoZSBudW1lcmF0b3IuXG4gICAgLy8gR2V0IFxcc3RydXQgZGltZW5zaW9ucyBmcm9tIFRlWGJvb2sgcGFnZSAzNTMuXG4gICAgdmFyIGhTdHJ1dCA9IDguNSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgIHZhciBkU3RydXQgPSAzLjUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgICBudW1lcm0uaGVpZ2h0ID0gbnVtZXJtLmhlaWdodCA8IGhTdHJ1dCA/IGhTdHJ1dCA6IG51bWVybS5oZWlnaHQ7XG4gICAgbnVtZXJtLmRlcHRoID0gbnVtZXJtLmRlcHRoIDwgZFN0cnV0ID8gZFN0cnV0IDogbnVtZXJtLmRlcHRoO1xuICB9XG5cbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoZHN0eWxlKTtcbiAgdmFyIGRlbm9tbSA9IGJ1aWxkR3JvdXAkMShncm91cC5kZW5vbSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG4gIHZhciBydWxlO1xuICB2YXIgcnVsZVdpZHRoO1xuICB2YXIgcnVsZVNwYWNpbmc7XG5cbiAgaWYgKGdyb3VwLmhhc0JhckxpbmUpIHtcbiAgICBpZiAoZ3JvdXAuYmFyU2l6ZSkge1xuICAgICAgcnVsZVdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBvcHRpb25zKTtcbiAgICAgIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJmcmFjLWxpbmVcIiwgb3B0aW9ucywgcnVsZVdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImZyYWMtbGluZVwiLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBydWxlV2lkdGggPSBydWxlLmhlaWdodDtcbiAgICBydWxlU3BhY2luZyA9IHJ1bGUuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJ1bGUgPSBudWxsO1xuICAgIHJ1bGVXaWR0aCA9IDA7XG4gICAgcnVsZVNwYWNpbmcgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gIH0gLy8gUnVsZSAxNWJcblxuXG4gIHZhciBudW1TaGlmdDtcbiAgdmFyIGNsZWFyYW5jZTtcbiAgdmFyIGRlbm9tU2hpZnQ7XG5cbiAgaWYgKHN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplIHx8IGdyb3VwLnNpemUgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMTtcblxuICAgIGlmIChydWxlV2lkdGggPiAwKSB7XG4gICAgICBjbGVhcmFuY2UgPSAzICogcnVsZVNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyYW5jZSA9IDcgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMjtcbiAgICAgIGNsZWFyYW5jZSA9IHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5udW0zO1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH1cblxuICAgIGRlbm9tU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVub20yO1xuICB9XG5cbiAgdmFyIGZyYWM7XG5cbiAgaWYgKCFydWxlKSB7XG4gICAgLy8gUnVsZSAxNWNcbiAgICB2YXIgY2FuZGlkYXRlQ2xlYXJhbmNlID0gbnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZUNsZWFyYW5jZSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICBkZW5vbVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpO1xuICAgIH1cblxuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBudW1lcm0sXG4gICAgICAgIHNoaWZ0OiAtbnVtU2hpZnRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUnVsZSAxNWRcbiAgICB2YXIgYXhpc0hlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuXG4gICAgaWYgKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDwgY2xlYXJhbmNlKSB7XG4gICAgICBudW1TaGlmdCArPSBjbGVhcmFuY2UgLSAobnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoYXhpc0hlaWdodCArIDAuNSAqIHJ1bGVXaWR0aCkpO1xuICAgIH1cblxuICAgIGlmIChheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KSA8IGNsZWFyYW5jZSkge1xuICAgICAgZGVub21TaGlmdCArPSBjbGVhcmFuY2UgLSAoYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCkpO1xuICAgIH1cblxuICAgIHZhciBtaWRTaGlmdCA9IC0oYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCk7XG4gICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGRlbm9tbSxcbiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHJ1bGUsXG4gICAgICAgIHNoaWZ0OiBtaWRTaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbnVtZXJtLFxuICAgICAgICBzaGlmdDogLW51bVNoaWZ0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IC8vIFNpbmNlIHdlIG1hbnVhbGx5IGNoYW5nZSB0aGUgc3R5bGUgc29tZXRpbWVzICh3aXRoIFxcZGZyYWMgb3IgXFx0ZnJhYyksXG4gIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuXG5cbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpO1xuICBmcmFjLmhlaWdodCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgZnJhYy5kZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gUnVsZSAxNWVcblxuICB2YXIgZGVsaW1TaXplO1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBTdHlsZSQxLkRJU1BMQVkuc2l6ZSkge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTE7XG4gIH0gZWxzZSBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5TQ1JJUFRTQ1JJUFQuc2l6ZSkge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoU3R5bGUkMS5TQ1JJUFQpLmZvbnRNZXRyaWNzKCkuZGVsaW0yO1xuICB9IGVsc2Uge1xuICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTI7XG4gIH1cblxuICB2YXIgbGVmdERlbGltO1xuICB2YXIgcmlnaHREZWxpbTtcblxuICBpZiAoZ3JvdXAubGVmdERlbGltID09IG51bGwpIHtcbiAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtb3BlblwiXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAubGVmdERlbGltLCBkZWxpbVNpemUsIHRydWUsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gIH1cblxuICBpZiAoZ3JvdXAuY29udGludWVkKSB7XG4gICAgcmlnaHREZWxpbSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdKTsgLy8gemVybyB3aWR0aCBmb3IgXFxjZnJhY1xuICB9IGVsc2UgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gPT0gbnVsbCkge1xuICAgIHJpZ2h0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xuICB9IGVsc2Uge1xuICAgIHJpZ2h0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShncm91cC5yaWdodERlbGltLCBkZWxpbVNpemUsIHRydWUsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0uY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIFtsZWZ0RGVsaW0sIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1mcmFjXCJdLCBbZnJhY10pLCByaWdodERlbGltXSwgb3B0aW9ucyk7XG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciQzID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZnJhY1wiLCBbYnVpbGRHcm91cChncm91cC5udW1lciwgb3B0aW9ucyksIGJ1aWxkR3JvdXAoZ3JvdXAuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgaWYgKCFncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICB2YXIgcnVsZVdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBvcHRpb25zKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgbWFrZUVtKHJ1bGVXaWR0aCkpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gYWRqdXN0U3R5bGUoZ3JvdXAuc2l6ZSwgb3B0aW9ucy5zdHlsZSk7XG5cbiAgaWYgKHN0eWxlLnNpemUgIT09IG9wdGlvbnMuc3R5bGUuc2l6ZSkge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbm9kZV0pO1xuICAgIHZhciBpc0Rpc3BsYXkgPSBzdHlsZS5zaXplID09PSBTdHlsZSQxLkRJU1BMQVkuc2l6ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIGlzRGlzcGxheSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjBcIik7XG4gIH1cblxuICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwgfHwgZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgdmFyIHdpdGhEZWxpbXMgPSBbXTtcblxuICAgIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgdmFyIGxlZnRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLmxlZnREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSldKTtcbiAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gobGVmdE9wKTtcbiAgICB9XG5cbiAgICB3aXRoRGVsaW1zLnB1c2gobm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmlnaHRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLnJpZ2h0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXSk7XG4gICAgICByaWdodE9wLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZVJvdyh3aXRoRGVsaW1zKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxkZnJhY1wiLCBcIlxcXFxmcmFjXCIsIFwiXFxcXHRmcmFjXCIsIFwiXFxcXGRiaW5vbVwiLCBcIlxcXFxiaW5vbVwiLCBcIlxcXFx0Ymlub21cIiwgXCJcXFxcXFxcXGF0b3BmcmFjXCIsIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBcIlxcXFxcXFxcYnJhY2VmcmFjXCIsIFwiXFxcXFxcXFxicmFja2ZyYWNcIiAvLyBkaXR0b1xuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXFxcXFxhdG9wZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFxiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiKVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJcXFxce1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJcXFxcfVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCJbXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgc2l6ZSA9IFwidGV4dFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzaXplLFxuICAgICAgYmFyU2l6ZTogbnVsbFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ0LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDNcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxjZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMjtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IHRydWUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZTogdHJ1ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzaXplOiBcImRpc3BsYXlcIixcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9XG59KTsgLy8gSW5maXggZ2VuZXJhbGl6ZWQgZnJhY3Rpb25zIC0tIHRoZXNlIGFyZSBub3QgcmVuZGVyZWQgZGlyZWN0bHksIGJ1dCByZXBsYWNlZFxuLy8gaW1tZWRpYXRlbHkgYnkgb25lIG9mIHRoZSB2YXJpYW50cyBhYm92ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlclwiLCBcIlxcXFxjaG9vc2VcIiwgXCJcXFxcYXRvcFwiLCBcIlxcXFxicmFjZVwiLCBcIlxcXFxicmFja1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHRva2VuXG4gICAgfSA9IF9yZWYzO1xuICAgIHZhciByZXBsYWNlV2l0aDtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcb3ZlclwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcYmlub21cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYXRvcFwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxicmFjZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFjZWZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2tcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG5cbn0pO1xudmFyIHN0eWxBcnJheSA9IFtcImRpc3BsYXlcIiwgXCJ0ZXh0XCIsIFwic2NyaXB0XCIsIFwic2NyaXB0c2NyaXB0XCJdO1xuXG52YXIgZGVsaW1Gcm9tVmFsdWUgPSBmdW5jdGlvbiBkZWxpbUZyb21WYWx1ZShkZWxpbVN0cmluZykge1xuICB2YXIgZGVsaW0gPSBudWxsO1xuXG4gIGlmIChkZWxpbVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgZGVsaW0gPSBkZWxpbVN0cmluZztcbiAgICBkZWxpbSA9IGRlbGltID09PSBcIi5cIiA/IG51bGwgOiBkZWxpbTtcbiAgfVxuXG4gIHJldHVybiBkZWxpbTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2VuZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA2LFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwibWF0aFwiLCBcInNpemVcIiwgXCJ0ZXh0XCIsIFwibWF0aFwiLCBcIm1hdGhcIl1cbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0LCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmNDtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzRdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbNV07IC8vIExvb2sgaW50byB0aGUgcGFyc2Ugbm9kZXMgdG8gZ2V0IHRoZSBkZXNpcmVkIGRlbGltaXRlcnMuXG5cbiAgICB2YXIgbGVmdE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICB2YXIgbGVmdERlbGltID0gbGVmdE5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgbGVmdE5vZGUuZmFtaWx5ID09PSBcIm9wZW5cIiA/IGRlbGltRnJvbVZhbHVlKGxlZnROb2RlLnRleHQpIDogbnVsbDtcbiAgICB2YXIgcmlnaHROb2RlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1sxXSk7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSByaWdodE5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgcmlnaHROb2RlLmZhbWlseSA9PT0gXCJjbG9zZVwiID8gZGVsaW1Gcm9tVmFsdWUocmlnaHROb2RlLnRleHQpIDogbnVsbDtcbiAgICB2YXIgYmFyTm9kZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMl0sIFwic2l6ZVwiKTtcbiAgICB2YXIgaGFzQmFyTGluZTtcbiAgICB2YXIgYmFyU2l6ZSA9IG51bGw7XG5cbiAgICBpZiAoYmFyTm9kZS5pc0JsYW5rKSB7XG4gICAgICAvLyBcXGdlbmZyYWMgYWN0cyBkaWZmZXJlbnRseSB0aGFuIFxcYWJvdmUuXG4gICAgICAvLyBcXGdlbmZyYWMgdHJlYXRzIGFuIGVtcHR5IHNpemUgZ3JvdXAgYXMgYSBzaWduYWwgdG8gdXNlIGFcbiAgICAgIC8vIHN0YW5kYXJkIGJhciBzaXplLiBcXGFib3ZlIHdvdWxkIHNlZSBzaXplID0gMCBhbmQgb21pdCB0aGUgYmFyLlxuICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhclNpemUgPSBiYXJOb2RlLnZhbHVlO1xuICAgICAgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICB9IC8vIEZpbmQgb3V0IGlmIHdlIHdhbnQgZGlzcGxheXN0eWxlLCB0ZXh0c3R5bGUsIGV0Yy5cblxuXG4gICAgdmFyIHNpemUgPSBcImF1dG9cIjtcbiAgICB2YXIgc3R5bCA9IGFyZ3NbM107XG5cbiAgICBpZiAoc3R5bC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIGlmIChzdHlsLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGV4dE9yZCA9IGFzc2VydE5vZGVUeXBlKHN0eWwuYm9keVswXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBzaXplID0gc3R5bEFycmF5W051bWJlcih0ZXh0T3JkLnRleHQpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bCA9IGFzc2VydE5vZGVUeXBlKHN0eWwsIFwidGV4dG9yZFwiKTtcbiAgICAgIHNpemUgPSBzdHlsQXJyYXlbTnVtYmVyKHN0eWwudGV4dCldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzaXplXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNCxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTsgLy8gXFxhYm92ZSBpcyBhbiBpbmZpeCBmcmFjdGlvbiB0aGF0IGFsc28gZGVmaW5lcyBhIGZyYWN0aW9uIGJhciBzaXplLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxhYm92ZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNSwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHRva2VuXG4gICAgfSA9IF9yZWY1O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoOiBcIlxcXFxcXFxcYWJvdmVmcmFjXCIsXG4gICAgICBzaXplOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWUsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXFxcXFxhYm92ZWZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcInNpemVcIiwgXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmNiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmNjtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBiYXJTaXplID0gYXNzZXJ0KGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwiaW5maXhcIikuc2l6ZSk7XG4gICAgdmFyIGRlbm9tID0gYXJnc1syXTtcbiAgICB2YXIgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2l6ZTogXCJhdXRvXCJcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNCxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTtcblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJob3JpekJyYWNlXCIsIGJ1dFxuLy8gYWxzbyBcInN1cHN1YlwiIHNpbmNlIGFuIG92ZXIvdW5kZXJicmFjZSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cbnZhciBodG1sQnVpbGRlciQzID0gKGdycCwgb3B0aW9ucykgPT4ge1xuICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlOyAvLyBQdWxsIG91dCB0aGUgYFBhcnNlTm9kZTxcImhvcml6QnJhY2VcIj5gIGlmIGBncnBgIGlzIGEgXCJzdXBzdWJcIiBub2RlLlxuXG4gIHZhciBzdXBTdWJHcm91cDtcbiAgdmFyIGdyb3VwO1xuXG4gIGlmIChncnAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIC8vIFJlZjogTGFUZVggc291cmNlMmU6IH19fX1cXGxpbWl0c31cbiAgICAvLyBpLmUuIExhVGVYIHRyZWF0cyB0aGUgYnJhY2Ugc2ltaWxhciB0byBhbiBvcCBhbmQgcGFzc2VzIGl0XG4gICAgLy8gd2l0aCBcXGxpbWl0cywgc28gd2UgbmVlZCB0byBhc3NpZ24gc3Vwc3ViIHN0eWxlLlxuICAgIHN1cFN1Ykdyb3VwID0gZ3JwLnN1cCA/IGJ1aWxkR3JvdXAkMShncnAuc3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKSwgb3B0aW9ucykgOiBidWlsZEdyb3VwJDEoZ3JwLnN1Yiwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJob3JpekJyYWNlXCIpO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShTdHlsZSQxLkRJU1BMQVkpKTsgLy8gQ3JlYXRlIHRoZSBzdHJldGNoeSBlbGVtZW50XG5cbiAgdmFyIGJyYWNlQm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpOyAvLyBHZW5lcmF0ZSB0aGUgdmxpc3QsIHdpdGggdGhlIGFwcHJvcHJpYXRlIGtlcm5zICAgICAgICDilI/ilIHilIHilIHilIHilIHilIHilIHilIHilJNcbiAgLy8gVGhpcyBmaXJzdCB2bGlzdCBjb250YWlucyB0aGUgY29udGVudCBhbmQgdGhlIGJyYWNlOiAgIGVxdWF0aW9uXG5cbiAgdmFyIHZsaXN0O1xuXG4gIGlmIChncm91cC5pc092ZXIpIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJyYWNlQm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMV0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICB9IGVsc2Uge1xuICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgIHBvc2l0aW9uRGF0YTogYm9keS5kZXB0aCArIDAuMSArIGJyYWNlQm9keS5oZWlnaHQsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJyYWNlQm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMC4xXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpOyAvLyAkRmxvd0ZpeE1lOiBSZXBsYWNlIHRoaXMgd2l0aCBwYXNzaW5nIFwic3ZnLWFsaWduXCIgaW50byBtYWtlVkxpc3QuXG5cbiAgICB2bGlzdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jbGFzc2VzLnB1c2goXCJzdmctYWxpZ25cIik7XG4gIH1cblxuICBpZiAoc3VwU3ViR3JvdXApIHtcbiAgICAvLyBUbyB3cml0ZSB0aGUgc3Vwc3ViLCB3cmFwIHRoZSBmaXJzdCB2bGlzdCBpbiBhbm90aGVyIHZsaXN0OlxuICAgIC8vIFRoZXkgY2FuJ3QgYWxsIGdvIGluIHRoZSBzYW1lIHZsaXN0LCBiZWNhdXNlIHRoZSBub3RlIG1pZ2h0IGJlXG4gICAgLy8gd2lkZXIgdGhhbiB0aGUgZXF1YXRpb24uIFdlIHdhbnQgdGhlIGVxdWF0aW9uIHRvIGNvbnRyb2wgdGhlXG4gICAgLy8gYnJhY2Ugd2lkdGguXG4gICAgLy8gICAgICBub3RlICAgICAgICAgIGxvbmcgbm90ZSAgICAgICAgICAgbG9uZyBub3RlXG4gICAgLy8gICDilI/ilIHilIHilIHilIHilIHilIHilIHilIHilJMgICBvciAgICDilI/ilIHilIHilIHilJMgICAgIG5vdCAgICDilI/ilIHilIHilIHilIHilIHilIHilIHilIHilIHilJNcbiAgICAvLyAgICBlcXVhdGlvbiAgICAgICAgICAgZXFuICAgICAgICAgICAgICAgICBlcW5cbiAgICB2YXIgdlNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcblxuICAgIGlmIChncm91cC5pc092ZXIpIHtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdlNwYW5cbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IDAuMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXBcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiB2U3Bhbi5kZXB0aCArIDAuMiArIHN1cFN1Ykdyb3VwLmhlaWdodCArIHN1cFN1Ykdyb3VwLmRlcHRoLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBzdXBTdWJHcm91cFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgICAgc2l6ZTogMC4yXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB2U3BhblxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xufTtcblxudmFyIG1hdGhtbEJ1aWxkZXIkMiA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbn07IC8vIEhvcml6b250YWwgc3RyZXRjaHkgYnJhY2VzXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVyYnJhY2VcIiwgXCJcXFxcdW5kZXJicmFjZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBpc092ZXI6IC9eXFxcXG92ZXIvLnRlc3QoZnVuY05hbWUpLFxuICAgICAgYmFzZTogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDMsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHJlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJ1cmxcIiwgXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBib2R5ID0gYXJnc1sxXTtcbiAgICB2YXIgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFxocmVmXCIsXG4gICAgICB1cmw6IGhyZWZcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChcIlxcXFxocmVmXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHJlZixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUFuY2hvcihncm91cC5ocmVmLCBbXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgbWF0aCA9IGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKTtcblxuICAgIGlmICghKG1hdGggaW5zdGFuY2VvZiBNYXRoTm9kZSkpIHtcbiAgICAgIG1hdGggPSBuZXcgTWF0aE5vZGUoXCJtcm93XCIsIFttYXRoXSk7XG4gICAgfVxuXG4gICAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGdyb3VwLmhyZWYpO1xuICAgIHJldHVybiBtYXRoO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcdXJsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgdmFyIGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgY29tbWFuZDogXCJcXFxcdXJsXCIsXG4gICAgICB1cmw6IGhyZWZcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChcIlxcXFx1cmxcIik7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhyZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gaHJlZltpXTtcblxuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBcIlxcXFx0ZXh0dHRcIixcbiAgICAgIGJvZHk6IGNoYXJzXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWYsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBJbiBMYVRlWCwgXFx2Y2VudGVyIGNhbiBhY3Qgb25seSBvbiBhIGJveCwgYXMgaW5cbi8vIFxcdmNlbnRlcntcXGhib3h7JFxcZnJhY3thK2J9e1xcZGZyYWN7Y317ZH19JH19XG4vLyBUaGlzIGZ1bmN0aW9uIGJ5IGl0c2VsZiBkb2Vzbid0IGRvIGFueXRoaW5nIGJ1dCBwcmV2ZW50IGEgc29mdCBsaW5lIGJyZWFrLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaGJveFwiLFxuICBuYW1lczogW1wiXFxcXGhib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucykpO1xuICB9XG5cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHRtbFwiLFxuICBuYW1lczogW1wiXFxcXGh0bWxDbGFzc1wiLCBcIlxcXFxodG1sSWRcIiwgXCJcXFxcaHRtbFN0eWxlXCIsIFwiXFxcXGh0bWxEYXRhXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmO1xuICAgIHZhciB2YWx1ZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG5cbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcImh0bWxFeHRlbnNpb25cIiwgXCJIVE1MIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCBvbiBzdHJpY3QgbW9kZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgdHJ1c3RDb250ZXh0O1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGh0bWxDbGFzc1wiOlxuICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sQ2xhc3NcIixcbiAgICAgICAgICBjbGFzczogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcaHRtbElkXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGh0bWxJZFwiLFxuICAgICAgICAgIGlkOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxodG1sU3R5bGVcIjpcbiAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcaHRtbFN0eWxlXCIsXG4gICAgICAgICAgc3R5bGU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGh0bWxEYXRhXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleVZhbCA9IGRhdGFbaV0uc3BsaXQoXCI9XCIpO1xuXG4gICAgICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkVycm9yIHBhcnNpbmcga2V5LXZhbHVlIGZvciBcXFxcaHRtbERhdGFcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbXCJkYXRhLVwiICsga2V5VmFsWzBdLnRyaW0oKV0gPSBrZXlWYWxbMV0udHJpbSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGh0bWxEYXRhXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaHRtbCBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh0cnVzdENvbnRleHQpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKGZ1bmNOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJodG1sXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgdmFyIGNsYXNzZXMgPSBbXCJlbmNsb3NpbmdcIl07XG5cbiAgICBpZiAoZ3JvdXAuYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgY2xhc3Nlcy5wdXNoKC4uLmdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH1cblxuICAgIHZhciBzcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3NlcywgZWxlbWVudHMsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiBncm91cC5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0ciAhPT0gXCJjbGFzc1wiICYmIGdyb3VwLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoYXR0ciwgZ3JvdXAuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHRtbG1hdGhtbFwiLFxuICBuYW1lczogW1wiXFxcXGh0bWxAbWF0aG1sXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJodG1sbWF0aG1sXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGh0bWw6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pLFxuICAgICAgbWF0aG1sOiBvcmRhcmd1bWVudChhcmdzWzFdKVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5odG1sLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAubWF0aG1sLCBvcHRpb25zKTtcbiAgfVxufSk7XG5cbnZhciBzaXplRGF0YSA9IGZ1bmN0aW9uIHNpemVEYXRhKHN0cikge1xuICBpZiAoL15bLStdPyAqKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspJC8udGVzdChzdHIpKSB7XG4gICAgLy8gc3RyIGlzIGEgbnVtYmVyIHdpdGggbm8gdW5pdCBzcGVjaWZpZWQuXG4gICAgLy8gZGVmYXVsdCB1bml0IGlzIGJwLCBwZXIgZ3JhcGhpeCBwYWNrYWdlLlxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6ICtzdHIsXG4gICAgICB1bml0OiBcImJwXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBtYXRjaCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhzdHIpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHN0ciArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLFxuICAgICAgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcblxuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5jbHVkZWdyYXBoaWNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJ1cmxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIHdpZHRoID0ge1xuICAgICAgbnVtYmVyOiAwLFxuICAgICAgdW5pdDogXCJlbVwiXG4gICAgfTtcbiAgICB2YXIgaGVpZ2h0ID0ge1xuICAgICAgbnVtYmVyOiAwLjksXG4gICAgICB1bml0OiBcImVtXCJcbiAgICB9OyAvLyBzb3J0YSBjaGFyYWN0ZXIgc2l6ZWQuXG5cbiAgICB2YXIgdG90YWxoZWlnaHQgPSB7XG4gICAgICBudW1iZXI6IDAsXG4gICAgICB1bml0OiBcImVtXCJcbiAgICB9O1xuICAgIHZhciBhbHQgPSBcIlwiO1xuXG4gICAgaWYgKG9wdEFyZ3NbMF0pIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVTdHIgPSBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7IC8vIFBhcnNlci5qcyBkb2VzIG5vdCBwYXJzZSBrZXkvdmFsdWUgcGFpcnMuIFdlIGdldCBhIHN0cmluZy5cblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVTdHIuc3BsaXQoXCIsXCIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleVZhbCA9IGF0dHJpYnV0ZXNbaV0uc3BsaXQoXCI9XCIpO1xuXG4gICAgICAgIGlmIChrZXlWYWwubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdmFyIHN0ciA9IGtleVZhbFsxXS50cmltKCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGtleVZhbFswXS50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbHRcIjpcbiAgICAgICAgICAgICAgYWx0ID0gc3RyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgIHdpZHRoID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b3RhbGhlaWdodFwiOlxuICAgICAgICAgICAgICB0b3RhbGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQga2V5OiAnXCIgKyBrZXlWYWxbMF0gKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChhbHQgPT09IFwiXCIpIHtcbiAgICAgIC8vIE5vIGFsdCBnaXZlbi4gVXNlIHRoZSBmaWxlIG5hbWUuIFN0cmlwIGF3YXkgdGhlIHBhdGguXG4gICAgICBhbHQgPSBzcmM7XG4gICAgICBhbHQgPSBhbHQucmVwbGFjZSgvXi4qW1xcXFwvXS8sICcnKTtcbiAgICAgIGFsdCA9IGFsdC5zdWJzdHJpbmcoMCwgYWx0Lmxhc3RJbmRleE9mKCcuJykpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICBjb21tYW5kOiBcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIHVybDogc3JjXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbHQ6IGFsdCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG90YWxoZWlnaHQ6IHRvdGFsaGVpZ2h0LFxuICAgICAgc3JjOiBzcmNcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gMDtcblxuICAgIGlmIChncm91cC53aWR0aC5udW1iZXIgPiAwKSB7XG4gICAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgIGhlaWdodDogbWFrZUVtKGhlaWdodCArIGRlcHRoKVxuICAgIH07XG5cbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtZGVwdGgpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IEltZyhncm91cC5zcmMsIGdyb3VwLmFsdCwgc3R5bGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG5vZGUuZGVwdGggPSBkZXB0aDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1nbHlwaFwiLCBbXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgZ3JvdXAuYWx0KTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgZGVwdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLnRvdGFsaGVpZ2h0LCBvcHRpb25zKSAtIGhlaWdodDtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidmFsaWduXCIsIG1ha2VFbSgtZGVwdGgpKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oaGVpZ2h0ICsgZGVwdGgpKTtcblxuICAgIGlmIChncm91cC53aWR0aC5udW1iZXIgPiAwKSB7XG4gICAgICB2YXIgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgbWFrZUVtKHdpZHRoKSk7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgZ3JvdXAuc3JjKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIEhvcml6b250YWwgc3BhY2luZyBjb21tYW5kc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwia2VyblwiLFxuICBuYW1lczogW1wiXFxcXGtlcm5cIiwgXCJcXFxcbWtlcm5cIiwgXCJcXFxcaHNraXBcIiwgXCJcXFxcbXNraXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBwcmltaXRpdmU6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBzaXplID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHZhciBtYXRoRnVuY3Rpb24gPSBmdW5jTmFtZVsxXSA9PT0gJ20nOyAvLyBcXG1rZXJuLCBcXG1za2lwXG5cbiAgICAgIHZhciBtdVVuaXQgPSBzaXplLnZhbHVlLnVuaXQgPT09ICdtdSc7XG5cbiAgICAgIGlmIChtYXRoRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCFtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgc3VwcG9ydHMgb25seSBtdSB1bml0cywgXCIgKyAoXCJub3QgXCIgKyBzaXplLnZhbHVlLnVuaXQgKyBcIiB1bml0c1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyLm1vZGUgIT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcIm1hdGhWc1RleHRVbml0c1wiLCBcIkxhVGVYJ3MgXCIgKyBmdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gbWF0aCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAhbWF0aEZ1bmN0aW9uXG4gICAgICAgIGlmIChtdVVuaXQpIHtcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwibWF0aFZzVGV4dFVuaXRzXCIsIFwiTGFUZVgncyBcIiArIGZ1bmNOYW1lICsgXCIgZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaW1lbnNpb246IHNpemUudmFsdWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VHbHVlKGdyb3VwLmRpbWVuc2lvbiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLmRpbWVuc2lvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlNwYWNlTm9kZShkaW1lbnNpb24pO1xuICB9XG5cbn0pO1xuXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFwXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGxsYXBcIiwgXCJcXFxcbWF0aHJsYXBcIiwgXCJcXFxcbWF0aGNsYXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLnNsaWNlKDUpLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBtYXRobGxhcCwgbWF0aHJsYXAsIG1hdGhjbGFwXG4gICAgdmFyIGlubmVyO1xuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJjbGFwXCIpIHtcbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cubWF0aC5sc3UuZWR1L35hcGVybGlzL3B1YmxpY2F0aW9ucy9tYXRoY2xhcC9cbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTsgLy8gd3JhcCwgc2luY2UgQ1NTIHdpbGwgY2VudGVyIGEgLmNsYXAgPiAuaW5uZXIgPiBzcGFuXG5cbiAgICAgIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiaW5uZXJcIl0sIFtpbm5lcl0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgdmFyIGZpeCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLmFsaWdubWVudF0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7IC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgY29ycmVjdGx5IHNldCBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGVcbiAgICAvLyB0d28gaXRlbXMgaW52b2x2ZWQgaW4gdGhlIGxhcC5cbiAgICAvLyBOZXh0LCB1c2UgYSBzdHJ1dCB0byBzZXQgdGhlIGhlaWdodCBvZiB0aGUgSFRNTCBib3VuZGluZyBib3guXG4gICAgLy8gT3RoZXJ3aXNlLCBhIHRhbGwgYXJndW1lbnQgbWF5IGJlIG1pc3BsYWNlZC5cbiAgICAvLyBUaGlzIGNvZGUgcmVzb2x2ZWQgaXNzdWUgIzExNTNcblxuICAgIHZhciBzdHJ1dCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cnV0XCJdKTtcbiAgICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0obm9kZS5oZWlnaHQgKyBub2RlLmRlcHRoKTtcblxuICAgIGlmIChub2RlLmRlcHRoKSB7XG4gICAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1ub2RlLmRlcHRoKTtcbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpOyAvLyBOZXh0LCBwcmV2ZW50IHZlcnRpY2FsIG1pc3BsYWNlbWVudCB3aGVuIG5leHQgdG8gc29tZXRoaW5nIHRhbGwuXG4gICAgLy8gVGhpcyBjb2RlIHJlc29sdmVzIGlzc3VlICMxMjM0XG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1widGhpbmJveFwiXSwgW25vZGVdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInZib3hcIl0sIFtub2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCAhPT0gXCJybGFwXCIpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiID8gXCItMVwiIDogXCItMC41XCI7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBvZmZzZXQgKyBcIndpZHRoXCIpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXChcIiwgXCIkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBvdXRlck1vZGUgPSBwYXJzZXIubW9kZTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShcIm1hdGhcIik7XG4gICAgdmFyIGNsb3NlID0gZnVuY05hbWUgPT09IFwiXFxcXChcIiA/IFwiXFxcXClcIiA6IFwiJFwiO1xuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgY2xvc2UpO1xuICAgIHBhcnNlci5leHBlY3QoY2xvc2UpO1xuICAgIHBhcnNlci5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzdHlsZTogXCJ0ZXh0XCIsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfVxuXG59KTsgLy8gQ2hlY2sgZm9yIGV4dHJhIGNsb3NpbmcgbWF0aCBkZWxpbWl0ZXJzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhpcyBpcy5cbiAgbmFtZXM6IFtcIlxcXFwpXCIsIFwiXFxcXF1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJNaXNtYXRjaGVkIFwiICsgY29udGV4dC5mdW5jTmFtZSk7XG4gIH1cblxufSk7XG5cbnZhciBjaG9vc2VNYXRoU3R5bGUgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgc3dpdGNoIChvcHRpb25zLnN0eWxlLnNpemUpIHtcbiAgICBjYXNlIFN0eWxlJDEuRElTUExBWS5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLmRpc3BsYXk7XG5cbiAgICBjYXNlIFN0eWxlJDEuVEVYVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG5cbiAgICBjYXNlIFN0eWxlJDEuU0NSSVBULnNpemU6XG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0O1xuXG4gICAgY2FzZSBTdHlsZSQxLlNDUklQVFNDUklQVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdHNjcmlwdDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRoY2hvaWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDQsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGlzcGxheTogb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICB0ZXh0OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIHNjcmlwdDogb3JkYXJndW1lbnQoYXJnc1syXSksXG4gICAgICBzY3JpcHRzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbM10pXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBib2R5ID0gY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShib2R5LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBib2R5ID0gY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGJvZHksIG9wdGlvbnMpO1xuICB9XG59KTtcblxudmFyIGFzc2VtYmxlU3VwU3ViID0gKGJhc2UsIHN1cEdyb3VwLCBzdWJHcm91cCwgb3B0aW9ucywgc3R5bGUsIHNsYW50LCBiYXNlU2hpZnQpID0+IHtcbiAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYmFzZV0pO1xuICB2YXIgc3ViSXNTaW5nbGVDaGFyYWN0ZXIgPSBzdWJHcm91cCAmJiB1dGlscy5pc0NoYXJhY3RlckJveChzdWJHcm91cCk7XG4gIHZhciBzdWI7XG4gIHZhciBzdXA7IC8vIFdlIG1hbnVhbGx5IGhhdmUgdG8gaGFuZGxlIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMuIFRoaXMsXG4gIC8vIGFzaWRlIGZyb20gdGhlIGtlcm4gY2FsY3VsYXRpb25zLCBpcyBjb3BpZWQgZnJvbSBzdXBzdWIuXG5cbiAgaWYgKHN1cEdyb3VwKSB7XG4gICAgdmFyIGVsZW0gPSBidWlsZEdyb3VwJDEoc3VwR3JvdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKTtcbiAgICBzdXAgPSB7XG4gICAgICBlbGVtLFxuICAgICAga2VybjogTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzEsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmczIC0gZWxlbS5kZXB0aClcbiAgICB9O1xuICB9XG5cbiAgaWYgKHN1Ykdyb3VwKSB7XG4gICAgdmFyIF9lbGVtID0gYnVpbGRHcm91cCQxKHN1Ykdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1YigpKSwgb3B0aW9ucyk7XG5cbiAgICBzdWIgPSB7XG4gICAgICBlbGVtOiBfZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcyLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNCAtIF9lbGVtLmhlaWdodClcbiAgICB9O1xuICB9IC8vIEJ1aWxkIHRoZSBmaW5hbCBncm91cCBhcyBhIHZsaXN0IG9mIHRoZSBwb3NzaWJsZSBzdWJzY3JpcHQsIGJhc2UsXG4gIC8vIGFuZCBwb3NzaWJsZSBzdXBlcnNjcmlwdC5cblxuXG4gIHZhciBmaW5hbEdyb3VwO1xuXG4gIGlmIChzdXAgJiYgc3ViKSB7XG4gICAgdmFyIGJvdHRvbSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1ICsgc3ViLmVsZW0uaGVpZ2h0ICsgc3ViLmVsZW0uZGVwdGggKyBzdWIua2VybiArIGJhc2UuZGVwdGggKyBiYXNlU2hpZnQ7XG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvdHRvbSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oLXNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1cC5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXAuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKHNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3ViKSB7XG4gICAgdmFyIHRvcCA9IGJhc2UuaGVpZ2h0IC0gYmFzZVNoaWZ0OyAvLyBTaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgLy8gdGhhdCB3ZSBhcmUgc3VwcG9zZWQgdG8gc2hpZnQgdGhlIGxpbWl0cyBieSAxLzIgb2YgdGhlIHNsYW50LFxuICAgIC8vIGJ1dCBzaW5jZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBsaW1pdHMgYWRkaW5nIGEgZnVsbCBzbGFudCBvZlxuICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuXG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IHRvcCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Yi5lbGVtLFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oLXNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogc3ViLmtlcm5cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc3VwKSB7XG4gICAgdmFyIF9ib3R0b20gPSBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IF9ib3R0b20sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJhc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1cC5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXAuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKHNsYW50KVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgIC8vIHN1cHN1YiB3YXMgc2VuZGluZyB1cyBhIGdyb3VwIHdpdGggbm8gc3VwZXJzY3JpcHQgb3JcbiAgICAvLyBzdWJzY3JpcHQpIGJ1dCBiZSBzYWZlLlxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gW2ZpbmFsR3JvdXBdO1xuXG4gIGlmIChzdWIgJiYgc2xhbnQgIT09IDAgJiYgIXN1YklzU2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgLy8gQSBuZWdhdGl2ZSBtYXJnaW4tbGVmdCB3YXMgYXBwbGllZCB0byB0aGUgbG93ZXIgbGltaXQuXG4gICAgLy8gQXZvaWQgYW4gb3ZlcmxhcCBieSBwbGFjaW5nIGEgc3BhY2VyIG9uIHRoZSBsZWZ0IG9uIHRoZSBncm91cC5cbiAgICB2YXIgc3BhY2VyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCJdLCBbXSwgb3B0aW9ucyk7XG4gICAgc3BhY2VyLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHNsYW50KTtcbiAgICBwYXJ0cy51bnNoaWZ0KHNwYWNlcik7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBwYXJ0cywgb3B0aW9ucyk7XG59O1xuXG4vLyBMaW1pdHMsIHN5bWJvbHNcbi8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG52YXIgbm9TdWNjZXNzb3IgPSBbXCJcXFxcc21hbGxpbnRcIl07IC8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwib3BcIiwgYnV0IGFsc29cbi8vIFwic3Vwc3ViXCIgc2luY2Ugc29tZSBvZiB0aGVtIChsaWtlIFxcaW50KSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cblxudmFyIGh0bWxCdWlsZGVyJDIgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIC8vIE9wZXJhdG9ycyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZy4gNDQzLTQ0NCwgcnVsZSAxMyhhKS5cbiAgdmFyIHN1cEdyb3VwO1xuICB2YXIgc3ViR3JvdXA7XG4gIHZhciBoYXNMaW1pdHMgPSBmYWxzZTtcbiAgdmFyIGdyb3VwO1xuXG4gIGlmIChncnAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAvLyBvdXQgdGhlIHN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHQgYW5kIHNldCB0aGUgZ3JvdXAgdG8gdGhlIG9wIGluXG4gICAgLy8gaXRzIGJhc2UuXG4gICAgc3VwR3JvdXAgPSBncnAuc3VwO1xuICAgIHN1Ykdyb3VwID0gZ3JwLnN1YjtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcIm9wXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BcIik7XG4gIH1cblxuICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICB2YXIgbGFyZ2UgPSBmYWxzZTtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUgJiYgZ3JvdXAuc3ltYm9sICYmICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHtcbiAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgbGFyZ2UgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGJhc2U7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzeW1ib2wsIGNyZWF0ZSB0aGUgc3ltYm9sLlxuICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICB2YXIgc3Rhc2ggPSBcIlwiO1xuXG4gICAgaWYgKGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpIHtcbiAgICAgIC8vIE5vIGZvbnQgZ2x5cGhzIHlldCwgc28gdXNlIGEgZ2x5cGggdy9vIHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgc3Rhc2ggPSBncm91cC5uYW1lLnN1YnN0cigxKTtcbiAgICAgIGdyb3VwLm5hbWUgPSBzdGFzaCA9PT0gXCJvaWludFwiID8gXCJcXFxcaWludFwiIDogXCJcXFxcaWlpbnRcIjtcbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVN5bWJvbChncm91cC5uYW1lLCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsIFtcIm1vcFwiLCBcIm9wLXN5bWJvbFwiLCBsYXJnZSA/IFwibGFyZ2Utb3BcIiA6IFwic21hbGwtb3BcIl0pO1xuXG4gICAgaWYgKHN0YXNoLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlJ3JlIGluIFxcb2lpbnQgb3IgXFxvaWlpbnQuIE92ZXJsYXkgdGhlIG92YWwuXG4gICAgICAvLyBUT0RPOiBXaGVuIGZvbnQgZ2x5cGhzIGFyZSBhdmFpbGFibGUsIGRlbGV0ZSB0aGlzIGNvZGUuXG4gICAgICB2YXIgaXRhbGljID0gYmFzZS5pdGFsaWM7XG4gICAgICB2YXIgb3ZhbCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhzdGFzaCArIFwiU2l6ZVwiICsgKGxhcmdlID8gXCIyXCIgOiBcIjFcIiksIG9wdGlvbnMpO1xuICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogYmFzZSxcbiAgICAgICAgICBzaGlmdDogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogb3ZhbCxcbiAgICAgICAgICBzaGlmdDogbGFyZ2UgPyAwLjA4IDogMFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBncm91cC5uYW1lID0gXCJcXFxcXCIgKyBzdGFzaDtcbiAgICAgIGJhc2UuY2xhc3Nlcy51bnNoaWZ0KFwibW9wXCIpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGJhc2UuaXRhbGljID0gaXRhbGljO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgaWYgKGlubmVyLmxlbmd0aCA9PT0gMSAmJiBpbm5lclswXSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICAgIGJhc2UgPSBpbm5lclswXTtcbiAgICAgIGJhc2UuY2xhc3Nlc1swXSA9IFwibW9wXCI7IC8vIHJlcGxhY2Ugb2xkIG1jbGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBpbm5lciwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEJ1aWxkIHRoZSB0ZXh0IGZyb20gdGhlXG4gICAgLy8gb3BlcmF0b3IncyBuYW1lLlxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ3JvdXAubmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShncm91cC5uYW1lW2ldLCBncm91cC5tb2RlLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiXSwgb3V0cHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiBjb250ZW50IG9mIG9wIGlzIGEgc2luZ2xlIHN5bWJvbCwgc2hpZnQgaXQgdmVydGljYWxseS5cblxuXG4gIHZhciBiYXNlU2hpZnQgPSAwO1xuICB2YXIgc2xhbnQgPSAwO1xuXG4gIGlmICgoYmFzZSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWlpbnRcIikgJiYgIWdyb3VwLnN1cHByZXNzQmFzZVNoaWZ0KSB7XG4gICAgLy8gV2Ugc3VwcHJlc3MgdGhlIHNoaWZ0IG9mIHRoZSBiYXNlIG9mIFxcb3ZlcnNldCBhbmQgXFx1bmRlcnNldC4gT3RoZXJ3aXNlLFxuICAgIC8vIHNoaWZ0IHRoZSBzeW1ib2wgc28gaXRzIGNlbnRlciBsaWVzIG9uIHRoZSBheGlzIChydWxlIDEzKS4gSXRcbiAgICAvLyBhcHBlYXJzIHRoYXQgb3VyIGZvbnRzIGhhdmUgdGhlIGNlbnRlcnMgb2YgdGhlIHN5bWJvbHMgYWxyZWFkeVxuICAgIC8vIGFsbW9zdCBvbiB0aGUgYXhpcywgc28gdGhlc2UgbnVtYmVycyBhcmUgdmVyeSBzbWFsbC4gTm90ZSB3ZVxuICAgIC8vIGRvbid0IGFjdHVhbGx5IGFwcGx5IHRoaXMgaGVyZSwgYnV0IGluc3RlYWQgaXQgaXMgdXNlZCBlaXRoZXIgaW5cbiAgICAvLyB0aGUgdmxpc3QgY3JlYXRpb24gb3Igc2VwYXJhdGVseSB3aGVuIHRoZXJlIGFyZSBubyBsaW1pdHMuXG4gICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7IC8vIFRoZSBzbGFudCBvZiB0aGUgc3ltYm9sIGlzIGp1c3QgaXRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgIC8vICRGbG93Rml4TWVcblxuICAgIHNsYW50ID0gYmFzZS5pdGFsaWM7XG4gIH1cblxuICBpZiAoaGFzTGltaXRzKSB7XG4gICAgcmV0dXJuIGFzc2VtYmxlU3VwU3ViKGJhc2UsIHN1cEdyb3VwLCBzdWJHcm91cCwgb3B0aW9ucywgc3R5bGUsIHNsYW50LCBiYXNlU2hpZnQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChiYXNlU2hpZnQpIHtcbiAgICAgIGJhc2Uuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBiYXNlLnN0eWxlLnRvcCA9IG1ha2VFbShiYXNlU2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciQxID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBub2RlO1xuXG4gIGlmIChncm91cC5zeW1ib2wpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubmFtZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIGlmICh1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGFyZ2VvcFwiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7XG4gICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgIC8vIG9wZXJhdG9yJ3MgbmFtZS5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibWlcIiwgW25ldyBUZXh0Tm9kZShncm91cC5uYW1lLnNsaWNlKDEpKV0pOyAvLyBBcHBlbmQgYW4gPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG5cbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuXG4gICAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibXJvd1wiLCBbbm9kZSwgb3BlcmF0b3JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgc2luZ2xlQ2hhckJpZ09wcyA9IHtcbiAgXCJcXHUyMjBGXCI6IFwiXFxcXHByb2RcIixcbiAgXCJcXHUyMjEwXCI6IFwiXFxcXGNvcHJvZFwiLFxuICBcIlxcdTIyMTFcIjogXCJcXFxcc3VtXCIsXG4gIFwiXFx1MjJjMFwiOiBcIlxcXFxiaWd3ZWRnZVwiLFxuICBcIlxcdTIyYzFcIjogXCJcXFxcYmlndmVlXCIsXG4gIFwiXFx1MjJjMlwiOiBcIlxcXFxiaWdjYXBcIixcbiAgXCJcXHUyMmMzXCI6IFwiXFxcXGJpZ2N1cFwiLFxuICBcIlxcdTJhMDBcIjogXCJcXFxcYmlnb2RvdFwiLFxuICBcIlxcdTJhMDFcIjogXCJcXFxcYmlnb3BsdXNcIixcbiAgXCJcXHUyYTAyXCI6IFwiXFxcXGJpZ290aW1lc1wiLFxuICBcIlxcdTJhMDRcIjogXCJcXFxcYmlndXBsdXNcIixcbiAgXCJcXHUyYTA2XCI6IFwiXFxcXGJpZ3NxY3VwXCJcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxjb3Byb2RcIiwgXCJcXFxcYmlndmVlXCIsIFwiXFxcXGJpZ3dlZGdlXCIsIFwiXFxcXGJpZ3VwbHVzXCIsIFwiXFxcXGJpZ2NhcFwiLCBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsIFwiXFxcXGJpZ29wbHVzXCIsIFwiXFxcXGJpZ29kb3RcIiwgXCJcXFxcYmlnc3FjdXBcIiwgXCJcXFxcc21hbGxpbnRcIiwgXCJcXHUyMjBGXCIsIFwiXFx1MjIxMFwiLCBcIlxcdTIyMTFcIiwgXCJcXHUyMmMwXCIsIFwiXFx1MjJjMVwiLCBcIlxcdTIyYzJcIiwgXCJcXHUyMmMzXCIsIFwiXFx1MmEwMFwiLCBcIlxcdTJhMDFcIiwgXCJcXHUyYTAyXCIsIFwiXFx1MmEwNFwiLCBcIlxcdTJhMDZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBmTmFtZSA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFyQmlnT3BzW2ZOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDFcbn0pOyAvLyBOb3RlOiBjYWxsaW5nIGRlZmluZUZ1bmN0aW9uIHdpdGggYSB0eXBlIHRoYXQncyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBvbmx5XG4vLyB3b3JrcyBiZWNhdXNlIHRoZSBzYW1lIGh0bWxCdWlsZGVyIGFuZCBtYXRobWxCdWlsZGVyIGFyZSBiZWluZyB1c2VkLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRob3BcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDFcbn0pOyAvLyBUaGVyZSBhcmUgMiBmbGFncyBmb3Igb3BlcmF0b3JzOyB3aGV0aGVyIHRoZXkgcHJvZHVjZSBsaW1pdHMgaW5cbi8vIGRpc3BsYXlzdHlsZSwgYW5kIHdoZXRoZXIgdGhleSBhcmUgc3ltYm9scyBhbmQgc2hvdWxkIGdyb3cgaW5cbi8vIGRpc3BsYXlzdHlsZS4gVGhlc2UgZm91ciBncm91cHMgY292ZXIgdGhlIGZvdXIgcG9zc2libGUgY2hvaWNlcy5cblxudmFyIHNpbmdsZUNoYXJJbnRlZ3JhbHMgPSB7XG4gIFwiXFx1MjIyYlwiOiBcIlxcXFxpbnRcIixcbiAgXCJcXHUyMjJjXCI6IFwiXFxcXGlpbnRcIixcbiAgXCJcXHUyMjJkXCI6IFwiXFxcXGlpaW50XCIsXG4gIFwiXFx1MjIyZVwiOiBcIlxcXFxvaW50XCIsXG4gIFwiXFx1MjIyZlwiOiBcIlxcXFxvaWludFwiLFxuICBcIlxcdTIyMzBcIjogXCJcXFxcb2lpaW50XCJcbn07IC8vIE5vIGxpbWl0cywgbm90IHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcYXJjc2luXCIsIFwiXFxcXGFyY2Nvc1wiLCBcIlxcXFxhcmN0YW5cIiwgXCJcXFxcYXJjdGdcIiwgXCJcXFxcYXJjY3RnXCIsIFwiXFxcXGFyZ1wiLCBcIlxcXFxjaFwiLCBcIlxcXFxjb3NcIiwgXCJcXFxcY29zZWNcIiwgXCJcXFxcY29zaFwiLCBcIlxcXFxjb3RcIiwgXCJcXFxcY290Z1wiLCBcIlxcXFxjb3RoXCIsIFwiXFxcXGNzY1wiLCBcIlxcXFxjdGdcIiwgXCJcXFxcY3RoXCIsIFwiXFxcXGRlZ1wiLCBcIlxcXFxkaW1cIiwgXCJcXFxcZXhwXCIsIFwiXFxcXGhvbVwiLCBcIlxcXFxrZXJcIiwgXCJcXFxcbGdcIiwgXCJcXFxcbG5cIiwgXCJcXFxcbG9nXCIsIFwiXFxcXHNlY1wiLCBcIlxcXFxzaW5cIiwgXCJcXFxcc2luaFwiLCBcIlxcXFxzaFwiLCBcIlxcXFx0YW5cIiwgXCJcXFxcdGFuaFwiLCBcIlxcXFx0Z1wiLCBcIlxcXFx0aFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTsgLy8gTGltaXRzLCBub3Qgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbWF4XCIsIFwiXFxcXG1pblwiLCBcIlxcXFxQclwiLCBcIlxcXFxzdXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjQpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTsgLy8gTm8gbGltaXRzLCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIiwgXCJcXFxcb2lpbnRcIiwgXCJcXFxcb2lpaW50XCIsIFwiXFx1MjIyYlwiLCBcIlxcdTIyMmNcIiwgXCJcXHUyMjJkXCIsIFwiXFx1MjIyZVwiLCBcIlxcdTIyMmZcIiwgXCJcXHUyMjMwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY1KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY1O1xuICAgIHZhciBmTmFtZSA9IGZ1bmNOYW1lO1xuXG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFySW50ZWdyYWxzW2ZOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDFcbn0pO1xuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seVxuLy8gXCJvcGVyYXRvcm5hbWVcIiwgYnV0IGFsc28gIFwic3Vwc3ViXCIgc2luY2UgXFxvcGVyYXRvcm5hbWUqIGNhblxuLy8gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cbnZhciBodG1sQnVpbGRlciQxID0gKGdycCwgb3B0aW9ucykgPT4ge1xuICAvLyBPcGVyYXRvcnMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0My00NDQsIHJ1bGUgMTMoYSkuXG4gIHZhciBzdXBHcm91cDtcbiAgdmFyIHN1Ykdyb3VwO1xuICB2YXIgaGFzTGltaXRzID0gZmFsc2U7XG4gIHZhciBncm91cDtcblxuICBpZiAoZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGxpbWl0cywgc3Vwc3ViIHdpbGwgcGFzcyB1cyBpdHMgZ3JvdXAgdG8gaGFuZGxlLiBQdWxsXG4gICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgIC8vIGl0cyBiYXNlLlxuICAgIHN1cEdyb3VwID0gZ3JwLnN1cDtcbiAgICBzdWJHcm91cCA9IGdycC5zdWI7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAuYmFzZSwgXCJvcGVyYXRvcm5hbWVcIik7XG4gICAgaGFzTGltaXRzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgXCJvcGVyYXRvcm5hbWVcIik7XG4gIH1cblxuICB2YXIgYmFzZTtcblxuICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGJvZHkgPSBncm91cC5ib2R5Lm1hcChjaGlsZCA9PiB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBDaGVjayBpZiB0aGUgbm9kZSBoYXMgYSBzdHJpbmcgYHRleHRgIHByb3BlcnR5LlxuICAgICAgdmFyIGNoaWxkVGV4dCA9IGNoaWxkLnRleHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogY2hpbGQubW9kZSxcbiAgICAgICAgICB0ZXh0OiBjaGlsZFRleHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ29uc29saWRhdGUgZnVuY3Rpb24gbmFtZXMgaW50byBzeW1ib2wgY2hhcmFjdGVycy5cblxuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uJDEoYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSwgdHJ1ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGV4cHJlc3Npb25baV07XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICAgICAgLy8gUGVyIGFtc29wbiBwYWNrYWdlLFxuICAgICAgICAvLyBjaGFuZ2UgbWludXMgdG8gaHlwaGVuIGFuZCBcXGFzdCB0byBhc3Rlcmlza1xuICAgICAgICBjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9cXHUyMjEyLywgXCItXCIpLnJlcGxhY2UoL1xcdTIyMTcvLCBcIipcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiXSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiXSwgW10sIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGhhc0xpbWl0cykge1xuICAgIHJldHVybiBhc3NlbWJsZVN1cFN1YihiYXNlLCBzdXBHcm91cCwgc3ViR3JvdXAsIG9wdGlvbnMsIG9wdGlvbnMuc3R5bGUsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAvLyBUaGUgc3RlcHMgdGFrZW4gaGVyZSBhcmUgc2ltaWxhciB0byB0aGUgaHRtbCB2ZXJzaW9uLlxuICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zLndpdGhGb250KFwibWF0aHJtXCIpKTsgLy8gSXMgZXhwcmVzc2lvbiBhIHN0cmluZyBvciBoYXMgaXQgc29tZXRoaW5nIGxpa2UgYSBmcmFjdGlvbj9cblxuICB2YXIgaXNBbGxTdHJpbmcgPSB0cnVlOyAvLyBkZWZhdWx0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlNwYWNlTm9kZSkgOyBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5NYXRoTm9kZSkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1pXCI6XG4gICAgICAgIGNhc2UgXCJtblwiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgY2FzZSBcIm1zcGFjZVwiOlxuICAgICAgICBjYXNlIFwibXRleHRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRG8gbm90aGluZyB5ZXQuXG5cbiAgICAgICAgY2FzZSBcIm1vXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5UZXh0Tm9kZSkge1xuICAgICAgICAgICAgICBjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9cXHUyMjEyLywgXCItXCIpLnJlcGxhY2UoL1xcdTIyMTcvLCBcIipcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0FsbFN0cmluZykge1xuICAgIC8vIFdyaXRlIGEgc2luZ2xlIFRleHROb2RlIGluc3RlYWQgb2YgbXVsdGlwbGUgbmVzdGVkIHRhZ3MuXG4gICAgdmFyIHdvcmQgPSBleHByZXNzaW9uLm1hcChub2RlID0+IG5vZGUudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gICAgZXhwcmVzc2lvbiA9IFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh3b3JkKV07XG4gIH1cblxuICB2YXIgaWRlbnRpZmllciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgZXhwcmVzc2lvbik7XG4gIGlkZW50aWZpZXIuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7IC8vIFxcdTIwNjEgaXMgdGhlIHNhbWUgYXMgJkFwcGx5RnVuY3Rpb247XG4gIC8vIHJlZjogaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9jaGFyc2V0cy9yZWZfaHRtbF9lbnRpdGllc19hLmFzcFxuXG4gIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcblxuICBpZiAoZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtpZGVudGlmaWVyLCBvcGVyYXRvcl0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoW2lkZW50aWZpZXIsIG9wZXJhdG9yXSk7XG4gIH1cbn07IC8vIFxcb3BlcmF0b3JuYW1lXG4vLyBhbXNvcG4uZHR4OiBcXG1hdGhvcHsjMVxca2VyblxcekBcXG9wZXJhdG9yQGZvbnQjM31cXG5ld21jb2Rlc0BcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3BlcmF0b3JuYW1lQFwiLCBcIlxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQxLFxuICBtYXRobWxCdWlsZGVyXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXG9wZXJhdG9ybmFtZVwiLCBcIlxcXFxAaWZzdGFyXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcXFxcb3BlcmF0b3JuYW1lQFwiKTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwib3JkZ3JvdXBcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC5zZW1pc2ltcGxlKSB7XG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlcmxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3ZlcmxpbmVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBPdmVybGluZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcgNDQzLCBSdWxlIDkuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwIGluIHRoZSBjcmFtcGVkIHN0eWxlLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOyAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcblxuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwib3ZlcmxpbmUtbGluZVwiLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgdmFyIGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwib3ZlcmxpbmVcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTIwM2VcIildKTtcbiAgICBvcGVyYXRvci5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcGVyYXRvcl0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50XCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLndpdGhQaGFudG9tKCksIGZhbHNlKTsgLy8gXFxwaGFudG9tIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAgLy8gU2VlIFwiY29sb3JcIiBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zLndpdGhQaGFudG9tKCkpXSk7XG4gICAgbm9kZS5oZWlnaHQgPSAwO1xuICAgIG5vZGUuZGVwdGggPSAwO1xuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmhlaWdodCA9IDA7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5baV0uZGVwdGggPSAwO1xuICAgICAgfVxuICAgIH0gLy8gU2VlIHNtYXNoIGZvciBjb21tZW50IHJlOiB1c2Ugb2YgbWFrZVZMaXN0XG5cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gRm9yIHNwYWNpbmcsIFRlWCB0cmVhdHMgXFxzbWFzaCBhcyBhIG1hdGggZ3JvdXAgKHNhbWUgc3BhY2luZyBhcyBvcmQpLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtub2RlXSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgb3B0aW9ucyk7XG4gICAgdmFyIHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcdnBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMywgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjM7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiaW5uZXJcIl0sIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIHZhciBmaXggPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInJsYXBcIl0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgb3B0aW9ucyk7XG4gICAgdmFyIHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2Vib3hcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZWJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBhbW91bnQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWU7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJhaXNlYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGR5OiBhbW91bnQsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIHZhciBkeSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IC1keSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcbiAgICB2YXIgZHkgPSBncm91cC5keS5udW1iZXIgKyBncm91cC5keS51bml0O1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBkeSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXHJlbGF4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZikge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGVcbiAgICB9O1xuICB9XG5cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicnVsZVwiLFxuICBuYW1lczogW1wiXFxcXHJ1bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJzaXplXCIsIFwic2l6ZVwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgc2hpZnQgPSBvcHRBcmdzWzBdO1xuICAgIHZhciB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICB2YXIgaGVpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJzaXplXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJ1bGVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2hpZnQ6IHNoaWZ0ICYmIGFzc2VydE5vZGVUeXBlKHNoaWZ0LCBcInNpemVcIikudmFsdWUsXG4gICAgICB3aWR0aDogd2lkdGgudmFsdWUsXG4gICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBNYWtlIGFuIGVtcHR5IHNwYW4gZm9yIHRoZSBydWxlXG4gICAgdmFyIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwicnVsZVwiXSwgW10sIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgdGhlIHNoaWZ0LCB3aWR0aCwgYW5kIGhlaWdodCBvZiB0aGUgcnVsZSwgYW5kIGFjY291bnQgZm9yIHVuaXRzXG5cbiAgICB2YXIgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBzaGlmdCA9IGdyb3VwLnNoaWZ0ID8gY2FsY3VsYXRlU2l6ZShncm91cC5zaGlmdCwgb3B0aW9ucykgOiAwOyAvLyBTdHlsZSB0aGUgcnVsZSB0byB0aGUgcmlnaHQgc2l6ZVxuXG4gICAgcnVsZS5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbWFrZUVtKHdpZHRoKTtcbiAgICBydWxlLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gbWFrZUVtKGhlaWdodCk7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBtYWtlRW0oc2hpZnQpOyAvLyBSZWNvcmQgdGhlIGhlaWdodCBhbmQgd2lkdGhcblxuICAgIHJ1bGUud2lkdGggPSB3aWR0aDtcbiAgICBydWxlLmhlaWdodCA9IGhlaWdodCArIHNoaWZ0O1xuICAgIHJ1bGUuZGVwdGggPSAtc2hpZnQ7IC8vIEZvbnQgc2l6ZSBpcyB0aGUgbnVtYmVyIGxhcmdlIGVub3VnaCB0aGF0IHRoZSBicm93c2VyIHdpbGxcbiAgICAvLyByZXNlcnZlIGF0IGxlYXN0IGBhYnNIZWlnaHRgIHNwYWNlIGFib3ZlIHRoZSBiYXNlbGluZS5cbiAgICAvLyBUaGUgMS4xMjUgZmFjdG9yIHdhcyBlbXBpcmljYWxseSBkZXRlcm1pbmVkXG5cbiAgICBydWxlLm1heEZvbnRTaXplID0gaGVpZ2h0ICogMS4xMjUgKiBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIHJldHVybiBydWxlO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBzaGlmdCA9IGdyb3VwLnNoaWZ0ID8gY2FsY3VsYXRlU2l6ZShncm91cC5zaGlmdCwgb3B0aW9ucykgOiAwO1xuICAgIHZhciBjb2xvciA9IG9wdGlvbnMuY29sb3IgJiYgb3B0aW9ucy5nZXRDb2xvcigpIHx8IFwiYmxhY2tcIjtcbiAgICB2YXIgcnVsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwibWF0aGJhY2tncm91bmRcIiwgY29sb3IpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgbWFrZUVtKHdpZHRoKSk7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKGhlaWdodCkpO1xuICAgIHZhciB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtydWxlXSk7XG5cbiAgICBpZiAoc2hpZnQgPj0gMCkge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKHNoaWZ0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG1ha2VFbShzaGlmdCkpO1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBtYWtlRW0oLXNoaWZ0KSk7XG4gICAgfVxuXG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIG1ha2VFbShzaGlmdCkpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzaXppbmdHcm91cCh2YWx1ZSwgb3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uJDEodmFsdWUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIEFkZCBzaXplLXJlc2V0dGluZyBjbGFzc2VzIHRvIHRoZSBpbm5lciBsaXN0IGFuZCBzZXQgbWF4Rm9udFNpemVcbiAgLy8gbWFudWFsbHkuIEhhbmRsZSBuZXN0ZWQgc2l6ZSBjaGFuZ2VzLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaW5uZXJbaV0uY2xhc3Nlcy5pbmRleE9mKFwic2l6aW5nXCIpO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyW2ldLmNsYXNzZXMsIG9wdGlvbnMuc2l6aW5nQ2xhc3NlcyhiYXNlT3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAoaW5uZXJbaV0uY2xhc3Nlc1twb3MgKyAxXSA9PT0gXCJyZXNldC1zaXplXCIgKyBvcHRpb25zLnNpemUpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXN0ZWQgc2l6ZSBjaGFuZ2U6IGUuZy4sIGlubmVyW2ldIGlzIHRoZSBcImJcIiBpblxuICAgICAgLy8gYFxcSHVnZSBhIFxcc21hbGwgYmAuIE92ZXJyaWRlIHRoZSBvbGQgc2l6ZSAodGhlIGByZXNldC1gIGNsYXNzKVxuICAgICAgLy8gYnV0IG5vdCB0aGUgbmV3IHNpemUuXG4gICAgICBpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID0gXCJyZXNldC1zaXplXCIgKyBiYXNlT3B0aW9ucy5zaXplO1xuICAgIH1cblxuICAgIGlubmVyW2ldLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgIGlubmVyW2ldLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGlubmVyKTtcbn1cbnZhciBzaXplRnVuY3MgPSBbXCJcXFxcdGlueVwiLCBcIlxcXFxzaXhwdHNpemVcIiwgXCJcXFxcc2NyaXB0c2l6ZVwiLCBcIlxcXFxmb290bm90ZXNpemVcIiwgXCJcXFxcc21hbGxcIiwgXCJcXFxcbm9ybWFsc2l6ZVwiLCBcIlxcXFxsYXJnZVwiLCBcIlxcXFxMYXJnZVwiLCBcIlxcXFxMQVJHRVwiLCBcIlxcXFxodWdlXCIsIFwiXFxcXEh1Z2VcIl07XG52YXIgaHRtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gSGFuZGxlIHNpemluZyBvcGVyYXRvcnMgbGlrZSBcXEh1Z2UuIFJlYWwgVGVYIGRvZXNuJ3QgYWN0dWFsbHkgYWxsb3dcbiAgLy8gdGhlc2UgZnVuY3Rpb25zIGluc2lkZSBvZiBtYXRoIGV4cHJlc3Npb25zLCBzbyB3ZSBkbyBzb21lIHNwZWNpYWxcbiAgLy8gaGFuZGxpbmcuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICByZXR1cm4gc2l6aW5nR3JvdXAoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNpemluZ1wiLFxuICBuYW1lczogc2l6ZUZ1bmNzLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBicmVha09uVG9rZW5UZXh0LFxuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGJyZWFrT25Ub2tlblRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICBzaXplOiBzaXplRnVuY3MuaW5kZXhPZihmdW5jTmFtZSkgKyAxLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyLFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU2l6ZShncm91cC5zaXplKTtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7IC8vIFRPRE8oZW1pbHkpOiBUaGlzIGRvZXNuJ3QgcHJvZHVjZSB0aGUgY29ycmVjdCBzaXplIGZvciBuZXN0ZWQgc2l6ZVxuICAgIC8vIGNoYW5nZXMsIGJlY2F1c2Ugd2UgZG9uJ3Qga2VlcCBzdGF0ZSBvZiB3aGF0IHN0eWxlIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIGluLCBzbyB3ZSBjYW4ndCByZXNldCB0aGUgc2l6ZSB0byBub3JtYWwgYmVmb3JlIGNoYW5naW5nIGl0LiAgTm93XG4gICAgLy8gdGhhdCB3ZSdyZSBwYXNzaW5nIGFuIG9wdGlvbnMgcGFyYW1ldGVyIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpeFxuICAgIC8vIHRoaXMuXG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIG1ha2VFbShuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyKSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vLyBzbWFzaCwgd2l0aCBvcHRpb25hbCBbdGJdLCBhcyBpbiBBTVNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzbWFzaFwiLFxuICBuYW1lczogW1wiXFxcXHNtYXNoXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgdmFyIHNtYXNoRGVwdGggPSBmYWxzZTtcbiAgICB2YXIgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG5cbiAgICBpZiAodGJBcmcpIHtcbiAgICAgIC8vIE9wdGlvbmFsIFt0Yl0gYXJndW1lbnQgaXMgZW5nYWdlZC5cbiAgICAgIC8vIHJlZjogYW1zbWF0aDogXFxyZW5ld2NvbW1hbmR7XFxzbWFzaH1bMV1bdGJdeyVcbiAgICAgIC8vICAgICAgICAgICAgICAgZGVmXFxtYkB0e1xcaHR9XFxkZWZcXG1iQGJ7XFxkcH1cXGRlZlxcbWJAdGJ7XFxodFxcekBcXHpAXFxkcH0lXG4gICAgICB2YXIgbGV0dGVyID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YkFyZy5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBub2RlID0gdGJBcmcuYm9keVtpXTsgLy8gJEZsb3dGaXhNZTogTm90IGV2ZXJ5IG5vZGUgdHlwZSBoYXMgYSBgdGV4dGAgcHJvcGVydHkuXG5cbiAgICAgICAgbGV0dGVyID0gbm9kZS50ZXh0O1xuXG4gICAgICAgIGlmIChsZXR0ZXIgPT09IFwidFwiKSB7XG4gICAgICAgICAgc21hc2hIZWlnaHQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCJiXCIpIHtcbiAgICAgICAgICBzbWFzaERlcHRoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgICAgICAgIHNtYXNoRGVwdGggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICBzbWFzaERlcHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic21hc2hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIHNtYXNoSGVpZ2h0LFxuICAgICAgc21hc2hEZXB0aFxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnNtYXNoSGVpZ2h0ICYmICFncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHtcbiAgICAgIG5vZGUuaGVpZ2h0ID0gMDsgLy8gSW4gb3JkZXIgdG8gaW5mbHVlbmNlIG1ha2VWTGlzdCwgd2UgaGF2ZSB0byByZXNldCB0aGUgY2hpbGRyZW4uXG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0uaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICBub2RlLmRlcHRoID0gMDtcblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltfaV0uZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50LCB3ZSd2ZSByZXNldCB0aGUgVGVYLWxpa2UgaGVpZ2h0IGFuZCBkZXB0aCB2YWx1ZXMuXG4gICAgLy8gQnV0IHRoZSBzcGFuIHN0aWxsIGhhcyBhbiBIVE1MIGxpbmUgaGVpZ2h0LlxuICAgIC8vIG1ha2VWTGlzdCBhcHBsaWVzIFwiZGlzcGxheTogdGFibGUtY2VsbFwiLCB3aGljaCBwcmV2ZW50cyB0aGUgYnJvd3NlclxuICAgIC8vIGZyb20gYWN0aW5nIG9uIHRoYXQgbGluZSBoZWlnaHQuIFNvIHdlJ2xsIGNhbGwgbWFrZVZMaXN0IG5vdy5cblxuXG4gICAgdmFyIHNtYXNoZWROb2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEZvciBzcGFjaW5nLCBUZVggdHJlYXRzIFxcaHBoYW50b20gYXMgYSBtYXRoIGdyb3VwIChzYW1lIHNwYWNpbmcgYXMgb3JkKS5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbc21hc2hlZE5vZGVdLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIGlmIChncm91cC5zbWFzaEhlaWdodCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwcHhcIik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoRGVwdGgpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3FydFwiLFxuICBuYW1lczogW1wiXFxcXHNxcnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGluZGV4ID0gb3B0QXJnc1swXTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3FydFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgaW5kZXhcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgLy8gRmlyc3QsIHdlIGRvIHRoZSBzYW1lIHN0ZXBzIGFzIGluIG92ZXJsaW5lIHRvIGJ1aWxkIHRoZSBpbm5lciBncm91cFxuICAgIC8vIGFuZCBsaW5lXG4gICAgdmFyIGlubmVyID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpO1xuXG4gICAgaWYgKGlubmVyLmhlaWdodCA9PT0gMCkge1xuICAgICAgLy8gUmVuZGVyIGEgc21hbGwgc3VyZC5cbiAgICAgIGlubmVyLmhlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuXG4gICAgaW5uZXIgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoaW5uZXIsIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gc2l6ZSBmb3IgdGhlIFxcc3VyZCBkZWxpbWl0ZXJcblxuICAgIHZhciBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpO1xuICAgIHZhciB0aGV0YSA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG4gICAgdmFyIHBoaSA9IHRoZXRhO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaWQgPCBTdHlsZSQxLlRFWFQuaWQpIHtcbiAgICAgIHBoaSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gLy8gQ2FsY3VsYXRlIHRoZSBjbGVhcmFuY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgbGluZVxuXG5cbiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHRoZXRhICsgcGhpIC8gNDtcbiAgICB2YXIgbWluRGVsaW1pdGVySGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlICsgdGhldGE7IC8vIENyZWF0ZSBhIHNxcnQgU1ZHIG9mIHRoZSByZXF1aXJlZCBtaW5pbXVtIHNpemVcblxuICAgIHZhciB7XG4gICAgICBzcGFuOiBpbWcsXG4gICAgICBydWxlV2lkdGgsXG4gICAgICBhZHZhbmNlV2lkdGhcbiAgICB9ID0gZGVsaW1pdGVyLnNxcnRJbWFnZShtaW5EZWxpbWl0ZXJIZWlnaHQsIG9wdGlvbnMpO1xuICAgIHZhciBkZWxpbURlcHRoID0gaW1nLmhlaWdodCAtIHJ1bGVXaWR0aDsgLy8gQWRqdXN0IHRoZSBjbGVhcmFuY2UgYmFzZWQgb24gdGhlIGRlbGltaXRlciBzaXplXG5cbiAgICBpZiAoZGVsaW1EZXB0aCA+IGlubmVyLmhlaWdodCArIGlubmVyLmRlcHRoICsgbGluZUNsZWFyYW5jZSkge1xuICAgICAgbGluZUNsZWFyYW5jZSA9IChsaW5lQ2xlYXJhbmNlICsgZGVsaW1EZXB0aCAtIGlubmVyLmhlaWdodCAtIGlubmVyLmRlcHRoKSAvIDI7XG4gICAgfSAvLyBTaGlmdCB0aGUgc3FydCBpbWFnZVxuXG5cbiAgICB2YXIgaW1nU2hpZnQgPSBpbWcuaGVpZ2h0IC0gaW5uZXIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDtcbiAgICBpbm5lci5zdHlsZS5wYWRkaW5nTGVmdCA9IG1ha2VFbShhZHZhbmNlV2lkdGgpOyAvLyBPdmVybGF5IHRoZSBpbWFnZSBhbmQgdGhlIGFyZ3VtZW50LlxuXG4gICAgdmFyIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXIsXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiBbXCJzdmctYWxpZ25cIl1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IC0oaW5uZXIuaGVpZ2h0ICsgaW1nU2hpZnQpXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbWdcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHJ1bGVXaWR0aFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICghZ3JvdXAuaW5kZXgpIHtcbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW2JvZHldLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIHRoZSBvcHRpb25hbCByb290IGluZGV4XG4gICAgICAvLyBUaGUgaW5kZXggaXMgYWx3YXlzIGluIHNjcmlwdHNjcmlwdCBzdHlsZVxuICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKFN0eWxlJDEuU0NSSVBUU0NSSVBUKTtcbiAgICAgIHZhciByb290bSA9IGJ1aWxkR3JvdXAkMShncm91cC5pbmRleCwgbmV3T3B0aW9ucywgb3B0aW9ucyk7IC8vIFRoZSBhbW91bnQgdGhlIGluZGV4IGlzIHNoaWZ0ZWQgYnkuIFRoaXMgaXMgdGFrZW4gZnJvbSB0aGUgVGVYXG4gICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuXG4gICAgICB2YXIgdG9TaGlmdCA9IDAuNiAqIChib2R5LmhlaWdodCAtIGJvZHkuZGVwdGgpOyAvLyBCdWlsZCBhIFZMaXN0IHdpdGggdGhlIHN1cGVyc2NyaXB0IHNoaWZ0ZWQgdXAgY29ycmVjdGx5XG5cbiAgICAgIHZhciByb290Vkxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiAtdG9TaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogcm9vdG1cbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpOyAvLyBBZGQgYSBjbGFzcyBzdXJyb3VuZGluZyBpdCBzbyB3ZSBjYW4gYWRkIG9uIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgLy8ga2VybmluZ1xuXG4gICAgICB2YXIgcm9vdFZMaXN0V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInJvb3RcIl0sIFtyb290Vkxpc3RdKTtcbiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW3Jvb3RWTGlzdFdyYXAsIGJvZHldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB7XG4gICAgICBib2R5LFxuICAgICAgaW5kZXhcbiAgICB9ID0gZ3JvdXA7XG4gICAgcmV0dXJuIGluZGV4ID8gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm9vdFwiLCBbYnVpbGRHcm91cChib2R5LCBvcHRpb25zKSwgYnVpbGRHcm91cChpbmRleCwgb3B0aW9ucyldKSA6IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNxcnRcIiwgW2J1aWxkR3JvdXAoYm9keSwgb3B0aW9ucyldKTtcbiAgfVxuXG59KTtcblxudmFyIHN0eWxlTWFwID0ge1xuICBcImRpc3BsYXlcIjogU3R5bGUkMS5ESVNQTEFZLFxuICBcInRleHRcIjogU3R5bGUkMS5URVhULFxuICBcInNjcmlwdFwiOiBTdHlsZSQxLlNDUklQVCxcbiAgXCJzY3JpcHRzY3JpcHRcIjogU3R5bGUkMS5TQ1JJUFRTQ1JJUFRcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c2NyaXB0c3R5bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBicmVha09uVG9rZW5UZXh0LFxuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7IC8vIFRPRE86IFJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHN0eWxlTWFwIGluIG11bHRpcGxlIHBsYWNlcyAoZS5nLlxuICAgIC8vIGhlcmUgYW5kIGluIGJ1aWxkSFRNTCBhbmQgZGUtZHVwZSB0aGUgZW51bWVyYXRpb24gb2YgYWxsIHRoZSBzdHlsZXMpLlxuICAgIC8vICRGbG93Rml4TWU6IFRoZSBuYW1lcyBhYm92ZSBleGFjdGx5IG1hdGNoIHRoZSBzdHlsZXMuXG5cbiAgICB2YXIgc3R5bGUgPSBmdW5jTmFtZS5zbGljZSgxLCBmdW5jTmFtZS5sZW5ndGggLSA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzdHlsZSB0byB1c2UgYnkgcHVsbGluZyBvdXQgdGhlIHN0eWxlIGZyb21cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICBzdHlsZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3R5bGUgY2hhbmdlcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBvbiBwZy4gNDQyLCBSdWxlIDMuXG4gICAgdmFyIG5ld1N0eWxlID0gc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuZXdTdHlsZSkud2l0aEZvbnQoJycpO1xuICAgIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBuZXdTdHlsZSA9IHN0eWxlTWFwW2dyb3VwLnN0eWxlXTtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobmV3U3R5bGUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIGlubmVyKTtcbiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICAgICAgXCJkaXNwbGF5XCI6IFtcIjBcIiwgXCJ0cnVlXCJdLFxuICAgICAgXCJ0ZXh0XCI6IFtcIjBcIiwgXCJmYWxzZVwiXSxcbiAgICAgIFwic2NyaXB0XCI6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgICAgIFwic2NyaXB0c2NyaXB0XCI6IFtcIjJcIiwgXCJmYWxzZVwiXVxuICAgIH07XG4gICAgdmFyIGF0dHIgPSBzdHlsZUF0dHJpYnV0ZXNbZ3JvdXAuc3R5bGVdO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgaHRtbEJ1aWxkZXJEZWxlZ2F0ZSA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgdmFyIGJhc2UgPSBncm91cC5iYXNlO1xuXG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgLy8gT3BlcmF0b3JzIGhhbmRsZSBzdXBzdWJzIGRpZmZlcmVudGx5IHdoZW4gdGhleSBoYXZlIGxpbWl0c1xuICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgdmFyIGRlbGVnYXRlID0gYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpO1xuICAgIHJldHVybiBkZWxlZ2F0ZSA/IGh0bWxCdWlsZGVyJDIgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikge1xuICAgIHZhciBfZGVsZWdhdGUgPSBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBTdHlsZSQxLkRJU1BMQVkuc2l6ZSB8fCBiYXNlLmxpbWl0cyk7XG5cbiAgICByZXR1cm4gX2RlbGVnYXRlID8gaHRtbEJ1aWxkZXIkMSA6IG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcImFjY2VudFwiKSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJhc2UuYmFzZSkgPyBodG1sQnVpbGRlciRhIDogbnVsbDtcbiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgdmFyIGlzU3VwID0gIWdyb3VwLnN1YjtcbiAgICByZXR1cm4gaXNTdXAgPT09IGJhc2UuaXNPdmVyID8gaHRtbEJ1aWxkZXIkMyA6IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07IC8vIFN1cGVyIHNjcmlwdHMgYW5kIHN1YnNjcmlwdHMsIHdob3NlIHByZWNpc2UgcGxhY2VtZW50IGNhbiBkZXBlbmQgb24gb3RoZXJcbi8vIGZ1bmN0aW9ucyB0aGF0IHByZWNlZGUgdGhlbS5cblxuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzdXBzdWJcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN1cGVyc2NyaXB0IGFuZCBzdWJzY3JpcHRzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VcbiAgICAvLyA0NDUtNDQ2LCBydWxlcyAxOChhLWYpLlxuICAgIC8vIEhlcmUgaXMgd2hlcmUgd2UgZGVmZXIgdG8gdGhlIGlubmVyIGdyb3VwIGlmIGl0IHNob3VsZCBoYW5kbGVcbiAgICAvLyBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgaXRzZWxmLlxuICAgIHZhciBidWlsZGVyRGVsZWdhdGUgPSBodG1sQnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTtcblxuICAgIGlmIChidWlsZGVyRGVsZWdhdGUpIHtcbiAgICAgIHJldHVybiBidWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBiYXNlOiB2YWx1ZUJhc2UsXG4gICAgICBzdXA6IHZhbHVlU3VwLFxuICAgICAgc3ViOiB2YWx1ZVN1YlxuICAgIH0gPSBncm91cDtcbiAgICB2YXIgYmFzZSA9IGJ1aWxkR3JvdXAkMSh2YWx1ZUJhc2UsIG9wdGlvbnMpO1xuICAgIHZhciBzdXBtO1xuICAgIHZhciBzdWJtO1xuICAgIHZhciBtZXRyaWNzID0gb3B0aW9ucy5mb250TWV0cmljcygpOyAvLyBSdWxlIDE4YVxuXG4gICAgdmFyIHN1cFNoaWZ0ID0gMDtcbiAgICB2YXIgc3ViU2hpZnQgPSAwO1xuICAgIHZhciBpc0NoYXJhY3RlckJveCA9IHZhbHVlQmFzZSAmJiB1dGlscy5pc0NoYXJhY3RlckJveCh2YWx1ZUJhc2UpO1xuXG4gICAgaWYgKHZhbHVlU3VwKSB7XG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS5zdXAoKSk7XG4gICAgICBzdXBtID0gYnVpbGRHcm91cCQxKHZhbHVlU3VwLCBuZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFpc0NoYXJhY3RlckJveCkge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gbmV3T3B0aW9ucy5mb250TWV0cmljcygpLnN1cERyb3AgKiBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVTdWIpIHtcbiAgICAgIHZhciBfbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS5zdWIoKSk7XG5cbiAgICAgIHN1Ym0gPSBidWlsZEdyb3VwJDEodmFsdWVTdWIsIF9uZXdPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFpc0NoYXJhY3RlckJveCkge1xuICAgICAgICBzdWJTaGlmdCA9IGJhc2UuZGVwdGggKyBfbmV3T3B0aW9ucy5mb250TWV0cmljcygpLnN1YkRyb3AgKiBfbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICB9XG4gICAgfSAvLyBSdWxlIDE4Y1xuXG5cbiAgICB2YXIgbWluU3VwU2hpZnQ7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gU3R5bGUkMS5ESVNQTEFZKSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuY3JhbXBlZCkge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAyO1xuICAgIH0gLy8gc2NyaXB0c3BhY2UgaXMgYSBmb250LXNpemUtaW5kZXBlbmRlbnQgc2l6ZSwgc28gc2NhbGUgaXRcbiAgICAvLyBhcHByb3ByaWF0ZWx5IGZvciB1c2UgYXMgdGhlIG1hcmdpblJpZ2h0LlxuXG5cbiAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1hcmdpblJpZ2h0ID0gbWFrZUVtKDAuNSAvIG1ldHJpY3MucHRQZXJFbSAvIG11bHRpcGxpZXIpO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gbnVsbDtcblxuICAgIGlmIChzdWJtKSB7XG4gICAgICAvLyBTdWJzY3JpcHRzIHNob3VsZG4ndCBiZSBzaGlmdGVkIGJ5IHRoZSBiYXNlJ3MgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIC8vIGFtb3VudC4gTm90ZSB3ZSBvbmx5IGRvIHRoaXMgd2hlbiB0aGUgYmFzZSBpcyBhIHNpbmdsZSBzeW1ib2wuXG4gICAgICB2YXIgaXNPaWludCA9IGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgJiYgZ3JvdXAuYmFzZS5uYW1lICYmIChncm91cC5iYXNlLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAuYmFzZS5uYW1lID09PSBcIlxcXFxvaWlpbnRcIik7XG5cbiAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgU3ltYm9sTm9kZSB8fCBpc09paW50KSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgbWFyZ2luTGVmdCA9IG1ha2VFbSgtYmFzZS5pdGFsaWMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdXBzdWI7XG5cbiAgICBpZiAoc3VwbSAmJiBzdWJtKSB7XG4gICAgICBzdXBTaGlmdCA9IE1hdGgubWF4KHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwbS5kZXB0aCArIDAuMjUgKiBtZXRyaWNzLnhIZWlnaHQpO1xuICAgICAgc3ViU2hpZnQgPSBNYXRoLm1heChzdWJTaGlmdCwgbWV0cmljcy5zdWIyKTtcbiAgICAgIHZhciBydWxlV2lkdGggPSBtZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzOyAvLyBSdWxlIDE4ZVxuXG4gICAgICB2YXIgbWF4V2lkdGggPSA0ICogcnVsZVdpZHRoO1xuXG4gICAgICBpZiAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoIC0gKHN1Ym0uaGVpZ2h0IC0gc3ViU2hpZnQpIDwgbWF4V2lkdGgpIHtcbiAgICAgICAgc3ViU2hpZnQgPSBtYXhXaWR0aCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpICsgc3VibS5oZWlnaHQ7XG4gICAgICAgIHZhciBwc2kgPSAwLjggKiBtZXRyaWNzLnhIZWlnaHQgLSAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoKTtcblxuICAgICAgICBpZiAocHNpID4gMCkge1xuICAgICAgICAgIHN1cFNoaWZ0ICs9IHBzaTtcbiAgICAgICAgICBzdWJTaGlmdCAtPSBwc2k7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZsaXN0RWxlbSA9IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWJtLFxuICAgICAgICBzaGlmdDogc3ViU2hpZnQsXG4gICAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgICBtYXJnaW5MZWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdXBtLFxuICAgICAgICBzaGlmdDogLXN1cFNoaWZ0LFxuICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiB2bGlzdEVsZW1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3VibSkge1xuICAgICAgLy8gUnVsZSAxOGJcbiAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIG1ldHJpY3Muc3ViMSwgc3VibS5oZWlnaHQgLSAwLjggKiBtZXRyaWNzLnhIZWlnaHQpO1xuICAgICAgdmFyIF92bGlzdEVsZW0gPSBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VibSxcbiAgICAgICAgbWFyZ2luTGVmdCxcbiAgICAgICAgbWFyZ2luUmlnaHRcbiAgICAgIH1dO1xuICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogc3ViU2hpZnQsXG4gICAgICAgIGNoaWxkcmVuOiBfdmxpc3RFbGVtXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHN1cG0pIHtcbiAgICAgIC8vIFJ1bGUgMThjLCBkXG4gICAgICBzdXBTaGlmdCA9IE1hdGgubWF4KHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwbS5kZXB0aCArIDAuMjUgKiBtZXRyaWNzLnhIZWlnaHQpO1xuICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogLXN1cFNoaWZ0LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBzdXBtLFxuICAgICAgICAgIG1hcmdpblJpZ2h0XG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3Vwc3ViIG11c3QgaGF2ZSBlaXRoZXIgc3VwIG9yIHN1Yi5cIik7XG4gICAgfSAvLyBXcmFwIHRoZSBzdXBzdWIgdmxpc3QgaW4gYSBzcGFuLm1zdXBzdWIgdG8gcmVzZXQgdGV4dC1hbGlnbi5cblxuXG4gICAgdmFyIG1jbGFzcyA9IGdldFR5cGVPZkRvbVRyZWUoYmFzZSwgXCJyaWdodFwiKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW21jbGFzc10sIFtiYXNlLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gSXMgdGhlIGlubmVyIGdyb3VwIGEgcmVsZXZhbnQgaG9yaXpvbmFsIGJyYWNlP1xuICAgIHZhciBpc0JyYWNlID0gZmFsc2U7XG4gICAgdmFyIGlzT3ZlcjtcbiAgICB2YXIgaXNTdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuXG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gW2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyldO1xuXG4gICAgaWYgKGdyb3VwLnN1Yikge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEdyb3VwKGdyb3VwLnN1Yiwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdXApIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG5cbiAgICBpZiAoaXNCcmFjZSkge1xuICAgICAgbm9kZVR5cGUgPSBpc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiO1xuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1Yikge1xuICAgICAgdmFyIGJhc2UgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIiAmJiBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZSA9PT0gU3R5bGUkMS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiYgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKGJhc2UubGltaXRzIHx8IG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1vdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1cFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1cCkge1xuICAgICAgdmFyIF9iYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKF9iYXNlICYmIF9iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBfYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoX2Jhc2UgJiYgX2Jhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJiBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKF9iYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3ViXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfYmFzZTIgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoX2Jhc2UyICYmIF9iYXNlMi50eXBlID09PSBcIm9wXCIgJiYgX2Jhc2UyLmxpbWl0cyAmJiBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoX2Jhc2UyICYmIF9iYXNlMi50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIF9iYXNlMi5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZTIubGltaXRzKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJzdXBcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwiYXRvbVwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibVwiICsgZ3JvdXAuZmFtaWx5XSk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSldKTtcblxuICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwiYmluXCIpIHtcbiAgICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG4vLyBcIm1hdGhvcmRcIiBhbmQgXCJ0ZXh0b3JkXCIgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxudmFyIGRlZmF1bHRWYXJpYW50ID0ge1xuICBcIm1pXCI6IFwiaXRhbGljXCIsXG4gIFwibW5cIjogXCJub3JtYWxcIixcbiAgXCJtdGV4dFwiOiBcIm5vcm1hbFwiXG59O1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwibWF0aG9yZFwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pO1xuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJpdGFsaWNcIjtcblxuICAgIGlmICh2YXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudFtub2RlLnR5cGVdKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIHZhcmlhbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBtYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKTtcbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHx8IFwibm9ybWFsXCI7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtblwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxccHJpbWVcIikge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICB9XG5cbiAgICBpZiAodmFyaWFudCAhPT0gZGVmYXVsdFZhcmlhbnRbbm9kZS50eXBlXSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxudmFyIGNzc1NwYWNlID0ge1xuICBcIlxcXFxub2JyZWFrXCI6IFwibm9icmVha1wiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCI6IFwiYWxsb3dicmVha1wiXG59OyAvLyBBIGxvb2t1cCB0YWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNwYWNpbmcgZnVuY3Rpb24vc3ltYm9sIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBsaWtlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBJZiBhIHN5bWJvbCBvciBjb21tYW5kIGlzIGEga2V5XG4vLyBpbiB0aGlzIHRhYmxlLCB0aGVuIGl0IHNob3VsZCBiZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgRnVydGhlcm1vcmUsXG4vLyB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBtYXkgaGF2ZSBhIGBjbGFzc05hbWVgIHNwZWNpZnlpbmcgYW4gZXh0cmEgQ1NTIGNsYXNzXG4vLyB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgYHNwYW5gLlxuXG52YXIgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07IC8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWd1bGFyU3BhY2VbZ3JvdXAudGV4dF0uY2xhc3NOYW1lIHx8IFwiXCI7IC8vIFNwYWNlcyBhcmUgZ2VuZXJhdGVkIGJ5IGFkZGluZyBhbiBhY3R1YWwgc3BhY2UuIEVhY2ggb2YgdGhlc2VcbiAgICAgIC8vIHRoaW5ncyBoYXMgYW4gZW50cnkgaW4gdGhlIHN5bWJvbHMgdGFibGUsIHNvIHRoZXNlIHdpbGwgYmUgdHVybmVkXG4gICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG5cbiAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICB2YXIgb3JkID0gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBvcmQuY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiBvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNsYXNzTmFtZV0sIFtidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gU3BhY2VzIGJhc2VkIG9uIGp1c3QgYSBDU1MgY2xhc3MuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNzc1NwYWNlW2dyb3VwLnRleHRdXSwgW10sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAocmVndWxhclNwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUwMGEwXCIpXSk7XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gQ1NTLWJhc2VkIE1hdGhNTCBzcGFjZXMgKFxcbm9icmVhaywgXFxhbGxvd2JyZWFrKSBhcmUgaWdub3JlZFxuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG52YXIgcGFkID0gKCkgPT4ge1xuICB2YXIgcGFkTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdKTtcbiAgcGFkTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjUwJVwiKTtcbiAgcmV0dXJuIHBhZE5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0YWdcIixcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW25ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFtwYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKV0pLCBwYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC50YWcsIG9wdGlvbnMpXSldKV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICByZXR1cm4gdGFibGU7IC8vIFRPRE86IExlZnQtYWxpZ25lZCB0YWdzLlxuICAgIC8vIEN1cnJlbnRseSwgdGhlIGdyb3VwIGFuZCBvcHRpb25zIHBhc3NlZCBoZXJlIGRvIG5vdCBjb250YWluXG4gICAgLy8gZW5vdWdoIGluZm8gdG8gc2V0IHRhZyBhbGlnbm1lbnQuIGBsZXFub2AgaXMgaW4gU2V0dGluZ3MgYnV0IGl0IGlzXG4gICAgLy8gbm90IHBhc3NlZCB0byBPcHRpb25zLiBPbiB0aGUgSFRNTCBzaWRlLCBsZXFubyBpc1xuICAgIC8vIHNldCBieSBhIENTUyBjbGFzcyBhcHBsaWVkIGluIGJ1aWxkVHJlZS5qcy4gVGhhdCB3b3VsZCBoYXZlIHdvcmtlZFxuICAgIC8vIGluIE1hdGhNTCBpZiBicm93c2VycyBzdXBwb3J0ZWQgPG1sYWJlbGVkdHI+LiBTaW5jZSB0aGV5IGRvbid0LCB3ZVxuICAgIC8vIG5lZWQgdG8gcmV3cml0ZSB0aGUgd2F5IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICB9XG5cbn0pO1xuXG52YXIgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIlxufTtcbnZhciB0ZXh0Rm9udFdlaWdodHMgPSB7XG4gIFwiXFxcXHRleHRiZlwiOiBcInRleHRiZlwiLFxuICBcIlxcXFx0ZXh0bWRcIjogXCJ0ZXh0bWRcIlxufTtcbnZhciB0ZXh0Rm9udFNoYXBlcyA9IHtcbiAgXCJcXFxcdGV4dGl0XCI6IFwidGV4dGl0XCIsXG4gIFwiXFxcXHRleHR1cFwiOiBcInRleHR1cFwiXG59O1xuXG52YXIgb3B0aW9uc1dpdGhGb250ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBmb250ID0gZ3JvdXAuZm9udDsgLy8gQ2hlY2tzIGlmIHRoZSBhcmd1bWVudCBpcyBhIGZvbnQgZmFtaWx5IG9yIGEgZm9udCBzdHlsZS5cblxuICBpZiAoIWZvbnQpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250RmFtaWx5KHRleHRGb250RmFtaWxpZXNbZm9udF0pO1xuICB9IGVsc2UgaWYgKHRleHRGb250V2VpZ2h0c1tmb250XSkge1xuICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFdlaWdodCh0ZXh0Rm9udFdlaWdodHNbZm9udF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFNoYXBlKHRleHRGb250U2hhcGVzW2ZvbnRdKTtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgbmFtZXM6IFsvLyBGb250IGZhbWlsaWVzXG4gIFwiXFxcXHRleHRcIiwgXCJcXFxcdGV4dHJtXCIsIFwiXFxcXHRleHRzZlwiLCBcIlxcXFx0ZXh0dHRcIiwgXCJcXFxcdGV4dG5vcm1hbFwiLCAvLyBGb250IHdlaWdodHNcbiAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRtZFwiLCAvLyBGb250IFNoYXBlc1xuICBcIlxcXFx0ZXh0aXRcIiwgXCJcXFxcdGV4dHVwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgZm9udDogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIHRydWUpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiXSwgaW5uZXIsIG5ld09wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInVuZGVybGluZVwiLFxuICBuYW1lczogW1wiXFxcXHVuZGVybGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVW5kZXJsaW5lcyBhcmUgaGFuZGxlZCBpbiB0aGUgVGVYYm9vayBwZyA0NDMsIFJ1bGUgMTAuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpOyAvLyBDcmVhdGUgdGhlIGxpbmUgdG8gZ28gYmVsb3cgdGhlIGJvZHlcblxuICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwidW5kZXJsaW5lLWxpbmVcIiwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIHZhciBkZWZhdWx0UnVsZVRoaWNrbmVzcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInRvcFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBpbm5lckdyb3VwLmhlaWdodCxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogZGVmYXVsdFJ1bGVUaGlja25lc3NcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGxpbmVcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDMgKiBkZWZhdWx0UnVsZVRoaWNrbmVzc1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXJHcm91cFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcInVuZGVybGluZVwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcGVyYXRvcl0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50dW5kZXJcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmNlbnRlclwiLFxuICBuYW1lczogW1wiXFxcXHZjZW50ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wib3JpZ2luYWxcIl0sXG4gICAgLy8gSW4gTGFUZVgsIFxcdmNlbnRlciBjYW4gYWN0IG9ubHkgb24gYSBib3guXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmNlbnRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICAgIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7XG4gICAgdmFyIGR5ID0gMC41ICogKGJvZHkuaGVpZ2h0IC0gYXhpc0hlaWdodCAtIChib2R5LmRlcHRoICsgYXhpc0hlaWdodCkpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInNoaWZ0XCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGR5LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBib2R5XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gZG8gdGhpcyBpbiBNYXRoTUwuXG4gICAgLy8gV3JpdGUgYSBjbGFzcyBhcyBhIGJyZWFkY3J1bWIgaW4gY2FzZSBzb21lIHBvc3QtcHJvY2Vzc29yIHdhbnRzXG4gICAgLy8gdG8gcGVyZm9ybSBhIHZjZW50ZXIgYWRqdXN0bWVudC5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSwgW1widmNlbnRlclwiXSk7XG4gIH1cblxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2ZXJiXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmVyYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICAvLyBcXHZlcmIgYW5kIFxcdmVyYiogYXJlIGRlYWx0IHdpdGggZGlyZWN0bHkgaW4gUGFyc2VyLmpzLlxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdCdzIGJlY2F1c2Ugb2YgYSBmYWlsdXJlIHRvIG1hdGNoIHRoZSB0d28gZGVsaW1pdGVyc1xuICAgIC8vIGluIHRoZSByZWdleCBpbiBMZXhlci5qcy4gIExhVGVYIHJhaXNlcyB0aGUgZm9sbG93aW5nIGVycm9yIHdoZW4gXFx2ZXJiIGlzXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2YgbGluZSAob3IgZmlsZSkuXG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcdmVyYiBlbmRlZCBieSBlbmQgb2YgbGluZSBpbnN0ZWFkIG9mIG1hdGNoaW5nIGRlbGltaXRlclwiKTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB0ZXh0ID0gbWFrZVZlcmIoZ3JvdXApO1xuICAgIHZhciBib2R5ID0gW107IC8vIFxcdmVyYiBlbnRlcnMgdGV4dCBtb2RlIGFuZCB0aGVyZWZvcmUgaXMgc2l6ZWQgbGlrZSBcXHRleHRzdHlsZVxuXG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUudGV4dCgpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoYyA9PT0gJ34nKSB7XG4gICAgICAgIGMgPSAnXFxcXHRleHRhc2NpaXRpbGRlJztcbiAgICAgIH1cblxuICAgICAgYm9keS5wdXNoKGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woYywgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIiwgZ3JvdXAubW9kZSwgbmV3T3B0aW9ucywgW1wibW9yZFwiLCBcInRleHR0dFwiXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiXS5jb25jYXQobmV3T3B0aW9ucy5zaXppbmdDbGFzc2VzKG9wdGlvbnMpKSwgYnVpbGRDb21tb24udHJ5Q29tYmluZUNoYXJzKGJvZHkpLCBuZXdPcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJtb25vc3BhY2VcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG4vKipcbiAqIENvbnZlcnRzIHZlcmIgZ3JvdXAgaW50byBib2R5IHN0cmluZy5cbiAqXG4gKiBcXHZlcmIqIHJlcGxhY2VzIGVhY2ggc3BhY2Ugd2l0aCBhbiBvcGVuIGJveCBcXHUyNDIzXG4gKiBcXHZlcmIgcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGEgbm8tYnJlYWsgc3BhY2UgXFx4QTBcbiAqL1xuXG52YXIgbWFrZVZlcmIgPSBncm91cCA9PiBncm91cC5ib2R5LnJlcGxhY2UoLyAvZywgZ3JvdXAuc3RhciA/ICdcXHUyNDIzJyA6ICdcXHhBMCcpO1xuXG4vKiogSW5jbHVkZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGFsbCBmdW5jdGlvbnMgYXJlIGRlZmluZWQuICovXG52YXIgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcblxuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVycyB0aGVuIHdoaXRlc3BhY2VcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBhbnkgQk1QIGNoYXJhY3RlclxuICogQ2FwdHVyaW5nIGdyb3VwczpcbiAqICAgWzFdIHJlZ3VsYXIgd2hpdGVzcGFjZVxuICogICBbMl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2VcbiAqICAgWzNdIGFueXRoaW5nIGVsc2UsIHdoaWNoIG1heSBpbmNsdWRlOlxuICogICAgIFs0XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmIqXG4gKiAgICAgWzVdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYlxuICogICAgIFs2XSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd29yZCwgZXhjbHVkaW5nIGFueSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gKiBKdXN0IGJlY2F1c2UgdGhlIExleGVyIG1hdGNoZXMgc29tZXRoaW5nIGRvZXNuJ3QgbWVhbiBpdCdzIHZhbGlkIGlucHV0OlxuICogSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZnVuY3Rpb24gb3Igc3ltYm9sIGRlZmluaXRpb24sIHRoZSBQYXJzZXIgd2lsbFxuICogc3RpbGwgcmVqZWN0IHRoZSBpbnB1dC5cbiAqL1xudmFyIHNwYWNlUmVnZXhTdHJpbmcgPSBcIlsgXFxyXFxuXFx0XVwiO1xudmFyIGNvbnRyb2xXb3JkUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcW2EtekEtWkBdK1wiO1xudmFyIGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbXlxcdUQ4MDAtXFx1REZGRl1cIjtcbnZhciBjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZyA9IFwiKFwiICsgY29udHJvbFdvcmRSZWdleFN0cmluZyArIFwiKVwiICsgc3BhY2VSZWdleFN0cmluZyArIFwiKlwiO1xudmFyIGNvbnRyb2xTcGFjZVJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXChcXG58WyBcXHJcXHRdK1xcbj8pWyBcXHJcXHRdKlwiO1xudmFyIGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Zl1cIjtcbnZhciBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKyRcIik7XG52YXIgdG9rZW5SZWdleFN0cmluZyA9IFwiKFwiICsgc3BhY2VSZWdleFN0cmluZyArIFwiKyl8XCIgKyAoIC8vIHdoaXRlc3BhY2VcbmNvbnRyb2xTcGFjZVJlZ2V4U3RyaW5nICsgXCJ8XCIpICsgLy8gXFx3aGl0ZXNwYWNlXG5cIihbIS1cXFxcW1xcXFxdLVxcdTIwMjdcXHUyMDJBLVxcdUQ3RkZcXHVGOTAwLVxcdUZGRkZdXCIgKyAoIC8vIHNpbmdsZSBjb2RlcG9pbnRcbmNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArIFwiKlwiKSArIC8vIC4uLnBsdXMgYWNjZW50c1xuXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgKCAvLyBzdXJyb2dhdGUgcGFpclxuY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIqXCIpICsgLy8gLi4ucGx1cyBhY2NlbnRzXG5cInxcXFxcXFxcXHZlcmJcXFxcKihbXl0pLio/XFxcXDRcIiArIC8vIFxcdmVyYipcblwifFxcXFxcXFxcdmVyYihbXiphLXpBLVpdKS4qP1xcXFw1XCIgKyAoIC8vIFxcdmVyYiB1bnN0YXJyZWRcblwifFwiICsgY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXhTdHJpbmcpICsgKCAvLyBcXG1hY3JvTmFtZSArIHNwYWNlc1xuXCJ8XCIgKyBjb250cm9sU3ltYm9sUmVnZXhTdHJpbmcgKyBcIilcIik7IC8vIFxcXFwsIFxcJywgZXRjLlxuXG4vKiogTWFpbiBMZXhlciBjbGFzcyAqL1xuXG5jbGFzcyBMZXhlciB7XG4gIC8vIENhdGVnb3J5IGNvZGVzLiBUaGUgbGV4ZXIgb25seSBzdXBwb3J0cyBjb21tZW50IGNoYXJhY3RlcnMgKDE0KSBmb3Igbm93LlxuICAvLyBNYWNyb0V4cGFuZGVyIGFkZGl0aW9uYWxseSBkaXN0aW5ndWlzaGVzIGFjdGl2ZSAoMTMpLlxuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLmlucHV0ID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlblJlZ2V4ID0gdm9pZCAwO1xuICAgIHRoaXMuY2F0Y29kZXMgPSB2b2lkIDA7XG4gICAgLy8gU2VwYXJhdGUgYWNjZW50cyBmcm9tIGNoYXJhY3RlcnNcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMudG9rZW5SZWdleCA9IG5ldyBSZWdFeHAodG9rZW5SZWdleFN0cmluZywgJ2cnKTtcbiAgICB0aGlzLmNhdGNvZGVzID0ge1xuICAgICAgXCIlXCI6IDE0LFxuICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIFwiflwiOiAxMyAvLyBhY3RpdmUgY2hhcmFjdGVyXG5cbiAgICB9O1xuICB9XG5cbiAgc2V0Q2F0Y29kZShjaGFyLCBjb2RlKSB7XG4gICAgdGhpcy5jYXRjb2Rlc1tjaGFyXSA9IGNvZGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbGV4ZXMgYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuXG5cbiAgbGV4KCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgdmFyIHBvcyA9IHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXg7XG5cbiAgICBpZiAocG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oXCJFT0ZcIiwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zKSk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gdGhpcy50b2tlblJlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmluZGV4ICE9PSBwb3MpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICdcIiArIGlucHV0W3Bvc10gKyBcIidcIiwgbmV3IFRva2VuKGlucHV0W3Bvc10sIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcyArIDEpKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBtYXRjaFs2XSB8fCBtYXRjaFszXSB8fCAobWF0Y2hbMl0gPyBcIlxcXFwgXCIgOiBcIiBcIik7XG5cbiAgICBpZiAodGhpcy5jYXRjb2Rlc1t0ZXh0XSA9PT0gMTQpIHtcbiAgICAgIC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgICB2YXIgbmxJbmRleCA9IGlucHV0LmluZGV4T2YoJ1xcbicsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpO1xuXG4gICAgICBpZiAobmxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IGlucHV0Lmxlbmd0aDsgLy8gRU9GXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJjb21tZW50QXRFbmRcIiwgXCIlIGNvbW1lbnQgaGFzIG5vIHRlcm1pbmF0aW5nIG5ld2xpbmU7IExhVGVYIHdvdWxkIFwiICsgXCJmYWlsIGJlY2F1c2Ugb2YgY29tbWVudGluZyB0aGUgZW5kIG9mIG1hdGggbW9kZSAoZS5nLiAkKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KSk7XG4gIH1cblxufVxuXG4vKipcbiAqIEEgYE5hbWVzcGFjZWAgcmVmZXJzIHRvIGEgc3BhY2Ugb2YgbmFtZWFibGUgdGhpbmdzIGxpa2UgbWFjcm9zIG9yIGxlbmd0aHMsXG4gKiB3aGljaCBjYW4gYmUgYHNldGAgZWl0aGVyIGdsb2JhbGx5IG9yIGxvY2FsIHRvIGEgbmVzdGVkIGdyb3VwLCB1c2luZyBhblxuICogdW5kbyBzdGFjayBzaW1pbGFyIHRvIGhvdyBUZVggaW1wbGVtZW50cyB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKiBQZXJmb3JtYW5jZS13aXNlLCBgZ2V0YCBhbmQgbG9jYWwgYHNldGAgdGFrZSBjb25zdGFudCB0aW1lLCB3aGlsZSBnbG9iYWxcbiAqIGBzZXRgIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIHRoZSBkZXB0aCBvZiBncm91cCBuZXN0aW5nLlxuICovXG5jbGFzcyBOYW1lc3BhY2Uge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1aWx0aW5zLCBnbG9iYWxNYWNyb3MpIHtcbiAgICBpZiAoYnVpbHRpbnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVpbHRpbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsTWFjcm9zID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbE1hY3JvcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1aWx0aW5zID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnQgPSBnbG9iYWxNYWNyb3M7XG4gICAgdGhpcy5idWlsdGlucyA9IGJ1aWx0aW5zO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cblxuXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy51bmRlZlN0YWNrLnB1c2goe30pO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBuZXN0ZWQgZ3JvdXAsIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZSBncm91cCBiZWdhbi5cbiAgICovXG5cblxuICBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmJhbGFuY2VkIG5hbWVzcGFjZSBkZXN0cnVjdGlvbjogYXR0ZW1wdCBcIiArIFwidG8gcG9wIGdsb2JhbCBuYW1lc3BhY2U7IHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiKTtcbiAgICB9XG5cbiAgICB2YXIgdW5kZWZzID0gdGhpcy51bmRlZlN0YWNrLnBvcCgpO1xuXG4gICAgZm9yICh2YXIgdW5kZWYgaW4gdW5kZWZzKSB7XG4gICAgICBpZiAodW5kZWZzLmhhc093blByb3BlcnR5KHVuZGVmKSkge1xuICAgICAgICBpZiAodW5kZWZzW3VuZGVmXSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY3VycmVudFt1bmRlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50W3VuZGVmXSA9IHVuZGVmc1t1bmRlZl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuZHMgYWxsIGN1cnJlbnRseSBuZXN0ZWQgZ3JvdXBzIChpZiBhbnkpLCByZXN0b3JpbmcgdmFsdWVzIGJlZm9yZSB0aGVcbiAgICogZ3JvdXBzIGJlZ2FuLiAgVXNlZnVsIGluIGNhc2Ugb2YgYW4gZXJyb3IgaW4gdGhlIG1pZGRsZSBvZiBwYXJzaW5nLlxuICAgKi9cblxuXG4gIGVuZEdyb3VwcygpIHtcbiAgICB3aGlsZSAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW5kR3JvdXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERldGVjdCB3aGV0aGVyIGBuYW1lYCBoYXMgYSBkZWZpbml0aW9uLiAgRXF1aXZhbGVudCB0b1xuICAgKiBgZ2V0KG5hbWUpICE9IG51bGxgLlxuICAgKi9cblxuXG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCB0aGlzLmJ1aWx0aW5zLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyB2YWx1ZS5cbiAgICpcbiAgICogTm90ZTogRG8gbm90IHVzZSBgaWYgKG5hbWVzcGFjZS5nZXQoLi4uKSlgIHRvIGRldGVjdCB3aGV0aGVyIGEgbWFjcm9cbiAgICogaXMgZGVmaW5lZCwgYXMgdGhlIGRlZmluaXRpb24gbWF5IGJlIHRoZSBlbXB0eSBzdHJpbmcgd2hpY2ggZXZhbHVhdGVzXG4gICAqIHRvIGBmYWxzZWAgaW4gSmF2YVNjcmlwdC4gIFVzZSBgaWYgKG5hbWVzcGFjZS5nZXQoLi4uKSAhPSBudWxsKWAgb3JcbiAgICogYGlmIChuYW1lc3BhY2UuaGFzKC4uLikpYC5cbiAgICovXG5cblxuICBnZXQobmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWx0aW5zW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgYW5kIG9wdGlvbmFsbHkgc2V0IGl0IGdsb2JhbGx5IHRvby5cbiAgICogTG9jYWwgc2V0KCkgc2V0cyB0aGUgY3VycmVudCB2YWx1ZSBhbmQgKHdoZW4gYXBwcm9wcmlhdGUpIGFkZHMgYW4gdW5kb1xuICAgKiBvcGVyYXRpb24gdG8gdGhlIHVuZG8gc3RhY2suICBHbG9iYWwgc2V0KCkgbWF5IGNoYW5nZSB0aGUgdW5kb1xuICAgKiBvcGVyYXRpb24gYXQgZXZlcnkgbGV2ZWwsIHNvIHRha2VzIHRpbWUgbGluZWFyIGluIHRoZWlyIG51bWJlci5cbiAgICogQSB2YWx1ZSBvZiB1bmRlZmluZWQgbWVhbnMgdG8gZGVsZXRlIGV4aXN0aW5nIGRlZmluaXRpb25zLlxuICAgKi9cblxuXG4gIHNldChuYW1lLCB2YWx1ZSwgZ2xvYmFsKSB7XG4gICAgaWYgKGdsb2JhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBnbG9iYWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAvLyBHbG9iYWwgc2V0IGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyBpbiBhbGwgZ3JvdXBzLiAgU2ltdWxhdGUgdGhpc1xuICAgICAgLy8gYnkgZGVzdHJveWluZyBhbnkgdW5kb3MgY3VycmVudGx5IHNjaGVkdWxlZCBmb3IgdGhpcyBuYW1lLFxuICAgICAgLy8gYW5kIGFkZGluZyBhbiB1bmRvIHdpdGggdGhlICpuZXcqIHZhbHVlIChpbiBjYXNlIGl0IGxhdGVyIGdldHNcbiAgICAgIC8vIGxvY2FsbHkgcmVzZXQgd2l0aGluIHRoaXMgZW52aXJvbm1lbnQpLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuZGVmU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5kZWZTdGFja1tpXVtuYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB0aGlzIHNldCBhdCBlbmQgb2YgdGhpcyBncm91cCAocG9zc2libHkgdG8gYHVuZGVmaW5lZGApLFxuICAgICAgLy8gdW5sZXNzIGFuIHVuZG8gaXMgYWxyZWFkeSBpbiBwbGFjZSwgaW4gd2hpY2ggY2FzZSB0aGF0IG9sZGVyXG4gICAgICAvLyB2YWx1ZSBpcyB0aGUgY29ycmVjdCBvbmUuXG4gICAgICB2YXIgdG9wID0gdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHRvcCAmJiAhdG9wLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRvcFtuYW1lXSA9IHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBQcmVkZWZpbmVkIG1hY3JvcyBmb3IgS2FUZVguXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBzb21lIGNvbW1hbmRzIGluIHRlcm1zIG9mIG90aGVycy5cbiAqL1xudmFyIG1hY3JvcyA9IF9tYWNyb3M7XG4vLyBtYWNybyB0b29sc1xuXG5kZWZpbmVNYWNybyhcIlxcXFxub2V4cGFuZFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUaGUgZXhwYW5zaW9uIGlzIHRoZSB0b2tlbiBpdHNlbGY7IGJ1dCB0aGF0IHRva2VuIGlzIGludGVycHJldGVkXG4gIC8vIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmSBpZiBpdCBpcyBhIGNvbnRyb2wgc2VxdWVuY2UgdGhhdFxuICAvLyB3b3VsZCBvcmRpbmFyaWx5IGJlIGV4cGFuZGVkIGJ5IFRlWOKAmXMgZXhwYW5zaW9uIHJ1bGVzLlxuICB2YXIgdCA9IGNvbnRleHQucG9wVG9rZW4oKTtcblxuICBpZiAoY29udGV4dC5pc0V4cGFuZGFibGUodC50ZXh0KSkge1xuICAgIHQubm9leHBhbmQgPSB0cnVlO1xuICAgIHQudHJlYXRBc1JlbGF4ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBbdF0sXG4gICAgbnVtQXJnczogMFxuICB9O1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxleHBhbmRhZnRlclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAvLyBUZVggZmlyc3QgcmVhZHMgdGhlIHRva2VuIHRoYXQgY29tZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgXFxleHBhbmRhZnRlcixcbiAgLy8gd2l0aG91dCBleHBhbmRpbmcgaXQ7IGxldOKAmXMgY2FsbCB0aGlzIHRva2VuIHQuIFRoZW4gVGVYIHJlYWRzIHRoZVxuICAvLyB0b2tlbiB0aGF0IGNvbWVzIGFmdGVyIHQgKGFuZCBwb3NzaWJseSBtb3JlIHRva2VucywgaWYgdGhhdCB0b2tlblxuICAvLyBoYXMgYW4gYXJndW1lbnQpLCByZXBsYWNpbmcgaXQgYnkgaXRzIGV4cGFuc2lvbi4gRmluYWxseSBUZVggcHV0c1xuICAvLyB0IGJhY2sgaW4gZnJvbnQgb2YgdGhhdCBleHBhbnNpb24uXG4gIHZhciB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBjb250ZXh0LmV4cGFuZE9uY2UodHJ1ZSk7IC8vIGV4cGFuZCBvbmx5IGFuIGV4cGFuZGFibGUgdG9rZW5cblxuICByZXR1cm4ge1xuICAgIHRva2VuczogW3RdLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn0pOyAvLyBMYVRlWCdzIFxcQGZpcnN0b2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMxLCBza2lwcGluZyAjMlxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBmaXJzdG9mdHdvIzEjMnsjMX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGZpcnN0b2Z0d29cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1swXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBzZWNvbmRvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzIsIHNraXBwaW5nICMxXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQHNlY29uZG9mdHdvIzEjMnsjMn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQHNlY29uZG9mdHdvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IGFyZ3NbMV0sXG4gICAgbnVtQXJnczogMFxuICB9O1xufSk7IC8vIExhVGVYJ3MgXFxAaWZuZXh0Y2hhcnsjMX17IzJ9eyMzfSBsb29rcyBhaGVhZCB0byB0aGUgbmV4dCAodW5leHBhbmRlZClcbi8vIHN5bWJvbCB0aGF0IGlzbid0IGEgc3BhY2UsIGNvbnN1bWluZyBhbnkgc3BhY2VzIGJ1dCBub3QgY29uc3VtaW5nIHRoZVxuLy8gZmlyc3Qgbm9uc3BhY2UgY2hhcmFjdGVyLiAgSWYgdGhhdCBub25zcGFjZSBjaGFyYWN0ZXIgbWF0Y2hlcyAjMSwgdGhlblxuLy8gdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzI7IG90aGVyd2lzZSwgaXQgZXhwYW5kcyB0byAjMy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmbmV4dGNoYXJcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDMpOyAvLyBzeW1ib2wsIGlmLCBlbHNlXG5cbiAgY29udGV4dC5jb25zdW1lU3BhY2VzKCk7XG4gIHZhciBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gIGlmIChhcmdzWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdWzBdLnRleHQgPT09IG5leHRUb2tlbi50ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMl0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmc3RhclwiLCBcIlxcXFxAaWZuZXh0Y2hhciAqe1xcXFxAZmlyc3RvZnR3b3sjMX19XCIpOyAvLyBMYVRlWCdzIFxcVGV4dE9yTWF0aHsjMX17IzJ9IGV4cGFuZHMgdG8gIzEgaW4gdGV4dCBtb2RlLCAjMiBpbiBtYXRoIG1vZGVcblxuZGVmaW5lTWFjcm8oXCJcXFxcVGV4dE9yTWF0aFwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG5cbiAgaWYgKGNvbnRleHQubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1swXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IGFyZ3NbMV0sXG4gICAgICBudW1BcmdzOiAwXG4gICAgfTtcbiAgfVxufSk7IC8vIExvb2t1cCB0YWJsZSBmb3IgcGFyc2luZyBudW1iZXJzIGluIGJhc2UgOCB0aHJvdWdoIDE2XG5cbnZhciBkaWdpdFRvTnVtYmVyID0ge1xuICBcIjBcIjogMCxcbiAgXCIxXCI6IDEsXG4gIFwiMlwiOiAyLFxuICBcIjNcIjogMyxcbiAgXCI0XCI6IDQsXG4gIFwiNVwiOiA1LFxuICBcIjZcIjogNixcbiAgXCI3XCI6IDcsXG4gIFwiOFwiOiA4LFxuICBcIjlcIjogOSxcbiAgXCJhXCI6IDEwLFxuICBcIkFcIjogMTAsXG4gIFwiYlwiOiAxMSxcbiAgXCJCXCI6IDExLFxuICBcImNcIjogMTIsXG4gIFwiQ1wiOiAxMixcbiAgXCJkXCI6IDEzLFxuICBcIkRcIjogMTMsXG4gIFwiZVwiOiAxNCxcbiAgXCJFXCI6IDE0LFxuICBcImZcIjogMTUsXG4gIFwiRlwiOiAxNVxufTsgLy8gVGVYIFxcY2hhciBtYWtlcyBhIGxpdGVyYWwgY2hhcmFjdGVyIChjYXRjb2RlIDEyKSB1c2luZyB0aGUgZm9sbG93aW5nIGZvcm1zOlxuLy8gKHNlZSBUaGUgVGVYQm9vaywgcC4gNDMpXG4vLyAgIFxcY2hhcjEyMyAgLS0gZGVjaW1hbFxuLy8gICBcXGNoYXInMTIzIC0tIG9jdGFsXG4vLyAgIFxcY2hhclwiMTIzIC0tIGhleFxuLy8gICBcXGNoYXJgeCAgIC0tIGNoYXJhY3RlciB0aGF0IGNhbiBiZSB3cml0dGVuIChpLmUuIGlzbid0IGFjdGl2ZSlcbi8vICAgXFxjaGFyYFxceCAgLS0gY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIHdyaXR0ZW4gKGUuZy4gJSlcbi8vIFRoZXNlIGFsbCByZWZlciB0byBjaGFyYWN0ZXJzIGZyb20gdGhlIGZvbnQsIHNvIHdlIHR1cm4gdGhlbSBpbnRvIHNwZWNpYWxcbi8vIGNhbGxzIHRvIGEgZnVuY3Rpb24gXFxAY2hhciBkZWFsdCB3aXRoIGluIHRoZSBQYXJzZXIuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGNoYXJcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB2YXIgYmFzZTtcbiAgdmFyIG51bWJlciA9ICcnO1xuXG4gIGlmICh0b2tlbi50ZXh0ID09PSBcIidcIikge1xuICAgIGJhc2UgPSA4O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09ICdcIicpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJgXCIpIHtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcblxuICAgIGlmICh0b2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDEpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcY2hhcmAgbWlzc2luZyBhcmd1bWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gMTA7XG4gIH1cblxuICBpZiAoYmFzZSkge1xuICAgIC8vIFBhcnNlIGEgbnVtYmVyIGluIHRoZSBnaXZlbiBiYXNlLCBzdGFydGluZyB3aXRoIGZpcnN0IGB0b2tlbmAuXG4gICAgbnVtYmVyID0gZGlnaXRUb051bWJlclt0b2tlbi50ZXh0XTtcblxuICAgIGlmIChudW1iZXIgPT0gbnVsbCB8fCBudW1iZXIgPj0gYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGJhc2UtXCIgKyBiYXNlICsgXCIgZGlnaXQgXCIgKyB0b2tlbi50ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgZGlnaXQ7XG5cbiAgICB3aGlsZSAoKGRpZ2l0ID0gZGlnaXRUb051bWJlcltjb250ZXh0LmZ1dHVyZSgpLnRleHRdKSAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkge1xuICAgICAgbnVtYmVyICo9IGJhc2U7XG4gICAgICBudW1iZXIgKz0gZGlnaXQ7XG4gICAgICBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXFxcXEBjaGFye1wiICsgbnVtYmVyICsgXCJ9XCI7XG59KTsgLy8gXFxuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3Nde2RlZmluaXRpb259XG4vLyBcXHJlbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXXtkZWZpbml0aW9ufVxuLy8gVE9ETzogT3B0aW9uYWwgYXJndW1lbnRzOiBcXG5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc11bZGVmYXVsdF17ZGVmaW5pdGlvbn1cblxudmFyIG5ld2NvbW1hbmQgPSAoY29udGV4dCwgZXhpc3RzT0ssIG5vbmV4aXN0c09LKSA9PiB7XG4gIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG5cbiAgaWYgKGFyZy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxuZXdjb21tYW5kJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG1hY3JvIG5hbWVcIik7XG4gIH1cblxuICB2YXIgbmFtZSA9IGFyZ1swXS50ZXh0O1xuICB2YXIgZXhpc3RzID0gY29udGV4dC5pc0RlZmluZWQobmFtZSk7XG5cbiAgaWYgKGV4aXN0cyAmJiAhZXhpc3RzT0spIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxuZXdjb21tYW5ke1wiICsgbmFtZSArIFwifSBhdHRlbXB0aW5nIHRvIHJlZGVmaW5lIFwiICsgKG5hbWUgKyBcIjsgdXNlIFxcXFxyZW5ld2NvbW1hbmRcIikpO1xuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgIW5vbmV4aXN0c09LKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxccmVuZXdjb21tYW5ke1wiICsgbmFtZSArIFwifSB3aGVuIGNvbW1hbmQgXCIgKyBuYW1lICsgXCIgXCIgKyBcImRvZXMgbm90IHlldCBleGlzdDsgdXNlIFxcXFxuZXdjb21tYW5kXCIpO1xuICB9XG5cbiAgdmFyIG51bUFyZ3MgPSAwO1xuICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG5cbiAgaWYgKGFyZy5sZW5ndGggPT09IDEgJiYgYXJnWzBdLnRleHQgPT09IFwiW1wiKSB7XG4gICAgdmFyIGFyZ1RleHQgPSAnJztcbiAgICB2YXIgdG9rZW4gPSBjb250ZXh0LmV4cGFuZE5leHRUb2tlbigpO1xuXG4gICAgd2hpbGUgKHRva2VuLnRleHQgIT09IFwiXVwiICYmIHRva2VuLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCBwcm9wZXJseSBleHBhbmQgYXJnLCBlLmcuLCBpZ25vcmUge31zXG4gICAgICBhcmdUZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICB0b2tlbiA9IGNvbnRleHQuZXhwYW5kTmV4dFRva2VuKCk7XG4gICAgfVxuXG4gICAgaWYgKCFhcmdUZXh0Lm1hdGNoKC9eXFxzKlswLTldK1xccyokLykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzOiBcIiArIGFyZ1RleHQpO1xuICAgIH1cblxuICAgIG51bUFyZ3MgPSBwYXJzZUludChhcmdUZXh0KTtcbiAgICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIH0gLy8gRmluYWwgYXJnIGlzIHRoZSBleHBhbnNpb24gb2YgdGhlIG1hY3JvXG5cblxuICBjb250ZXh0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgIHRva2VuczogYXJnLFxuICAgIG51bUFyZ3NcbiAgfSk7XG4gIHJldHVybiAnJztcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5ld2NvbW1hbmRcIiwgY29udGV4dCA9PiBuZXdjb21tYW5kKGNvbnRleHQsIGZhbHNlLCB0cnVlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxyZW5ld2NvbW1hbmRcIiwgY29udGV4dCA9PiBuZXdjb21tYW5kKGNvbnRleHQsIHRydWUsIGZhbHNlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxwcm92aWRlY29tbWFuZFwiLCBjb250ZXh0ID0+IG5ld2NvbW1hbmQoY29udGV4dCwgdHJ1ZSwgdHJ1ZSkpOyAvLyB0ZXJtaW5hbCAoY29uc29sZSkgdG9vbHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbWVzc2FnZVwiLCBjb250ZXh0ID0+IHtcbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5sb2coYXJnLnJldmVyc2UoKS5tYXAodG9rZW4gPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKSk7XG4gIHJldHVybiAnJztcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXJybWVzc2FnZVwiLCBjb250ZXh0ID0+IHtcbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5lcnJvcihhcmcucmV2ZXJzZSgpLm1hcCh0b2tlbiA9PiB0b2tlbi50ZXh0KS5qb2luKFwiXCIpKTtcbiAgcmV0dXJuICcnO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxzaG93XCIsIGNvbnRleHQgPT4ge1xuICB2YXIgdG9rID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB2YXIgbmFtZSA9IHRvay50ZXh0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gIGNvbnNvbGUubG9nKHRvaywgY29udGV4dC5tYWNyb3MuZ2V0KG5hbWUpLCBmdW5jdGlvbnNbbmFtZV0sIHN5bWJvbHMubWF0aFtuYW1lXSwgc3ltYm9scy50ZXh0W25hbWVdKTtcbiAgcmV0dXJuICcnO1xufSk7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdyb3VwaW5nXG4vLyBcXGxldFxcYmdyb3VwPXsgXFxsZXRcXGVncm91cD19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJncm91cFwiLCBcIntcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlZ3JvdXBcIiwgXCJ9XCIpOyAvLyBTeW1ib2xzIGZyb20gbGF0ZXgubHR4OlxuLy8gXFxkZWZ+e1xcbm9icmVha3NwYWNle319XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG4vLyBcXGRlZiBcXEFBIHtcXHIgQX1cblxuZGVmaW5lTWFjcm8oXCJ+XCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxxXCIsIFwiYFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJxXCIsIFwiJ1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFhXCIsIFwiXFxcXHIgYVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFBXCIsIFwiXFxcXHIgQVwiKTsgLy8gQ29weXJpZ2h0IChDKSBhbmQgcmVnaXN0ZXJlZCAoUikgc3ltYm9scy4gVXNlIHJhdyBzeW1ib2wgaW4gTWF0aE1MLlxuLy8gXFxEZWNsYXJlVGV4dENvbW1hbmREZWZhdWx0e1xcdGV4dGNvcHlyaWdodH17XFx0ZXh0Y2lyY2xlZHtjfX1cbi8vIFxcRGVjbGFyZVRleHRDb21tYW5kRGVmYXVsdHtcXHRleHRyZWdpc3RlcmVkfXtcXHRleHRjaXJjbGVkeyVcbi8vICAgICAgXFxjaGVja0BtYXRoZm9udHNcXGZvbnRzaXplXFxzZkBzaXplXFx6QFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250IFJ9fVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXGNvcHlyaWdodH17JVxuLy8gICAgXFxpZm1tb2Rle1xcbmZzc0B0ZXh0e1xcdGV4dGNvcHlyaWdodH19XFxlbHNlXFx0ZXh0Y29weXJpZ2h0XFxmaX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dGNvcHlyaWdodFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcdGV4dGNpcmNsZWR7Y319e1xcXFxjaGFyYMKpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvcHlyaWdodFwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFx0ZXh0Y29weXJpZ2h0fXtcXFxcdGV4dHtcXFxcdGV4dGNvcHlyaWdodH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHRleHRjaXJjbGVke1xcXFxzY3JpcHRzaXplIFJ9fXtcXFxcY2hhcmDCrn1cIik7IC8vIENoYXJhY3RlcnMgb21pdHRlZCBmcm9tIFVuaWNvZGUgcmFuZ2UgMUQ0MDDigJMxRDdGRlxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMkNcIiwgXCJcXFxcbWF0aHNjcntCfVwiKTsgLy8gc2NyaXB0XG5cbmRlZmluZU1hY3JvKFwiXFx1MjEzMFwiLCBcIlxcXFxtYXRoc2Nye0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTMxXCIsIFwiXFxcXG1hdGhzY3J7Rn1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMEJcIiwgXCJcXFxcbWF0aHNjcntIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExMFwiLCBcIlxcXFxtYXRoc2Nye0l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTEyXCIsIFwiXFxcXG1hdGhzY3J7TH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMzNcIiwgXCJcXFxcbWF0aHNjcntNfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExQlwiLCBcIlxcXFxtYXRoc2Nye1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTJEXCIsIFwiXFxcXG1hdGhmcmFre0N9XCIpOyAvLyBGcmFrdHVyXG5cbmRlZmluZU1hY3JvKFwiXFx1MjEwQ1wiLCBcIlxcXFxtYXRoZnJha3tIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEyOFwiLCBcIlxcXFxtYXRoZnJha3tafVwiKTsgLy8gRGVmaW5lIFxcQmJiayB3aXRoIGEgbWFjcm8gdGhhdCB3b3JrcyBpbiBib3RoIEhUTUwgYW5kIE1hdGhNTC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcQmJia1wiLCBcIlxcXFxCYmJ7a31cIik7IC8vIFVuaWNvZGUgbWlkZGxlIGRvdFxuLy8gVGhlIEthVGVYIGZvbnRzIGRvIG5vdCBjb250YWluIFUrMDBCNy4gSW5zdGVhZCwgXFxjZG90cCBkaXNwbGF5c1xuLy8gdGhlIGRvdCBhdCBVKzIyQzUgYW5kIGdpdmVzIGl0IHB1bmN0IHNwYWNpbmcuXG5cbmRlZmluZU1hY3JvKFwiXFx1MDBiN1wiLCBcIlxcXFxjZG90cFwiKTsgLy8gXFxsbGFwIGFuZCBcXHJsYXAgcmVuZGVyIHRoZWlyIGNvbnRlbnRzIGluIHRleHQgbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGFwXCIsIFwiXFxcXG1hdGhsbGFwe1xcXFx0ZXh0cm17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJsYXBcIiwgXCJcXFxcbWF0aHJsYXB7XFxcXHRleHRybXsjMX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2xhcFwiLCBcIlxcXFxtYXRoY2xhcHtcXFxcdGV4dHJteyMxfX1cIik7IC8vIFxcbWF0aHN0cnV0IGZyb20gdGhlIFRlWGJvb2ssIHAgMzYwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG1hdGhzdHJ1dFwiLCBcIlxcXFx2cGhhbnRvbXsofVwiKTsgLy8gXFx1bmRlcmJhciBmcm9tIFRlWGJvb2sgcCAzNTNcblxuZGVmaW5lTWFjcm8oXCJcXFxcdW5kZXJiYXJcIiwgXCJcXFxcdW5kZXJsaW5le1xcXFx0ZXh0eyMxfX1cIik7IC8vIFxcbm90IGlzIGRlZmluZWQgYnkgYmFzZS9mb250bWF0aC5sdHggdmlhXG4vLyBcXERlY2xhcmVNYXRoU3ltYm9se1xcbm90fXtcXG1hdGhyZWx9e3N5bWJvbHN9e1wiMzZ9XG4vLyBJdCdzIHRodXMgdHJlYXRlZCBsaWtlIGEgXFxtYXRocmVsLCBidXQgZGVmaW5lZCBieSBhIHN5bWJvbCB0aGF0IGhhcyB6ZXJvXG4vLyB3aWR0aCBidXQgZXh0ZW5kcyB0byB0aGUgcmlnaHQuICBXZSB1c2UgXFxybGFwIHRvIGdldCB0aGF0IHNwYWNpbmcuXG4vLyBGb3IgTWF0aE1MIHdlIHdyaXRlIFUrMDMzOCBoZXJlLiBidWlsZE1hdGhNTC5qcyB3aWxsIHRoZW4gZG8gdGhlIG92ZXJsYXkuXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdFwiLCAnXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse1xcXFxtYXRocmxhcFxcXFxAbm90fX17XFxcXGNoYXJcIjMzOH0nKTsgLy8gTmVnYXRlZCBzeW1ib2xzIGZyb20gYmFzZS9mb250bWF0aC5sdHg6XG4vLyBcXGRlZlxcbmVxe1xcbm90PX0gXFxsZXRcXG5lPVxcbmVxXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXG4vLyAgIFxcbm90aW57XFxtYXRocmVse1xcbUB0aFxcbWF0aHBhbGV0dGVcXGNAbmNlbFxcaW59fVxuLy8gXFxkZWZcXGNAbmNlbCMxIzJ7XFxtQHRoXFxvb2FsaWdueyRcXGhmaWwjMVxcbWtlcm4xbXUvXFxoZmlsJFxcY3JjciQjMSMyJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHtcXFxcbm90PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYOKJoH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmVcIiwgXCJcXFxcbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGluXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse3tcXFxcaW59XFxcXG1hdGhsbGFwey9cXFxcbXNraXAxbXV9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYOKIiX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjA5XCIsIFwiXFxcXG5vdGluXCIpOyAvLyBVbmljb2RlIHN0YWNrZWQgcmVsYXRpb25zXG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1OFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxrZXJuey0xZW19XFxcXHJhaXNlYm94ezAuNGVtfXskXFxcXHNjcmlwdHNpemVcXFxcZnJvd24kfX1cIiArIFwifXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjU4fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNTlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXHdlZGdlfXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1OH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVBXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFx2ZWV9ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVBfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFxzY3JpcHRzaXplXFxcXHN0YXJ9ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1Qn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVEXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFxtYXRocm17ZGVmfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVEfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUVcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXG1hdGhybXttfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVFfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUZcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55P317PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUZ9fVwiKTsgLy8gTWlzYyBVbmljb2RlXG5cbmRlZmluZU1hY3JvKFwiXFx1MjdDMlwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMDNDXCIsIFwiXFxcXG1hdGhjbG9zZXshXFxcXG1rZXJuLTAuOG11IX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyMENcIiwgXCJcXFxcbm90bmlcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUNcIiwgXCJcXFxcdWxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUVcIiwgXCJcXFxcbGxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTAwQTlcIiwgXCJcXFxcY29weXJpZ2h0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUwMEFFXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHVGRTBGXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpOyAvLyBUaGUgS2FUZVggZm9udHMgaGF2ZSBjb3JuZXJzIGF0IGNvZGVwb2ludHMgdGhhdCBkb24ndCBtYXRjaCBVbmljb2RlLlxuLy8gRm9yIE1hdGhNTCBwdXJwb3NlcywgdXNlIHRoZSBVbmljb2RlIGNvZGUgcG9pbnQuXG5cbmRlZmluZU1hY3JvKFwiXFxcXHVsY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdWxjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxY319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXJjb3JuZXJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB1cmNvcm5lcn17XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMzFkfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsbGNvcm5lclwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGxsY29ybmVyfXtcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIzMWV9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbHJjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxZn19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWF8yzrVcbi8vIFxcdmRvdHN7XFx2Ym94e1xcYmFzZWxpbmVza2lwNFxccEAgIFxcbGluZXNraXBsaW1pdFxcekBcbi8vIFxca2VybjZcXHBAXFxoYm94ey59XFxoYm94ey59XFxoYm94ey59fX1cbi8vIFdlJ2xsIGNhbGwgXFx2YXJ2ZG90cywgd2hpY2ggZ2V0cyBhIGdseXBoIGZyb20gc3ltYm9scy5qcy5cbi8vIFRoZSB6ZXJvLXdpZHRoIHJ1bGUgZ2V0cyB1cyBhbiBlcXVpdmFsZW50IHRvIHRoZSB2ZXJ0aWNhbCA2cHQga2Vybi5cblxuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdHNcIiwgXCJcXFxcbWF0aG9yZHtcXFxcdmFydmRvdHNcXFxccnVsZXswcHR9ezE1cHR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYW1zbWF0aC5zdHlcbi8vIGh0dHA6Ly9taXJyb3JzLmNvbmNlcnRwYXNzLmNvbS90ZXgtYXJjaGl2ZS9tYWNyb3MvbGF0ZXgvcmVxdWlyZWQvYW1zbWF0aC9hbXNtYXRoLnBkZlxuLy8gSXRhbGljIEdyZWVrIGNhcGl0YWwgbGV0dGVycy4gIEFNUyBkZWZpbmVzIHRoZXNlIHdpdGggXFxEZWNsYXJlTWF0aFN5bWJvbCxcbi8vIGJ1dCB0aGV5IGFyZSBlcXVpdmFsZW50IHRvIFxcbWF0aGl0e1xcTGV0dGVyfS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcdmFyR2FtbWFcIiwgXCJcXFxcbWF0aGl0e1xcXFxHYW1tYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJEZWx0YVwiLCBcIlxcXFxtYXRoaXR7XFxcXERlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclRoZXRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcVGhldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyTGFtYmRhXCIsIFwiXFxcXG1hdGhpdHtcXFxcTGFtYmRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclhpXCIsIFwiXFxcXG1hdGhpdHtcXFxcWGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxQaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJTaWdtYVwiLCBcIlxcXFxtYXRoaXR7XFxcXFNpZ21hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclVwc2lsb25cIiwgXCJcXFxcbWF0aGl0e1xcXFxVcHNpbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBoaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFBoaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQc2lcIiwgXCJcXFxcbWF0aGl0e1xcXFxQc2l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyT21lZ2FcIiwgXCJcXFxcbWF0aGl0e1xcXFxPbWVnYX1cIik7IC8vXFxuZXdjb21tYW5ke1xcc3Vic3RhY2t9WzFde1xcc3ViYXJyYXl7Y30jMVxcZW5kc3ViYXJyYXl9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHN1YnN0YWNrXCIsIFwiXFxcXGJlZ2lue3N1YmFycmF5fXtjfSMxXFxcXGVuZHtzdWJhcnJheX1cIik7IC8vIFxccmVuZXdjb21tYW5ke1xcY29sb259e1xcbm9icmVha1xcbXNraXAybXVcXG1hdGhwdW5jdHt9XFxub25zY3JpcHRcbi8vIFxcbWtlcm4tXFx0aGlubXVza2lwezp9XFxtc2tpcDZtdXBsdXMxbXVcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvblwiLCBcIlxcXFxub2JyZWFrXFxcXG1za2lwMm11XFxcXG1hdGhwdW5jdHt9XCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2Vybi0zbXV9e1xcXFxta2Vybi0zbXV9e317fXs6fVxcXFxtc2tpcDZtdVxcXFxyZWxheFwiKTsgLy8gXFxuZXdjb21tYW5ke1xcYm94ZWR9WzFde1xcZmJveHtcXG1AdGgkXFxkaXNwbGF5c3R5bGUjMSR9fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxib3hlZFwiLCBcIlxcXFxmYm94eyRcXFxcZGlzcGxheXN0eWxleyMxfSR9XCIpOyAvLyBcXGRlZlxcaWZme1xcRE9UU0JcXDtcXExvbmdsZWZ0cmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVze1xcRE9UU0JcXDtcXExvbmdyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZWRieXtcXERPVFNCXFw7XFxMb25nbGVmdGFycm93XFw7fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxpZmZcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdHJpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZXNcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25ncmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllZGJ5XCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRhcnJvd1xcXFw7XCIpOyAvLyBBTVNNYXRoJ3MgYXV0b21hdGljIFxcZG90cywgYmFzZWQgb24gXFxtZG90c0BAIG1hY3JvLlxuXG52YXIgZG90c0J5VG9rZW4gPSB7XG4gICcsJzogJ1xcXFxkb3RzYycsXG4gICdcXFxcbm90JzogJ1xcXFxkb3RzYicsXG4gIC8vIFxca2V5YmluQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICcrJzogJ1xcXFxkb3RzYicsXG4gICc9JzogJ1xcXFxkb3RzYicsXG4gICc8JzogJ1xcXFxkb3RzYicsXG4gICc+JzogJ1xcXFxkb3RzYicsXG4gICctJzogJ1xcXFxkb3RzYicsXG4gICcqJzogJ1xcXFxkb3RzYicsXG4gICc6JzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNCOlxuICAnXFxcXERPVFNCJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcY29wcm9kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlndmVlJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnd2VkZ2UnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWd1cGx1cyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ2NhcCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ2N1cCc6ICdcXFxcZG90c2InLFxuICAnXFxcXHByb2QnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxzdW0nOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdvdGltZXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdvcGx1cyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ29kb3QnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdzcWN1cCc6ICdcXFxcZG90c2InLFxuICAnXFxcXEFuZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGxvbmdyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcTG9uZ3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcTG9uZ2xlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGxvbmdsZWZ0cmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdsZWZ0cmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXG1hcHN0byc6ICdcXFxcZG90c2InLFxuICAnXFxcXGxvbmdtYXBzdG8nOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxob29rcmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXGRvdGVxJzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhiaW46XG4gICdcXFxcbWF0aGJpbic6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRocmVsOlxuICAnXFxcXG1hdGhyZWwnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxyZWxiYXInOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxSZWxiYXInOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFx4cmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXHhsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU0k6XG4gICdcXFxcRE9UU0knOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxvaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaWlpaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaWRvdHNpbnQnOiAnXFxcXGRvdHNpJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU1g6XG4gICdcXFxcRE9UU1gnOiAnXFxcXGRvdHN4J1xufTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNcIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgLy8gVE9ETzogSWYgdXNlZCBpbiB0ZXh0IG1vZGUsIHNob3VsZCBleHBhbmQgdG8gXFx0ZXh0ZWxsaXBzaXMuXG4gIC8vIEhvd2V2ZXIsIGluIEthVGVYLCBcXHRleHRlbGxpcHNpcyBhbmQgXFxsZG90cyBiZWhhdmUgdGhlIHNhbWVcbiAgLy8gKGluIHRleHQgbW9kZSksIGFuZCBpdCdzIHVubGlrZWx5IHdlJ2Qgc2VlIGFueSBvZiB0aGUgbWF0aCBjb21tYW5kc1xuICAvLyB0aGF0IGFmZmVjdCB0aGUgYmVoYXZpb3Igb2YgXFxkb3RzIHdoZW4gaW4gdGV4dCBtb2RlLiAgU28gZmluZSBmb3Igbm93XG4gIC8vICh1bnRpbCB3ZSBzdXBwb3J0IFxcaWZtbW9kZSAuLi4gXFxlbHNlIC4uLiBcXGZpKS5cbiAgdmFyIHRoZWRvdHMgPSAnXFxcXGRvdHNvJztcbiAgdmFyIG5leHQgPSBjb250ZXh0LmV4cGFuZEFmdGVyRnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBkb3RzQnlUb2tlbikge1xuICAgIHRoZWRvdHMgPSBkb3RzQnlUb2tlbltuZXh0XTtcbiAgfSBlbHNlIGlmIChuZXh0LnN1YnN0cigwLCA0KSA9PT0gJ1xcXFxub3QnKSB7XG4gICAgdGhlZG90cyA9ICdcXFxcZG90c2InO1xuICB9IGVsc2UgaWYgKG5leHQgaW4gc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKFsnYmluJywgJ3JlbCddLCBzeW1ib2xzLm1hdGhbbmV4dF0uZ3JvdXApKSB7XG4gICAgICB0aGVkb3RzID0gJ1xcXFxkb3RzYic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoZWRvdHM7XG59KTtcbnZhciBzcGFjZUFmdGVyRG90cyA9IHtcbiAgLy8gXFxyaWdodGRlbGltQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICcpJzogdHJ1ZSxcbiAgJ10nOiB0cnVlLFxuICAnXFxcXHJicmFjayc6IHRydWUsXG4gICdcXFxcfSc6IHRydWUsXG4gICdcXFxccmJyYWNlJzogdHJ1ZSxcbiAgJ1xcXFxyYW5nbGUnOiB0cnVlLFxuICAnXFxcXHJjZWlsJzogdHJ1ZSxcbiAgJ1xcXFxyZmxvb3InOiB0cnVlLFxuICAnXFxcXHJncm91cCc6IHRydWUsXG4gICdcXFxccm1vdXN0YWNoZSc6IHRydWUsXG4gICdcXFxccmlnaHQnOiB0cnVlLFxuICAnXFxcXGJpZ3InOiB0cnVlLFxuICAnXFxcXGJpZ2dyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdyJzogdHJ1ZSxcbiAgJ1xcXFxCaWdncic6IHRydWUsXG4gIC8vIFxcZXh0cmFAIGFsc28gdGVzdHMgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICckJzogdHJ1ZSxcbiAgLy8gXFxleHRyYXBAIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJzsnOiB0cnVlLFxuICAnLic6IHRydWUsXG4gICcsJzogdHJ1ZVxufTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNvXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzY1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDsgLy8gXFxkb3RzYyB1c2VzIFxcZXh0cmFAIGJ1dCBub3QgXFxleHRyYXBALCBpbnN0ZWFkIHNwZWNpYWxseSBjaGVja2luZyBmb3JcbiAgLy8gJzsnIGFuZCAnLicsIGJ1dCBkb2Vzbid0IGNoZWNrIGZvciAnLCcuXG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMgJiYgbmV4dCAhPT0gJywnKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxjZG90c1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcIjtcbiAgfVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzYlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNtXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2lcIiwgXCJcXFxcIVxcXFxjZG90c1wiKTsgLy8gYW1zbWF0aCBkb2Vzbid0IGFjdHVhbGx5IGRlZmluZSBcXGRvdHN4LCBidXQgXFxkb3RzIGZvbGxvd2VkIGJ5IGEgbWFjcm9cbi8vIHN0YXJ0aW5nIHdpdGggXFxET1RTWCBpbXBsaWVzIFxcZG90c28sIGFuZCB0aGVuIFxcZXh0cmFAIGRldGVjdHMgdGhpcyBjYXNlXG4vLyBhbmQgZm9yY2VzIHRoZSBhZGRlZCBgXFwsYC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c3hcIiwgXCJcXFxcbGRvdHNcXFxcLFwiKTsgLy8gXFxsZXRcXERPVFNJXFxyZWxheFxuLy8gXFxsZXRcXERPVFNCXFxyZWxheFxuLy8gXFxsZXRcXERPVFNYXFxyZWxheFxuXG5kZWZpbmVNYWNybyhcIlxcXFxET1RTSVwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNCXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU1hcIiwgXCJcXFxccmVsYXhcIik7IC8vIFNwYWNpbmcsIGJhc2VkIG9uIGFtc21hdGguc3R5J3Mgb3ZlcnJpZGUgb2YgTGFUZVggZGVmYXVsdHNcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFx0bXNwYWNlfVszXXslXG4vLyAgIFxcaWZtbW9kZVxcbXNraXAjMSMyXFxlbHNlXFxrZXJuIzEjM1xcZmlcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFx0bXNwYWNlXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXGtlcm4jMSMzfXtcXFxcbXNraXAjMSMyfVxcXFxyZWxheFwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFwsfXtcXHRtc3BhY2UrXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXCxcIiwgXCJcXFxcdG1zcGFjZSt7M211fXsuMTY2N2VtfVwiKTsgLy8gXFxsZXRcXHRoaW5zcGFjZVxcLFxuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGluc3BhY2VcIiwgXCJcXFxcLFwiKTsgLy8gXFxkZWZcXD57XFxtc2tpcFxcbWVkbXVza2lwfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFw6fXtcXHRtc3BhY2UrXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBcXD4gYW5kIG1hdGggbW9kZSBvZiBcXDogc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcPlwiLCBcIlxcXFxtc2tpcHs0bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcOlwiLCBcIlxcXFx0bXNwYWNlK3s0bXV9ey4yMjIyZW19XCIpOyAvLyBcXGxldFxcbWVkc3BhY2VcXDpcblxuZGVmaW5lTWFjcm8oXCJcXFxcbWVkc3BhY2VcIiwgXCJcXFxcOlwiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFw7fXtcXHRtc3BhY2UrXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXAgPSA1bXUgcGx1cyA1bXVcblxuZGVmaW5lTWFjcm8oXCJcXFxcO1wiLCBcIlxcXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19XCIpOyAvLyBcXGxldFxcdGhpY2tzcGFjZVxcO1xuXG5kZWZpbmVNYWNybyhcIlxcXFx0aGlja3NwYWNlXCIsIFwiXFxcXDtcIik7IC8vIFxccmVuZXdjb21tYW5ke1xcIX17XFx0bXNwYWNlLVxcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFwhXCIsIFwiXFxcXHRtc3BhY2UtezNtdX17LjE2NjdlbX1cIik7IC8vIFxcbGV0XFxuZWd0aGluc3BhY2VcXCFcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpbnNwYWNlXCIsIFwiXFxcXCFcIik7IC8vIFxcbmV3Y29tbWFuZHtcXG5lZ21lZHNwYWNlfXtcXHRtc3BhY2UtXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZWdtZWRzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19XCIpOyAvLyBcXG5ld2NvbW1hbmR7XFxuZWd0aGlja3NwYWNlfXtcXHRtc3BhY2UtXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpY2tzcGFjZVwiLCBcIlxcXFx0bXNwYWNlLXs1bXV9ey4yNzdlbX1cIik7IC8vIFxcZGVmXFxlbnNwYWNle1xca2Vybi41ZW0gfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlbnNwYWNlXCIsIFwiXFxcXGtlcm4uNWVtIFwiKTsgLy8gXFxkZWZcXGVuc2tpcHtcXGhza2lwLjVlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVuc2tpcFwiLCBcIlxcXFxoc2tpcC41ZW1cXFxccmVsYXhcIik7IC8vIFxcZGVmXFxxdWFke1xcaHNraXAxZW1cXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxxdWFkXCIsIFwiXFxcXGhza2lwMWVtXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxccXF1YWR7XFxoc2tpcDJlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHFxdWFkXCIsIFwiXFxcXGhza2lwMmVtXFxcXHJlbGF4XCIpOyAvLyBcXHRhZ0BpbkBkaXNwbGF5IGZvcm0gb2YgXFx0YWdcblxuZGVmaW5lTWFjcm8oXCJcXFxcdGFnXCIsIFwiXFxcXEBpZnN0YXJcXFxcdGFnQGxpdGVyYWxcXFxcdGFnQHBhcmVuXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQHBhcmVuXCIsIFwiXFxcXHRhZ0BsaXRlcmFseyh7IzF9KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAbGl0ZXJhbFwiLCBjb250ZXh0ID0+IHtcbiAgaWYgKGNvbnRleHQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk11bHRpcGxlIFxcXFx0YWdcIik7XG4gIH1cblxuICByZXR1cm4gXCJcXFxcZ2RlZlxcXFxkZkB0YWd7XFxcXHRleHR7IzF9fVwiO1xufSk7IC8vIFxccmVuZXdjb21tYW5ke1xcYm1vZH17XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwXFxta2VybjVtdVxcbWF0aGJpblxuLy8gICB7XFxvcGVyYXRvckBmb250IG1vZH1cXHBlbmFsdHk5MDBcbi8vICAgXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcH1cbi8vIFxcbmV3Y29tbWFuZHtcXHBvZH1bMV17XFxhbGxvd2JyZWFrXG4vLyAgIFxcaWZAZGlzcGxheVxcbWtlcm4xOG11XFxlbHNlXFxta2VybjhtdVxcZmkoIzEpfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFxwbW9kfVsxXXtcXHBvZHt7XFxvcGVyYXRvckBmb250IG1vZH1cXG1rZXJuNm11IzF9fVxuLy8gXFxuZXdjb21tYW5ke1xcbW9kfVsxXXtcXGFsbG93YnJlYWtcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxuLy8gICBcXGVsc2VcXG1rZXJuMTJtdVxcZml7XFxvcGVyYXRvckBmb250IG1vZH1cXCxcXCwjMX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcbWVkbXVza2lwID0gNG11IHBsdXMgMm11IG1pbnVzIDRtdVxuXG5kZWZpbmVNYWNybyhcIlxcXFxibW9kXCIsIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1za2lwMW11fXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDVtdX17XFxcXG1za2lwNW11fVwiICsgXCJcXFxcbWF0aGJpbntcXFxccm0gbW9kfVwiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDFtdX17XFxcXG1za2lwNW11fXtcXFxcbXNraXA1bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccG9kXCIsIFwiXFxcXGFsbG93YnJlYWtcIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX0oIzEpXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccG1vZFwiLCBcIlxcXFxwb2R7e1xcXFxybSBtb2R9XFxcXG1rZXJuNm11IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbW9kXCIsIFwiXFxcXGFsbG93YnJlYWtcIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX1cIiArIFwie1xcXFxybSBtb2R9XFxcXCxcXFxcLCMxXCIpOyAvLyBcXHBtYiAgICAtLSAgIEEgc2ltdWxhdGlvbiBvZiBib2xkLlxuLy8gVGhlIHZlcnNpb24gaW4gYW1ic3kuc3R5IHdvcmtzIGJ5IHR5cGVzZXR0aW5nIHRocmVlIGNvcGllcyBvZiB0aGUgYXJndW1lbnRcbi8vIHdpdGggc21hbGwgb2Zmc2V0cy4gV2UgdXNlIHR3byBjb3BpZXMuIFdlIG9taXQgdGhlIHZlcnRpY2FsIG9mZnNldCBiZWNhdXNlXG4vLyBvZiByZW5kZXJpbmcgcHJvYmxlbXMgdGhhdCBtYWtlVkxpc3QgZW5jb3VudGVycyBpbiBTYWZhcmkuXG5cbmRlZmluZU1hY3JvKFwiXFxcXHBtYlwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXEBiaW5yZWx7IzF9e1xcXFxtYXRocmxhcHsjMX1cXFxca2VybjAuNXB4IzF9fVwiICsgXCJ7XFxcXG1hdGhiZnsjMX19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWCBzb3VyY2UyZVxuLy8gXFxleHBhbmRhZnRlclxcbGV0XFxleHBhbmRhZnRlclxcQG5vcm1hbGNyXG4vLyAgICAgXFxjc25hbWVcXGV4cGFuZGFmdGVyXFxAZ29iYmxlXFxzdHJpbmdcXFxcIFxcZW5kY3NuYW1lXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXFxuZXdsaW5le1xcQG5vcm1hbGNyXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbmV3bGluZVwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpOyAvLyBcXGRlZlxcVGVYe1RcXGtlcm4tLjE2NjdlbVxcbG93ZXIuNWV4XFxoYm94e0V9XFxrZXJuLS4xMjVlbVhcXEB9XG4vLyBUT0RPOiBEb2Vzbid0IG5vcm1hbGx5IHdvcmsgaW4gbWF0aCBtb2RlIGJlY2F1c2UgXFxAIGZhaWxzLiAgS2FUZVggZG9lc24ndFxuLy8gc3VwcG9ydCBcXEAgeWV0LCBzbyB0aGF0J3Mgb21pdHRlZCwgYW5kIHdlIGFkZCBcXHRleHQgc28gdGhhdCB0aGUgcmVzdWx0XG4vLyBkb2Vzbid0IGxvb2sgZnVubnkgaW4gbWF0aCBtb2RlLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxUZVhcIiwgXCJcXFxcdGV4dHJte1xcXFxodG1sQG1hdGhtbHtcIiArIFwiVFxcXFxrZXJuLS4xNjY3ZW1cXFxccmFpc2Vib3h7LS41ZXh9e0V9XFxcXGtlcm4tLjEyNWVtWFwiICsgXCJ9e1RlWH19XCIpOyAvLyBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcTGFUZVh9e0xcXGtlcm4tLjM2ZW0lXG4vLyAgICAgICAgIHtcXHNib3hcXHpAIFQlXG4vLyAgICAgICAgICBcXHZib3ggdG9cXGh0XFx6QHtcXGhib3h7XFxjaGVja0BtYXRoZm9udHNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcZm9udHNpemVcXHNmQHNpemVcXHpAXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG1hdGhAZm9udHNmYWxzZVxcc2VsZWN0Zm9udFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQX0lXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBcXHZzc30lXG4vLyAgICAgICAgIH0lXG4vLyAgICAgICAgIFxca2Vybi0uMTVlbSVcbi8vICAgICAgICAgXFxUZVh9XG4vLyBUaGlzIGNvZGUgYWxpZ25zIHRoZSB0b3Agb2YgdGhlIEEgd2l0aCB0aGUgVCAoZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgVGVYJ3Ncbi8vIGJveGVzLCB0aG91Z2ggdmlzdWFsbHkgdGhlIEEgYXBwZWFycyB0byBleHRlbmQgYWJvdmUgc2xpZ2h0bHkpLlxuLy8gV2UgY29tcHV0ZSB0aGUgY29ycmVzcG9uZGluZyBcXHJhaXNlYm94IHdoZW4gQSBpcyByZW5kZXJlZCBpbiBcXG5vcm1hbHNpemVcbi8vIFxcc2NyaXB0c3R5bGUsIHdoaWNoIGhhcyBhIHNjYWxlIGZhY3RvciBvZiAwLjcgKHNlZSBPcHRpb25zLmpzKS5cblxudmFyIGxhdGV4UmFpc2VBID0gbWFrZUVtKGZvbnRNZXRyaWNzRGF0YVsnTWFpbi1SZWd1bGFyJ11bXCJUXCIuY2hhckNvZGVBdCgwKV1bMV0gLSAwLjcgKiBmb250TWV0cmljc0RhdGFbJ01haW4tUmVndWxhciddW1wiQVwiLmNoYXJDb2RlQXQoMCldWzFdKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyAoXCJMXFxcXGtlcm4tLjM2ZW1cXFxccmFpc2Vib3h7XCIgKyBsYXRleFJhaXNlQSArIFwifXtcXFxcc2NyaXB0c3R5bGUgQX1cIikgKyBcIlxcXFxrZXJuLS4xNWVtXFxcXFRlWH17TGFUZVh9fVwiKTsgLy8gTmV3IEthVGVYIGxvZ28gYmFzZWQgb24gdHdlYWtpbmcgTGFUZVggbG9nb1xuXG5kZWZpbmVNYWNybyhcIlxcXFxLYVRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgKFwiS1xcXFxrZXJuLS4xN2VtXFxcXHJhaXNlYm94e1wiICsgbGF0ZXhSYWlzZUEgKyBcIn17XFxcXHNjcmlwdHN0eWxlIEF9XCIpICsgXCJcXFxca2Vybi0uMTVlbVxcXFxUZVh9e0thVGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXGhzcGFjZXtcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlfVxuLy8gXFxkZWZcXEBoc3BhY2UjMXtcXGhza2lwICAjMVxccmVsYXh9XG4vLyBcXGRlZlxcQGhzcGFjZXIjMXtcXHZydWxlIFxcQHdpZHRoXFx6QFxcbm9icmVha1xuLy8gICAgICAgICAgICAgICAgIFxcaHNraXAgIzFcXGhza2lwIFxcekBza2lwfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRodG9vbHMuc3R5XG4vL1xccHJvdmlkZWNvbW1hbmRcXG9yZGluYXJ5Y29sb257On1cblxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBcIjpcIik7IC8vXFxkZWZcXHZjZW50Y29sb257XFxtYXRocmVse1xcbWF0aG9wXFxvcmRpbmFyeWNvbG9ufX1cbi8vVE9ETyhlZGVtYWluZSk6IE5vdCB5ZXQgY2VudGVyZWQuIEZpeCB2aWEgXFxyYWlzZWJveCBvciAjNzI2XG5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aG9wXFxcXG9yZGluYXJ5Y29sb259XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZGJsY29sb257XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tLjltdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRibGNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0uOW11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9PX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU0fX1cIik7IC8vIOKJlFxuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uZXFxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fT19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiM2R9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uZXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXG1hdGhyZWx7LX19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjIxMn19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZXFxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVsez1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjU1fX1cIik7IC8vIOKJlVxuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzZFxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzl9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcRXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXG1hdGhyZWx7LX1cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIxMlxcXFxjaGFyXFxcIjIyMzd9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uYXBwcm94e1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNhXFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25hcHByb3h7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmFwcHJveFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXGRibGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxhcHByb3h9fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3XFxcXGNoYXJcXFwiMjI0OH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25zaW17XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uc2ltXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHNpbX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjNjfX1cIik7IC8vIFNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBpbXBsZW1lbnRlZCB3aXRoIG1hY3JvcyB0byBtYXRodG9vbHMgZnVuY3Rpb25zLlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyMzdcIiwgXCJcXFxcZGJsY29sb25cIik7IC8vIDo6XG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzOVwiLCBcIlxcXFxlcWNvbG9uXCIpOyAvLyAtOlxuXG5kZWZpbmVNYWNybyhcIlxcdTIyNTRcIiwgXCJcXFxcY29sb25lcXFcIik7IC8vIDo9XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NVwiLCBcIlxcXFxlcXFjb2xvblwiKTsgLy8gPTpcblxuZGVmaW5lTWFjcm8oXCJcXHUyQTc0XCIsIFwiXFxcXENvbG9uZXFxXCIpOyAvLyA6Oj1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbG9uZXF1YWxzLnN0eVxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHJhdGlvXCIsIFwiXFxcXHZjZW50Y29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uXCIsIFwiXFxcXGRibGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXVhbHNcIiwgXCJcXFxcY29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uZXF1YWxzXCIsIFwiXFxcXENvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25cIiwgXCJcXFxcZXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25taW51c1wiLCBcIlxcXFxjb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbm1pbnVzXCIsIFwiXFxcXENvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uXCIsIFwiXFxcXGVxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uY29sb25cIiwgXCJcXFxcRXFjb2xvblwiKTsgLy8gXFxjb2xvbmFwcHJveCBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTsgLy8gXFxjb2xvbnNpbSBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbnNpbVwiLCBcIlxcXFxDb2xvbnNpbVwiKTsgLy8gQWRkaXRpb25hbCBtYWNyb3MsIGltcGxlbWVudGVkIGJ5IGFuYWxvZ3kgd2l0aCBtYXRodG9vbHMgZGVmaW5pdGlvbnM6XG5cbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzaW1jb2xvbmNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHNpbVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFwcHJveGNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcYXBwcm94XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7IC8vIFByZXNlbnQgaW4gbmV3dHhtYXRoLCBweGZvbnRzIGFuZCB0eGZvbnRzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdG5pXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxub3RcXFxcbml9e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyMEN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsc3VwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsaW5mfVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRnJvbSBhbXNvcG4uc3R5XG5cbmRlZmluZU1hY3JvKFwiXFxcXGluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2lualxcXFwsbGltfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntwcm9qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXG92ZXJsaW5le2xpbX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGluZXtsaW19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcnJpZ2h0YXJyb3d7bGltfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJwcm9qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGVmdGFycm93e2xpbX19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNYXRoTUwgYWx0ZXJuYXRlcyBmb3IgS2FUZVggZ2x5cGhzIGluIHRoZSBVbmljb2RlIHByaXZhdGUgYXJlYVxuXG5kZWZpbmVNYWNybyhcIlxcXFxndmVydG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBndmVydG5lcXF9e1xcdTIyNjl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHZlcnRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbHZlcnRuZXFxfXtcXHUyMjY4fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5nZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmdlcXF9e1xcdTIyNzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmdlcXNsYW50XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmdlcXNsYW50fXtcXHUyMjcxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5sZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmxlcXF9e1xcdTIyNzB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmxlcXNsYW50XCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbmxlcXNsYW50fXtcXHUyMjcwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zaG9ydG1pZFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQG5zaG9ydG1pZH174oikfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnNob3J0cGFyYWxsZWx9e+KIpn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc3Vic2V0ZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnN1YnNldGVxcX17XFx1MjI4OH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuc3Vwc2V0ZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnN1cHNldGVxcX17XFx1MjI4OX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdWJzZXRuZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdWJzZXRuZXF9e+KKin1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJzdWJzZXRuZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vic2V0bmVxcX174quLfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1cHNldG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1cHNldG5lcX174oqLfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1cHNldG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdXBzZXRuZXFxfXviq4x9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1hdGhcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBpbWF0aH17XFx1MDEzMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxqbWF0aFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGptYXRofXtcXHUwMjM3fVwiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3RtYXJ5cmQgYW5kIHNlbWFudGljXG4vLyBUaGUgc3RtYXJ5cmQgYW5kIHNlbWFudGljIHBhY2thZ2VzIHJlbmRlciB0aGUgbmV4dCBmb3VyIGl0ZW1zIGJ5IGNhbGxpbmcgYVxuLy8gZ2x5cGguIFRob3NlIGdseXBocyBkbyBub3QgZXhpc3QgaW4gdGhlIEthVGVYIGZvbnRzLiBIZW5jZSB0aGUgbWFjcm9zLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntbXFxcXG1rZXJuLTMuMm11W319XCIgKyBcIntcXFxcbWF0aG9wZW57XFxcXGNoYXJgXFx1MjdlNn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnJicmFja2V0XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aGNsb3Nle11cXFxcbWtlcm4tMy4ybXVdfX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1MjdlN319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyN2U2XCIsIFwiXFxcXGxsYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIFtcblxuZGVmaW5lTWFjcm8oXCJcXHUyN2U3XCIsIFwiXFxcXHJyYnJhY2tldFwiKTsgLy8gYmxhY2tib2FyZCBib2xkIF1cblxuZGVmaW5lTWFjcm8oXCJcXFxcbEJyYWNlXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aG9wZW57XFxcXHtcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyOTgzfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdVxcXFx9fX1cIiArIFwie1xcXFxtYXRoY2xvc2V7XFxcXGNoYXJgXFx1Mjk4NH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyOTgzXCIsIFwiXFxcXGxCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIHtcblxuZGVmaW5lTWFjcm8oXCJcXHUyOTg0XCIsIFwiXFxcXHJCcmFjZVwiKTsgLy8gYmxhY2tib2FyZCBib2xkIH1cbi8vIFRPRE86IENyZWF0ZSB2YXJpYWJsZSBzaXplZCB2ZXJzaW9ucyBvZiB0aGUgbGFzdCB0d28gaXRlbXMuIEkgYmVsaWV2ZSB0aGF0XG4vLyB3aWxsIHJlcXVpcmUgbmV3IGZvbnQgZ2x5cGhzLlxuLy8gVGhlIHN0bWFyeXJkIGZ1bmN0aW9uIGBcXG1pbnVzb2AgcHJvdmlkZXMgYSBcIlBsaW1zb2xsXCIgc3ltYm9sIHRoYXRcbi8vIHN1cGVyaW1wb3NlcyB0aGUgY2hhcmFjdGVycyBcXGNpcmMgYW5kIFxcbWF0aG1pbnVzLiBVc2VkIGluIGNoZW1pc3RyeS5cblxuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNvXCIsIFwiXFxcXG1hdGhiaW57XFxcXGh0bWxAbWF0aG1se1wiICsgXCJ7XFxcXG1hdGhybGFwe1xcXFxtYXRoY2hvaWNle1xcXFxrZXJuezAuMTQ1ZW19fXtcXFxca2VybnswLjE0NWVtfX1cIiArIFwie1xcXFxrZXJuezAuMTAxNWVtfX17XFxcXGtlcm57MC4wNzI1ZW19fVxcXFxjaXJjfXstfX19XCIgKyBcIntcXFxcY2hhcmDiprV9fVwiKTtcbmRlZmluZU1hY3JvKFwi4qa1XCIsIFwiXFxcXG1pbnVzb1wiKTsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG4vLyBUaGUgdGV4dmMgcGFja2FnZSBjb250YWlucyBtYWNyb3MgYXZhaWxhYmxlIGluIG1lZGlhd2lraSBwYWdlcy5cbi8vIFdlIG9taXQgdGhlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIGF0XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOkRpc3BsYXlpbmdfYV9mb3JtdWxhI0RlcHJlY2F0ZWRfc3ludGF4XG4vLyBXZSBhbHNvIG9taXQgdGV4dmMncyBcXE8sIHdoaWNoIGNvbmZsaWN0cyB3aXRoIFxcdGV4dHtcXE99XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRhcnJcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZEFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhbmdcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFuZ1wiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1YXJyXCIsIFwiXFxcXHVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1QXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxVYXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWlwiLCBcIlxcXFxtYXRoYmJ7Wn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZnN5bVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFscGhhXCIsIFwiXFxcXG1hdGhybXtBfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJldGFcIiwgXCJcXFxcbWF0aHJte0J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnVsbFwiLCBcIlxcXFxidWxsZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDaGlcIiwgXCJcXFxcbWF0aHJte1h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2x1YnNcIiwgXCJcXFxcY2x1YnN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbnVtc1wiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDb21wbGV4XCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhZ2dlclwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlhbW9uZHNcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlbXB0eVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEVwc2lsb25cIiwgXCJcXFxcbWF0aHJte0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXRhXCIsIFwiXFxcXG1hdGhybXtIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4aXN0XCIsIFwiXFxcXGV4aXN0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSGFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhlYXJ0c1wiLCBcIlxcXFxoZWFydHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWFnZVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluZmluXCIsIFwiXFxcXGluZnR5XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSW90YVwiLCBcIlxcXFxtYXRocm17SX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpc2luXCIsIFwiXFxcXGluXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2FwcGFcIiwgXCJcXFxcbWF0aHJte0t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFyclwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsQXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsckFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExyYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTXVcIiwgXCJcXFxcbWF0aHJte019XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmF0bnVtc1wiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOdVwiLCBcIlxcXFxtYXRocm17Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxPbWljcm9uXCIsIFwiXFxcXG1hdGhybXtPfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSaG9cIiwgXCJcXFxcbWF0aHJte1B9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2RvdFwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2VjdFwiLCBcIlxcXFxTXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3BhZGVzXCIsIFwiXFxcXHNwYWRlc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJlXCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3VwZVwiLCBcIlxcXFxzdXBzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRhdVwiLCBcIlxcXFxtYXRocm17VH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGV0YXN5bVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTsgLy8gVE9ETzogZGVmaW5lTWFjcm8oXCJcXFxcdmFyY29wcGFcIiwgXCJcXFxcXFxtYm94e1xcXFxjb3BwYX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHdlaWVycFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpldGFcIiwgXCJcXFxcbWF0aHJte1p9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdGF0bWF0aC5zdHlcbi8vIGh0dHBzOi8vY3Rhbi5tYXRoLmlsbGlub2lzLmVkdS9tYWNyb3MvbGF0ZXgvY29udHJpYi9zdGF0bWF0aC9zdGF0bWF0aC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWluXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtaW59XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWF4XCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtYXh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGxpbVwiLCBcIlxcXFxET1RTQlxcXFxtYXRob3B7XFxcXG9wZXJhdG9ybmFtZXtwbGltfX1cXFxcbGltaXRzXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBicmFrZXQuc3R5XG4vLyBodHRwOi8vY3Rhbi5tYXRoLndhc2hpbmd0b24uZWR1L3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9jb250cmliL2JyYWtldC9icmFrZXQucGRmXG5cbmRlZmluZU1hY3JvKFwiXFxcXGJyYVwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX18fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7fHsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJyYWtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJyYVwiLCBcIlxcXFxsZWZ0XFxcXGxhbmdsZSMxXFxcXHJpZ2h0fFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEtldFwiLCBcIlxcXFxsZWZ0fCMxXFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcblxudmFyIGJyYWtldEhlbHBlciA9IG9uZSA9PiBjb250ZXh0ID0+IHtcbiAgdmFyIGxlZnQgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIHZhciBtaWRkbGUgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIHZhciBtaWRkbGVEb3VibGUgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIHZhciByaWdodCA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgdmFyIG9sZE1pZGRsZSA9IGNvbnRleHQubWFjcm9zLmdldChcInxcIik7XG4gIHZhciBvbGRNaWRkbGVEb3VibGUgPSBjb250ZXh0Lm1hY3Jvcy5nZXQoXCJcXFxcfFwiKTtcbiAgY29udGV4dC5tYWNyb3MuYmVnaW5Hcm91cCgpO1xuXG4gIHZhciBtaWRNYWNybyA9IGRvdWJsZSA9PiBjb250ZXh0ID0+IHtcbiAgICBpZiAob25lKSB7XG4gICAgICAvLyBPbmx5IG1vZGlmeSB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgfCBvciBcXHxcbiAgICAgIGNvbnRleHQubWFjcm9zLnNldChcInxcIiwgb2xkTWlkZGxlKTtcblxuICAgICAgaWYgKG1pZGRsZURvdWJsZS5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5tYWNyb3Muc2V0KFwiXFxcXHxcIiwgb2xkTWlkZGxlRG91YmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG91YmxlZCA9IGRvdWJsZTtcblxuICAgIGlmICghZG91YmxlICYmIG1pZGRsZURvdWJsZS5sZW5ndGgpIHtcbiAgICAgIC8vIE1pbWljIFxcQGlmbmV4dGNoYXJcbiAgICAgIHZhciBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuXG4gICAgICBpZiAobmV4dFRva2VuLnRleHQgPT09IFwifFwiKSB7XG4gICAgICAgIGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICAgICAgZG91YmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogZG91YmxlZCA/IG1pZGRsZURvdWJsZSA6IG1pZGRsZSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9O1xuXG4gIGNvbnRleHQubWFjcm9zLnNldChcInxcIiwgbWlkTWFjcm8oZmFsc2UpKTtcblxuICBpZiAobWlkZGxlRG91YmxlLmxlbmd0aCkge1xuICAgIGNvbnRleHQubWFjcm9zLnNldChcIlxcXFx8XCIsIG1pZE1hY3JvKHRydWUpKTtcbiAgfVxuXG4gIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7XG4gIHZhciBleHBhbmRlZCA9IGNvbnRleHQuZXhwYW5kVG9rZW5zKFsuLi5yaWdodCwgLi4uYXJnLCAuLi5sZWZ0IC8vIHJldmVyc2VkXG4gIF0pO1xuICBjb250ZXh0Lm1hY3Jvcy5lbmRHcm91cCgpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogZXhwYW5kZWQucmV2ZXJzZSgpLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJyYUBrZXRcIiwgYnJha2V0SGVscGVyKGZhbHNlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxicmFAc2V0XCIsIGJyYWtldEhlbHBlcih0cnVlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFrZXRcIiwgXCJcXFxcYnJhQGtldHtcXFxcbGVmdFxcXFxsYW5nbGV9XCIgKyBcIntcXFxcLFxcXFxtaWRkbGVcXFxcdmVydFxcXFwsfXtcXFxcLFxcXFxtaWRkbGVcXFxcdmVydFxcXFwsfXtcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFNldFwiLCBcIlxcXFxicmFAc2V0e1xcXFxsZWZ0XFxcXHtcXFxcOn1cIiArIFwie1xcXFw7XFxcXG1pZGRsZVxcXFx2ZXJ0XFxcXDt9e1xcXFw7XFxcXG1pZGRsZVxcXFxWZXJ0XFxcXDt9e1xcXFw6XFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2V0XCIsIFwiXFxcXGJyYUBzZXR7XFxcXHtcXFxcLH17XFxcXG1pZH17fXtcXFxcLFxcXFx9fVwiKTsgLy8gaGFzIG5vIHN1cHBvcnQgZm9yIHNwZWNpYWwgfHwgb3IgXFx8XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhY3R1YXJpYWxhbmdsZS5kdHhcblxuZGVmaW5lTWFjcm8oXCJcXFxcYW5nbG5cIiwgXCJ7XFxcXGFuZ2wgbn1cIik7IC8vIEN1c3RvbSBLaGFuIEFjYWRlbXkgY29sb3JzLCBzaG91bGQgYmUgbW92ZWQgdG8gYW4gb3B0aW9uYWwgcGFja2FnZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxibHVlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzY0OTVlZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYTUwMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGlua1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjAwYWZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkZjAwMzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuXCIsIFwiXFxcXHRleHRjb2xvcnsjIzI4YWU3Yn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheVwiLCBcIlxcXFx0ZXh0Y29sb3J7Z3JheX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzlkMzhiZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjY2NmYWZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4MGY2ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVDXCIsIFwiXFxcXHRleHRjb2xvcnsjIzYzZDllYX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMTFhY2NkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwYzdmOTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRleHRjb2xvcnsjIzk0ZmZmNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjZlZGQ1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwMWQxYzF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRleHRjb2xvcnsjIzAxYTk5NX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjA4MTcwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYjZmZmIwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOGFmMjgxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzRjZjcwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMWZhYjU0fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmVlbkVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMGQ5MjNmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZmQwYTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYmI3MX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY5YzM5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlMDdkMTB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2E3NWEwNX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmY2E5YTl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmY4NDgyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2Y5Njg1ZH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlODRkMzl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYmMyNjEyfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25BXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmYmRlMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjkyYzZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZWQ1ZmE2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25EXCIsIFwiXFxcXHRleHRjb2xvcnsjI2NhMzM3Y317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM5ZTAzNGV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZGRkN2ZmfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2M2YjlmY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNhYTg3ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNzg1NGFifXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzU0M2I3OH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjVmOWU4fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50QlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlZGYyZGZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UwZTVjY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjZmN2Y3fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5QlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmMGYxZjJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UzZTVlNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheURcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZDZkOGRhfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiYWJlYzJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlGXCIsIFwiXFxcXHRleHRjb2xvcnsjIzg4OGQ5M317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUdcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNjI2NTY5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5SFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMzYjNlNDB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlJXCIsIFwiXFxcXHRleHRjb2xvcnsjIzIxMjQyY317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2FCbHVlXCIsIFwiXFxcXHRleHRjb2xvcnsjIzMxNDQ1M317IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2FHcmVlblwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3MUIzMDd9eyMxfVwiKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIOKAnGd1bGxldOKAnSB3aGVyZSBtYWNyb3MgYXJlIGV4cGFuZGVkXG4gKiB1bnRpbCBvbmx5IG5vbi1tYWNybyB0b2tlbnMgcmVtYWluLlxuICovXG4vLyBMaXN0IG9mIGNvbW1hbmRzIHRoYXQgYWN0IGxpa2UgbWFjcm9zIGJ1dCBhcmVuJ3QgZGVmaW5lZCBhcyBhIG1hY3JvLFxuLy8gZnVuY3Rpb24sIG9yIHN5bWJvbC4gIFVzZWQgaW4gYGlzRGVmaW5lZGAuXG52YXIgaW1wbGljaXRDb21tYW5kcyA9IHtcbiAgXCJeXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIl9cIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXGxpbWl0c1wiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbm9saW1pdHNcIjogdHJ1ZSAvLyBQYXJzZXIuanNcblxufTtcbmNsYXNzIE1hY3JvRXhwYW5kZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MsIG1vZGUpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1hY3JvcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCA9IDA7XG4gICAgdGhpcy5mZWVkKGlucHV0KTsgLy8gTWFrZSBuZXcgZ2xvYmFsIG5hbWVzcGFjZVxuXG4gICAgdGhpcy5tYWNyb3MgPSBuZXcgTmFtZXNwYWNlKG1hY3Jvcywgc2V0dGluZ3MubWFjcm9zKTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuc3RhY2sgPSBbXTsgLy8gY29udGFpbnMgdG9rZW5zIGluIFJFVkVSU0Ugb3JkZXJcbiAgfVxuICAvKipcbiAgICogRmVlZCBhIG5ldyBpbnB1dCBzdHJpbmcgdG8gdGhlIHNhbWUgTWFjcm9FeHBhbmRlclxuICAgKiAod2l0aCBleGlzdGluZyBtYWNyb3MgZXRjLikuXG4gICAqL1xuXG5cbiAgZmVlZChpbnB1dCkge1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoaW5wdXQsIHRoaXMuc2V0dGluZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG5cblxuICBzd2l0Y2hNb2RlKG5ld01vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG5cblxuICBiZWdpbkdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmJlZ2luR3JvdXAoKTtcbiAgfVxuICAvKipcbiAgICogRW5kIGN1cnJlbnQgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuXG5cbiAgZW5kR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXAoKTtcbiAgfVxuICAvKipcbiAgICogRW5kcyBhbGwgY3VycmVudGx5IG5lc3RlZCBncm91cHMgKGlmIGFueSksIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZVxuICAgKiBncm91cHMgYmVnYW4uICBVc2VmdWwgaW4gY2FzZSBvZiBhbiBlcnJvciBpbiB0aGUgbWlkZGxlIG9mIHBhcnNpbmcuXG4gICAqL1xuXG5cbiAgZW5kR3JvdXBzKCkge1xuICAgIHRoaXMubWFjcm9zLmVuZEdyb3VwcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3Btb3N0IHRva2VuIG9uIHRoZSBzdGFjaywgd2l0aG91dCBleHBhbmRpbmcgaXQuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZnV0dXJlbGV0YC5cbiAgICovXG5cblxuICBmdXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0aGlzLmxleGVyLmxleCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgbmV4dCB1bmV4cGFuZGVkIHRva2VuLlxuICAgKi9cblxuXG4gIHBvcFRva2VuKCkge1xuICAgIHRoaXMuZnV0dXJlKCk7IC8vIGVuc3VyZSBub24tZW1wdHkgc3RhY2tcblxuICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBnaXZlbiB0b2tlbiB0byB0aGUgdG9rZW4gc3RhY2suICBJbiBwYXJ0aWN1bGFyLCB0aGlzIGdldCBiZSB1c2VkXG4gICAqIHRvIHB1dCBiYWNrIGEgdG9rZW4gcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAqL1xuXG5cbiAgcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGFuIGFycmF5IG9mIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suXG4gICAqL1xuXG5cbiAgcHVzaFRva2Vucyh0b2tlbnMpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goLi4udG9rZW5zKTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbiBtYWNybyBhcmd1bWVudCB3aXRob3V0IGV4cGFuZGluZyB0b2tlbnMgYW5kIGFwcGVuZCB0aGUgYXJyYXkgb2ZcbiAgICogdG9rZW5zIHRvIHRoZSB0b2tlbiBzdGFjay4gVXNlcyBUb2tlbiBhcyBhIGNvbnRhaW5lciBmb3IgdGhlIHJlc3VsdC5cbiAgICovXG5cblxuICBzY2FuQXJndW1lbnQoaXNPcHRpb25hbCkge1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciB0b2tlbnM7XG5cbiAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIFxcQGlmbmV4dGNoYXIgZ29iYmxlcyBhbnkgc3BhY2UgZm9sbG93aW5nIGl0XG5cbiAgICAgIGlmICh0aGlzLmZ1dHVyZSgpLnRleHQgIT09IFwiW1wiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzdGFydCA9IHRoaXMucG9wVG9rZW4oKTsgLy8gZG9uJ3QgaW5jbHVkZSBbIGluIHRva2Vuc1xuXG4gICAgICAoe1xuICAgICAgICB0b2tlbnMsXG4gICAgICAgIGVuZFxuICAgICAgfSA9IHRoaXMuY29uc3VtZUFyZyhbXCJdXCJdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7XG4gICAgICAgIHRva2VucyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfSA9IHRoaXMuY29uc3VtZUFyZygpKTtcbiAgICB9IC8vIGluZGljYXRlIHRoZSBlbmQgb2YgYW4gYXJndW1lbnRcblxuXG4gICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKFwiRU9GXCIsIGVuZC5sb2MpKTtcbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICByZXR1cm4gc3RhcnQucmFuZ2UoZW5kLCBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSBhbGwgZm9sbG93aW5nIHNwYWNlIHRva2Vucywgd2l0aG91dCBleHBhbnNpb24uXG4gICAqL1xuXG5cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLmZ1dHVyZSgpO1xuXG4gICAgICBpZiAodG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSBhbiBhcmd1bWVudCBmcm9tIHRoZSB0b2tlbiBzdHJlYW0sIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgKiBvZiB0b2tlbnMgYW5kIHN0YXJ0L2VuZCB0b2tlbi5cbiAgICovXG5cblxuICBjb25zdW1lQXJnKGRlbGltcykge1xuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYSBkZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBzaG9ydGVzdCAocG9zc2libHlcbiAgICAvLyBlbXB0eSkgc2VxdWVuY2Ugb2YgdG9rZW5zIHdpdGggcHJvcGVybHkgbmVzdGVkIHsuLi59IGdyb3VwcyB0aGF0IGlzXG4gICAgLy8gZm9sbG93ZWQgLi4uIGJ5IHRoaXMgcGFydGljdWxhciBsaXN0IG9mIG5vbi1wYXJhbWV0ZXIgdG9rZW5zLlxuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYW4gdW5kZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBuZXh0IG5vbmJsYW5rXG4gICAgLy8gdG9rZW4sIHVubGVzcyB0aGF0IHRva2VuIGlzIOKAmHvigJksIHdoZW4gdGhlIGFyZ3VtZW50IHdpbGwgYmUgdGhlXG4gICAgLy8gZW50aXJlIHsuLi59IGdyb3VwIHRoYXQgZm9sbG93cy5cbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGlzRGVsaW1pdGVkID0gZGVsaW1zICYmIGRlbGltcy5sZW5ndGggPiAwO1xuXG4gICAgaWYgKCFpc0RlbGltaXRlZCkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBiZXR3ZWVuIGFyZ3VtZW50cy4gIEFzIHRoZSBUZVhib29rIHNheXM6XG4gICAgICAvLyBcIkFmdGVyIHlvdSBoYXZlIHNhaWQg4oCYXFxkZWZcXHJvdyMxIzJ7Li4ufeKAmSwgeW91IGFyZSBhbGxvd2VkIHRvXG4gICAgICAvLyAgcHV0IHNwYWNlcyBiZXR3ZWVuIHRoZSBhcmd1bWVudHMgKGUuZy4sIOKAmFxccm93IHggbuKAmSksIGJlY2F1c2VcbiAgICAgIC8vICBUZVggZG9lc27igJl0IHVzZSBzaW5nbGUgc3BhY2VzIGFzIHVuZGVsaW1pdGVkIGFyZ3VtZW50cy5cIlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5mdXR1cmUoKTtcbiAgICB2YXIgdG9rO1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIG1hdGNoID0gMDtcblxuICAgIGRvIHtcbiAgICAgIHRvayA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICAgIHRva2Vucy5wdXNoKHRvayk7XG5cbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgKytkZXB0aDtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwifVwiKSB7XG4gICAgICAgIC0tZGVwdGg7XG5cbiAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXh0cmEgfVwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgaW4gYSBtYWNybyBhcmd1bWVudFwiICsgXCIsIGV4cGVjdGVkICdcIiArIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQgPyBkZWxpbXNbbWF0Y2hdIDogXCJ9XCIpICsgXCInXCIsIHRvayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQpIHtcbiAgICAgICAgaWYgKChkZXB0aCA9PT0gMCB8fCBkZXB0aCA9PT0gMSAmJiBkZWxpbXNbbWF0Y2hdID09PSBcIntcIikgJiYgdG9rLnRleHQgPT09IGRlbGltc1ttYXRjaF0pIHtcbiAgICAgICAgICArK21hdGNoO1xuXG4gICAgICAgICAgaWYgKG1hdGNoID09PSBkZWxpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIGRlbGltcyBpbiB0b2tlbnNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoLW1hdGNoLCBtYXRjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGVwdGggIT09IDAgfHwgaXNEZWxpbWl0ZWQpOyAvLyBJZiB0aGUgYXJndW1lbnQgZm91bmQgLi4uIGhhcyB0aGUgZm9ybSDigJh7PG5lc3RlZCB0b2tlbnM+feKAmSxcbiAgICAvLyAuLi4gdGhlIG91dGVybW9zdCBicmFjZXMgZW5jbG9zaW5nIHRoZSBhcmd1bWVudCBhcmUgcmVtb3ZlZFxuXG5cbiAgICBpZiAoc3RhcnQudGV4dCA9PT0gXCJ7XCIgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50ZXh0ID09PSBcIn1cIikge1xuICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgdG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcblxuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogdG9rXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29uc3VtZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiAoZGVsaW1pdGVkKSBhcmd1bWVudHMgZnJvbSB0aGUgdG9rZW5cbiAgICogc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgY29uc3VtZUFyZ3MobnVtQXJncywgZGVsaW1pdGVycykge1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggIT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBkZWxpbWl0ZXJzIGRvZXNuJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBhcmdzIVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbGltcyA9IGRlbGltaXRlcnNbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG5cbiAgICAgICAgaWYgKGRlbGltc1tpXSAhPT0gdG9rLnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVzZSBvZiB0aGUgbWFjcm8gZG9lc24ndCBtYXRjaCBpdHMgZGVmaW5pdGlvblwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1BcmdzOyBfaSsrKSB7XG4gICAgICBhcmdzLnB1c2godGhpcy5jb25zdW1lQXJnKGRlbGltaXRlcnMgJiYgZGVsaW1pdGVyc1tfaSArIDFdKS50b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZXhwYW5kZWQsIHRoZSByZXN1bHRpbmcgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIG9udG9cbiAgICogdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIgYW5kIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gYXJyYXksXG4gICAqIGFsc28gaW4gcmV2ZXJzZSBvcmRlci5cbiAgICpcbiAgICogSWYgbm90LCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIHJldHVybmVkIHdpdGhvdXQgcmVtb3ZpbmcgaXRcbiAgICogZnJvbSB0aGUgc3RhY2suICBUaGlzIGNhc2UgY2FuIGJlIGRldGVjdGVkIGJ5IGEgYFRva2VuYCByZXR1cm4gdmFsdWVcbiAgICogaW5zdGVhZCBvZiBhbiBgQXJyYXlgIHJldHVybiB2YWx1ZS5cbiAgICpcbiAgICogSW4gZWl0aGVyIGNhc2UsIHRoZSBuZXh0IHRva2VuIHdpbGwgYmUgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2ssXG4gICAqIG9yIHRoZSBzdGFjayB3aWxsIGJlIGVtcHR5LlxuICAgKlxuICAgKiBVc2VkIHRvIGltcGxlbWVudCBgZXhwYW5kQWZ0ZXJGdXR1cmVgIGFuZCBgZXhwYW5kTmV4dFRva2VuYC5cbiAgICpcbiAgICogSWYgZXhwYW5kYWJsZU9ubHksIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnMgYXJlIGV4cGFuZGVkIGFuZFxuICAgKiBhbiB1bmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZSByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKi9cblxuXG4gIGV4cGFuZE9uY2UoZXhwYW5kYWJsZU9ubHkpIHtcbiAgICB2YXIgdG9wVG9rZW4gPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgIHZhciBleHBhbnNpb24gPSAhdG9wVG9rZW4ubm9leHBhbmQgPyB0aGlzLl9nZXRFeHBhbnNpb24obmFtZSkgOiBudWxsO1xuXG4gICAgaWYgKGV4cGFuc2lvbiA9PSBudWxsIHx8IGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbi51bmV4cGFuZGFibGUpIHtcbiAgICAgIGlmIChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24gPT0gbnVsbCAmJiBuYW1lWzBdID09PSBcIlxcXFxcIiAmJiAhdGhpcy5pc0RlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9wVG9rZW4pO1xuICAgICAgcmV0dXJuIHRvcFRva2VuO1xuICAgIH1cblxuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQrKztcblxuICAgIGlmICh0aGlzLmV4cGFuc2lvbkNvdW50ID4gdGhpcy5zZXR0aW5ncy5tYXhFeHBhbmQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVG9vIG1hbnkgZXhwYW5zaW9uczogaW5maW5pdGUgbG9vcCBvciBcIiArIFwibmVlZCB0byBpbmNyZWFzZSBtYXhFeHBhbmQgc2V0dGluZ1wiKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0gZXhwYW5zaW9uLnRva2VucztcbiAgICB2YXIgYXJncyA9IHRoaXMuY29uc3VtZUFyZ3MoZXhwYW5zaW9uLm51bUFyZ3MsIGV4cGFuc2lvbi5kZWxpbWl0ZXJzKTtcblxuICAgIGlmIChleHBhbnNpb24ubnVtQXJncykge1xuICAgICAgLy8gcGFzdGUgYXJndW1lbnRzIGluIHBsYWNlIG9mIHRoZSBwbGFjZWhvbGRlcnNcbiAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgpOyAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5XG5cbiAgICAgIGZvciAodmFyIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW5jb21wbGV0ZSBwbGFjZWhvbGRlciBhdCBlbmQgb2YgbWFjcm8gYm9keVwiLCB0b2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvayA9IHRva2Vuc1stLWldOyAvLyBuZXh0IHRva2VuIG9uIHN0YWNrXG5cbiAgICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAvLyAjIyDihpIgI1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7IC8vIGRyb3AgZmlyc3QgI1xuICAgICAgICAgIH0gZWxzZSBpZiAoL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHRoZSBpbmRpY2F0ZWQgYXJndW1lbnRcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMiwgLi4uYXJnc1srdG9rLnRleHQgLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm90IGEgdmFsaWQgYXJndW1lbnQgbnVtYmVyXCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDb25jYXRlbmF0ZSBleHBhbnNpb24gb250byB0b3Agb2Ygc3RhY2suXG5cblxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgKGlmIHBvc3NpYmxlKSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nXG4gICAqIHRvcCB0b2tlbiBvbiB0aGUgc3RhY2sgKHdpdGhvdXQgcmVtb3ZpbmcgYW55dGhpbmcgZnJvbSB0aGUgc3RhY2spLlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGV4cGFuZGFmdGVyXFxmdXR1cmVsZXRgLlxuICAgKiBFcXVpdmFsZW50IHRvIGV4cGFuZE9uY2UoKSBmb2xsb3dlZCBieSBmdXR1cmUoKS5cbiAgICovXG5cblxuICBleHBhbmRBZnRlckZ1dHVyZSgpIHtcbiAgICB0aGlzLmV4cGFuZE9uY2UoKTtcbiAgICByZXR1cm4gdGhpcy5mdXR1cmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kIGZpcnN0IHRva2VuLCB0aGVuIHJldHVybiBmaXJzdCBub24tZXhwYW5kYWJsZSB0b2tlbi5cbiAgICovXG5cblxuICBleHBhbmROZXh0VG9rZW4oKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGV4cGFuZGVkID0gdGhpcy5leHBhbmRPbmNlKCk7IC8vIGV4cGFuZE9uY2UgcmV0dXJucyBUb2tlbiBpZiBhbmQgb25seSBpZiBpdCdzIGZ1bGx5IGV4cGFuZGVkLlxuXG4gICAgICBpZiAoZXhwYW5kZWQgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAvLyB0aGUgdG9rZW4gYWZ0ZXIgXFxub2V4cGFuZCBpcyBpbnRlcnByZXRlZCBhcyBpZiBpdHMgbWVhbmluZ1xuICAgICAgICAvLyB3ZXJlIOKAmFxccmVsYXjigJlcbiAgICAgICAgaWYgKGV4cGFuZGVkLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIGV4cGFuZGVkLnRleHQgPSBcIlxcXFxyZWxheFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7IC8vID09PSBleHBhbmRlZFxuICAgICAgfVxuICAgIH0gLy8gRmxvdyB1bmFibGUgdG8gZmlndXJlIG91dCB0aGF0IHRoaXMgcGF0aHdheSBpcyBpbXBvc3NpYmxlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80ODA4XG5cblxuICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVucmVhY2hhYmxlXG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMsIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuXG5cbiAgZXhwYW5kTWFjcm8obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgPyB0aGlzLmV4cGFuZFRva2VucyhbbmV3IFRva2VuKG5hbWUpXSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gdG9rZW4gc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucy4gIE5vdGUgdGhhdCB0aGUgaW5wdXQgdG9rZW5zIGFyZSBpbiByZXZlcnNlIG9yZGVyLCBidXQgdGhlXG4gICAqIG91dHB1dCB0b2tlbnMgYXJlIGluIGZvcndhcmQgb3JkZXIuXG4gICAqL1xuXG5cbiAgZXhwYW5kVG9rZW5zKHRva2Vucykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcblxuICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IG9sZFN0YWNrTGVuZ3RoKSB7XG4gICAgICB2YXIgZXhwYW5kZWQgPSB0aGlzLmV4cGFuZE9uY2UodHJ1ZSk7IC8vIGV4cGFuZCBvbmx5IGV4cGFuZGFibGUgdG9rZW5zXG4gICAgICAvLyBleHBhbmRPbmNlIHJldHVybnMgVG9rZW4gaWYgYW5kIG9ubHkgaWYgaXQncyBmdWxseSBleHBhbmRlZC5cblxuICAgICAgaWYgKGV4cGFuZGVkIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgaWYgKGV4cGFuZGVkLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIC8vIHRoZSBleHBhbnNpb24gb2YgXFxub2V4cGFuZCBpcyB0aGUgdG9rZW4gaXRzZWxmXG4gICAgICAgICAgZXhwYW5kZWQubm9leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICBleHBhbmRlZC50cmVhdEFzUmVsYXggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBzdHJpbmcsXG4gICAqIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuXG5cbiAgZXhwYW5kTWFjcm9Bc1RleHQobmFtZSkge1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLmV4cGFuZE1hY3JvKG5hbWUpO1xuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGFuZGVkIG1hY3JvIGFzIGEgcmV2ZXJzZWQgYXJyYXkgb2YgdG9rZW5zIGFuZCBhIG1hY3JvXG4gICAqIGFyZ3VtZW50IGNvdW50LiAgT3IgcmV0dXJucyBgbnVsbGAgaWYgbm8gc3VjaCBtYWNyby5cbiAgICovXG5cblxuICBfZ2V0RXhwYW5zaW9uKG5hbWUpIHtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcblxuICAgIGlmIChkZWZpbml0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIG1haW5seSBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGhlcmVcbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH0gLy8gSWYgYSBzaW5nbGUgY2hhcmFjdGVyIGhhcyBhbiBhc3NvY2lhdGVkIGNhdGNvZGUgb3RoZXIgdGhhbiAxM1xuICAgIC8vIChhY3RpdmUgY2hhcmFjdGVyKSwgdGhlbiBkb24ndCBleHBhbmQgaXQuXG5cblxuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNhdGNvZGUgPSB0aGlzLmxleGVyLmNhdGNvZGVzW25hbWVdO1xuXG4gICAgICBpZiAoY2F0Y29kZSAhPSBudWxsICYmIGNhdGNvZGUgIT09IDEzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXhwYW5zaW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGRlZmluaXRpb24odGhpcykgOiBkZWZpbml0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBleHBhbnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBudW1BcmdzID0gMDtcblxuICAgICAgaWYgKGV4cGFuc2lvbi5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHN0cmlwcGVkID0gZXhwYW5zaW9uLnJlcGxhY2UoLyMjL2csIFwiXCIpO1xuXG4gICAgICAgIHdoaWxlIChzdHJpcHBlZC5pbmRleE9mKFwiI1wiICsgKG51bUFyZ3MgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgKytudW1BcmdzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib2R5TGV4ZXIgPSBuZXcgTGV4ZXIoZXhwYW5zaW9uLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgIHZhciB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG5cbiAgICAgIHdoaWxlICh0b2sudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIHVzaW5nIHB1c2ggYW5kIHBvcFxuXG4gICAgICB2YXIgZXhwYW5kZWQgPSB7XG4gICAgICAgIHRva2VucyxcbiAgICAgICAgbnVtQXJnc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5zaW9uO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgY3VycmVudGx5IFwiZGVmaW5lZFwiIChoYXMgc29tZVxuICAgKiBmdW5jdGlvbmFsaXR5KSwgbWVhbmluZyB0aGF0IGl0J3MgYSBtYWNybyAoaW4gdGhlIGN1cnJlbnQgZ3JvdXApLFxuICAgKiBhIGZ1bmN0aW9uLCBhIHN5bWJvbCwgb3Igb25lIG9mIHRoZSBzcGVjaWFsIGNvbW1hbmRzIGxpc3RlZCBpblxuICAgKiBgaW1wbGljaXRDb21tYW5kc2AuXG4gICAqL1xuXG5cbiAgaXNEZWZpbmVkKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpIHx8IGZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBzeW1ib2xzLm1hdGguaGFzT3duUHJvcGVydHkobmFtZSkgfHwgc3ltYm9scy50ZXh0Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IGltcGxpY2l0Q29tbWFuZHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBleHBhbmRhYmxlLlxuICAgKi9cblxuXG4gIGlzRXhwYW5kYWJsZShuYW1lKSB7XG4gICAgdmFyIG1hY3JvID0gdGhpcy5tYWNyb3MuZ2V0KG5hbWUpO1xuICAgIHJldHVybiBtYWNybyAhPSBudWxsID8gdHlwZW9mIG1hY3JvID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYWNybyA9PT0gXCJmdW5jdGlvblwiIHx8ICFtYWNyby51bmV4cGFuZGFibGUgOiBmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWZ1bmN0aW9uc1tuYW1lXS5wcmltaXRpdmU7XG4gIH1cblxufVxuXG4vLyBIZWxwZXJzIGZvciBQYXJzZXIuanMgaGFuZGxpbmcgb2YgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdCBjaGFyYWN0ZXJzLlxudmFyIHVuaWNvZGVTdWJSZWdFeCA9IC9eW+KCiuKCi+KCjOKCjeKCjuKCgOKCgeKCguKCg+KChOKCheKChuKCh+KCiOKCieKCkOKCkeKCleG1ouKxvOKCluKCl+KCmOKCmeKCkuKCmuG1o+KCm+KCnOG1pOG1peKCk+G1puG1p+G1qOG1qeG1ql0vO1xudmFyIHVTdWJzQW5kU3VwcyA9IE9iamVjdC5mcmVlemUoe1xuICAn4oKKJzogJysnLFxuICAn4oKLJzogJy0nLFxuICAn4oKMJzogJz0nLFxuICAn4oKNJzogJygnLFxuICAn4oKOJzogJyknLFxuICAn4oKAJzogJzAnLFxuICAn4oKBJzogJzEnLFxuICAn4oKCJzogJzInLFxuICAn4oKDJzogJzMnLFxuICAn4oKEJzogJzQnLFxuICAn4oKFJzogJzUnLFxuICAn4oKGJzogJzYnLFxuICAn4oKHJzogJzcnLFxuICAn4oKIJzogJzgnLFxuICAn4oKJJzogJzknLFxuICAnXFx1MjA5MCc6ICdhJyxcbiAgJ1xcdTIwOTEnOiAnZScsXG4gICdcXHUyMDk1JzogJ2gnLFxuICAnXFx1MUQ2Mic6ICdpJyxcbiAgJ1xcdTJDN0MnOiAnaicsXG4gICdcXHUyMDk2JzogJ2snLFxuICAnXFx1MjA5Nyc6ICdsJyxcbiAgJ1xcdTIwOTgnOiAnbScsXG4gICdcXHUyMDk5JzogJ24nLFxuICAnXFx1MjA5Mic6ICdvJyxcbiAgJ1xcdTIwOUEnOiAncCcsXG4gICdcXHUxRDYzJzogJ3InLFxuICAnXFx1MjA5Qic6ICdzJyxcbiAgJ1xcdTIwOUMnOiAndCcsXG4gICdcXHUxRDY0JzogJ3UnLFxuICAnXFx1MUQ2NSc6ICd2JyxcbiAgJ1xcdTIwOTMnOiAneCcsXG4gICdcXHUxRDY2JzogJ86yJyxcbiAgJ1xcdTFENjcnOiAnzrMnLFxuICAnXFx1MUQ2OCc6ICfPgScsXG4gICdcXHUxRDY5JzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2QSc6ICfPhycsXG4gICfigbonOiAnKycsXG4gICfigbsnOiAnLScsXG4gICfigbwnOiAnPScsXG4gICfigb0nOiAnKCcsXG4gICfigb4nOiAnKScsXG4gICfigbAnOiAnMCcsXG4gICfCuSc6ICcxJyxcbiAgJ8KyJzogJzInLFxuICAnwrMnOiAnMycsXG4gICfigbQnOiAnNCcsXG4gICfigbUnOiAnNScsXG4gICfigbYnOiAnNicsXG4gICfigbcnOiAnNycsXG4gICfigbgnOiAnOCcsXG4gICfigbknOiAnOScsXG4gICdcXHUxRDJDJzogJ0EnLFxuICAnXFx1MUQyRSc6ICdCJyxcbiAgJ1xcdTFEMzAnOiAnRCcsXG4gICdcXHUxRDMxJzogJ0UnLFxuICAnXFx1MUQzMyc6ICdHJyxcbiAgJ1xcdTFEMzQnOiAnSCcsXG4gICdcXHUxRDM1JzogJ0knLFxuICAnXFx1MUQzNic6ICdKJyxcbiAgJ1xcdTFEMzcnOiAnSycsXG4gICdcXHUxRDM4JzogJ0wnLFxuICAnXFx1MUQzOSc6ICdNJyxcbiAgJ1xcdTFEM0EnOiAnTicsXG4gICdcXHUxRDNDJzogJ08nLFxuICAnXFx1MUQzRSc6ICdQJyxcbiAgJ1xcdTFEM0YnOiAnUicsXG4gICdcXHUxRDQwJzogJ1QnLFxuICAnXFx1MUQ0MSc6ICdVJyxcbiAgJ1xcdTJDN0QnOiAnVicsXG4gICdcXHUxRDQyJzogJ1cnLFxuICAnXFx1MUQ0Myc6ICdhJyxcbiAgJ1xcdTFENDcnOiAnYicsXG4gICdcXHUxRDlDJzogJ2MnLFxuICAnXFx1MUQ0OCc6ICdkJyxcbiAgJ1xcdTFENDknOiAnZScsXG4gICdcXHUxREEwJzogJ2YnLFxuICAnXFx1MUQ0RCc6ICdnJyxcbiAgJ1xcdTAyQjAnOiAnaCcsXG4gICdcXHUyMDcxJzogJ2knLFxuICAnXFx1MDJCMic6ICdqJyxcbiAgJ1xcdTFENEYnOiAnaycsXG4gICdcXHUwMkUxJzogJ2wnLFxuICAnXFx1MUQ1MCc6ICdtJyxcbiAgJ1xcdTIwN0YnOiAnbicsXG4gICdcXHUxRDUyJzogJ28nLFxuICAnXFx1MUQ1Nic6ICdwJyxcbiAgJ1xcdTAyQjMnOiAncicsXG4gICdcXHUwMkUyJzogJ3MnLFxuICAnXFx1MUQ1Nyc6ICd0JyxcbiAgJ1xcdTFENTgnOiAndScsXG4gICdcXHUxRDVCJzogJ3YnLFxuICAnXFx1MDJCNyc6ICd3JyxcbiAgJ1xcdTAyRTMnOiAneCcsXG4gICdcXHUwMkI4JzogJ3knLFxuICAnXFx1MURCQic6ICd6JyxcbiAgJ1xcdTFENUQnOiAnzrInLFxuICAnXFx1MUQ1RSc6ICfOsycsXG4gICdcXHUxRDVGJzogJ860JyxcbiAgJ1xcdTFENjAnOiAnXFx1MDNkNScsXG4gICdcXHUxRDYxJzogJ8+HJyxcbiAgJ1xcdTFEQkYnOiAnzrgnXG59KTtcblxuLyogZXNsaW50IG5vLWNvbnN0YW50LWNvbmRpdGlvbjowICovXG5cbnZhciB1bmljb2RlQWNjZW50cyA9IHtcbiAgXCLMgVwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXCdcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcYWN1dGVcIlxuICB9LFxuICBcIsyAXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcYFwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxncmF2ZVwiXG4gIH0sXG4gIFwizIhcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxcXFwiXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGRkb3RcIlxuICB9LFxuICBcIsyDXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcflwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFx0aWxkZVwiXG4gIH0sXG4gIFwizIRcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFw9XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGJhclwiXG4gIH0sXG4gIFwizIZcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFx1XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGJyZXZlXCJcbiAgfSxcbiAgXCLMjFwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXHZcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcY2hlY2tcIlxuICB9LFxuICBcIsyCXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcXlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxoYXRcIlxuICB9LFxuICBcIsyHXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcLlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxkb3RcIlxuICB9LFxuICBcIsyKXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcclwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxtYXRocmluZ1wiXG4gIH0sXG4gIFwizItcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxIXCJcbiAgfSxcbiAgXCLMp1wiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXGNcIlxuICB9XG59O1xudmFyIHVuaWNvZGVTeW1ib2xzID0ge1xuICBcIsOhXCI6IFwiYcyBXCIsXG4gIFwiw6BcIjogXCJhzIBcIixcbiAgXCLDpFwiOiBcImHMiFwiLFxuICBcIsefXCI6IFwiYcyIzIRcIixcbiAgXCLDo1wiOiBcImHMg1wiLFxuICBcIsSBXCI6IFwiYcyEXCIsXG4gIFwixINcIjogXCJhzIZcIixcbiAgXCLhuq9cIjogXCJhzIbMgVwiLFxuICBcIuG6sVwiOiBcImHMhsyAXCIsXG4gIFwi4bq1XCI6IFwiYcyGzINcIixcbiAgXCLHjlwiOiBcImHMjFwiLFxuICBcIsOiXCI6IFwiYcyCXCIsXG4gIFwi4bqlXCI6IFwiYcyCzIFcIixcbiAgXCLhuqdcIjogXCJhzILMgFwiLFxuICBcIuG6q1wiOiBcImHMgsyDXCIsXG4gIFwiyKdcIjogXCJhzIdcIixcbiAgXCLHoVwiOiBcImHMh8yEXCIsXG4gIFwiw6VcIjogXCJhzIpcIixcbiAgXCLHu1wiOiBcImHMisyBXCIsXG4gIFwi4biDXCI6IFwiYsyHXCIsXG4gIFwixIdcIjogXCJjzIFcIixcbiAgXCLhuIlcIjogXCJjzKfMgVwiLFxuICBcIsSNXCI6IFwiY8yMXCIsXG4gIFwixIlcIjogXCJjzIJcIixcbiAgXCLEi1wiOiBcImPMh1wiLFxuICBcIsOnXCI6IFwiY8ynXCIsXG4gIFwixI9cIjogXCJkzIxcIixcbiAgXCLhuItcIjogXCJkzIdcIixcbiAgXCLhuJFcIjogXCJkzKdcIixcbiAgXCLDqVwiOiBcImXMgVwiLFxuICBcIsOoXCI6IFwiZcyAXCIsXG4gIFwiw6tcIjogXCJlzIhcIixcbiAgXCLhur1cIjogXCJlzINcIixcbiAgXCLEk1wiOiBcImXMhFwiLFxuICBcIuG4l1wiOiBcImXMhMyBXCIsXG4gIFwi4biVXCI6IFwiZcyEzIBcIixcbiAgXCLElVwiOiBcImXMhlwiLFxuICBcIuG4nVwiOiBcImXMp8yGXCIsXG4gIFwixJtcIjogXCJlzIxcIixcbiAgXCLDqlwiOiBcImXMglwiLFxuICBcIuG6v1wiOiBcImXMgsyBXCIsXG4gIFwi4buBXCI6IFwiZcyCzIBcIixcbiAgXCLhu4VcIjogXCJlzILMg1wiLFxuICBcIsSXXCI6IFwiZcyHXCIsXG4gIFwiyKlcIjogXCJlzKdcIixcbiAgXCLhuJ9cIjogXCJmzIdcIixcbiAgXCLHtVwiOiBcImfMgVwiLFxuICBcIuG4oVwiOiBcImfMhFwiLFxuICBcIsSfXCI6IFwiZ8yGXCIsXG4gIFwix6dcIjogXCJnzIxcIixcbiAgXCLEnVwiOiBcImfMglwiLFxuICBcIsShXCI6IFwiZ8yHXCIsXG4gIFwixKNcIjogXCJnzKdcIixcbiAgXCLhuKdcIjogXCJozIhcIixcbiAgXCLIn1wiOiBcImjMjFwiLFxuICBcIsSlXCI6IFwiaMyCXCIsXG4gIFwi4bijXCI6IFwiaMyHXCIsXG4gIFwi4bipXCI6IFwiaMynXCIsXG4gIFwiw61cIjogXCJpzIFcIixcbiAgXCLDrFwiOiBcImnMgFwiLFxuICBcIsOvXCI6IFwiacyIXCIsXG4gIFwi4bivXCI6IFwiacyIzIFcIixcbiAgXCLEqVwiOiBcImnMg1wiLFxuICBcIsSrXCI6IFwiacyEXCIsXG4gIFwixK1cIjogXCJpzIZcIixcbiAgXCLHkFwiOiBcImnMjFwiLFxuICBcIsOuXCI6IFwiacyCXCIsXG4gIFwix7BcIjogXCJqzIxcIixcbiAgXCLEtVwiOiBcImrMglwiLFxuICBcIuG4sVwiOiBcImvMgVwiLFxuICBcIsepXCI6IFwia8yMXCIsXG4gIFwixLdcIjogXCJrzKdcIixcbiAgXCLEulwiOiBcImzMgVwiLFxuICBcIsS+XCI6IFwibMyMXCIsXG4gIFwixLxcIjogXCJszKdcIixcbiAgXCLhuL9cIjogXCJtzIFcIixcbiAgXCLhuYFcIjogXCJtzIdcIixcbiAgXCLFhFwiOiBcIm7MgVwiLFxuICBcIse5XCI6IFwibsyAXCIsXG4gIFwiw7FcIjogXCJuzINcIixcbiAgXCLFiFwiOiBcIm7MjFwiLFxuICBcIuG5hVwiOiBcIm7Mh1wiLFxuICBcIsWGXCI6IFwibsynXCIsXG4gIFwiw7NcIjogXCJvzIFcIixcbiAgXCLDslwiOiBcIm/MgFwiLFxuICBcIsO2XCI6IFwib8yIXCIsXG4gIFwiyKtcIjogXCJvzIjMhFwiLFxuICBcIsO1XCI6IFwib8yDXCIsXG4gIFwi4bmNXCI6IFwib8yDzIFcIixcbiAgXCLhuY9cIjogXCJvzIPMiFwiLFxuICBcIsitXCI6IFwib8yDzIRcIixcbiAgXCLFjVwiOiBcIm/MhFwiLFxuICBcIuG5k1wiOiBcIm/MhMyBXCIsXG4gIFwi4bmRXCI6IFwib8yEzIBcIixcbiAgXCLFj1wiOiBcIm/MhlwiLFxuICBcIseSXCI6IFwib8yMXCIsXG4gIFwiw7RcIjogXCJvzIJcIixcbiAgXCLhu5FcIjogXCJvzILMgVwiLFxuICBcIuG7k1wiOiBcIm/MgsyAXCIsXG4gIFwi4buXXCI6IFwib8yCzINcIixcbiAgXCLIr1wiOiBcIm/Mh1wiLFxuICBcIsixXCI6IFwib8yHzIRcIixcbiAgXCLFkVwiOiBcIm/Mi1wiLFxuICBcIuG5lVwiOiBcInDMgVwiLFxuICBcIuG5l1wiOiBcInDMh1wiLFxuICBcIsWVXCI6IFwicsyBXCIsXG4gIFwixZlcIjogXCJyzIxcIixcbiAgXCLhuZlcIjogXCJyzIdcIixcbiAgXCLFl1wiOiBcInLMp1wiLFxuICBcIsWbXCI6IFwic8yBXCIsXG4gIFwi4bmlXCI6IFwic8yBzIdcIixcbiAgXCLFoVwiOiBcInPMjFwiLFxuICBcIuG5p1wiOiBcInPMjMyHXCIsXG4gIFwixZ1cIjogXCJzzIJcIixcbiAgXCLhuaFcIjogXCJzzIdcIixcbiAgXCLFn1wiOiBcInPMp1wiLFxuICBcIuG6l1wiOiBcInTMiFwiLFxuICBcIsWlXCI6IFwidMyMXCIsXG4gIFwi4bmrXCI6IFwidMyHXCIsXG4gIFwixaNcIjogXCJ0zKdcIixcbiAgXCLDulwiOiBcInXMgVwiLFxuICBcIsO5XCI6IFwidcyAXCIsXG4gIFwiw7xcIjogXCJ1zIhcIixcbiAgXCLHmFwiOiBcInXMiMyBXCIsXG4gIFwix5xcIjogXCJ1zIjMgFwiLFxuICBcIseWXCI6IFwidcyIzIRcIixcbiAgXCLHmlwiOiBcInXMiMyMXCIsXG4gIFwixalcIjogXCJ1zINcIixcbiAgXCLhublcIjogXCJ1zIPMgVwiLFxuICBcIsWrXCI6IFwidcyEXCIsXG4gIFwi4bm7XCI6IFwidcyEzIhcIixcbiAgXCLFrVwiOiBcInXMhlwiLFxuICBcIseUXCI6IFwidcyMXCIsXG4gIFwiw7tcIjogXCJ1zIJcIixcbiAgXCLFr1wiOiBcInXMilwiLFxuICBcIsWxXCI6IFwidcyLXCIsXG4gIFwi4bm9XCI6IFwidsyDXCIsXG4gIFwi4bqDXCI6IFwid8yBXCIsXG4gIFwi4bqBXCI6IFwid8yAXCIsXG4gIFwi4bqFXCI6IFwid8yIXCIsXG4gIFwixbVcIjogXCJ3zIJcIixcbiAgXCLhuodcIjogXCJ3zIdcIixcbiAgXCLhuphcIjogXCJ3zIpcIixcbiAgXCLhuo1cIjogXCJ4zIhcIixcbiAgXCLhuotcIjogXCJ4zIdcIixcbiAgXCLDvVwiOiBcInnMgVwiLFxuICBcIuG7s1wiOiBcInnMgFwiLFxuICBcIsO/XCI6IFwiecyIXCIsXG4gIFwi4bu5XCI6IFwiecyDXCIsXG4gIFwiyLNcIjogXCJ5zIRcIixcbiAgXCLFt1wiOiBcInnMglwiLFxuICBcIuG6j1wiOiBcInnMh1wiLFxuICBcIuG6mVwiOiBcInnMilwiLFxuICBcIsW6XCI6IFwiesyBXCIsXG4gIFwixb5cIjogXCJ6zIxcIixcbiAgXCLhupFcIjogXCJ6zIJcIixcbiAgXCLFvFwiOiBcInrMh1wiLFxuICBcIsOBXCI6IFwiQcyBXCIsXG4gIFwiw4BcIjogXCJBzIBcIixcbiAgXCLDhFwiOiBcIkHMiFwiLFxuICBcIseeXCI6IFwiQcyIzIRcIixcbiAgXCLDg1wiOiBcIkHMg1wiLFxuICBcIsSAXCI6IFwiQcyEXCIsXG4gIFwixIJcIjogXCJBzIZcIixcbiAgXCLhuq5cIjogXCJBzIbMgVwiLFxuICBcIuG6sFwiOiBcIkHMhsyAXCIsXG4gIFwi4bq0XCI6IFwiQcyGzINcIixcbiAgXCLHjVwiOiBcIkHMjFwiLFxuICBcIsOCXCI6IFwiQcyCXCIsXG4gIFwi4bqkXCI6IFwiQcyCzIFcIixcbiAgXCLhuqZcIjogXCJBzILMgFwiLFxuICBcIuG6qlwiOiBcIkHMgsyDXCIsXG4gIFwiyKZcIjogXCJBzIdcIixcbiAgXCLHoFwiOiBcIkHMh8yEXCIsXG4gIFwiw4VcIjogXCJBzIpcIixcbiAgXCLHulwiOiBcIkHMisyBXCIsXG4gIFwi4biCXCI6IFwiQsyHXCIsXG4gIFwixIZcIjogXCJDzIFcIixcbiAgXCLhuIhcIjogXCJDzKfMgVwiLFxuICBcIsSMXCI6IFwiQ8yMXCIsXG4gIFwixIhcIjogXCJDzIJcIixcbiAgXCLEilwiOiBcIkPMh1wiLFxuICBcIsOHXCI6IFwiQ8ynXCIsXG4gIFwixI5cIjogXCJEzIxcIixcbiAgXCLhuIpcIjogXCJEzIdcIixcbiAgXCLhuJBcIjogXCJEzKdcIixcbiAgXCLDiVwiOiBcIkXMgVwiLFxuICBcIsOIXCI6IFwiRcyAXCIsXG4gIFwiw4tcIjogXCJFzIhcIixcbiAgXCLhurxcIjogXCJFzINcIixcbiAgXCLEklwiOiBcIkXMhFwiLFxuICBcIuG4llwiOiBcIkXMhMyBXCIsXG4gIFwi4biUXCI6IFwiRcyEzIBcIixcbiAgXCLElFwiOiBcIkXMhlwiLFxuICBcIuG4nFwiOiBcIkXMp8yGXCIsXG4gIFwixJpcIjogXCJFzIxcIixcbiAgXCLDilwiOiBcIkXMglwiLFxuICBcIuG6vlwiOiBcIkXMgsyBXCIsXG4gIFwi4buAXCI6IFwiRcyCzIBcIixcbiAgXCLhu4RcIjogXCJFzILMg1wiLFxuICBcIsSWXCI6IFwiRcyHXCIsXG4gIFwiyKhcIjogXCJFzKdcIixcbiAgXCLhuJ5cIjogXCJGzIdcIixcbiAgXCLHtFwiOiBcIkfMgVwiLFxuICBcIuG4oFwiOiBcIkfMhFwiLFxuICBcIsSeXCI6IFwiR8yGXCIsXG4gIFwix6ZcIjogXCJHzIxcIixcbiAgXCLEnFwiOiBcIkfMglwiLFxuICBcIsSgXCI6IFwiR8yHXCIsXG4gIFwixKJcIjogXCJHzKdcIixcbiAgXCLhuKZcIjogXCJIzIhcIixcbiAgXCLInlwiOiBcIkjMjFwiLFxuICBcIsSkXCI6IFwiSMyCXCIsXG4gIFwi4biiXCI6IFwiSMyHXCIsXG4gIFwi4bioXCI6IFwiSMynXCIsXG4gIFwiw41cIjogXCJJzIFcIixcbiAgXCLDjFwiOiBcIknMgFwiLFxuICBcIsOPXCI6IFwiScyIXCIsXG4gIFwi4biuXCI6IFwiScyIzIFcIixcbiAgXCLEqFwiOiBcIknMg1wiLFxuICBcIsSqXCI6IFwiScyEXCIsXG4gIFwixKxcIjogXCJJzIZcIixcbiAgXCLHj1wiOiBcIknMjFwiLFxuICBcIsOOXCI6IFwiScyCXCIsXG4gIFwixLBcIjogXCJJzIdcIixcbiAgXCLEtFwiOiBcIkrMglwiLFxuICBcIuG4sFwiOiBcIkvMgVwiLFxuICBcIseoXCI6IFwiS8yMXCIsXG4gIFwixLZcIjogXCJLzKdcIixcbiAgXCLEuVwiOiBcIkzMgVwiLFxuICBcIsS9XCI6IFwiTMyMXCIsXG4gIFwixLtcIjogXCJMzKdcIixcbiAgXCLhuL5cIjogXCJNzIFcIixcbiAgXCLhuYBcIjogXCJNzIdcIixcbiAgXCLFg1wiOiBcIk7MgVwiLFxuICBcIse4XCI6IFwiTsyAXCIsXG4gIFwiw5FcIjogXCJOzINcIixcbiAgXCLFh1wiOiBcIk7MjFwiLFxuICBcIuG5hFwiOiBcIk7Mh1wiLFxuICBcIsWFXCI6IFwiTsynXCIsXG4gIFwiw5NcIjogXCJPzIFcIixcbiAgXCLDklwiOiBcIk/MgFwiLFxuICBcIsOWXCI6IFwiT8yIXCIsXG4gIFwiyKpcIjogXCJPzIjMhFwiLFxuICBcIsOVXCI6IFwiT8yDXCIsXG4gIFwi4bmMXCI6IFwiT8yDzIFcIixcbiAgXCLhuY5cIjogXCJPzIPMiFwiLFxuICBcIsisXCI6IFwiT8yDzIRcIixcbiAgXCLFjFwiOiBcIk/MhFwiLFxuICBcIuG5klwiOiBcIk/MhMyBXCIsXG4gIFwi4bmQXCI6IFwiT8yEzIBcIixcbiAgXCLFjlwiOiBcIk/MhlwiLFxuICBcIseRXCI6IFwiT8yMXCIsXG4gIFwiw5RcIjogXCJPzIJcIixcbiAgXCLhu5BcIjogXCJPzILMgVwiLFxuICBcIuG7klwiOiBcIk/MgsyAXCIsXG4gIFwi4buWXCI6IFwiT8yCzINcIixcbiAgXCLIrlwiOiBcIk/Mh1wiLFxuICBcIsiwXCI6IFwiT8yHzIRcIixcbiAgXCLFkFwiOiBcIk/Mi1wiLFxuICBcIuG5lFwiOiBcIlDMgVwiLFxuICBcIuG5llwiOiBcIlDMh1wiLFxuICBcIsWUXCI6IFwiUsyBXCIsXG4gIFwixZhcIjogXCJSzIxcIixcbiAgXCLhuZhcIjogXCJSzIdcIixcbiAgXCLFllwiOiBcIlLMp1wiLFxuICBcIsWaXCI6IFwiU8yBXCIsXG4gIFwi4bmkXCI6IFwiU8yBzIdcIixcbiAgXCLFoFwiOiBcIlPMjFwiLFxuICBcIuG5plwiOiBcIlPMjMyHXCIsXG4gIFwixZxcIjogXCJTzIJcIixcbiAgXCLhuaBcIjogXCJTzIdcIixcbiAgXCLFnlwiOiBcIlPMp1wiLFxuICBcIsWkXCI6IFwiVMyMXCIsXG4gIFwi4bmqXCI6IFwiVMyHXCIsXG4gIFwixaJcIjogXCJUzKdcIixcbiAgXCLDmlwiOiBcIlXMgVwiLFxuICBcIsOZXCI6IFwiVcyAXCIsXG4gIFwiw5xcIjogXCJVzIhcIixcbiAgXCLHl1wiOiBcIlXMiMyBXCIsXG4gIFwix5tcIjogXCJVzIjMgFwiLFxuICBcIseVXCI6IFwiVcyIzIRcIixcbiAgXCLHmVwiOiBcIlXMiMyMXCIsXG4gIFwixahcIjogXCJVzINcIixcbiAgXCLhubhcIjogXCJVzIPMgVwiLFxuICBcIsWqXCI6IFwiVcyEXCIsXG4gIFwi4bm6XCI6IFwiVcyEzIhcIixcbiAgXCLFrFwiOiBcIlXMhlwiLFxuICBcIseTXCI6IFwiVcyMXCIsXG4gIFwiw5tcIjogXCJVzIJcIixcbiAgXCLFrlwiOiBcIlXMilwiLFxuICBcIsWwXCI6IFwiVcyLXCIsXG4gIFwi4bm8XCI6IFwiVsyDXCIsXG4gIFwi4bqCXCI6IFwiV8yBXCIsXG4gIFwi4bqAXCI6IFwiV8yAXCIsXG4gIFwi4bqEXCI6IFwiV8yIXCIsXG4gIFwixbRcIjogXCJXzIJcIixcbiAgXCLhuoZcIjogXCJXzIdcIixcbiAgXCLhuoxcIjogXCJYzIhcIixcbiAgXCLhuopcIjogXCJYzIdcIixcbiAgXCLDnVwiOiBcIlnMgVwiLFxuICBcIuG7slwiOiBcIlnMgFwiLFxuICBcIsW4XCI6IFwiWcyIXCIsXG4gIFwi4bu4XCI6IFwiWcyDXCIsXG4gIFwiyLJcIjogXCJZzIRcIixcbiAgXCLFtlwiOiBcIlnMglwiLFxuICBcIuG6jlwiOiBcIlnMh1wiLFxuICBcIsW5XCI6IFwiWsyBXCIsXG4gIFwixb1cIjogXCJazIxcIixcbiAgXCLhupBcIjogXCJazIJcIixcbiAgXCLFu1wiOiBcIlrMh1wiLFxuICBcIs6sXCI6IFwizrHMgVwiLFxuICBcIuG9sFwiOiBcIs6xzIBcIixcbiAgXCLhvrFcIjogXCLOscyEXCIsXG4gIFwi4b6wXCI6IFwizrHMhlwiLFxuICBcIs6tXCI6IFwizrXMgVwiLFxuICBcIuG9slwiOiBcIs61zIBcIixcbiAgXCLOrlwiOiBcIs63zIFcIixcbiAgXCLhvbRcIjogXCLOt8yAXCIsXG4gIFwizq9cIjogXCLOucyBXCIsXG4gIFwi4b22XCI6IFwizrnMgFwiLFxuICBcIs+KXCI6IFwizrnMiFwiLFxuICBcIs6QXCI6IFwizrnMiMyBXCIsXG4gIFwi4b+SXCI6IFwizrnMiMyAXCIsXG4gIFwi4b+RXCI6IFwizrnMhFwiLFxuICBcIuG/kFwiOiBcIs65zIZcIixcbiAgXCLPjFwiOiBcIs6/zIFcIixcbiAgXCLhvbhcIjogXCLOv8yAXCIsXG4gIFwiz41cIjogXCLPhcyBXCIsXG4gIFwi4b26XCI6IFwiz4XMgFwiLFxuICBcIs+LXCI6IFwiz4XMiFwiLFxuICBcIs6wXCI6IFwiz4XMiMyBXCIsXG4gIFwi4b+iXCI6IFwiz4XMiMyAXCIsXG4gIFwi4b+hXCI6IFwiz4XMhFwiLFxuICBcIuG/oFwiOiBcIs+FzIZcIixcbiAgXCLPjlwiOiBcIs+JzIFcIixcbiAgXCLhvbxcIjogXCLPicyAXCIsXG4gIFwizo5cIjogXCLOpcyBXCIsXG4gIFwi4b+qXCI6IFwizqXMgFwiLFxuICBcIs6rXCI6IFwizqXMiFwiLFxuICBcIuG/qVwiOiBcIs6lzIRcIixcbiAgXCLhv6hcIjogXCLOpcyGXCIsXG4gIFwizo9cIjogXCLOqcyBXCIsXG4gIFwi4b+6XCI6IFwizqnMgFwiXG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgcGFyc2VyIHVzZWQgdG8gcGFyc2Ugb3V0IGEgVGVYIGV4cHJlc3Npb24gZnJvbSB0aGVcbiAqIGlucHV0LiBTaW5jZSBUZVggaXNuJ3QgY29udGV4dC1mcmVlLCBzdGFuZGFyZCBwYXJzZXJzIGRvbid0IHdvcmsgcGFydGljdWxhcmx5XG4gKiB3ZWxsLlxuICpcbiAqIFRoZSBzdHJhdGVneSBvZiB0aGlzIHBhcnNlciBpcyBhcyBzdWNoOlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyAodGhlIGAucGFyc2UuLi5gIG9uZXMpIHRha2UgYSBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICogcGFyc2Ugc3RyaW5nIHRvIHBhcnNlIHRva2VucyBmcm9tLiBUaGUgbGV4ZXIgKGZvdW5kIGluIExleGVyLmpzLCBzdG9yZWQgYXRcbiAqIHRoaXMuZ3VsbGV0LmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgcmV0dXJuIFBhcnNlTm9kZXMuXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncykge1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmd1bGxldCA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSB2b2lkIDA7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB2b2lkIDA7XG4gICAgLy8gU3RhcnQgaW4gbWF0aCBtb2RlXG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7IC8vIENyZWF0ZSBhIG5ldyBtYWNybyBleHBhbmRlciAoZ3VsbGV0KSBhbmQgKGluZGlyZWN0bHkgdmlhIHRoYXQpIGFsc28gYVxuICAgIC8vIG5ldyBsZXhlciAobW91dGgpIGZvciB0aGlzIHBhcnNlciAoc3RvbWFjaCwgaW4gdGhlIGxhbmd1YWdlIG9mIFRlWClcblxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCB0aGlzLm1vZGUpOyAvLyBTdG9yZSB0aGUgc2V0dGluZ3MgZm9yIHVzZSBpbiBwYXJzaW5nXG5cbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7IC8vIENvdW50IGxlZnRyaWdodCBkZXB0aCAoZm9yIFxcbWlkZGxlIGVycm9ycylcblxuICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICAgKiBhcHByb3ByaWF0ZSBlcnJvciBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgZXhwZWN0KHRleHQsIGNvbnN1bWUpIHtcbiAgICBpZiAoY29uc3VtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdW1lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZXRjaCgpLnRleHQgIT09IHRleHQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMuZmV0Y2goKS50ZXh0ICsgXCInXCIsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWUpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY2FyZHMgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBjb25zaWRlcmluZyBpdCBjb25zdW1lZC5cbiAgICovXG5cblxuICBjb25zdW1lKCkge1xuICAgIHRoaXMubmV4dFRva2VuID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgb3IgaWYgdGhlcmUgaXNuJ3Qgb25lIChhdCB0aGVcbiAgICogYmVnaW5uaW5nLCBvciBpZiB0aGUgcHJldmlvdXMgbG9va2FoZWFkIHRva2VuIHdhcyBjb25zdW1lKClkKSxcbiAgICogZmV0Y2ggdGhlIG5leHQgdG9rZW4gYXMgdGhlIG5ldyBsb29rYWhlYWQgdG9rZW4gYW5kIHJldHVybiBpdC5cbiAgICovXG5cblxuICBmZXRjaCgpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW47XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cblxuXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5ndWxsZXQuc3dpdGNoTW9kZShuZXdNb2RlKTtcbiAgfVxuICAvKipcbiAgICogTWFpbiBwYXJzaW5nIGZ1bmN0aW9uLCB3aGljaCBwYXJzZXMgYW4gZW50aXJlIGlucHV0LlxuICAgKi9cblxuXG4gIHBhcnNlKCkge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5nbG9iYWxHcm91cCkge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgbWF0aCBleHByZXNzaW9uLlxuICAgICAgLy8gKExhVGVYIGNyZWF0ZXMgYSBuZXcgZ3JvdXAgZm9yIGV2ZXJ5ICQuLi4kLCAkJC4uLiQkLCBcXFsuLi5cXF0uKVxuICAgICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIH0gLy8gVXNlIG9sZCBcXGNvbG9yIGJlaGF2aW9yIChzYW1lIGFzIExhVGVYJ3MgXFx0ZXh0Y29sb3IpIGlmIHJlcXVlc3RlZC5cbiAgICAvLyBXZSBkbyB0aGlzIHdpdGhpbiB0aGUgZ3JvdXAgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24sIHNvIGl0IGRvZXNuJ3RcbiAgICAvLyBwb2xsdXRlIHNldHRpbmdzLm1hY3Jvcy5cblxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sb3JJc1RleHRDb2xvcikge1xuICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjb2xvclwiLCBcIlxcXFx0ZXh0Y29sb3JcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgaW5wdXRcbiAgICAgIHZhciBwYXJzZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTsgLy8gSWYgd2Ugc3VjY2VlZGVkLCBtYWtlIHN1cmUgdGhlcmUncyBhbiBFT0YgYXQgdGhlIGVuZFxuXG4gICAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTsgLy8gRW5kIHRoZSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBleHByZXNzaW9uXG5cbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5nbG9iYWxHcm91cCkge1xuICAgICAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2U7IC8vIENsb3NlIGFueSBsZWZ0b3ZlciBncm91cHMgaW4gY2FzZSBvZiBhIHBhcnNlIGVycm9yLlxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmd1bGxldC5lbmRHcm91cHMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZ1bGx5IHBhcnNlIGEgc2VwYXJhdGUgc2VxdWVuY2Ugb2YgdG9rZW5zIGFzIGEgc2VwYXJhdGUgam9iLlxuICAgKiBUb2tlbnMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiByZXZlcnNlIG9yZGVyLCBhcyBpbiBhIE1hY3JvRGVmaW5pdGlvbi5cbiAgICovXG5cblxuICBzdWJwYXJzZSh0b2tlbnMpIHtcbiAgICAvLyBTYXZlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuICAgIHZhciBvbGRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBSdW4gdGhlIG5ldyBqb2IsIHRlcm1pbmF0aW5nIGl0IHdpdGggYW4gZXhjZXNzICd9J1xuXG4gICAgdGhpcy5ndWxsZXQucHVzaFRva2VuKG5ldyBUb2tlbihcIn1cIikpO1xuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICB2YXIgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpOyAvLyBSZXN0b3JlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuXG4gICAgdGhpcy5uZXh0VG9rZW4gPSBvbGRUb2tlbjtcbiAgICByZXR1cm4gcGFyc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFwiZXhwcmVzc2lvblwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgYXRvbXMuXG4gICAqXG4gICAqIGBicmVha09uSW5maXhgOiBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeCBub2Rlcz8gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgaGFwcGVucyB3aGVuIGZ1bmN0aW9ucyBoYXZlIGhpZ2hlciBwcmVjZW5kZW5jZSBoYW4gaW5maXhcbiAgICogICAgICAgICAgICAgICAgIG5vZGVzIGluIGltcGxpY2l0IHBhcnNlcy5cbiAgICpcbiAgICogYGJyZWFrT25Ub2tlblRleHRgOiBUaGUgdGV4dCBvZiB0aGUgdG9rZW4gdGhhdCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgd2l0aCwgb3IgYG51bGxgIGlmIHNvbWV0aGluZyBlbHNlIHNob3VsZCBlbmQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAgICovXG4gIHBhcnNlRXhwcmVzc2lvbihicmVha09uSW5maXgsIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICB2YXIgYm9keSA9IFtdOyAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGluIG1hdGggbW9kZVxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChQYXJzZXIuZW5kT2ZFeHByZXNzaW9uLmluZGV4T2YobGV4LnRleHQpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBmdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGF0b20udHlwZSA9PT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBib2R5LnB1c2goYXRvbSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbmZpeE5vZGVzKGJvZHkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXdyaXRlcyBpbmZpeCBvcGVyYXRvcnMgc3VjaCBhcyBcXG92ZXIgd2l0aCBjb3JyZXNwb25kaW5nIGNvbW1hbmRzIHN1Y2hcbiAgICogYXMgXFxmcmFjLlxuICAgKlxuICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwLiAgSWYgdGhlcmUncyBtb3JlIHRoYW4gb25lXG4gICAqIHRoZW4gdGhlIGV4cHJlc3Npb24gaXMgYW1iaWd1b3VzLiAgVGhpcyBjYW4gYmUgcmVzb2x2ZWQgYnkgYWRkaW5nIHt9LlxuICAgKi9cblxuXG4gIGhhbmRsZUluZml4Tm9kZXMoYm9keSkge1xuICAgIHZhciBvdmVySW5kZXggPSAtMTtcbiAgICB2YXIgZnVuY05hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChib2R5W2ldLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICBpZiAob3ZlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwib25seSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwXCIsIGJvZHlbaV0udG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgb3ZlckluZGV4ID0gaTtcbiAgICAgICAgZnVuY05hbWUgPSBib2R5W2ldLnJlcGxhY2VXaXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdmVySW5kZXggIT09IC0xICYmIGZ1bmNOYW1lKSB7XG4gICAgICB2YXIgbnVtZXJOb2RlO1xuICAgICAgdmFyIGRlbm9tTm9kZTtcbiAgICAgIHZhciBudW1lckJvZHkgPSBib2R5LnNsaWNlKDAsIG92ZXJJbmRleCk7XG4gICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgaWYgKG51bWVyQm9keS5sZW5ndGggPT09IDEgJiYgbnVtZXJCb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1lck5vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBudW1lckJvZHlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBkZW5vbU5vZGUgPSBkZW5vbUJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZW5vbU5vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBkZW5vbUJvZHlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGFib3ZlZnJhY1wiKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgYm9keVtvdmVySW5kZXhdLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgd2l0aCBuaWNlIGVycm9ycy5cbiAgICovXG5cblxuICBoYW5kbGVTdXBTdWJzY3JpcHQobmFtZSAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICApIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgdmFyIHN5bWJvbCA9IHN5bWJvbFRva2VuLnRleHQ7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIGlnbm9yZSBzcGFjZXMgYmVmb3JlIHN1cC9zdWJzY3JpcHQgYXJndW1lbnRcblxuICAgIHZhciBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsIHN5bWJvbFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICAgKiBjb250YWluZWQgd2l0aGluIGEgY29sb3Igbm9kZSB3aG9zZSBjb2xvciBpcyBkZXRlcm1pbmVkIGJ5IGVycm9yQ29sb3JcbiAgICovXG5cblxuICBmb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KSB7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogdGV4dFtpXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBib2R5OiB0ZXh0b3JkQXJyYXlcbiAgICB9O1xuICAgIHZhciBjb2xvck5vZGUgPSB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgYm9keTogW3RleHROb2RlXVxuICAgIH07XG4gICAgcmV0dXJuIGNvbG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2l0aCBvcHRpb25hbCBzdXBlci9zdWJzY3JpcHRzLlxuICAgKi9cblxuXG4gIHBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KSB7XG4gICAgLy8gVGhlIGJvZHkgb2YgYW4gYXRvbSBpcyBhbiBpbXBsaWNpdCBncm91cCwgc28gdGhhdCB0aGluZ3MgbGlrZVxuICAgIC8vIFxcbGVmdCh4XFxyaWdodCleMiB3b3JrIGNvcnJlY3RseS5cbiAgICB2YXIgYmFzZSA9IHRoaXMucGFyc2VHcm91cChcImF0b21cIiwgYnJlYWtPblRva2VuVGV4dCk7IC8vIEluIHRleHQgbW9kZSwgd2UgZG9uJ3QgaGF2ZSBzdXBlcnNjcmlwdHMgb3Igc3Vic2NyaXB0c1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH0gLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cblxuICAgIHZhciBzdXBlcnNjcmlwdDtcbiAgICB2YXIgc3Vic2NyaXB0O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIEd1YXJhbnRlZWQgaW4gbWF0aCBtb2RlLCBzbyBlYXQgYW55IHNwYWNlcyBmaXJzdC5cbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG5cbiAgICAgIHZhciBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCIgfHwgbGV4LnRleHQgPT09IFwiXFxcXG5vbGltaXRzXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbGltaXQgY29udHJvbFxuICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAgIHZhciBsaW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgYmFzZS5saW1pdHMgPSBsaW1pdHM7XG4gICAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgICAgICAgaWYgKGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSB7XG4gICAgICAgICAgICBiYXNlLmxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgc3VwZXJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyc2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1YnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1cGVyc2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJpbWUgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIHRleHQ6IFwiXFxcXHByaW1lXCJcbiAgICAgICAgfTsgLy8gTWFueSBwcmltZXMgY2FuIGJlIGdyb3VwZWQgdG9nZXRoZXIsIHNvIHdlIGhhbmRsZSB0aGlzIGhlcmVcblxuICAgICAgICB2YXIgcHJpbWVzID0gW3ByaW1lXTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7IC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuXG4gICAgICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCBvbmUsIGFkZCBhbm90aGVyIHByaW1lIHRvIHRoZSBsaXN0XG4gICAgICAgICAgcHJpbWVzLnB1c2gocHJpbWUpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IC8vIElmIHRoZXJlJ3MgYSBzdXBlcnNjcmlwdCBmb2xsb3dpbmcgdGhlIHByaW1lcywgY29tYmluZSB0aGF0XG4gICAgICAgIC8vIHN1cGVyc2NyaXB0IGluIHdpdGggdGhlIHByaW1lcy5cblxuXG4gICAgICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICBwcmltZXMucHVzaCh0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpKTtcbiAgICAgICAgfSAvLyBQdXQgZXZlcnl0aGluZyBpbnRvIGFuIG9yZGdyb3VwIGFzIHRoZSBzdXBlcnNjcmlwdFxuXG5cbiAgICAgICAgc3VwZXJzY3JpcHQgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBib2R5OiBwcmltZXNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodVN1YnNBbmRTdXBzW2xleC50ZXh0XSkge1xuICAgICAgICAvLyBBIFVuaWNvZGUgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gV2UgdHJlYXQgdGhlc2Ugc2ltaWxhcmx5IHRvIHRoZSB1bmljb2RlLW1hdGggcGFja2FnZS5cbiAgICAgICAgLy8gU28gd2UgcmVuZGVyIGEgc3RyaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHRzIHRoZVxuICAgICAgICAvLyBzYW1lIGFzIGEgKHN1YnxzdXBlcilzY3JpcHQgb2YgcmVndWxhciBjaGFyYWN0ZXJzLlxuICAgICAgICB2YXIgc3RyID0gdVN1YnNBbmRTdXBzW2xleC50ZXh0XTtcbiAgICAgICAgdmFyIGlzU3ViID0gdW5pY29kZVN1YlJlZ0V4LnRlc3QobGV4LnRleHQpO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTsgLy8gQ29udGludWUgZmV0Y2hpbmcgdG9rZW5zIHRvIGZpbGwgb3V0IHRoZSBzdHJpbmcuXG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmZldGNoKCkudGV4dDtcblxuICAgICAgICAgIGlmICghdVN1YnNBbmRTdXBzW3Rva2VuXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVuaWNvZGVTdWJSZWdFeC50ZXN0KHRva2VuKSAhPT0gaXNTdWIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHN0ciArPSB1U3Vic0FuZFN1cHNbdG9rZW5dO1xuICAgICAgICB9IC8vIE5vdyBjcmVhdGUgYSAoc3VifHN1cGVyKXNjcmlwdC5cblxuXG4gICAgICAgIHZhciBib2R5ID0gbmV3IFBhcnNlcihzdHIsIHRoaXMuc2V0dGluZ3MpLnBhcnNlKCk7XG5cbiAgICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgICAgc3Vic2NyaXB0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdXBlcnNjcmlwdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IHdhc24ndCBeLCBfLCBvciAnLCBzdG9wIHBhcnNpbmcgc3VwZXIvc3Vic2NyaXB0c1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEJhc2UgbXVzdCBiZSBzZXQgaWYgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0IGFyZSBzZXQgcGVyIGxvZ2ljIGFib3ZlLFxuICAgIC8vIGJ1dCBuZWVkIHRvIGNoZWNrIGhlcmUgZm9yIHR5cGUgY2hlY2sgdG8gcGFzcy5cblxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgLy8gSWYgd2UgZ290IGVpdGhlciBhIHN1cGVyc2NyaXB0IG9yIHN1YnNjcmlwdCwgY3JlYXRlIGEgc3Vwc3ViXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgIHN1Yjogc3Vic2NyaXB0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgcGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lIC8vIEZvciBkZXRlcm1pbmluZyBpdHMgY29udGV4dFxuICApIHtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgdmFyIGZ1bmMgPSB0b2tlbi50ZXh0O1xuICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcblxuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIGNvbW1hbmQgdG9rZW5cblxuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IFwiYXRvbVwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5Bcmd1bWVudCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJHb3QgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyB3aXRoIG5vIGFyZ3VtZW50c1wiICsgKG5hbWUgPyBcIiBhcyBcIiArIG5hbWUgOiBcIlwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiB0ZXh0IG1vZGVcIiwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIiAmJiBmdW5jRGF0YS5hbGxvd2VkSW5NYXRoID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiBtYXRoIG1vZGVcIiwgdG9rZW4pO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhcmdzLFxuICAgICAgb3B0QXJnc1xuICAgIH0gPSB0aGlzLnBhcnNlQXJndW1lbnRzKGZ1bmMsIGZ1bmNEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICAgKi9cblxuXG4gIGNhbGxGdW5jdGlvbihuYW1lLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICBwYXJzZXI6IHRoaXMsXG4gICAgICB0b2tlbixcbiAgICAgIGJyZWFrT25Ub2tlblRleHRcbiAgICB9O1xuICAgIHZhciBmdW5jID0gZnVuY3Rpb25zW25hbWVdO1xuXG4gICAgaWYgKGZ1bmMgJiYgZnVuYy5oYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZnVuYy5oYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk5vIGZ1bmN0aW9uIGhhbmRsZXIgZm9yIFwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gICAqL1xuXG5cbiAgcGFyc2VBcmd1bWVudHMoZnVuYywgLy8gU2hvdWxkIGxvb2sgbGlrZSBcIlxcbmFtZVwiIG9yIFwiXFxiZWdpbntuYW1lfVwiLlxuICBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuXG4gICAgaWYgKHRvdGFsQXJncyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIG9wdEFyZ3M6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG9wdEFyZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBcmdzOyBpKyspIHtcbiAgICAgIHZhciBhcmdUeXBlID0gZnVuY0RhdGEuYXJnVHlwZXMgJiYgZnVuY0RhdGEuYXJnVHlwZXNbaV07XG4gICAgICB2YXIgaXNPcHRpb25hbCA9IGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG5cbiAgICAgIGlmIChmdW5jRGF0YS5wcmltaXRpdmUgJiYgYXJnVHlwZSA9PSBudWxsIHx8IC8vIFxcc3FydCBleHBhbmRzIGludG8gcHJpbWl0aXZlIGlmIG9wdGlvbmFsIGFyZ3VtZW50IGRvZXNuJ3QgZXhpc3RcbiAgICAgIGZ1bmNEYXRhLnR5cGUgPT09IFwic3FydFwiICYmIGkgPT09IDEgJiYgb3B0QXJnc1swXSA9PSBudWxsKSB7XG4gICAgICAgIGFyZ1R5cGUgPSBcInByaW1pdGl2ZVwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKFwiYXJndW1lbnQgdG8gJ1wiICsgZnVuYyArIFwiJ1wiLCBhcmdUeXBlLCBpc09wdGlvbmFsKTtcblxuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgb3B0QXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTnVsbCBhcmd1bWVudCwgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhcmdzLFxuICAgICAgb3B0QXJnc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gICAqL1xuXG5cbiAgcGFyc2VHcm91cE9mVHlwZShuYW1lLCB0eXBlLCBvcHRpb25hbCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29sb3JHcm91cChvcHRpb25hbCk7XG5cbiAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVybEdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgdHlwZSk7XG5cbiAgICAgIGNhc2UgXCJoYm94XCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBoYm94IGFyZ3VtZW50IHR5cGUgd3JhcHMgdGhlIGFyZ3VtZW50IGluIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICAgICAgLy8gXFxoYm94LCB3aGljaCBpcyBsaWtlIFxcdGV4dCBidXQgc3dpdGNoaW5nIHRvIFxcdGV4dHN0eWxlIHNpemUuXG4gICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIFwidGV4dFwiKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAgIT0gbnVsbCA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgICAgICAgbW9kZTogZ3JvdXAubW9kZSxcbiAgICAgICAgICAgIGJvZHk6IFtncm91cF0sXG4gICAgICAgICAgICBzdHlsZTogXCJ0ZXh0XCIgLy8gc2ltdWxhdGUgXFx0ZXh0c3R5bGVcblxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInJhd1wiLCBvcHRpb25hbCk7XG4gICAgICAgICAgcmV0dXJuIHRva2VuICE9IG51bGwgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHRcbiAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwicHJpbWl0aXZlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQSBwcmltaXRpdmUgYXJndW1lbnQgY2Fubm90IGJlIG9wdGlvbmFsXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAobmFtZSk7XG5cbiAgICAgICAgICBpZiAoX2dyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYXMgXCIgKyBuYW1lLCB0aGlzLmZldGNoKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfZ3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm9yaWdpbmFsXCI6XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmtub3duIGdyb3VwIHR5cGUgYXMgXCIgKyBuYW1lLCB0aGlzLmZldGNoKCkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY2FyZCBhbnkgc3BhY2UgdG9rZW5zLCBmZXRjaGluZyB0aGUgbmV4dCBub24tc3BhY2UgdG9rZW4uXG4gICAqL1xuXG5cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICB3aGlsZSAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwLCBlc3NlbnRpYWxseSByZXR1cm5pbmcgdGhlIHN0cmluZyBmb3JtZWQgYnkgdGhlXG4gICAqIGJyYWNlLWVuY2xvc2VkIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuXG5cbiAgcGFyc2VTdHJpbmdHcm91cChtb2RlTmFtZSwgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgb3B0aW9uYWwpIHtcbiAgICB2YXIgYXJnVG9rZW4gPSB0aGlzLmd1bGxldC5zY2FuQXJndW1lbnQob3B0aW9uYWwpO1xuXG4gICAgaWYgKGFyZ1Rva2VuID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBuZXh0VG9rZW47XG5cbiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgc3RyICs9IG5leHRUb2tlbi50ZXh0O1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25zdW1lKCk7IC8vIGNvbnN1bWUgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcblxuICAgIGFyZ1Rva2VuLnRleHQgPSBzdHI7XG4gICAgcmV0dXJuIGFyZ1Rva2VuO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSByZWdleC1kZWxpbWl0ZWQgZ3JvdXA6IHRoZSBsYXJnZXN0IHNlcXVlbmNlIG9mIHRva2Vuc1xuICAgKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICogZm9ybWVkIGJ5IHRoZSB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cblxuXG4gIHBhcnNlUmVnZXhHcm91cChyZWdleCwgbW9kZU5hbWUgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgKSB7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgdmFyIGxhc3RUb2tlbiA9IGZpcnN0VG9rZW47XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIG5leHRUb2tlbjtcblxuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiICYmIHJlZ2V4LnRlc3Qoc3RyICsgbmV4dFRva2VuLnRleHQpKSB7XG4gICAgICBsYXN0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgXCIgKyBtb2RlTmFtZSArIFwiOiAnXCIgKyBmaXJzdFRva2VuLnRleHQgKyBcIidcIiwgZmlyc3RUb2tlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0VG9rZW4ucmFuZ2UobGFzdFRva2VuLCBzdHIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBjb2xvciBkZXNjcmlwdGlvbi5cbiAgICovXG5cblxuICBwYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuXG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSAvXigjW2EtZjAtOV17M318Iz9bYS1mMC05XXs2fXxbYS16XSspJC9pLmV4ZWMocmVzLnRleHQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGNvbG9yOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IG1hdGNoWzBdO1xuXG4gICAgaWYgKC9eWzAtOWEtZl17Nn0kL2kudGVzdChjb2xvcikpIHtcbiAgICAgIC8vIFdlIGFsbG93IGEgNi1kaWdpdCBIVE1MIGNvbG9yIHNwZWMgd2l0aG91dCBhIGxlYWRpbmcgXCIjXCIuXG4gICAgICAvLyBUaGlzIGZvbGxvd3MgdGhlIHhjb2xvciBwYWNrYWdlJ3MgSFRNTCBjb2xvciBtb2RlbC5cbiAgICAgIC8vIFByZWRlZmluZWQgY29sb3IgbmFtZXMgYXJlIGFsbCBtaXNzZWQgYnkgdGhpcyBSZWdFeCBwYXR0ZXJuLlxuICAgICAgY29sb3IgPSBcIiNcIiArIGNvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yLXRva2VuXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpemUgc3BlY2lmaWNhdGlvbiwgY29uc2lzdGluZyBvZiBtYWduaXR1ZGUgYW5kIHVuaXQuXG4gICAqL1xuXG5cbiAgcGFyc2VTaXplR3JvdXAob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBpc0JsYW5rID0gZmFsc2U7IC8vIGRvbid0IGV4cGFuZCBiZWZvcmUgcGFyc2VTdHJpbmdHcm91cFxuXG4gICAgdGhpcy5ndWxsZXQuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgaWYgKCFvcHRpb25hbCAmJiB0aGlzLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVJlZ2V4R3JvdXAoL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9ICokLywgXCJzaXplXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25hbCAmJiByZXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEJlY2F1c2Ugd2UndmUgdGVzdGVkIGZvciB3aGF0IGlzICFvcHRpb25hbCwgdGhpcyBibG9jayB3b24ndFxuICAgICAgLy8gYWZmZWN0IFxca2VybiwgXFxoc3BhY2UsIGV0Yy4gSXQgd2lsbCBjYXB0dXJlIHRoZSBtYW5kYXRvcnkgYXJndW1lbnRzXG4gICAgICAvLyB0byBcXGdlbmZyYWMgYW5kIFxcYWJvdmUuXG4gICAgICByZXMudGV4dCA9IFwiMHB0XCI7IC8vIEVuYWJsZSBcXGFib3Zle31cblxuICAgICAgaXNCbGFuayA9IHRydWU7IC8vIFRoaXMgaXMgaGVyZSBzcGVjaWZpY2FsbHkgZm9yIFxcZ2VuZnJhY1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhyZXMudGV4dCk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG5cbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJ1wiLCByZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemVcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgaXNCbGFua1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBVUkwsIGNoZWNraW5nIGVzY2FwZWQgbGV0dGVycyBhbmQgYWxsb3dlZCBwcm90b2NvbHMsXG4gICAqIGFuZCBzZXR0aW5nIHRoZSBjYXRjb2RlIG9mICUgYXMgYW4gYWN0aXZlIGNoYXJhY3RlciAoYXMgaW4gXFxoeXBlcnJlZikuXG4gICAqL1xuXG5cbiAgcGFyc2VVcmxHcm91cChvcHRpb25hbCkge1xuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCIlXCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIn5cIiwgMTIpOyAvLyBvdGhlciBjaGFyYWN0ZXJcblxuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJ1cmxcIiwgb3B0aW9uYWwpO1xuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCIlXCIsIDE0KTsgLy8gY29tbWVudCBjaGFyYWN0ZXJcblxuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCJ+XCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuXG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGh5cGVycmVmIHBhY2thZ2UgYWxsb3dzIGJhY2tzbGFzaGVzIGFsb25lIGluIGhyZWYsIGJ1dCBkb2Vzbid0XG4gICAgLy8gZ2VuZXJhdGUgdmFsaWQgbGlua3MgaW4gc3VjaCBjYXNlczsgd2UgaW50ZXJwcmV0IHRoaXMgYXNcbiAgICAvLyBcInVuZGVmaW5lZFwiIGJlaGF2aW91ciwgYW5kIGtlZXAgdGhlbSBhcy1pcy4gU29tZSBicm93c2VyIHdpbGxcbiAgICAvLyByZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLlxuXG5cbiAgICB2YXIgdXJsID0gcmVzLnRleHQucmVwbGFjZSgvXFxcXChbIyQlJn5fXnt9XSkvZywgJyQxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1cmxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYXJndW1lbnQgd2l0aCB0aGUgbW9kZSBzcGVjaWZpZWQuXG4gICAqL1xuXG5cbiAgcGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBtb2RlKSB7XG4gICAgdmFyIGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcblxuICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIC8vIFN3aXRjaCB0byBzcGVjaWZpZWQgbW9kZVxuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBcIkVPRlwiKTsgLy8gVE9ETzogZmluZCBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gZGVub3RlIHRoZSBlbmRcblxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpOyAvLyBleHBlY3QgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcblxuICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGxvYzogYXJnVG9rZW4ubG9jLFxuICAgICAgYm9keTogZXhwcmVzc2lvblxuICAgIH07XG5cbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIG1vZGUgYmFja1xuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIG9yZGluYXJ5IGdyb3VwLCB3aGljaCBpcyBlaXRoZXIgYSBzaW5nbGUgbnVjbGV1cyAobGlrZSBcInhcIilcbiAgICogb3IgYW4gZXhwcmVzc2lvbiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKSBvciBhbiBpbXBsaWNpdCBncm91cCwgYSBncm91cFxuICAgKiB0aGF0IHN0YXJ0cyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0XG4gICAqIGdyb3VwIGVuZHMsIG9yIGF0IEVPRi5cbiAgICovXG5cblxuICBwYXJzZUdyb3VwKG5hbWUsIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgdGV4dCA9IGZpcnN0VG9rZW4udGV4dDtcbiAgICB2YXIgcmVzdWx0OyAvLyBUcnkgdG8gcGFyc2UgYW4gb3BlbiBicmFjZSBvciBcXGJlZ2luZ3JvdXBcblxuICAgIGlmICh0ZXh0ID09PSBcIntcIiB8fCB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgdmFyIGdyb3VwRW5kID0gdGV4dCA9PT0gXCJ7XCIgPyBcIn1cIiA6IFwiXFxcXGVuZGdyb3VwXCI7XG4gICAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7IC8vIElmIHdlIGdldCBhIGJyYWNlLCBwYXJzZSBhbiBleHByZXNzaW9uXG5cbiAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGdyb3VwRW5kKTtcbiAgICAgIHZhciBsYXN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgICB0aGlzLmV4cGVjdChncm91cEVuZCk7IC8vIENoZWNrIHRoYXQgd2UgZ290IGEgbWF0Y2hpbmcgY2xvc2luZyBicmFjZVxuXG4gICAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICBib2R5OiBleHByZXNzaW9uLFxuICAgICAgICAvLyBBIGdyb3VwIGZvcm1lZCBieSBcXGJlZ2luZ3JvdXAuLi5cXGVuZGdyb3VwIGlzIGEgc2VtaS1zaW1wbGUgZ3JvdXBcbiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBhZmZlY3Qgc3BhY2luZyBpbiBtYXRoIG1vZGUsIGkuZS4sIGlzIHRyYW5zcGFyZW50LlxuICAgICAgICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkzMC93aGVuLXNob3VsZC1vbmUtXG4gICAgICAgIC8vIHVzZS1iZWdpbmdyb3VwLWluc3RlYWQtb2YtYmdyb3VwXG4gICAgICAgIHNlbWlzaW1wbGU6IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIiB8fCB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBuYW1lLCBwYXJzZSB0aGUgZnVuY3Rpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgbnVjbGV1c1xuICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUpIHx8IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIHRleHRbMF0gPT09IFwiXFxcXFwiICYmICFpbXBsaWNpdENvbW1hbmRzLmhhc093blByb3BlcnR5KHRleHQpKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRocm93T25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2U6IFwiICsgdGV4dCwgZmlyc3RUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzLmZvcm1hdFVuc3VwcG9ydGVkQ21kKHRleHQpO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGb3JtIGxpZ2F0dXJlLWxpa2UgY29tYmluYXRpb25zIG9mIGNoYXJhY3RlcnMgZm9yIHRleHQgbW9kZS5cbiAgICogVGhpcyBpbmNsdWRlcyBpbnB1dHMgbGlrZSBcIi0tXCIsIFwiLS0tXCIsIFwiYGBcIiBhbmQgXCInJ1wiLlxuICAgKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gICAqIGNoYXJhY3RlciBpbiBlYWNoIHZhbHVlIGJ5IGEgc2luZ2xlIHRleHRvcmQgbm9kZSBoYXZpbmcgbXVsdGlwbGVcbiAgICogY2hhcmFjdGVycyBpbiBpdHMgdmFsdWUuICBUaGUgcmVwcmVzZW50YXRpb24gaXMgc3RpbGwgQVNDSUkgc291cmNlLlxuICAgKiBUaGUgZ3JvdXAgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICovXG5cblxuICBmb3JtTGlnYXR1cmVzKGdyb3VwKSB7XG4gICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBhID0gZ3JvdXBbaV07IC8vICRGbG93Rml4TWU6IE5vdCBldmVyeSBub2RlIHR5cGUgaGFzIGEgYHRleHRgIHByb3BlcnR5LlxuXG4gICAgICB2YXIgdiA9IGEudGV4dDtcblxuICAgICAgaWYgKHYgPT09IFwiLVwiICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICBpZiAoaSArIDEgPCBuICYmIGdyb3VwW2kgKyAyXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAzLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMl0pLFxuICAgICAgICAgICAgdGV4dDogXCItLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gdikge1xuICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICB0ZXh0OiB2ICsgdlxuICAgICAgICB9KTtcbiAgICAgICAgbiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBzaW5nbGUgc3ltYm9sIG91dCBvZiB0aGUgc3RyaW5nLiBIZXJlLCB3ZSBoYW5kbGUgc2luZ2xlIGNoYXJhY3RlclxuICAgKiBzeW1ib2xzIGFuZCBzcGVjaWFsIGZ1bmN0aW9ucyBsaWtlIFxcdmVyYi5cbiAgICovXG5cblxuICBwYXJzZVN5bWJvbCgpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgdGV4dCA9IG51Y2xldXMudGV4dDtcblxuICAgIGlmICgvXlxcXFx2ZXJiW15hLXpBLVpdLy50ZXN0KHRleHQpKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIHZhciBhcmcgPSB0ZXh0LnNsaWNlKDUpO1xuICAgICAgdmFyIHN0YXIgPSBhcmcuY2hhckF0KDApID09PSBcIipcIjtcblxuICAgICAgaWYgKHN0YXIpIHtcbiAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEpO1xuICAgICAgfSAvLyBMZXhlcidzIHRva2VuUmVnZXggaXMgY29uc3RydWN0ZWQgdG8gYWx3YXlzIGhhdmUgbWF0Y2hpbmdcbiAgICAgIC8vIGZpcnN0L2xhc3QgY2hhcmFjdGVycy5cblxuXG4gICAgICBpZiAoYXJnLmxlbmd0aCA8IDIgfHwgYXJnLmNoYXJBdCgwKSAhPT0gYXJnLnNsaWNlKC0xKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGFzc2VydGlvbiBmYWlsZWQgLS1cXG4gICAgICAgICAgICAgICAgICAgIHBsZWFzZSByZXBvcnQgd2hhdCBpbnB1dCBjYXVzZWQgdGhpcyBidWdcIik7XG4gICAgICB9XG5cbiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7IC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFyXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidmVyYlwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgYm9keTogYXJnLFxuICAgICAgICBzdGFyXG4gICAgICB9O1xuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYSBzeW1ib2wsIHBvc3NpYmx5IHdpdGggYWNjZW50cy5cbiAgICAvLyBGaXJzdCBleHBhbmQgYW55IGFjY2VudGVkIGJhc2Ugc3ltYm9sIGFjY29yZGluZyB0byB1bmljb2RlU3ltYm9scy5cblxuXG4gICAgaWYgKHVuaWNvZGVTeW1ib2xzLmhhc093blByb3BlcnR5KHRleHRbMF0pICYmICFzeW1ib2xzW3RoaXMubW9kZV1bdGV4dFswXV0pIHtcbiAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgbm90IHN0cmljdCAoWGVUZVgtY29tcGF0aWJsZSkgaW4gbWF0aCBtb2RlLlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0ICYmIHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJ1bmljb2RlVGV4dEluTWF0aE1vZGVcIiwgXCJBY2NlbnRlZCBVbmljb2RlIHRleHQgY2hhcmFjdGVyIFxcXCJcIiArIHRleHRbMF0gKyBcIlxcXCIgdXNlZCBpbiBcIiArIFwibWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdW5pY29kZVN5bWJvbHNbdGV4dFswXV0gKyB0ZXh0LnN1YnN0cigxKTtcbiAgICB9IC8vIFN0cmlwIG9mZiBhbnkgY29tYmluaW5nIGNoYXJhY3RlcnNcblxuXG4gICAgdmFyIG1hdGNoID0gY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG5cbiAgICAgIGlmICh0ZXh0ID09PSAnaScpIHtcbiAgICAgICAgdGV4dCA9ICdcXHUwMTMxJzsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gJ2onKSB7XG4gICAgICAgIHRleHQgPSAnXFx1MDIzNyc7IC8vIGRvdGxlc3MgaiwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9XG4gICAgfSAvLyBSZWNvZ25pemUgYmFzZSBzeW1ib2xcblxuXG4gICAgdmFyIHN5bWJvbDtcblxuICAgIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0pIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09ICdtYXRoJyAmJiBleHRyYUxhdGluLmluZGV4T2YodGV4dCkgPj0gMCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVuaWNvZGVUZXh0SW5NYXRoTW9kZVwiLCBcIkxhdGluLTEvVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwID0gc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdLmdyb3VwO1xuICAgICAgdmFyIGxvYyA9IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpO1xuICAgICAgdmFyIHM7XG5cbiAgICAgIGlmIChBVE9NUy5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICB2YXIgZmFtaWx5ID0gZ3JvdXA7XG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGZhbWlseSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IGdyb3VwLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ29kZXBvaW50KHRleHQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVua25vd25TeW1ib2xcIiwgXCJVbnJlY29nbml6ZWQgVW5pY29kZSBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIlwiICsgKFwiIChcIiArIHRleHQuY2hhckNvZGVBdCgwKSArIFwiKVwiKSwgbnVjbGV1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gbWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsbCBub25tYXRoZW1hdGljYWwgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSByZW5kZXJlZCBhcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgaW4gdGV4dCBtb2RlICh3cmFwcGVkIGluIFxcdGV4dCkgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpdFxuICAgICAgLy8gdGFrZXMgdG8gcmVuZGVyIHRoZW0gaW4gTGFUZVguICBTZXR0aW5nIGBtb2RlOiB0aGlzLm1vZGVgIGlzXG4gICAgICAvLyBhbm90aGVyIG5hdHVyYWwgY2hvaWNlICh0aGUgdXNlciByZXF1ZXN0ZWQgbWF0aCBtb2RlKSwgYnV0XG4gICAgICAvLyB0aGlzIG1ha2VzIGl0IG1vcmUgZGlmZmljdWx0IGZvciBnZXRDaGFyYWN0ZXJNZXRyaWNzKCkgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRob3V0IG1ldHJpY3MgYW5kIHRob3NlIGZvclxuICAgICAgLy8gd2hpY2ggd2Ugd2FudCB0byBzaW11bGF0ZSB0aGUgbGV0dGVyIE0uXG5cblxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhY2NlbnQgPSBtYXRjaFswXVtpXTtcblxuICAgICAgICBpZiAoIXVuaWNvZGVBY2NlbnRzW2FjY2VudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gYWNjZW50ICcgXCIgKyBhY2NlbnQgKyBcIidcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tbWFuZCA9IHVuaWNvZGVBY2NlbnRzW2FjY2VudF1bdGhpcy5tb2RlXSB8fCB1bmljb2RlQWNjZW50c1thY2NlbnRdLnRleHQ7XG5cbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJBY2NlbnQgXCIgKyBhY2NlbnQgKyBcIiB1bnN1cHBvcnRlZCBpbiBcIiArIHRoaXMubW9kZSArIFwiIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgYmFzZTogc3ltYm9sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cblxufVxuUGFyc2VyLmVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kZ3JvdXBcIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiXTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbiBwYXJzZVRyZWUodG9QYXJzZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCEodHlwZW9mIHRvUGFyc2UgPT09ICdzdHJpbmcnIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2FUZVggY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHRvUGFyc2UsIHNldHRpbmdzKTsgLy8gQmxhbmsgb3V0IGFueSBcXGRmQHRhZyB0byBhdm9pZCBzcHVyaW91cyBcIkR1cGxpY2F0ZSBcXHRhZ1wiIGVycm9yc1xuXG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGRmQHRhZ1wiXTtcbiAgdmFyIHRyZWUgPSBwYXJzZXIucGFyc2UoKTsgLy8gUHJldmVudCBhIGNvbG9yIGRlZmluaXRpb24gZnJvbSBwZXJzaXN0aW5nIGJldHdlZW4gY2FsbHMgdG8ga2F0ZXgucmVuZGVyKCkuXG5cbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcY3VycmVudEBjb2xvclwiXTtcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcY29sb3JcIl07IC8vIElmIHRoZSBpbnB1dCB1c2VkIFxcdGFnLCBpdCB3aWxsIHNldCB0aGUgXFxkZkB0YWcgbWFjcm8gdG8gdGhlIHRhZy5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXBhcmF0ZWx5IHBhcnNlIHRoZSB0YWcgYW5kIHdyYXAgdGhlIHRyZWUuXG5cbiAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx0YWcgd29ya3Mgb25seSBpbiBkaXNwbGF5IGVxdWF0aW9uc1wiKTtcbiAgICB9XG5cbiAgICB0cmVlID0gW3tcbiAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgIGJvZHk6IHRyZWUsXG4gICAgICB0YWc6IHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gdHJlZTtcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHBsYWNlIHRoYXQgZXhwcmVzc2lvbiBpbiB0aGUgRE9NIG5vZGVcbiAqIGdpdmVuLlxuICovXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGV4cHJlc3Npb24sIGJhc2VOb2RlLCBvcHRpb25zKSB7XG4gIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgdmFyIG5vZGUgPSByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9Ob2RlKCk7XG4gIGJhc2VOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xufTsgLy8gS2FUZVgncyBzdHlsZXMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBxdWlya3MgbW9kZS4gUHJpbnQgb3V0IGFuIGVycm9yLCBhbmRcbi8vIGRpc2FibGUgcmVuZGVyaW5nLlxuXG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArIFwid2Vic2l0ZSBoYXMgYSBzdWl0YWJsZSBkb2N0eXBlLlwiKTtcblxuICAgIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLlwiKTtcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIHRoYXQuXG4gKi9cblxuXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyhleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBtYXJrdXAgPSByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9NYXJrdXAoKTtcbiAgcmV0dXJuIG1hcmt1cDtcbn07XG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xuXG5cbnZhciBnZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uIGdlbmVyYXRlUGFyc2VUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG4vKipcbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBhIEthVGVYIFBhcnNlRXJyb3IgYW5kIG9wdGlvbnMudGhyb3dPbkVycm9yIGlzIGZhbHNlLFxuICogcmVuZGVycyB0aGUgaW52YWxpZCBMYVRlWCBhcyBhIHNwYW4gd2l0aCBob3ZlciB0aXRsZSBnaXZpbmcgdGhlIEthVGVYXG4gKiBlcnJvciBtZXNzYWdlLiAgT3RoZXJ3aXNlLCBzaW1wbHkgdGhyb3dzIHRoZSBlcnJvci5cbiAqL1xuXG5cbnZhciByZW5kZXJFcnJvciA9IGZ1bmN0aW9uIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRocm93T25FcnJvciB8fCAhKGVycm9yIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXgtZXJyb3JcIl0sIFtuZXcgU3ltYm9sTm9kZShleHByZXNzaW9uKV0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6XCIgKyBvcHRpb25zLmVycm9yQ29sb3IpO1xuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciBhZHZhbmNlZFxuICogdXNlIGNhc2VzIChsaWtlIHJlbmRlcmluZyB0byBjdXN0b20gb3V0cHV0KS5cbiAqL1xuXG5cbnZhciByZW5kZXJUb0RvbVRyZWUgPSBmdW5jdGlvbiByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZSwgd2l0aCBqdXN0IEhUTUwgKG5vIE1hdGhNTCkuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG52YXIgcmVuZGVyVG9IVE1MVHJlZSA9IGZ1bmN0aW9uIHJlbmRlclRvSFRNTFRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkSFRNTFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9XG59O1xuXG52YXIga2F0ZXggPSB7XG4gIC8qKlxuICAgKiBDdXJyZW50IEthVGVYIHZlcnNpb25cbiAgICovXG4gIHZlcnNpb246IFwiMC4xNS42XCIsXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgY29tYmluYXRpb24sIGFuZCBhZGRzXG4gICAqIGl0IGFzIGEgY2hpbGQgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZS5cbiAgICovXG4gIHJlbmRlcixcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MK01hdGhNTCBjb21iaW5hdGlvbiBzdHJpbmcsXG4gICAqIGZvciBzZW5kaW5nIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICByZW5kZXJUb1N0cmluZyxcblxuICAvKipcbiAgICogS2FUZVggZXJyb3IsIHVzdWFsbHkgZHVyaW5nIHBhcnNpbmcuXG4gICAqL1xuICBQYXJzZUVycm9yLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hlbWEgb2YgU2V0dGluZ3NcbiAgICovXG4gIFNFVFRJTkdTX1NDSEVNQSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIEthVGVYJ3MgaW50ZXJuYWwgcGFyc2UgdHJlZSBzdHJ1Y3R1cmUsXG4gICAqIHdpdGhvdXQgcmVuZGVyaW5nIHRvIEhUTUwgb3IgTWF0aE1MLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcGFyc2U6IGdlbmVyYXRlUGFyc2VUcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvRG9tVHJlZTogcmVuZGVyVG9Eb21UcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwgaW50ZXJuYWwgRE9NIHRyZWUgcmVwcmVzZW50YXRpb24sXG4gICAqIHdpdGhvdXQgTWF0aE1MIGFuZCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvSFRNTFRyZWU6IHJlbmRlclRvSFRNTFRyZWUsXG5cbiAgLyoqXG4gICAqIGV4dGVuZHMgaW50ZXJuYWwgZm9udCBtZXRyaWNzIG9iamVjdCB3aXRoIGEgbmV3IG9iamVjdFxuICAgKiBlYWNoIGtleSBpbiB0aGUgbmV3IG9iamVjdCByZXByZXNlbnRzIGEgZm9udCBuYW1lXG4gICovXG4gIF9fc2V0Rm9udE1ldHJpY3M6IHNldEZvbnRNZXRyaWNzLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IHN5bWJvbCB0byBidWlsdGluIHN5bWJvbHMgdGFibGVcbiAgICovXG4gIF9fZGVmaW5lU3ltYm9sOiBkZWZpbmVTeW1ib2wsXG5cbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgbWFjcm8gdG8gYnVpbHRpbiBtYWNybyBsaXN0XG4gICAqL1xuICBfX2RlZmluZU1hY3JvOiBkZWZpbmVNYWNybyxcblxuICAvKipcbiAgICogRXhwb3NlIHRoZSBkb20gdHJlZSBub2RlIHR5cGVzLCB3aGljaCBjYW4gYmUgdXNlZnVsIGZvciB0eXBlIGNoZWNraW5nIG5vZGVzLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fZG9tVHJlZToge1xuICAgIFNwYW4sXG4gICAgQW5jaG9yLFxuICAgIFN5bWJvbE5vZGUsXG4gICAgU3ZnTm9kZSxcbiAgICBQYXRoTm9kZSxcbiAgICBMaW5lTm9kZVxuICB9XG59O1xuXG5leHBvcnQgeyBrYXRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/katex/dist/katex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-notion-x/build/third-party/equation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-notion-x/build/third-party/equation.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Equation: function() { return /* binding */ Equation; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _matejmazur_react_katex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @matejmazur/react-katex */ \"(app-pages-browser)/./node_modules/@matejmazur/react-katex/dist/react-katex.m.js\");\n/* harmony import */ var notion_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! notion-utils */ \"(app-pages-browser)/./node_modules/notion-utils/build/index.js\");\n/* harmony import */ var notion_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! notion-utils */ \"(app-pages-browser)/./node_modules/is-url-superb/index.js\");\n/* harmony import */ var react_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-image */ \"(app-pages-browser)/./node_modules/react-image/umd/index.js\");\n/* harmony import */ var react_lazy_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-lazy-images */ \"(app-pages-browser)/./node_modules/react-notion-x/node_modules/react-lazy-images/dist/react-lazy-images.es.js\");\n/* harmony import */ var react_hotkeys_hook__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-hotkeys-hook */ \"(app-pages-browser)/./node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js\");\n/* harmony import */ var react_fast_compare__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-fast-compare */ \"(app-pages-browser)/./node_modules/react-fast-compare/index.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// ../../node_modules/lodash.throttle/index.js\nvar require_lodash = __commonJS({\n  \"../../node_modules/lodash.throttle/index.js\"(exports, module) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function throttle2(func, wait, options) {\n      var leading = true, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = \"leading\" in options ? !!options.leading : leading;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        \"leading\": leading,\n        \"maxWait\": wait,\n        \"trailing\": trailing\n      });\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module.exports = throttle2;\n  }\n});\n\n// src/third-party/equation.tsx\n\n\n\n\n// src/context.tsx\n\n\n// src/components/asset-wrapper.tsx\n\n\n\n// src/utils.ts\n\n\n// src/map-image-url.ts\nvar defaultMapImageUrl = (url, block) => {\n  if (!url) {\n    return null;\n  }\n  if (url.startsWith(\"data:\")) {\n    return url;\n  }\n  if (url.startsWith(\"https://images.unsplash.com\")) {\n    return url;\n  }\n  try {\n    const u = new URL(url);\n    if (u.pathname.startsWith(\"/secure.notion-static.com\") && u.hostname.endsWith(\".amazonaws.com\")) {\n      if (u.searchParams.has(\"X-Amz-Credential\") && u.searchParams.has(\"X-Amz-Signature\") && u.searchParams.has(\"X-Amz-Algorithm\")) {\n        return url;\n      }\n    }\n  } catch (e) {\n  }\n  if (url.startsWith(\"/images\")) {\n    url = `https://www.notion.so${url}`;\n  }\n  url = `https://www.notion.so${url.startsWith(\"/image\") ? url : `/image/${encodeURIComponent(url)}`}`;\n  const notionImageUrlV2 = new URL(url);\n  let table = block.parent_table === \"space\" ? \"block\" : block.parent_table;\n  if (table === \"collection\" || table === \"team\") {\n    table = \"block\";\n  }\n  notionImageUrlV2.searchParams.set(\"table\", table);\n  notionImageUrlV2.searchParams.set(\"id\", block.id);\n  notionImageUrlV2.searchParams.set(\"cache\", \"v2\");\n  url = notionImageUrlV2.toString();\n  return url;\n};\n\n// src/map-page-url.ts\nvar defaultMapPageUrl = (rootPageId) => (pageId) => {\n  pageId = (pageId || \"\").replace(/-/g, \"\");\n  if (rootPageId && pageId === rootPageId) {\n    return \"/\";\n  } else {\n    return `/${pageId}`;\n  }\n};\n\n// src/utils.ts\nvar cs = (...classes) => classes.filter((a) => !!a).join(\" \");\nvar getHashFragmentValue = (url) => {\n  return url.includes(\"#\") ? url.replace(/^.+(#.+)$/, \"$1\") : \"\";\n};\nvar isBrowser = typeof window !== \"undefined\";\nvar youtubeDomains = /* @__PURE__ */ new Set([\n  \"youtu.be\",\n  \"youtube.com\",\n  \"www.youtube.com\",\n  \"youtube-nocookie.com\",\n  \"www.youtube-nocookie.com\"\n]);\nvar getYoutubeId = (url) => {\n  try {\n    const { hostname } = new URL(url);\n    if (!youtubeDomains.has(hostname)) {\n      return null;\n    }\n    const regExp = /^.*(youtu\\.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/i;\n    const match = url.match(regExp);\n    if (match && match[2].length == 11) {\n      return match[2];\n    }\n  } catch (e) {\n  }\n  return null;\n};\n\n// src/components/eoi.tsx\n\n\n// src/icons/type-github.tsx\n\nfunction SvgTypeGitHub(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadValues({\n    viewBox: \"0 0 260 260\"\n  }, props), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M128.00106,0 C57.3172926,0 0,57.3066942 0,128.00106 C0,184.555281 36.6761997,232.535542 87.534937,249.460899 C93.9320223,250.645779 96.280588,246.684165 96.280588,243.303333 C96.280588,240.251045 96.1618878,230.167899 96.106777,219.472176 C60.4967585,227.215235 52.9826207,204.369712 52.9826207,204.369712 C47.1599584,189.574598 38.770408,185.640538 38.770408,185.640538 C27.1568785,177.696113 39.6458206,177.859325 39.6458206,177.859325 C52.4993419,178.762293 59.267365,191.04987 59.267365,191.04987 C70.6837675,210.618423 89.2115753,204.961093 96.5158685,201.690482 C97.6647155,193.417512 100.981959,187.77078 104.642583,184.574357 C76.211799,181.33766 46.324819,170.362144 46.324819,121.315702 C46.324819,107.340889 51.3250588,95.9223682 59.5132437,86.9583937 C58.1842268,83.7344152 53.8029229,70.715562 60.7532354,53.0843636 C60.7532354,53.0843636 71.5019501,49.6441813 95.9626412,66.2049595 C106.172967,63.368876 117.123047,61.9465949 128.00106,61.8978432 C138.879073,61.9465949 149.837632,63.368876 160.067033,66.2049595 C184.49805,49.6441813 195.231926,53.0843636 195.231926,53.0843636 C202.199197,70.715562 197.815773,83.7344152 196.486756,86.9583937 C204.694018,95.9223682 209.660343,107.340889 209.660343,121.315702 C209.660343,170.478725 179.716133,181.303747 151.213281,184.472614 C155.80443,188.444828 159.895342,196.234518 159.895342,208.176593 C159.895342,225.303317 159.746968,239.087361 159.746968,243.303333 C159.746968,246.709601 162.05102,250.70089 168.53925,249.443941 C219.370432,232.499507 256,184.536204 256,128.00106 C256,57.3066942 198.691187,0 128.00106,0 Z M47.9405593,182.340212 C47.6586465,182.976105 46.6581745,183.166873 45.7467277,182.730227 C44.8183235,182.312656 44.2968914,181.445722 44.5978808,180.80771 C44.8734344,180.152739 45.876026,179.97045 46.8023103,180.409216 C47.7328342,180.826786 48.2627451,181.702199 47.9405593,182.340212 Z M54.2367892,187.958254 C53.6263318,188.524199 52.4329723,188.261363 51.6232682,187.366874 C50.7860088,186.474504 50.6291553,185.281144 51.2480912,184.70672 C51.8776254,184.140775 53.0349512,184.405731 53.8743302,185.298101 C54.7115892,186.201069 54.8748019,187.38595 54.2367892,187.958254 Z M58.5562413,195.146347 C57.7719732,195.691096 56.4895886,195.180261 55.6968417,194.042013 C54.9125733,192.903764 54.9125733,191.538713 55.713799,190.991845 C56.5086651,190.444977 57.7719732,190.936735 58.5753181,192.066505 C59.3574669,193.22383 59.3574669,194.58888 58.5562413,195.146347 Z M65.8613592,203.471174 C65.1597571,204.244846 63.6654083,204.03712 62.5716717,202.981538 C61.4524999,201.94927 61.1409122,200.484596 61.8446341,199.710926 C62.5547146,198.935137 64.0575422,199.15346 65.1597571,200.200564 C66.2704506,201.230712 66.6095936,202.705984 65.8613592,203.471174 Z M75.3025151,206.281542 C74.9930474,207.284134 73.553809,207.739857 72.1039724,207.313809 C70.6562556,206.875043 69.7087748,205.700761 70.0012857,204.687571 C70.302275,203.678621 71.7478721,203.20382 73.2083069,203.659543 C74.6539041,204.09619 75.6035048,205.261994 75.3025151,206.281542 Z M86.046947,207.473627 C86.0829806,208.529209 84.8535871,209.404622 83.3316829,209.4237 C81.8013,209.457614 80.563428,208.603398 80.5464708,207.564772 C80.5464708,206.498591 81.7483088,205.631657 83.2786917,205.606221 C84.8005962,205.576546 86.046947,206.424403 86.046947,207.473627 Z M96.6021471,207.069023 C96.7844366,208.099171 95.7267341,209.156872 94.215428,209.438785 C92.7295577,209.710099 91.3539086,209.074206 91.1652603,208.052538 C90.9808515,206.996955 92.0576306,205.939253 93.5413813,205.66582 C95.054807,205.402984 96.4092596,206.021919 96.6021471,207.069023 Z\",\n    fill: \"#161614\"\n  })));\n}\nvar type_github_default = SvgTypeGitHub;\n\n// src/components/eoi.tsx\nvar EOI = ({ block, inline, className }) => {\n  var _a, _b, _c;\n  const { components } = useNotionContext();\n  const { original_url, attributes, domain } = (block == null ? void 0 : block.format) || {};\n  if (!original_url || !attributes) {\n    return null;\n  }\n  const title = (_a = attributes.find((attr) => attr.id === \"title\")) == null ? void 0 : _a.values[0];\n  let owner = (_b = attributes.find((attr) => attr.id === \"owner\")) == null ? void 0 : _b.values[0];\n  const lastUpdatedAt = (_c = attributes.find((attr) => attr.id === \"updated_at\")) == null ? void 0 : _c.values[0];\n  const lastUpdated = lastUpdatedAt ? (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.formatNotionDateTime)(lastUpdatedAt) : null;\n  let externalImage;\n  switch (domain) {\n    case \"github.com\":\n      externalImage = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(type_github_default, null);\n      if (owner) {\n        const parts = owner.split(\"/\");\n        owner = parts[parts.length - 1];\n      }\n      break;\n    default:\n      if (true) {\n        console.log(\n          `Unsupported external_object_instance domain \"${domain}\"`,\n          JSON.stringify(block, null, 2)\n        );\n      }\n      return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Link, {\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    href: original_url,\n    className: cs(\n      \"notion-external\",\n      inline ? \"notion-external-mention\" : \"notion-external-block notion-row\",\n      className\n    )\n  }, externalImage && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-external-image\"\n  }, externalImage), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-external-description\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-external-title\"\n  }, title), (owner || lastUpdated) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-external-subtitle\"\n  }, owner && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, owner), owner && lastUpdated && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \" \\u2022 \"), lastUpdated && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \"Updated \", lastUpdated))));\n};\n\n// src/components/text.tsx\n\n\n\n// src/components/graceful-image.tsx\n\n\nvar GracefulImage = (props) => {\n  if (isBrowser) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_image__WEBPACK_IMPORTED_MODULE_3__.Img, __spreadValues({}, props));\n  } else {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", __spreadValues({}, props));\n  }\n};\n\n// src/components/page-title.tsx\n\n\n\n// src/components/page-icon.tsx\n\n\n\n// src/icons/default-page-icon.tsx\n\nvar DefaultPageIcon = (props) => {\n  const _a = props, { className } = _a, rest = __objRest(_a, [\"className\"]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadProps(__spreadValues({\n    className\n  }, rest), {\n    viewBox: \"0 0 30 30\",\n    width: \"16\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z\"\n  }));\n};\n\n// src/components/lazy-image.tsx\n\n\n\nvar LazyImage = (_a) => {\n  var _b = _a, {\n    src,\n    alt,\n    className,\n    style,\n    zoomable = false,\n    priority = false,\n    height\n  } = _b, rest = __objRest(_b, [\n    \"src\",\n    \"alt\",\n    \"className\",\n    \"style\",\n    \"zoomable\",\n    \"priority\",\n    \"height\"\n  ]);\n  var _a2, _b2, _c;\n  const { recordMap, zoom, previewImages, forceCustomImages, components } = useNotionContext();\n  const zoomRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(zoom ? zoom.clone() : null);\n  const previewImage = previewImages ? (_c = (_a2 = recordMap == null ? void 0 : recordMap.preview_images) == null ? void 0 : _a2[src]) != null ? _c : (_b2 = recordMap == null ? void 0 : recordMap.preview_images) == null ? void 0 : _b2[(0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeUrl)(src)] : null;\n  const onLoad = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (e) => {\n      if (zoomable && (e.target.src || e.target.srcset)) {\n        if (zoomRef.current) {\n          ;\n          zoomRef.current.attach(e.target);\n        }\n      }\n    },\n    [zoomRef, zoomable]\n  );\n  const attachZoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (image) => {\n      if (zoomRef.current && image) {\n        ;\n        zoomRef.current.attach(image);\n      }\n    },\n    [zoomRef]\n  );\n  const attachZoomRef = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => zoomable ? attachZoom : void 0,\n    [zoomable, attachZoom]\n  );\n  if (previewImage) {\n    const aspectRatio = previewImage.originalHeight / previewImage.originalWidth;\n    if (components.Image) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Image, {\n        src,\n        alt,\n        style,\n        className,\n        width: previewImage.originalWidth,\n        height: previewImage.originalHeight,\n        blurDataURL: previewImage.dataURIBase64,\n        placeholder: \"blur\",\n        priority,\n        onLoad\n      });\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_lazy_images__WEBPACK_IMPORTED_MODULE_4__.LazyImageFull, __spreadProps(__spreadValues({\n      src\n    }, rest), {\n      experimentalDecode: true\n    }), ({ imageState, ref }) => {\n      const isLoaded = imageState === react_lazy_images__WEBPACK_IMPORTED_MODULE_4__.ImageState.LoadSuccess;\n      const wrapperStyle = {\n        width: \"100%\"\n      };\n      const imgStyle = {};\n      if (height) {\n        wrapperStyle.height = height;\n      } else {\n        imgStyle.position = \"absolute\";\n        wrapperStyle.paddingBottom = `${aspectRatio * 100}%`;\n      }\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: cs(\n          \"lazy-image-wrapper\",\n          isLoaded && \"lazy-image-loaded\",\n          className\n        ),\n        style: wrapperStyle\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: \"lazy-image-preview\",\n        src: previewImage.dataURIBase64,\n        alt,\n        ref,\n        style,\n        decoding: \"async\"\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        className: \"lazy-image-real\",\n        src,\n        alt,\n        ref: attachZoomRef,\n        style: __spreadValues(__spreadValues({}, style), imgStyle),\n        width: previewImage.originalWidth,\n        height: previewImage.originalHeight,\n        decoding: \"async\",\n        loading: \"lazy\"\n      }));\n    });\n  } else {\n    if (components.Image && forceCustomImages) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Image, {\n        src,\n        alt,\n        className,\n        style,\n        width: null,\n        height: height || null,\n        priority,\n        onLoad\n      });\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", __spreadValues({\n      className,\n      style,\n      src,\n      alt,\n      ref: attachZoomRef,\n      loading: \"lazy\",\n      decoding: \"async\"\n    }, rest));\n  }\n};\n\n// src/components/page-icon.tsx\nvar isIconBlock = (value) => {\n  return value.type === \"page\" || value.type === \"callout\" || value.type === \"collection_view\" || value.type === \"collection_view_page\";\n};\nvar PageIconImpl = ({\n  block,\n  className,\n  inline = true,\n  hideDefaultIcon = false,\n  defaultIcon\n}) => {\n  var _a;\n  const { mapImageUrl, recordMap, darkMode } = useNotionContext();\n  let isImage = false;\n  let content = null;\n  if (isIconBlock(block)) {\n    const icon = ((_a = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockIcon)(block, recordMap)) == null ? void 0 : _a.trim()) || defaultIcon;\n    const title = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockTitle)(block, recordMap);\n    if (icon && (0,notion_utils__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(icon)) {\n      const url = mapImageUrl(icon, block);\n      isImage = true;\n      content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LazyImage, {\n        src: url,\n        alt: title || \"page icon\",\n        className: cs(className, \"notion-page-icon\")\n      });\n    } else if (icon && icon.startsWith(\"/icons/\")) {\n      const url = \"https://www.notion.so\" + icon + \"?mode=\" + (darkMode ? \"dark\" : \"light\");\n      content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LazyImage, {\n        src: url,\n        alt: title || \"page icon\",\n        className: cs(className, \"notion-page-icon\")\n      });\n    } else if (!icon) {\n      if (!hideDefaultIcon) {\n        isImage = true;\n        content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultPageIcon, {\n          className: cs(className, \"notion-page-icon\"),\n          alt: title ? title : \"page icon\"\n        });\n      }\n    } else {\n      isImage = false;\n      content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: cs(className, \"notion-page-icon\"),\n        role: \"img\",\n        \"aria-label\": icon\n      }, icon);\n    }\n  }\n  if (!content) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: cs(\n      inline ? \"notion-page-icon-inline\" : \"notion-page-icon-hero\",\n      isImage ? \"notion-page-icon-image\" : \"notion-page-icon-span\"\n    )\n  }, content);\n};\nvar PageIcon = react__WEBPACK_IMPORTED_MODULE_0__.memo(PageIconImpl);\n\n// src/components/page-title.tsx\nvar PageTitleImpl = (_a) => {\n  var _b = _a, { block, className, defaultIcon } = _b, rest = __objRest(_b, [\"block\", \"className\", \"defaultIcon\"]);\n  var _a2, _b2;\n  const { recordMap } = useNotionContext();\n  if (!block)\n    return null;\n  if (block.type === \"collection_view_page\" || block.type === \"collection_view\") {\n    const title = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockTitle)(block, recordMap);\n    if (!title) {\n      return null;\n    }\n    const titleDecoration = [[title]];\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", __spreadValues({\n      className: cs(\"notion-page-title\", className)\n    }, rest), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageIcon, {\n      block,\n      defaultIcon,\n      className: \"notion-page-title-icon\"\n    }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"notion-page-title-text\"\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Text, {\n      value: titleDecoration,\n      block\n    })));\n  }\n  if (!((_a2 = block.properties) == null ? void 0 : _a2.title)) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", __spreadValues({\n    className: cs(\"notion-page-title\", className)\n  }, rest), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageIcon, {\n    block,\n    defaultIcon,\n    className: \"notion-page-title-icon\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    className: \"notion-page-title-text\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Text, {\n    value: (_b2 = block.properties) == null ? void 0 : _b2.title,\n    block\n  })));\n};\nvar PageTitle = react__WEBPACK_IMPORTED_MODULE_0__.memo(PageTitleImpl);\n\n// src/components/text.tsx\nvar Text = ({ value, block, linkProps, linkProtocol }) => {\n  const { components, recordMap, mapPageUrl, mapImageUrl, rootDomain } = useNotionContext();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, value == null ? void 0 : value.map(([text, decorations], index) => {\n    if (!decorations) {\n      if (text === \",\") {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n          key: index,\n          style: { padding: \"0.5em\" }\n        });\n      } else {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n          key: index\n        }, text);\n      }\n    }\n    const formatted = decorations.reduce(\n      (element, decorator) => {\n        var _a, _b, _c, _d, _e;\n        switch (decorator[0]) {\n          case \"p\": {\n            const blockId = decorator[1];\n            const linkedBlock = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;\n            if (!linkedBlock) {\n              console.log('\"p\" missing block', blockId);\n              return null;\n            }\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.PageLink, {\n              className: \"notion-link\",\n              href: mapPageUrl(blockId)\n            }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageTitle, {\n              block: linkedBlock\n            }));\n          }\n          case \"\\u2023\": {\n            const linkType = decorator[1][0];\n            const id = decorator[1][1];\n            switch (linkType) {\n              case \"u\": {\n                const user = (_b = recordMap.notion_user[id]) == null ? void 0 : _b.value;\n                if (!user) {\n                  console.log('\"\\u2023\" missing user', id);\n                  return null;\n                }\n                const name = [user.given_name, user.family_name].filter(Boolean).join(\" \");\n                return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GracefulImage, {\n                  className: \"notion-user\",\n                  src: mapImageUrl(user.profile_photo, block),\n                  alt: name\n                });\n              }\n              default: {\n                const linkedBlock = (_c = recordMap.block[id]) == null ? void 0 : _c.value;\n                if (!linkedBlock) {\n                  console.log('\"\\u2023\" missing block', linkType, id);\n                  return null;\n                }\n                return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.PageLink, __spreadProps(__spreadValues({\n                  className: \"notion-link\",\n                  href: mapPageUrl(id)\n                }, linkProps), {\n                  target: \"_blank\",\n                  rel: \"noopener noreferrer\"\n                }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageTitle, {\n                  block: linkedBlock\n                }));\n              }\n            }\n          }\n          case \"h\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n              className: `notion-${decorator[1]}`\n            }, element);\n          case \"c\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n              className: \"notion-inline-code\"\n            }, element);\n          case \"b\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"b\", null, element);\n          case \"i\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"em\", null, element);\n          case \"s\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"s\", null, element);\n          case \"_\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n              className: \"notion-inline-underscore\"\n            }, element);\n          case \"e\":\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Equation, {\n              math: decorator[1],\n              inline: true\n            });\n          case \"m\":\n            return element;\n          case \"a\": {\n            const v = decorator[1];\n            const pathname = v.substr(1);\n            const id = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.parsePageId)(pathname, { uuid: true });\n            if ((v[0] === \"/\" || v.includes(rootDomain)) && id) {\n              const href = v.includes(rootDomain) ? v : `${mapPageUrl(id)}${getHashFragmentValue(v)}`;\n              return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.PageLink, __spreadValues({\n                className: \"notion-link\",\n                href\n              }, linkProps), element);\n            } else {\n              return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Link, __spreadValues({\n                className: \"notion-link\",\n                href: linkProtocol ? `${linkProtocol}:${decorator[1]}` : decorator[1]\n              }, linkProps), element);\n            }\n          }\n          case \"d\": {\n            const v = decorator[1];\n            const type = v == null ? void 0 : v.type;\n            if (type === \"date\") {\n              const startDate = v.start_date;\n              return (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(startDate);\n            } else if (type === \"daterange\") {\n              const startDate = v.start_date;\n              const endDate = v.end_date;\n              return `${(0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(startDate)} \\u2192 ${(0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(endDate)}`;\n            } else {\n              return element;\n            }\n          }\n          case \"u\": {\n            const userId = decorator[1];\n            const user = (_d = recordMap.notion_user[userId]) == null ? void 0 : _d.value;\n            if (!user) {\n              console.log(\"missing user\", userId);\n              return null;\n            }\n            const name = [user.given_name, user.family_name].filter(Boolean).join(\" \");\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GracefulImage, {\n              className: \"notion-user\",\n              src: mapImageUrl(user.profile_photo, block),\n              alt: name\n            });\n          }\n          case \"eoi\": {\n            const blockId = decorator[1];\n            const externalObjectInstance = (_e = recordMap.block[blockId]) == null ? void 0 : _e.value;\n            return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EOI, {\n              block: externalObjectInstance,\n              inline: true\n            });\n          }\n          default:\n            if (true) {\n              console.log(\"unsupported text format\", decorator);\n            }\n            return element;\n        }\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, text)\n    );\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      key: index\n    }, formatted);\n  }));\n};\n\n// src/components/header.tsx\n\n\n\n\n// src/icons/search-icon.tsx\n\nvar SearchIcon = (props) => {\n  const _a = props, { className } = _a, rest = __objRest(_a, [\"className\"]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadValues({\n    className: cs(\"notion-icon\", className),\n    viewBox: \"0 0 17 17\"\n  }, rest), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M6.78027 13.6729C8.24805 13.6729 9.60156 13.1982 10.709 12.4072L14.875 16.5732C15.0684 16.7666 15.3232 16.8633 15.5957 16.8633C16.167 16.8633 16.5713 16.4238 16.5713 15.8613C16.5713 15.5977 16.4834 15.3516 16.29 15.1582L12.1504 11.0098C13.0205 9.86719 13.5391 8.45215 13.5391 6.91406C13.5391 3.19629 10.498 0.155273 6.78027 0.155273C3.0625 0.155273 0.0214844 3.19629 0.0214844 6.91406C0.0214844 10.6318 3.0625 13.6729 6.78027 13.6729ZM6.78027 12.2139C3.87988 12.2139 1.48047 9.81445 1.48047 6.91406C1.48047 4.01367 3.87988 1.61426 6.78027 1.61426C9.68066 1.61426 12.0801 4.01367 12.0801 6.91406C12.0801 9.81445 9.68066 12.2139 6.78027 12.2139Z\"\n  }));\n};\n\n// src/components/search-dialog.tsx\nvar import_lodash = __toESM(require_lodash(), 1);\n\n\n\n// src/icons/clear-icon.tsx\n\nvar ClearIcon = (props) => {\n  const _a = props, { className } = _a, rest = __objRest(_a, [\"className\"]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadProps(__spreadValues({\n    className: cs(\"notion-icon\", className)\n  }, rest), {\n    viewBox: \"0 0 30 30\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M15,0C6.716,0,0,6.716,0,15s6.716,15,15,15s15-6.716,15-15S23.284,0,15,0z M22,20.6L20.6,22L15,16.4L9.4,22L8,20.6l5.6-5.6 L8,9.4L9.4,8l5.6,5.6L20.6,8L22,9.4L16.4,15L22,20.6z\"\n  }));\n};\n\n// src/icons/loading-icon.tsx\n\nvar LoadingIcon = (props) => {\n  const _a = props, { className } = _a, rest = __objRest(_a, [\"className\"]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadProps(__spreadValues({\n    className: cs(\"notion-icon\", className)\n  }, rest), {\n    viewBox: \"0 0 24 24\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n    x1: \"28.1542969%\",\n    y1: \"63.7402344%\",\n    x2: \"74.6289062%\",\n    y2: \"17.7832031%\",\n    id: \"linearGradient-1\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n    stopColor: \"rgba(164, 164, 164, 1)\",\n    offset: \"0%\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n    stopColor: \"rgba(164, 164, 164, 0)\",\n    stopOpacity: \"0\",\n    offset: \"100%\"\n  }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    id: \"Page-1\",\n    stroke: \"none\",\n    strokeWidth: \"1\",\n    fill: \"none\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    transform: \"translate(-236.000000, -286.000000)\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    transform: \"translate(238.000000, 286.000000)\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    id: \"Oval-2\",\n    stroke: \"url(#linearGradient-1)\",\n    strokeWidth: \"4\",\n    cx: \"10\",\n    cy: \"12\",\n    r: \"10\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M10,2 C4.4771525,2 0,6.4771525 0,12\",\n    id: \"Oval-2\",\n    stroke: \"rgba(164, 164, 164, 1)\",\n    strokeWidth: \"4\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    id: \"Rectangle-1\",\n    fill: \"rgba(164, 164, 164, 1)\",\n    x: \"8\",\n    y: \"0\",\n    width: \"4\",\n    height: \"4\",\n    rx: \"8\"\n  })))));\n};\n\n// src/components/search-dialog.tsx\nvar SearchDialog = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isLoading: false,\n      query: \"\",\n      searchResult: null,\n      searchError: null\n    };\n    this._onAfterOpen = () => {\n      if (this._inputRef.current) {\n        this._inputRef.current.focus();\n      }\n    };\n    this._onChangeQuery = (e) => {\n      const query = e.target.value;\n      this.setState({ query });\n      if (!query.trim()) {\n        this.setState({ isLoading: false, searchResult: null, searchError: null });\n        return;\n      } else {\n        this._search();\n      }\n    };\n    this._onClearQuery = () => {\n      this._onChangeQuery({ target: { value: \"\" } });\n    };\n    this._warmupSearch = () => __async(this, null, function* () {\n      const { searchNotion, rootBlockId } = this.props;\n      yield searchNotion({\n        query: \"\",\n        ancestorId: rootBlockId\n      });\n    });\n    this._searchImpl = () => __async(this, null, function* () {\n      const { searchNotion, rootBlockId } = this.props;\n      const { query } = this.state;\n      if (!query.trim()) {\n        this.setState({ isLoading: false, searchResult: null, searchError: null });\n        return;\n      }\n      this.setState({ isLoading: true });\n      const result = yield searchNotion({\n        query,\n        ancestorId: rootBlockId\n      });\n      console.log(\"search\", query, result);\n      let searchResult = null;\n      let searchError = null;\n      if (result.error || result.errorId) {\n        searchError = result;\n      } else {\n        searchResult = __spreadValues({}, result);\n        const results = searchResult.results.map((result2) => {\n          var _a, _b;\n          const block = (_a = searchResult.recordMap.block[result2.id]) == null ? void 0 : _a.value;\n          if (!block)\n            return;\n          const title = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockTitle)(block, searchResult.recordMap);\n          if (!title) {\n            return;\n          }\n          result2.title = title;\n          result2.block = block;\n          result2.recordMap = searchResult.recordMap;\n          result2.page = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockParentPage)(block, searchResult.recordMap, {\n            inclusive: true\n          }) || block;\n          if (!result2.page.id) {\n            return;\n          }\n          if ((_b = result2.highlight) == null ? void 0 : _b.text) {\n            result2.highlight.html = result2.highlight.text.replace(/<gzkNfoUU>/gi, \"<b>\").replace(/<\\/gzkNfoUU>/gi, \"</b>\");\n          }\n          return result2;\n        }).filter(Boolean);\n        const searchResultsMap = results.reduce(\n          (map, result2) => __spreadProps(__spreadValues({}, map), {\n            [result2.page.id]: result2\n          }),\n          {}\n        );\n        searchResult.results = Object.values(searchResultsMap);\n      }\n      if (this.state.query === query) {\n        this.setState({ isLoading: false, searchResult, searchError });\n      }\n    });\n    this._inputRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n  }\n  componentDidMount() {\n    this._search = (0, import_lodash.default)(this._searchImpl.bind(this), 1e3);\n    this._warmupSearch();\n  }\n  render() {\n    const { isOpen, onClose } = this.props;\n    const { isLoading, query, searchResult, searchError } = this.state;\n    const hasQuery = !!query.trim();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NotionContextConsumer, null, (ctx2) => {\n      const { components, defaultPageIcon, mapPageUrl } = ctx2;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Modal, {\n        isOpen,\n        contentLabel: \"Search\",\n        className: \"notion-search\",\n        overlayClassName: \"notion-search-overlay\",\n        onRequestClose: onClose,\n        onAfterOpen: this._onAfterOpen\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"quickFindMenu\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"searchBar\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"inlineIcon\"\n      }, isLoading ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LoadingIcon, {\n        className: \"loadingIcon\"\n      }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchIcon, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", {\n        className: \"searchInput\",\n        placeholder: \"Search\",\n        value: query,\n        ref: this._inputRef,\n        onChange: this._onChangeQuery\n      }), query && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        role: \"button\",\n        className: \"clearButton\",\n        onClick: this._onClearQuery\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClearIcon, {\n        className: \"clearIcon\"\n      }))), hasQuery && searchResult && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, searchResult.results.length ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NotionContextProvider, __spreadProps(__spreadValues({}, ctx2), {\n        recordMap: searchResult.recordMap\n      }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"resultsPane\"\n      }, searchResult.results.map((result) => {\n        var _a;\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.PageLink, {\n          key: result.id,\n          className: cs(\"result\", \"notion-page-link\"),\n          href: mapPageUrl(\n            result.page.id,\n            searchResult.recordMap\n          )\n        }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageTitle, {\n          block: result.page,\n          defaultIcon: defaultPageIcon\n        }), ((_a = result.highlight) == null ? void 0 : _a.html) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n          className: \"notion-search-result-highlight\",\n          dangerouslySetInnerHTML: {\n            __html: result.highlight.html\n          }\n        }));\n      })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"footer\", {\n        className: \"resultsFooter\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        className: \"resultsCount\"\n      }, searchResult.total), searchResult.total === 1 ? \" result\" : \" results\"))) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"noResultsPane\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"noResults\"\n      }, \"No results\"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"noResultsDetail\"\n      }, \"Try different search terms\"))), hasQuery && !searchResult && searchError && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"noResultsPane\"\n      }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"noResults\"\n      }, \"Search error\"))));\n    });\n  }\n};\n\n// src/components/header.tsx\nvar Header = ({ block }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"header\", {\n    className: \"notion-header\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-nav-header\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Breadcrumbs, {\n    block\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Search, {\n    block\n  })));\n};\nvar Breadcrumbs = ({ block, rootOnly = false }) => {\n  const { recordMap, mapPageUrl, components } = useNotionContext();\n  const breadcrumbs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const breadcrumbs2 = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getPageBreadcrumbs)(recordMap, block.id);\n    if (rootOnly) {\n      return [breadcrumbs2[0]].filter(Boolean);\n    }\n    return breadcrumbs2;\n  }, [recordMap, block.id, rootOnly]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"breadcrumbs\",\n    key: \"breadcrumbs\"\n  }, breadcrumbs.map((breadcrumb, index) => {\n    if (!breadcrumb) {\n      return null;\n    }\n    const pageLinkProps = {};\n    const componentMap = {\n      pageLink: components.PageLink\n    };\n    if (breadcrumb.active) {\n      componentMap.pageLink = (props) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", __spreadValues({}, props));\n    } else {\n      pageLinkProps.href = mapPageUrl(breadcrumb.pageId);\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      key: breadcrumb.pageId\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(componentMap.pageLink, __spreadValues({\n      className: cs(\"breadcrumb\", breadcrumb.active && \"active\")\n    }, pageLinkProps), breadcrumb.icon && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PageIcon, {\n      className: \"icon\",\n      block: breadcrumb.block\n    }), breadcrumb.title && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"title\"\n    }, breadcrumb.title)), index < breadcrumbs.length - 1 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n      className: \"spacer\"\n    }, \"/\"));\n  }));\n};\nvar Search = ({ block, search, title = \"Search\" }) => {\n  const { searchNotion, rootPageId, isShowingSearch, onHideSearch } = useNotionContext();\n  const onSearchNotion = search || searchNotion;\n  const [isSearchOpen, setIsSearchOpen] = react__WEBPACK_IMPORTED_MODULE_0__.useState(isShowingSearch);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setIsSearchOpen(isShowingSearch);\n  }, [isShowingSearch]);\n  const onOpenSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    setIsSearchOpen(true);\n  }, []);\n  const onCloseSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    setIsSearchOpen(false);\n    if (onHideSearch) {\n      onHideSearch();\n    }\n  }, [onHideSearch]);\n  (0,react_hotkeys_hook__WEBPACK_IMPORTED_MODULE_6__.useHotkeys)(\"cmd+p\", (event) => {\n    onOpenSearch();\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  (0,react_hotkeys_hook__WEBPACK_IMPORTED_MODULE_6__.useHotkeys)(\"cmd+k\", (event) => {\n    onOpenSearch();\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  const hasSearch = !!onSearchNotion;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, hasSearch && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    role: \"button\",\n    className: cs(\"breadcrumb\", \"button\", \"notion-search-button\"),\n    onClick: onOpenSearch\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchIcon, {\n    className: \"searchIcon\"\n  }), title && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    className: \"title\"\n  }, title)), isSearchOpen && hasSearch && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchDialog, {\n    isOpen: isSearchOpen,\n    rootBlockId: rootPageId || (block == null ? void 0 : block.id),\n    onClose: onCloseSearch,\n    searchNotion: onSearchNotion\n  }));\n};\n\n// src/components/asset.tsx\n\n\n\n// src/components/lite-youtube-embed.tsx\n\nvar qs = (params) => {\n  return Object.keys(params).map(\n    (key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`\n  ).join(\"&\");\n};\nvar LiteYouTubeEmbed = ({\n  id,\n  defaultPlay = false,\n  mute = false,\n  lazyImage = false,\n  iframeTitle = \"YouTube video\",\n  alt = \"Video preview\",\n  params = {},\n  adLinksPreconnect = true,\n  style,\n  className\n}) => {\n  const muteParam = mute || defaultPlay ? \"1\" : \"0\";\n  const queryString = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => qs(__spreadValues({ autoplay: \"1\", mute: muteParam }, params)),\n    [muteParam, params]\n  );\n  const resolution = \"hqdefault\";\n  const posterUrl = `https://i.ytimg.com/vi/${id}/${resolution}.jpg`;\n  const ytUrl = \"https://www.youtube-nocookie.com\";\n  const iframeSrc = `${ytUrl}/embed/${id}?${queryString}`;\n  const [isPreconnected, setIsPreconnected] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const [iframeInitialized, setIframeInitialized] = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultPlay);\n  const [isIframeLoaded, setIsIframeLoaded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const warmConnections = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (isPreconnected)\n      return;\n    setIsPreconnected(true);\n  }, [isPreconnected]);\n  const onLoadIframe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (iframeInitialized)\n      return;\n    setIframeInitialized(true);\n  }, [iframeInitialized]);\n  const onIframeLoaded = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    setIsIframeLoaded(true);\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", {\n    rel: \"preload\",\n    href: posterUrl,\n    as: \"image\"\n  }), isPreconnected && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", {\n    rel: \"preconnect\",\n    href: ytUrl\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", {\n    rel: \"preconnect\",\n    href: \"https://www.google.com\"\n  })), isPreconnected && adLinksPreconnect && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", {\n    rel: \"preconnect\",\n    href: \"https://static.doubleclick.net\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", {\n    rel: \"preconnect\",\n    href: \"https://googleads.g.doubleclick.net\"\n  })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    onClick: onLoadIframe,\n    onPointerOver: warmConnections,\n    className: cs(\n      \"notion-yt-lite\",\n      isIframeLoaded && \"notion-yt-loaded\",\n      iframeInitialized && \"notion-yt-initialized\",\n      className\n    ),\n    style\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n    src: posterUrl,\n    className: \"notion-yt-thumbnail\",\n    loading: lazyImage ? \"lazy\" : void 0,\n    alt\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"notion-yt-playbtn\"\n  }), iframeInitialized && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"iframe\", {\n    width: \"560\",\n    height: \"315\",\n    frameBorder: \"0\",\n    allow: \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\",\n    allowFullScreen: true,\n    title: iframeTitle,\n    src: iframeSrc,\n    onLoad: onIframeLoaded\n  })));\n};\n\n// src/components/asset.tsx\nvar isServer = typeof window === \"undefined\";\nvar supportedAssetTypes = [\n  \"video\",\n  \"image\",\n  \"embed\",\n  \"figma\",\n  \"typeform\",\n  \"excalidraw\",\n  \"maps\",\n  \"tweet\",\n  \"pdf\",\n  \"gist\",\n  \"codepen\",\n  \"drive\"\n];\nvar Asset = ({ block, zoomable = true, children }) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  const { recordMap, mapImageUrl, components } = useNotionContext();\n  if (!block || !supportedAssetTypes.includes(block.type)) {\n    return null;\n  }\n  const style = {\n    position: \"relative\",\n    display: \"flex\",\n    justifyContent: \"center\",\n    alignSelf: \"center\",\n    width: \"100%\",\n    maxWidth: \"100%\",\n    flexDirection: \"column\"\n  };\n  const assetStyle = {};\n  if (block.format) {\n    const {\n      block_aspect_ratio,\n      block_height,\n      block_width,\n      block_full_width,\n      block_page_width,\n      block_preserve_scale\n    } = block.format;\n    if (block_full_width || block_page_width) {\n      if (block_full_width) {\n        style.width = \"100vw\";\n      } else {\n        style.width = \"100%\";\n      }\n      if (block.type === \"video\") {\n        if (block_height) {\n          style.height = block_height;\n        } else if (block_aspect_ratio) {\n          style.paddingBottom = `${block_aspect_ratio * 100}%`;\n        } else if (block_preserve_scale) {\n          style.objectFit = \"contain\";\n        }\n      } else if (block_aspect_ratio && block.type !== \"image\") {\n        style.paddingBottom = `${block_aspect_ratio * 100}%`;\n      } else if (block_height) {\n        style.height = block_height;\n      } else if (block_preserve_scale) {\n        if (block.type === \"image\") {\n          style.height = \"100%\";\n        } else {\n          style.paddingBottom = \"75%\";\n          style.minHeight = 100;\n        }\n      }\n    } else {\n      switch ((_a = block.format) == null ? void 0 : _a.block_alignment) {\n        case \"center\": {\n          style.alignSelf = \"center\";\n          break;\n        }\n        case \"left\": {\n          style.alignSelf = \"start\";\n          break;\n        }\n        case \"right\": {\n          style.alignSelf = \"end\";\n          break;\n        }\n      }\n      if (block_width) {\n        style.width = block_width;\n      }\n      if (block_preserve_scale && block.type !== \"image\") {\n        style.paddingBottom = \"50%\";\n        style.minHeight = 100;\n      } else {\n        if (block_height && block.type !== \"image\") {\n          style.height = block_height;\n        }\n      }\n    }\n    if (block.type === \"image\") {\n      assetStyle.objectFit = \"cover\";\n    } else if (block_preserve_scale) {\n      assetStyle.objectFit = \"contain\";\n    }\n  }\n  let source = ((_b = recordMap.signed_urls) == null ? void 0 : _b[block.id]) || ((_e = (_d = (_c = block.properties) == null ? void 0 : _c.source) == null ? void 0 : _d[0]) == null ? void 0 : _e[0]);\n  let content = null;\n  if (!source) {\n    return null;\n  }\n  if (block.type === \"tweet\") {\n    const src = source;\n    if (!src)\n      return null;\n    const id = src.split(\"?\")[0].split(\"/\").pop();\n    if (!id)\n      return null;\n    content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: __spreadProps(__spreadValues({}, assetStyle), {\n        maxWidth: 420,\n        width: \"100%\",\n        marginLeft: \"auto\",\n        marginRight: \"auto\"\n      })\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Tweet, {\n      id\n    }));\n  } else if (block.type === \"pdf\") {\n    style.overflow = \"auto\";\n    style.background = \"rgb(226, 226, 226)\";\n    style.display = \"block\";\n    if (!style.padding) {\n      style.padding = \"8px 16px\";\n    }\n    if (!isServer) {\n      content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.Pdf, {\n        file: source\n      });\n    }\n  } else if (block.type === \"embed\" || block.type === \"video\" || block.type === \"figma\" || block.type === \"typeform\" || block.type === \"gist\" || block.type === \"maps\" || block.type === \"excalidraw\" || block.type === \"codepen\" || block.type === \"drive\") {\n    if (block.type === \"video\" && source && source.indexOf(\"youtube\") < 0 && source.indexOf(\"youtu.be\") < 0 && source.indexOf(\"vimeo\") < 0 && source.indexOf(\"wistia\") < 0 && source.indexOf(\"loom\") < 0 && source.indexOf(\"videoask\") < 0 && source.indexOf(\"getcloudapp\") < 0) {\n      style.paddingBottom = void 0;\n      content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\", {\n        playsInline: true,\n        controls: true,\n        preload: \"metadata\",\n        style: assetStyle,\n        src: source,\n        title: block.type\n      });\n    } else {\n      let src = ((_f = block.format) == null ? void 0 : _f.display_source) || source;\n      if (src) {\n        const youtubeVideoId = block.type === \"video\" ? getYoutubeId(src) : null;\n        if (youtubeVideoId) {\n          content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiteYouTubeEmbed, {\n            id: youtubeVideoId,\n            style: assetStyle,\n            className: \"notion-asset-object-fit\"\n          });\n        } else if (block.type === \"gist\") {\n          if (!src.endsWith(\".pibb\")) {\n            src = `${src}.pibb`;\n          }\n          assetStyle.width = \"100%\";\n          style.paddingBottom = \"50%\";\n          content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"iframe\", {\n            style: assetStyle,\n            className: \"notion-asset-object-fit\",\n            src,\n            title: \"GitHub Gist\",\n            frameBorder: \"0\",\n            loading: \"lazy\",\n            scrolling: \"auto\"\n          });\n        } else {\n          content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"iframe\", {\n            className: \"notion-asset-object-fit\",\n            style: assetStyle,\n            src,\n            title: `iframe ${block.type}`,\n            frameBorder: \"0\",\n            allowFullScreen: true,\n            loading: \"lazy\",\n            scrolling: \"auto\"\n          });\n        }\n      }\n    }\n  } else if (block.type === \"image\") {\n    if (source.includes(\"file.notion.so\")) {\n      source = (_i = (_h = (_g = block.properties) == null ? void 0 : _g.source) == null ? void 0 : _h[0]) == null ? void 0 : _i[0];\n    }\n    const src = mapImageUrl(source, block);\n    const caption = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getTextContent)((_j = block.properties) == null ? void 0 : _j.caption);\n    const alt = caption || \"notion image\";\n    content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LazyImage, {\n      src,\n      alt,\n      zoomable,\n      height: style.height,\n      style: assetStyle\n    });\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    style\n  }, content, block.type === \"image\" && children), block.type !== \"image\" && children);\n};\n\n// src/components/asset-wrapper.tsx\nvar urlStyle = { width: \"100%\" };\nvar AssetWrapper = ({ blockId, block }) => {\n  var _a, _b, _c, _d, _e, _f;\n  const value = block;\n  const { components, mapPageUrl, rootDomain, zoom } = useNotionContext();\n  let isURL = false;\n  if (block.type === \"image\") {\n    const caption = (_c = (_b = (_a = value == null ? void 0 : value.properties) == null ? void 0 : _a.caption) == null ? void 0 : _b[0]) == null ? void 0 : _c[0];\n    if (caption) {\n      const id = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.parsePageId)(caption, { uuid: true });\n      const isPage = caption.charAt(0) === \"/\" && id;\n      if (isPage || isValidURL(caption)) {\n        isURL = true;\n      }\n    }\n  }\n  const figure = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"figure\", {\n    className: cs(\n      \"notion-asset-wrapper\",\n      `notion-asset-wrapper-${block.type}`,\n      ((_d = value.format) == null ? void 0 : _d.block_full_width) && \"notion-asset-wrapper-full\",\n      blockId\n    )\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Asset, {\n    block: value,\n    zoomable: zoom && !isURL\n  }, ((_e = value == null ? void 0 : value.properties) == null ? void 0 : _e.caption) && !isURL && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"figcaption\", {\n    className: \"notion-asset-caption\"\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Text, {\n    value: value.properties.caption,\n    block\n  }))));\n  if (isURL) {\n    const caption = (_f = value == null ? void 0 : value.properties) == null ? void 0 : _f.caption[0][0];\n    const id = (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.parsePageId)(caption, { uuid: true });\n    const isPage = caption.charAt(0) === \"/\" && id;\n    const captionHostname = extractHostname(caption);\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(components.PageLink, {\n      style: urlStyle,\n      href: isPage ? mapPageUrl(id) : caption,\n      target: captionHostname && captionHostname !== rootDomain && !caption.startsWith(\"/\") ? \"blank_\" : null\n    }, figure);\n  }\n  return figure;\n};\nfunction isValidURL(str) {\n  const pattern = new RegExp(\n    \"^(https?:\\\\/\\\\/)?((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*(\\\\?[;&a-z\\\\d%_.~+=-]*)?(\\\\#[-a-z\\\\d_]*)?$\",\n    \"i\"\n  );\n  return !!pattern.test(str);\n}\nfunction extractHostname(url) {\n  try {\n    const hostname = new URL(url).hostname;\n    return hostname;\n  } catch (err) {\n    return \"\";\n  }\n}\n\n// src/components/checkbox.tsx\n\n\n// src/icons/check.tsx\n\nfunction SvgCheck(props) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadValues({\n    viewBox: \"0 0 14 14\"\n  }, props), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    d: \"M5.5 12L14 3.5 12.5 2l-7 7-4-4.003L0 6.499z\"\n  }));\n}\nvar check_default = SvgCheck;\n\n// src/components/checkbox.tsx\nvar Checkbox = ({ isChecked }) => {\n  let content = null;\n  if (isChecked) {\n    content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"notion-property-checkbox-checked\"\n    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(check_default, null));\n  } else {\n    content = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      className: \"notion-property-checkbox-unchecked\"\n    });\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    className: \"notion-property notion-property-checkbox\"\n  }, content);\n};\n\n// src/next.tsx\n\n\nvar wrapNextImage = (NextImage) => {\n  return react__WEBPACK_IMPORTED_MODULE_0__.memo(function ReactNotionXNextImage(_a) {\n    var _b = _a, {\n      src,\n      alt,\n      width,\n      height,\n      className,\n      style,\n      layout\n    } = _b, rest = __objRest(_b, [\n      \"src\",\n      \"alt\",\n      \"width\",\n      \"height\",\n      \"className\",\n      \"style\",\n      \"layout\"\n    ]);\n    if (!layout) {\n      layout = width && height ? \"intrinsic\" : \"fill\";\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NextImage, __spreadValues({\n      className,\n      src,\n      alt,\n      width: layout === \"intrinsic\" && width,\n      height: layout === \"intrinsic\" && height,\n      objectFit: style == null ? void 0 : style.objectFit,\n      objectPosition: style == null ? void 0 : style.objectPosition,\n      layout\n    }, rest));\n  }, react_fast_compare__WEBPACK_IMPORTED_MODULE_7__);\n};\nvar wrapNextLink = (NextLink) => function ReactNotionXNextLink(_a) {\n  var _b = _a, {\n    href,\n    as,\n    passHref,\n    prefetch,\n    replace,\n    scroll,\n    shallow,\n    locale\n  } = _b, linkProps = __objRest(_b, [\n    \"href\",\n    \"as\",\n    \"passHref\",\n    \"prefetch\",\n    \"replace\",\n    \"scroll\",\n    \"shallow\",\n    \"locale\"\n  ]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NextLink, {\n    href,\n    as,\n    passHref,\n    prefetch,\n    replace,\n    scroll,\n    shallow,\n    locale\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", __spreadValues({}, linkProps)));\n};\n\n// src/context.tsx\nvar DefaultLink = (props) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", __spreadValues({\n  target: \"_blank\",\n  rel: \"noopener noreferrer\"\n}, props));\nvar DefaultLinkMemo = react__WEBPACK_IMPORTED_MODULE_0__.memo(DefaultLink);\nvar DefaultPageLink = (props) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", __spreadValues({}, props));\nvar DefaultPageLinkMemo = react__WEBPACK_IMPORTED_MODULE_0__.memo(DefaultPageLink);\nvar DefaultEmbed = (props) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AssetWrapper, __spreadValues({}, props));\nvar DefaultHeader = Header;\nvar dummyComponent = (name) => () => {\n  console.warn(\n    `Warning: using empty component \"${name}\" (you should override this in NotionRenderer.components)`\n  );\n  return null;\n};\nvar dummyOverrideFn = (_, defaultValueFn) => defaultValueFn();\nvar defaultComponents = {\n  Image: null,\n  Link: DefaultLinkMemo,\n  PageLink: DefaultPageLinkMemo,\n  Checkbox,\n  Callout: void 0,\n  Code: dummyComponent(\"Code\"),\n  Equation: dummyComponent(\"Equation\"),\n  Collection: dummyComponent(\"Collection\"),\n  Property: void 0,\n  propertyTextValue: dummyOverrideFn,\n  propertySelectValue: dummyOverrideFn,\n  propertyRelationValue: dummyOverrideFn,\n  propertyFormulaValue: dummyOverrideFn,\n  propertyTitleValue: dummyOverrideFn,\n  propertyPersonValue: dummyOverrideFn,\n  propertyFileValue: dummyOverrideFn,\n  propertyCheckboxValue: dummyOverrideFn,\n  propertyUrlValue: dummyOverrideFn,\n  propertyEmailValue: dummyOverrideFn,\n  propertyPhoneNumberValue: dummyOverrideFn,\n  propertyNumberValue: dummyOverrideFn,\n  propertyLastEditedTimeValue: dummyOverrideFn,\n  propertyCreatedTimeValue: dummyOverrideFn,\n  propertyDateValue: dummyOverrideFn,\n  Pdf: dummyComponent(\"Pdf\"),\n  Tweet: dummyComponent(\"Tweet\"),\n  Modal: dummyComponent(\"Modal\"),\n  Header: DefaultHeader,\n  Embed: DefaultEmbed\n};\nvar defaultNotionContext = {\n  recordMap: {\n    block: {},\n    collection: {},\n    collection_view: {},\n    collection_query: {},\n    notion_user: {},\n    signed_urls: {}\n  },\n  components: defaultComponents,\n  mapPageUrl: defaultMapPageUrl(),\n  mapImageUrl: defaultMapImageUrl,\n  searchNotion: null,\n  isShowingSearch: false,\n  onHideSearch: null,\n  fullPage: false,\n  darkMode: false,\n  previewImages: false,\n  forceCustomImages: false,\n  showCollectionViewDropdown: true,\n  linkTableTitleProperties: true,\n  isLinkCollectionToUrlProperty: false,\n  showTableOfContents: false,\n  minTableOfContentsItems: 3,\n  defaultPageIcon: null,\n  defaultPageCover: null,\n  defaultPageCoverPosition: 0.5,\n  zoom: null\n};\nvar ctx = react__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultNotionContext);\nvar NotionContextProvider = (_a) => {\n  var _b = _a, {\n    components: themeComponents = {},\n    children,\n    mapPageUrl,\n    mapImageUrl,\n    rootPageId\n  } = _b, rest = __objRest(_b, [\n    \"components\",\n    \"children\",\n    \"mapPageUrl\",\n    \"mapImageUrl\",\n    \"rootPageId\"\n  ]);\n  for (const key of Object.keys(rest)) {\n    if (rest[key] === void 0) {\n      delete rest[key];\n    }\n  }\n  const wrappedThemeComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => __spreadValues({}, themeComponents),\n    [themeComponents]\n  );\n  if (wrappedThemeComponents.nextImage) {\n    wrappedThemeComponents.Image = wrapNextImage(themeComponents.nextImage);\n  }\n  if (wrappedThemeComponents.nextLink) {\n    wrappedThemeComponents.nextLink = wrapNextLink(themeComponents.nextLink);\n  }\n  for (const key of Object.keys(wrappedThemeComponents)) {\n    if (!wrappedThemeComponents[key]) {\n      delete wrappedThemeComponents[key];\n    }\n  }\n  const value = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => __spreadProps(__spreadValues(__spreadValues({}, defaultNotionContext), rest), {\n      rootPageId,\n      mapPageUrl: mapPageUrl != null ? mapPageUrl : defaultMapPageUrl(rootPageId),\n      mapImageUrl: mapImageUrl != null ? mapImageUrl : defaultMapImageUrl,\n      components: __spreadValues(__spreadValues({}, defaultComponents), wrappedThemeComponents)\n    }),\n    [mapImageUrl, mapPageUrl, wrappedThemeComponents, rootPageId, rest]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ctx.Provider, {\n    value\n  }, children);\n};\nvar NotionContextConsumer = ctx.Consumer;\nvar useNotionContext = () => {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ctx);\n};\n\n// src/third-party/equation.tsx\nvar katexSettings = {\n  throwOnError: false,\n  strict: false\n};\nvar Equation = (_a) => {\n  var _b = _a, { block, math, inline = false, className } = _b, rest = __objRest(_b, [\"block\", \"math\", \"inline\", \"className\"]);\n  const { recordMap } = useNotionContext();\n  math = math || (0,notion_utils__WEBPACK_IMPORTED_MODULE_2__.getBlockTitle)(block, recordMap);\n  if (!math)\n    return null;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    role: \"button\",\n    tabIndex: 0,\n    className: cs(\n      \"notion-equation\",\n      inline ? \"notion-equation-inline\" : \"notion-equation-block\",\n      className\n    )\n  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_matejmazur_react_katex__WEBPACK_IMPORTED_MODULE_1__[\"default\"], __spreadValues({\n    math,\n    settings: katexSettings\n  }, rest)));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ub3Rpb24teC9idWlsZC90aGlyZC1wYXJ0eS9lcXVhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRyx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBcUI7QUFDL0I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFlO0FBQ2hELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBZTtBQUMvQix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLGdEQUFxQjtBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFrQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQXlDO0FBQzFELFVBQVUsWUFBWTtBQUN0QixpQkFBaUIsMkRBQWM7QUFDL0I7QUFDQTtBQUNBLHlCQUF5QixnREFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQixnREFBcUIsQ0FBQywrREFBSztBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW5vdGlvbi14L2J1aWxkL3RoaXJkLXBhcnR5L2VxdWF0aW9uLmpzPzAwMjQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfbG9kYXNoID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBGVU5DX0VSUk9SX1RFWFQgPSBcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIjtcbiAgICB2YXIgTkFOID0gMCAvIDA7XG4gICAgdmFyIHN5bWJvbFRhZyA9IFwiW29iamVjdCBTeW1ib2xdXCI7XG4gICAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuICAgIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG4gICAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG4gICAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4gICAgdmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuICAgIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuICAgIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4gICAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICAgIHZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncywgbGFzdFRoaXMsIG1heFdhaXQsIHJlc3VsdCwgdGltZXJJZCwgbGFzdENhbGxUaW1lLCBsYXN0SW52b2tlVGltZSA9IDAsIGxlYWRpbmcgPSBmYWxzZSwgbWF4aW5nID0gZmFsc2UsIHRyYWlsaW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSBcIm1heFdhaXRcIiBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9IFwidHJhaWxpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncywgdGhpc0FyZyA9IGxhc3RUaGlzO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdm9pZCAwO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsIHJlc3VsdDIgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG4gICAgICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0MiwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG4gICAgICAgIHJldHVybiBsYXN0Q2FsbFRpbWUgPT09IHZvaWQgMCB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB2b2lkIDAgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLCBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm90dGxlMihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBcImxlYWRpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9IFwidHJhaWxpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICBcImxlYWRpbmdcIjogbGVhZGluZyxcbiAgICAgICAgXCJtYXhXYWl0XCI6IHdhaXQsXG4gICAgICAgIFwidHJhaWxpbmdcIjogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSBcIm9iamVjdFwiIHx8IHR5cGUgPT0gXCJmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJzeW1ib2xcIiB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09IFwiZnVuY3Rpb25cIiA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgXCJcIiA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgXCJcIik7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlMjtcbiAgfVxufSk7XG5cbi8vIHNyYy90aGlyZC1wYXJ0eS9lcXVhdGlvbi50c3hcbmltcG9ydCAqIGFzIFJlYWN0MjEgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgS2F0ZXggZnJvbSBcIkBtYXRlam1henVyL3JlYWN0LWthdGV4XCI7XG5pbXBvcnQgeyBnZXRCbG9ja1RpdGxlIGFzIGdldEJsb2NrVGl0bGU0IH0gZnJvbSBcIm5vdGlvbi11dGlsc1wiO1xuXG4vLyBzcmMvY29udGV4dC50c3hcbmltcG9ydCAqIGFzIFJlYWN0MjAgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2Fzc2V0LXdyYXBwZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDE2IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgcGFyc2VQYWdlSWQgYXMgcGFyc2VQYWdlSWQyIH0gZnJvbSBcIm5vdGlvbi11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IGlzVXJsLCBmb3JtYXREYXRlLCBmb3JtYXROb3Rpb25EYXRlVGltZSB9IGZyb20gXCJub3Rpb24tdXRpbHNcIjtcblxuLy8gc3JjL21hcC1pbWFnZS11cmwudHNcbnZhciBkZWZhdWx0TWFwSW1hZ2VVcmwgPSAodXJsLCBibG9jaykgPT4ge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL2ltYWdlcy51bnNwbGFzaC5jb21cIikpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgdSA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAodS5wYXRobmFtZS5zdGFydHNXaXRoKFwiL3NlY3VyZS5ub3Rpb24tc3RhdGljLmNvbVwiKSAmJiB1Lmhvc3RuYW1lLmVuZHNXaXRoKFwiLmFtYXpvbmF3cy5jb21cIikpIHtcbiAgICAgIGlmICh1LnNlYXJjaFBhcmFtcy5oYXMoXCJYLUFtei1DcmVkZW50aWFsXCIpICYmIHUuc2VhcmNoUGFyYW1zLmhhcyhcIlgtQW16LVNpZ25hdHVyZVwiKSAmJiB1LnNlYXJjaFBhcmFtcy5oYXMoXCJYLUFtei1BbGdvcml0aG1cIikpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvaW1hZ2VzXCIpKSB7XG4gICAgdXJsID0gYGh0dHBzOi8vd3d3Lm5vdGlvbi5zbyR7dXJsfWA7XG4gIH1cbiAgdXJsID0gYGh0dHBzOi8vd3d3Lm5vdGlvbi5zbyR7dXJsLnN0YXJ0c1dpdGgoXCIvaW1hZ2VcIikgPyB1cmwgOiBgL2ltYWdlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHVybCl9YH1gO1xuICBjb25zdCBub3Rpb25JbWFnZVVybFYyID0gbmV3IFVSTCh1cmwpO1xuICBsZXQgdGFibGUgPSBibG9jay5wYXJlbnRfdGFibGUgPT09IFwic3BhY2VcIiA/IFwiYmxvY2tcIiA6IGJsb2NrLnBhcmVudF90YWJsZTtcbiAgaWYgKHRhYmxlID09PSBcImNvbGxlY3Rpb25cIiB8fCB0YWJsZSA9PT0gXCJ0ZWFtXCIpIHtcbiAgICB0YWJsZSA9IFwiYmxvY2tcIjtcbiAgfVxuICBub3Rpb25JbWFnZVVybFYyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0YWJsZVwiLCB0YWJsZSk7XG4gIG5vdGlvbkltYWdlVXJsVjIuc2VhcmNoUGFyYW1zLnNldChcImlkXCIsIGJsb2NrLmlkKTtcbiAgbm90aW9uSW1hZ2VVcmxWMi5zZWFyY2hQYXJhbXMuc2V0KFwiY2FjaGVcIiwgXCJ2MlwiKTtcbiAgdXJsID0gbm90aW9uSW1hZ2VVcmxWMi50b1N0cmluZygpO1xuICByZXR1cm4gdXJsO1xufTtcblxuLy8gc3JjL21hcC1wYWdlLXVybC50c1xudmFyIGRlZmF1bHRNYXBQYWdlVXJsID0gKHJvb3RQYWdlSWQpID0+IChwYWdlSWQpID0+IHtcbiAgcGFnZUlkID0gKHBhZ2VJZCB8fCBcIlwiKS5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICBpZiAocm9vdFBhZ2VJZCAmJiBwYWdlSWQgPT09IHJvb3RQYWdlSWQpIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAvJHtwYWdlSWR9YDtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgY3MgPSAoLi4uY2xhc3NlcykgPT4gY2xhc3Nlcy5maWx0ZXIoKGEpID0+ICEhYSkuam9pbihcIiBcIik7XG52YXIgZ2V0SGFzaEZyYWdtZW50VmFsdWUgPSAodXJsKSA9PiB7XG4gIHJldHVybiB1cmwuaW5jbHVkZXMoXCIjXCIpID8gdXJsLnJlcGxhY2UoL14uKygjLispJC8sIFwiJDFcIikgOiBcIlwiO1xufTtcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIHlvdXR1YmVEb21haW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcInlvdXR1LmJlXCIsXG4gIFwieW91dHViZS5jb21cIixcbiAgXCJ3d3cueW91dHViZS5jb21cIixcbiAgXCJ5b3V0dWJlLW5vY29va2llLmNvbVwiLFxuICBcInd3dy55b3V0dWJlLW5vY29va2llLmNvbVwiXG5dKTtcbnZhciBnZXRZb3V0dWJlSWQgPSAodXJsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBob3N0bmFtZSB9ID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmICgheW91dHViZURvbWFpbnMuaGFzKGhvc3RuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZ0V4cCA9IC9eLiooeW91dHVcXC5iZVxcL3x2XFwvfHVcXC9cXHdcXC98ZW1iZWRcXC98d2F0Y2hcXD92PXwmdj0pKFteIyY/XSopLiovaTtcbiAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdFeHApO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaFsyXS5sZW5ndGggPT0gMTEpIHtcbiAgICAgIHJldHVybiBtYXRjaFsyXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL2VvaS50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2ljb25zL3R5cGUtZ2l0aHViLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBTdmdUeXBlR2l0SHViKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgdmlld0JveDogXCIwIDAgMjYwIDI2MFwiXG4gIH0sIHByb3BzKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTI4LjAwMTA2LDAgQzU3LjMxNzI5MjYsMCAwLDU3LjMwNjY5NDIgMCwxMjguMDAxMDYgQzAsMTg0LjU1NTI4MSAzNi42NzYxOTk3LDIzMi41MzU1NDIgODcuNTM0OTM3LDI0OS40NjA4OTkgQzkzLjkzMjAyMjMsMjUwLjY0NTc3OSA5Ni4yODA1ODgsMjQ2LjY4NDE2NSA5Ni4yODA1ODgsMjQzLjMwMzMzMyBDOTYuMjgwNTg4LDI0MC4yNTEwNDUgOTYuMTYxODg3OCwyMzAuMTY3ODk5IDk2LjEwNjc3NywyMTkuNDcyMTc2IEM2MC40OTY3NTg1LDIyNy4yMTUyMzUgNTIuOTgyNjIwNywyMDQuMzY5NzEyIDUyLjk4MjYyMDcsMjA0LjM2OTcxMiBDNDcuMTU5OTU4NCwxODkuNTc0NTk4IDM4Ljc3MDQwOCwxODUuNjQwNTM4IDM4Ljc3MDQwOCwxODUuNjQwNTM4IEMyNy4xNTY4Nzg1LDE3Ny42OTYxMTMgMzkuNjQ1ODIwNiwxNzcuODU5MzI1IDM5LjY0NTgyMDYsMTc3Ljg1OTMyNSBDNTIuNDk5MzQxOSwxNzguNzYyMjkzIDU5LjI2NzM2NSwxOTEuMDQ5ODcgNTkuMjY3MzY1LDE5MS4wNDk4NyBDNzAuNjgzNzY3NSwyMTAuNjE4NDIzIDg5LjIxMTU3NTMsMjA0Ljk2MTA5MyA5Ni41MTU4Njg1LDIwMS42OTA0ODIgQzk3LjY2NDcxNTUsMTkzLjQxNzUxMiAxMDAuOTgxOTU5LDE4Ny43NzA3OCAxMDQuNjQyNTgzLDE4NC41NzQzNTcgQzc2LjIxMTc5OSwxODEuMzM3NjYgNDYuMzI0ODE5LDE3MC4zNjIxNDQgNDYuMzI0ODE5LDEyMS4zMTU3MDIgQzQ2LjMyNDgxOSwxMDcuMzQwODg5IDUxLjMyNTA1ODgsOTUuOTIyMzY4MiA1OS41MTMyNDM3LDg2Ljk1ODM5MzcgQzU4LjE4NDIyNjgsODMuNzM0NDE1MiA1My44MDI5MjI5LDcwLjcxNTU2MiA2MC43NTMyMzU0LDUzLjA4NDM2MzYgQzYwLjc1MzIzNTQsNTMuMDg0MzYzNiA3MS41MDE5NTAxLDQ5LjY0NDE4MTMgOTUuOTYyNjQxMiw2Ni4yMDQ5NTk1IEMxMDYuMTcyOTY3LDYzLjM2ODg3NiAxMTcuMTIzMDQ3LDYxLjk0NjU5NDkgMTI4LjAwMTA2LDYxLjg5Nzg0MzIgQzEzOC44NzkwNzMsNjEuOTQ2NTk0OSAxNDkuODM3NjMyLDYzLjM2ODg3NiAxNjAuMDY3MDMzLDY2LjIwNDk1OTUgQzE4NC40OTgwNSw0OS42NDQxODEzIDE5NS4yMzE5MjYsNTMuMDg0MzYzNiAxOTUuMjMxOTI2LDUzLjA4NDM2MzYgQzIwMi4xOTkxOTcsNzAuNzE1NTYyIDE5Ny44MTU3NzMsODMuNzM0NDE1MiAxOTYuNDg2NzU2LDg2Ljk1ODM5MzcgQzIwNC42OTQwMTgsOTUuOTIyMzY4MiAyMDkuNjYwMzQzLDEwNy4zNDA4ODkgMjA5LjY2MDM0MywxMjEuMzE1NzAyIEMyMDkuNjYwMzQzLDE3MC40Nzg3MjUgMTc5LjcxNjEzMywxODEuMzAzNzQ3IDE1MS4yMTMyODEsMTg0LjQ3MjYxNCBDMTU1LjgwNDQzLDE4OC40NDQ4MjggMTU5Ljg5NTM0MiwxOTYuMjM0NTE4IDE1OS44OTUzNDIsMjA4LjE3NjU5MyBDMTU5Ljg5NTM0MiwyMjUuMzAzMzE3IDE1OS43NDY5NjgsMjM5LjA4NzM2MSAxNTkuNzQ2OTY4LDI0My4zMDMzMzMgQzE1OS43NDY5NjgsMjQ2LjcwOTYwMSAxNjIuMDUxMDIsMjUwLjcwMDg5IDE2OC41MzkyNSwyNDkuNDQzOTQxIEMyMTkuMzcwNDMyLDIzMi40OTk1MDcgMjU2LDE4NC41MzYyMDQgMjU2LDEyOC4wMDEwNiBDMjU2LDU3LjMwNjY5NDIgMTk4LjY5MTE4NywwIDEyOC4wMDEwNiwwIFogTTQ3Ljk0MDU1OTMsMTgyLjM0MDIxMiBDNDcuNjU4NjQ2NSwxODIuOTc2MTA1IDQ2LjY1ODE3NDUsMTgzLjE2Njg3MyA0NS43NDY3Mjc3LDE4Mi43MzAyMjcgQzQ0LjgxODMyMzUsMTgyLjMxMjY1NiA0NC4yOTY4OTE0LDE4MS40NDU3MjIgNDQuNTk3ODgwOCwxODAuODA3NzEgQzQ0Ljg3MzQzNDQsMTgwLjE1MjczOSA0NS44NzYwMjYsMTc5Ljk3MDQ1IDQ2LjgwMjMxMDMsMTgwLjQwOTIxNiBDNDcuNzMyODM0MiwxODAuODI2Nzg2IDQ4LjI2Mjc0NTEsMTgxLjcwMjE5OSA0Ny45NDA1NTkzLDE4Mi4zNDAyMTIgWiBNNTQuMjM2Nzg5MiwxODcuOTU4MjU0IEM1My42MjYzMzE4LDE4OC41MjQxOTkgNTIuNDMyOTcyMywxODguMjYxMzYzIDUxLjYyMzI2ODIsMTg3LjM2Njg3NCBDNTAuNzg2MDA4OCwxODYuNDc0NTA0IDUwLjYyOTE1NTMsMTg1LjI4MTE0NCA1MS4yNDgwOTEyLDE4NC43MDY3MiBDNTEuODc3NjI1NCwxODQuMTQwNzc1IDUzLjAzNDk1MTIsMTg0LjQwNTczMSA1My44NzQzMzAyLDE4NS4yOTgxMDEgQzU0LjcxMTU4OTIsMTg2LjIwMTA2OSA1NC44NzQ4MDE5LDE4Ny4zODU5NSA1NC4yMzY3ODkyLDE4Ny45NTgyNTQgWiBNNTguNTU2MjQxMywxOTUuMTQ2MzQ3IEM1Ny43NzE5NzMyLDE5NS42OTEwOTYgNTYuNDg5NTg4NiwxOTUuMTgwMjYxIDU1LjY5Njg0MTcsMTk0LjA0MjAxMyBDNTQuOTEyNTczMywxOTIuOTAzNzY0IDU0LjkxMjU3MzMsMTkxLjUzODcxMyA1NS43MTM3OTksMTkwLjk5MTg0NSBDNTYuNTA4NjY1MSwxOTAuNDQ0OTc3IDU3Ljc3MTk3MzIsMTkwLjkzNjczNSA1OC41NzUzMTgxLDE5Mi4wNjY1MDUgQzU5LjM1NzQ2NjksMTkzLjIyMzgzIDU5LjM1NzQ2NjksMTk0LjU4ODg4IDU4LjU1NjI0MTMsMTk1LjE0NjM0NyBaIE02NS44NjEzNTkyLDIwMy40NzExNzQgQzY1LjE1OTc1NzEsMjA0LjI0NDg0NiA2My42NjU0MDgzLDIwNC4wMzcxMiA2Mi41NzE2NzE3LDIwMi45ODE1MzggQzYxLjQ1MjQ5OTksMjAxLjk0OTI3IDYxLjE0MDkxMjIsMjAwLjQ4NDU5NiA2MS44NDQ2MzQxLDE5OS43MTA5MjYgQzYyLjU1NDcxNDYsMTk4LjkzNTEzNyA2NC4wNTc1NDIyLDE5OS4xNTM0NiA2NS4xNTk3NTcxLDIwMC4yMDA1NjQgQzY2LjI3MDQ1MDYsMjAxLjIzMDcxMiA2Ni42MDk1OTM2LDIwMi43MDU5ODQgNjUuODYxMzU5MiwyMDMuNDcxMTc0IFogTTc1LjMwMjUxNTEsMjA2LjI4MTU0MiBDNzQuOTkzMDQ3NCwyMDcuMjg0MTM0IDczLjU1MzgwOSwyMDcuNzM5ODU3IDcyLjEwMzk3MjQsMjA3LjMxMzgwOSBDNzAuNjU2MjU1NiwyMDYuODc1MDQzIDY5LjcwODc3NDgsMjA1LjcwMDc2MSA3MC4wMDEyODU3LDIwNC42ODc1NzEgQzcwLjMwMjI3NSwyMDMuNjc4NjIxIDcxLjc0Nzg3MjEsMjAzLjIwMzgyIDczLjIwODMwNjksMjAzLjY1OTU0MyBDNzQuNjUzOTA0MSwyMDQuMDk2MTkgNzUuNjAzNTA0OCwyMDUuMjYxOTk0IDc1LjMwMjUxNTEsMjA2LjI4MTU0MiBaIE04Ni4wNDY5NDcsMjA3LjQ3MzYyNyBDODYuMDgyOTgwNiwyMDguNTI5MjA5IDg0Ljg1MzU4NzEsMjA5LjQwNDYyMiA4My4zMzE2ODI5LDIwOS40MjM3IEM4MS44MDEzLDIwOS40NTc2MTQgODAuNTYzNDI4LDIwOC42MDMzOTggODAuNTQ2NDcwOCwyMDcuNTY0NzcyIEM4MC41NDY0NzA4LDIwNi40OTg1OTEgODEuNzQ4MzA4OCwyMDUuNjMxNjU3IDgzLjI3ODY5MTcsMjA1LjYwNjIyMSBDODQuODAwNTk2MiwyMDUuNTc2NTQ2IDg2LjA0Njk0NywyMDYuNDI0NDAzIDg2LjA0Njk0NywyMDcuNDczNjI3IFogTTk2LjYwMjE0NzEsMjA3LjA2OTAyMyBDOTYuNzg0NDM2NiwyMDguMDk5MTcxIDk1LjcyNjczNDEsMjA5LjE1Njg3MiA5NC4yMTU0MjgsMjA5LjQzODc4NSBDOTIuNzI5NTU3NywyMDkuNzEwMDk5IDkxLjM1MzkwODYsMjA5LjA3NDIwNiA5MS4xNjUyNjAzLDIwOC4wNTI1MzggQzkwLjk4MDg1MTUsMjA2Ljk5Njk1NSA5Mi4wNTc2MzA2LDIwNS45MzkyNTMgOTMuNTQxMzgxMywyMDUuNjY1ODIgQzk1LjA1NDgwNywyMDUuNDAyOTg0IDk2LjQwOTI1OTYsMjA2LjAyMTkxOSA5Ni42MDIxNDcxLDIwNy4wNjkwMjMgWlwiLFxuICAgIGZpbGw6IFwiIzE2MTYxNFwiXG4gIH0pKSk7XG59XG52YXIgdHlwZV9naXRodWJfZGVmYXVsdCA9IFN2Z1R5cGVHaXRIdWI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2VvaS50c3hcbnZhciBFT0kgPSAoeyBibG9jaywgaW5saW5lLCBjbGFzc05hbWUgfSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgeyBjb21wb25lbnRzIH0gPSB1c2VOb3Rpb25Db250ZXh0KCk7XG4gIGNvbnN0IHsgb3JpZ2luYWxfdXJsLCBhdHRyaWJ1dGVzLCBkb21haW4gfSA9IChibG9jayA9PSBudWxsID8gdm9pZCAwIDogYmxvY2suZm9ybWF0KSB8fCB7fTtcbiAgaWYgKCFvcmlnaW5hbF91cmwgfHwgIWF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0aXRsZSA9IChfYSA9IGF0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5pZCA9PT0gXCJ0aXRsZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlc1swXTtcbiAgbGV0IG93bmVyID0gKF9iID0gYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLmlkID09PSBcIm93bmVyXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWVzWzBdO1xuICBjb25zdCBsYXN0VXBkYXRlZEF0ID0gKF9jID0gYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLmlkID09PSBcInVwZGF0ZWRfYXRcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYy52YWx1ZXNbMF07XG4gIGNvbnN0IGxhc3RVcGRhdGVkID0gbGFzdFVwZGF0ZWRBdCA/IGZvcm1hdE5vdGlvbkRhdGVUaW1lKGxhc3RVcGRhdGVkQXQpIDogbnVsbDtcbiAgbGV0IGV4dGVybmFsSW1hZ2U7XG4gIHN3aXRjaCAoZG9tYWluKSB7XG4gICAgY2FzZSBcImdpdGh1Yi5jb21cIjpcbiAgICAgIGV4dGVybmFsSW1hZ2UgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQodHlwZV9naXRodWJfZGVmYXVsdCwgbnVsbCk7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBvd25lci5zcGxpdChcIi9cIik7XG4gICAgICAgIG93bmVyID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYFVuc3VwcG9ydGVkIGV4dGVybmFsX29iamVjdF9pbnN0YW5jZSBkb21haW4gXCIke2RvbWFpbn1cImAsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuTGluaywge1xuICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiLFxuICAgIGhyZWY6IG9yaWdpbmFsX3VybCxcbiAgICBjbGFzc05hbWU6IGNzKFxuICAgICAgXCJub3Rpb24tZXh0ZXJuYWxcIixcbiAgICAgIGlubGluZSA/IFwibm90aW9uLWV4dGVybmFsLW1lbnRpb25cIiA6IFwibm90aW9uLWV4dGVybmFsLWJsb2NrIG5vdGlvbi1yb3dcIixcbiAgICAgIGNsYXNzTmFtZVxuICAgIClcbiAgfSwgZXh0ZXJuYWxJbWFnZSAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJub3Rpb24tZXh0ZXJuYWwtaW1hZ2VcIlxuICB9LCBleHRlcm5hbEltYWdlKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibm90aW9uLWV4dGVybmFsLWRlc2NyaXB0aW9uXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwibm90aW9uLWV4dGVybmFsLXRpdGxlXCJcbiAgfSwgdGl0bGUpLCAob3duZXIgfHwgbGFzdFVwZGF0ZWQpICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1leHRlcm5hbC1zdWJ0aXRsZVwiXG4gIH0sIG93bmVyICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgb3duZXIpLCBvd25lciAmJiBsYXN0VXBkYXRlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiIFxcdTIwMjIgXCIpLCBsYXN0VXBkYXRlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiVXBkYXRlZCBcIiwgbGFzdFVwZGF0ZWQpKSkpO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvdGV4dC50c3hcbmltcG9ydCAqIGFzIFJlYWN0OCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHBhcnNlUGFnZUlkIH0gZnJvbSBcIm5vdGlvbi11dGlsc1wiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9ncmFjZWZ1bC1pbWFnZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0MyBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEltZyB9IGZyb20gXCJyZWFjdC1pbWFnZVwiO1xudmFyIEdyYWNlZnVsSW1hZ2UgPSAocHJvcHMpID0+IHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoSW1nLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcykpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9wYWdlLXRpdGxlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q3IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0QmxvY2tUaXRsZSBhcyBnZXRCbG9ja1RpdGxlMiB9IGZyb20gXCJub3Rpb24tdXRpbHNcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvcGFnZS1pY29uLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0QmxvY2tJY29uLCBnZXRCbG9ja1RpdGxlIH0gZnJvbSBcIm5vdGlvbi11dGlsc1wiO1xuXG4vLyBzcmMvaWNvbnMvZGVmYXVsdC1wYWdlLWljb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG52YXIgRGVmYXVsdFBhZ2VJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHsgY2xhc3NOYW1lIH0gPSBfYSwgcmVzdCA9IF9fb2JqUmVzdChfYSwgW1wiY2xhc3NOYW1lXCJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICBjbGFzc05hbWVcbiAgfSwgcmVzdCksIHtcbiAgICB2aWV3Qm94OiBcIjAgMCAzMCAzMFwiLFxuICAgIHdpZHRoOiBcIjE2XCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE2LDFINHYyOGgyMlYxMUwxNiwxeiBNMTYsMy44MjhMMjMuMTcyLDExSDE2VjMuODI4eiBNMjQsMjdINlYzaDh2MTBoMTBWMjd6IE04LDE3aDE0di0ySDhWMTd6IE04LDIxaDE0di0ySDhWMjF6IE04LDI1aDE0di0ySDhWMjV6XCJcbiAgfSkpO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvbGF6eS1pbWFnZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0NSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVVybCB9IGZyb20gXCJub3Rpb24tdXRpbHNcIjtcbmltcG9ydCB7IEltYWdlU3RhdGUsIExhenlJbWFnZUZ1bGwgfSBmcm9tIFwicmVhY3QtbGF6eS1pbWFnZXNcIjtcbnZhciBMYXp5SW1hZ2UgPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICBzcmMsXG4gICAgYWx0LFxuICAgIGNsYXNzTmFtZSxcbiAgICBzdHlsZSxcbiAgICB6b29tYWJsZSA9IGZhbHNlLFxuICAgIHByaW9yaXR5ID0gZmFsc2UsXG4gICAgaGVpZ2h0XG4gIH0gPSBfYiwgcmVzdCA9IF9fb2JqUmVzdChfYiwgW1xuICAgIFwic3JjXCIsXG4gICAgXCJhbHRcIixcbiAgICBcImNsYXNzTmFtZVwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInpvb21hYmxlXCIsXG4gICAgXCJwcmlvcml0eVwiLFxuICAgIFwiaGVpZ2h0XCJcbiAgXSk7XG4gIHZhciBfYTIsIF9iMiwgX2M7XG4gIGNvbnN0IHsgcmVjb3JkTWFwLCB6b29tLCBwcmV2aWV3SW1hZ2VzLCBmb3JjZUN1c3RvbUltYWdlcywgY29tcG9uZW50cyB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICBjb25zdCB6b29tUmVmID0gUmVhY3Q1LnVzZVJlZih6b29tID8gem9vbS5jbG9uZSgpIDogbnVsbCk7XG4gIGNvbnN0IHByZXZpZXdJbWFnZSA9IHByZXZpZXdJbWFnZXMgPyAoX2MgPSAoX2EyID0gcmVjb3JkTWFwID09IG51bGwgPyB2b2lkIDAgOiByZWNvcmRNYXAucHJldmlld19pbWFnZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbc3JjXSkgIT0gbnVsbCA/IF9jIDogKF9iMiA9IHJlY29yZE1hcCA9PSBudWxsID8gdm9pZCAwIDogcmVjb3JkTWFwLnByZXZpZXdfaW1hZ2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyW25vcm1hbGl6ZVVybChzcmMpXSA6IG51bGw7XG4gIGNvbnN0IG9uTG9hZCA9IFJlYWN0NS51c2VDYWxsYmFjayhcbiAgICAoZSkgPT4ge1xuICAgICAgaWYgKHpvb21hYmxlICYmIChlLnRhcmdldC5zcmMgfHwgZS50YXJnZXQuc3Jjc2V0KSkge1xuICAgICAgICBpZiAoem9vbVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIHpvb21SZWYuY3VycmVudC5hdHRhY2goZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbem9vbVJlZiwgem9vbWFibGVdXG4gICk7XG4gIGNvbnN0IGF0dGFjaFpvb20gPSBSZWFjdDUudXNlQ2FsbGJhY2soXG4gICAgKGltYWdlKSA9PiB7XG4gICAgICBpZiAoem9vbVJlZi5jdXJyZW50ICYmIGltYWdlKSB7XG4gICAgICAgIDtcbiAgICAgICAgem9vbVJlZi5jdXJyZW50LmF0dGFjaChpbWFnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbem9vbVJlZl1cbiAgKTtcbiAgY29uc3QgYXR0YWNoWm9vbVJlZiA9IFJlYWN0NS51c2VNZW1vKFxuICAgICgpID0+IHpvb21hYmxlID8gYXR0YWNoWm9vbSA6IHZvaWQgMCxcbiAgICBbem9vbWFibGUsIGF0dGFjaFpvb21dXG4gICk7XG4gIGlmIChwcmV2aWV3SW1hZ2UpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHByZXZpZXdJbWFnZS5vcmlnaW5hbEhlaWdodCAvIHByZXZpZXdJbWFnZS5vcmlnaW5hbFdpZHRoO1xuICAgIGlmIChjb21wb25lbnRzLkltYWdlKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuSW1hZ2UsIHtcbiAgICAgICAgc3JjLFxuICAgICAgICBhbHQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHdpZHRoOiBwcmV2aWV3SW1hZ2Uub3JpZ2luYWxXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwcmV2aWV3SW1hZ2Uub3JpZ2luYWxIZWlnaHQsXG4gICAgICAgIGJsdXJEYXRhVVJMOiBwcmV2aWV3SW1hZ2UuZGF0YVVSSUJhc2U2NCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiYmx1clwiLFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgb25Mb2FkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChMYXp5SW1hZ2VGdWxsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHNyY1xuICAgIH0sIHJlc3QpLCB7XG4gICAgICBleHBlcmltZW50YWxEZWNvZGU6IHRydWVcbiAgICB9KSwgKHsgaW1hZ2VTdGF0ZSwgcmVmIH0pID0+IHtcbiAgICAgIGNvbnN0IGlzTG9hZGVkID0gaW1hZ2VTdGF0ZSA9PT0gSW1hZ2VTdGF0ZS5Mb2FkU3VjY2VzcztcbiAgICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgICB9O1xuICAgICAgY29uc3QgaW1nU3R5bGUgPSB7fTtcbiAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgd3JhcHBlclN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZ1N0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB3cmFwcGVyU3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke2FzcGVjdFJhdGlvICogMTAwfSVgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY3MoXG4gICAgICAgICAgXCJsYXp5LWltYWdlLXdyYXBwZXJcIixcbiAgICAgICAgICBpc0xvYWRlZCAmJiBcImxhenktaW1hZ2UtbG9hZGVkXCIsXG4gICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgICksXG4gICAgICAgIHN0eWxlOiB3cmFwcGVyU3R5bGVcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYXp5LWltYWdlLXByZXZpZXdcIixcbiAgICAgICAgc3JjOiBwcmV2aWV3SW1hZ2UuZGF0YVVSSUJhc2U2NCxcbiAgICAgICAgYWx0LFxuICAgICAgICByZWYsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhenktaW1hZ2UtcmVhbFwiLFxuICAgICAgICBzcmMsXG4gICAgICAgIGFsdCxcbiAgICAgICAgcmVmOiBhdHRhY2hab29tUmVmLFxuICAgICAgICBzdHlsZTogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHN0eWxlKSwgaW1nU3R5bGUpLFxuICAgICAgICB3aWR0aDogcHJldmlld0ltYWdlLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgIGhlaWdodDogcHJldmlld0ltYWdlLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBsb2FkaW5nOiBcImxhenlcIlxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChjb21wb25lbnRzLkltYWdlICYmIGZvcmNlQ3VzdG9tSW1hZ2VzKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuSW1hZ2UsIHtcbiAgICAgICAgc3JjLFxuICAgICAgICBhbHQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCBudWxsLFxuICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgb25Mb2FkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImltZ1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIHNyYyxcbiAgICAgIGFsdCxcbiAgICAgIHJlZjogYXR0YWNoWm9vbVJlZixcbiAgICAgIGxvYWRpbmc6IFwibGF6eVwiLFxuICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIlxuICAgIH0sIHJlc3QpKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvcGFnZS1pY29uLnRzeFxudmFyIGlzSWNvbkJsb2NrID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZS50eXBlID09PSBcInBhZ2VcIiB8fCB2YWx1ZS50eXBlID09PSBcImNhbGxvdXRcIiB8fCB2YWx1ZS50eXBlID09PSBcImNvbGxlY3Rpb25fdmlld1wiIHx8IHZhbHVlLnR5cGUgPT09IFwiY29sbGVjdGlvbl92aWV3X3BhZ2VcIjtcbn07XG52YXIgUGFnZUljb25JbXBsID0gKHtcbiAgYmxvY2ssXG4gIGNsYXNzTmFtZSxcbiAgaW5saW5lID0gdHJ1ZSxcbiAgaGlkZURlZmF1bHRJY29uID0gZmFsc2UsXG4gIGRlZmF1bHRJY29uXG59KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBtYXBJbWFnZVVybCwgcmVjb3JkTWFwLCBkYXJrTW9kZSB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICBsZXQgaXNJbWFnZSA9IGZhbHNlO1xuICBsZXQgY29udGVudCA9IG51bGw7XG4gIGlmIChpc0ljb25CbG9jayhibG9jaykpIHtcbiAgICBjb25zdCBpY29uID0gKChfYSA9IGdldEJsb2NrSWNvbihibG9jaywgcmVjb3JkTWFwKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRyaW0oKSkgfHwgZGVmYXVsdEljb247XG4gICAgY29uc3QgdGl0bGUgPSBnZXRCbG9ja1RpdGxlKGJsb2NrLCByZWNvcmRNYXApO1xuICAgIGlmIChpY29uICYmIGlzVXJsKGljb24pKSB7XG4gICAgICBjb25zdCB1cmwgPSBtYXBJbWFnZVVybChpY29uLCBibG9jayk7XG4gICAgICBpc0ltYWdlID0gdHJ1ZTtcbiAgICAgIGNvbnRlbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoTGF6eUltYWdlLCB7XG4gICAgICAgIHNyYzogdXJsLFxuICAgICAgICBhbHQ6IHRpdGxlIHx8IFwicGFnZSBpY29uXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY3MoY2xhc3NOYW1lLCBcIm5vdGlvbi1wYWdlLWljb25cIilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaWNvbiAmJiBpY29uLnN0YXJ0c1dpdGgoXCIvaWNvbnMvXCIpKSB7XG4gICAgICBjb25zdCB1cmwgPSBcImh0dHBzOi8vd3d3Lm5vdGlvbi5zb1wiICsgaWNvbiArIFwiP21vZGU9XCIgKyAoZGFya01vZGUgPyBcImRhcmtcIiA6IFwibGlnaHRcIik7XG4gICAgICBjb250ZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KExhenlJbWFnZSwge1xuICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgYWx0OiB0aXRsZSB8fCBcInBhZ2UgaWNvblwiLFxuICAgICAgICBjbGFzc05hbWU6IGNzKGNsYXNzTmFtZSwgXCJub3Rpb24tcGFnZS1pY29uXCIpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpY29uKSB7XG4gICAgICBpZiAoIWhpZGVEZWZhdWx0SWNvbikge1xuICAgICAgICBpc0ltYWdlID0gdHJ1ZTtcbiAgICAgICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChEZWZhdWx0UGFnZUljb24sIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNzKGNsYXNzTmFtZSwgXCJub3Rpb24tcGFnZS1pY29uXCIpLFxuICAgICAgICAgIGFsdDogdGl0bGUgPyB0aXRsZSA6IFwicGFnZSBpY29uXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzSW1hZ2UgPSBmYWxzZTtcbiAgICAgIGNvbnRlbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjcyhjbGFzc05hbWUsIFwibm90aW9uLXBhZ2UtaWNvblwiKSxcbiAgICAgICAgcm9sZTogXCJpbWdcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGljb25cbiAgICAgIH0sIGljb24pO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNzKFxuICAgICAgaW5saW5lID8gXCJub3Rpb24tcGFnZS1pY29uLWlubGluZVwiIDogXCJub3Rpb24tcGFnZS1pY29uLWhlcm9cIixcbiAgICAgIGlzSW1hZ2UgPyBcIm5vdGlvbi1wYWdlLWljb24taW1hZ2VcIiA6IFwibm90aW9uLXBhZ2UtaWNvbi1zcGFuXCJcbiAgICApXG4gIH0sIGNvbnRlbnQpO1xufTtcbnZhciBQYWdlSWNvbiA9IFJlYWN0Ni5tZW1vKFBhZ2VJY29uSW1wbCk7XG5cbi8vIHNyYy9jb21wb25lbnRzL3BhZ2UtdGl0bGUudHN4XG52YXIgUGFnZVRpdGxlSW1wbCA9IChfYSkgPT4ge1xuICB2YXIgX2IgPSBfYSwgeyBibG9jaywgY2xhc3NOYW1lLCBkZWZhdWx0SWNvbiB9ID0gX2IsIHJlc3QgPSBfX29ialJlc3QoX2IsIFtcImJsb2NrXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGVmYXVsdEljb25cIl0pO1xuICB2YXIgX2EyLCBfYjI7XG4gIGNvbnN0IHsgcmVjb3JkTWFwIH0gPSB1c2VOb3Rpb25Db250ZXh0KCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChibG9jay50eXBlID09PSBcImNvbGxlY3Rpb25fdmlld19wYWdlXCIgfHwgYmxvY2sudHlwZSA9PT0gXCJjb2xsZWN0aW9uX3ZpZXdcIikge1xuICAgIGNvbnN0IHRpdGxlID0gZ2V0QmxvY2tUaXRsZTIoYmxvY2ssIHJlY29yZE1hcCk7XG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlRGVjb3JhdGlvbiA9IFtbdGl0bGVdXTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjbGFzc05hbWU6IGNzKFwibm90aW9uLXBhZ2UtdGl0bGVcIiwgY2xhc3NOYW1lKVxuICAgIH0sIHJlc3QpLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoUGFnZUljb24sIHtcbiAgICAgIGJsb2NrLFxuICAgICAgZGVmYXVsdEljb24sXG4gICAgICBjbGFzc05hbWU6IFwibm90aW9uLXBhZ2UtdGl0bGUtaWNvblwiXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1wYWdlLXRpdGxlLXRleHRcIlxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChUZXh0LCB7XG4gICAgICB2YWx1ZTogdGl0bGVEZWNvcmF0aW9uLFxuICAgICAgYmxvY2tcbiAgICB9KSkpO1xuICB9XG4gIGlmICghKChfYTIgPSBibG9jay5wcm9wZXJ0aWVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRpdGxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9fc3ByZWFkVmFsdWVzKHtcbiAgICBjbGFzc05hbWU6IGNzKFwibm90aW9uLXBhZ2UtdGl0bGVcIiwgY2xhc3NOYW1lKVxuICB9LCByZXN0KSwgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFBhZ2VJY29uLCB7XG4gICAgYmxvY2ssXG4gICAgZGVmYXVsdEljb24sXG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1wYWdlLXRpdGxlLWljb25cIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1wYWdlLXRpdGxlLXRleHRcIlxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIHZhbHVlOiAoX2IyID0gYmxvY2sucHJvcGVydGllcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi50aXRsZSxcbiAgICBibG9ja1xuICB9KSkpO1xufTtcbnZhciBQYWdlVGl0bGUgPSBSZWFjdDcubWVtbyhQYWdlVGl0bGVJbXBsKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvdGV4dC50c3hcbnZhciBUZXh0ID0gKHsgdmFsdWUsIGJsb2NrLCBsaW5rUHJvcHMsIGxpbmtQcm90b2NvbCB9KSA9PiB7XG4gIGNvbnN0IHsgY29tcG9uZW50cywgcmVjb3JkTWFwLCBtYXBQYWdlVXJsLCBtYXBJbWFnZVVybCwgcm9vdERvbWFpbiB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFJlYWN0OC5GcmFnbWVudCwgbnVsbCwgdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLm1hcCgoW3RleHQsIGRlY29yYXRpb25zXSwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWRlY29yYXRpb25zKSB7XG4gICAgICBpZiAodGV4dCA9PT0gXCIsXCIpIHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgc3R5bGU6IHsgcGFkZGluZzogXCIwLjVlbVwiIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFJlYWN0OC5GcmFnbWVudCwge1xuICAgICAgICAgIGtleTogaW5kZXhcbiAgICAgICAgfSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGRlY29yYXRpb25zLnJlZHVjZShcbiAgICAgIChlbGVtZW50LCBkZWNvcmF0b3IpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgc3dpdGNoIChkZWNvcmF0b3JbMF0pIHtcbiAgICAgICAgICBjYXNlIFwicFwiOiB7XG4gICAgICAgICAgICBjb25zdCBibG9ja0lkID0gZGVjb3JhdG9yWzFdO1xuICAgICAgICAgICAgY29uc3QgbGlua2VkQmxvY2sgPSAoX2EgPSByZWNvcmRNYXAuYmxvY2tbYmxvY2tJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghbGlua2VkQmxvY2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1wicFwiIG1pc3NpbmcgYmxvY2snLCBibG9ja0lkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuUGFnZUxpbmssIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1saW5rXCIsXG4gICAgICAgICAgICAgIGhyZWY6IG1hcFBhZ2VVcmwoYmxvY2tJZClcbiAgICAgICAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChQYWdlVGl0bGUsIHtcbiAgICAgICAgICAgICAgYmxvY2s6IGxpbmtlZEJsb2NrXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXHUyMDIzXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtUeXBlID0gZGVjb3JhdG9yWzFdWzBdO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBkZWNvcmF0b3JbMV1bMV07XG4gICAgICAgICAgICBzd2l0Y2ggKGxpbmtUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gKF9iID0gcmVjb3JkTWFwLm5vdGlvbl91c2VyW2lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1wiXFx1MjAyM1wiIG1pc3NpbmcgdXNlcicsIGlkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gW3VzZXIuZ2l2ZW5fbmFtZSwgdXNlci5mYW1pbHlfbmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoR3JhY2VmdWxJbWFnZSwge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi11c2VyXCIsXG4gICAgICAgICAgICAgICAgICBzcmM6IG1hcEltYWdlVXJsKHVzZXIucHJvZmlsZV9waG90bywgYmxvY2spLFxuICAgICAgICAgICAgICAgICAgYWx0OiBuYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtlZEJsb2NrID0gKF9jID0gcmVjb3JkTWFwLmJsb2NrW2lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbGlua2VkQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcIlxcdTIwMjNcIiBtaXNzaW5nIGJsb2NrJywgbGlua1R5cGUsIGlkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuUGFnZUxpbmssIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1saW5rXCIsXG4gICAgICAgICAgICAgICAgICBocmVmOiBtYXBQYWdlVXJsKGlkKVxuICAgICAgICAgICAgICAgIH0sIGxpbmtQcm9wcyksIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFBhZ2VUaXRsZSwge1xuICAgICAgICAgICAgICAgICAgYmxvY2s6IGxpbmtlZEJsb2NrXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogYG5vdGlvbi0ke2RlY29yYXRvclsxXX1gXG4gICAgICAgICAgICB9LCBlbGVtZW50KTtcbiAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLWlubGluZS1jb2RlXCJcbiAgICAgICAgICAgIH0sIGVsZW1lbnQpO1xuICAgICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFwiYlwiLCBudWxsLCBlbGVtZW50KTtcbiAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcImVtXCIsIG51bGwsIGVsZW1lbnQpO1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFwic1wiLCBudWxsLCBlbGVtZW50KTtcbiAgICAgICAgICBjYXNlIFwiX1wiOlxuICAgICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLWlubGluZS11bmRlcnNjb3JlXCJcbiAgICAgICAgICAgIH0sIGVsZW1lbnQpO1xuICAgICAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuRXF1YXRpb24sIHtcbiAgICAgICAgICAgICAgbWF0aDogZGVjb3JhdG9yWzFdLFxuICAgICAgICAgICAgICBpbmxpbmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZGVjb3JhdG9yWzFdO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSB2LnN1YnN0cigxKTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gcGFyc2VQYWdlSWQocGF0aG5hbWUsIHsgdXVpZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICgodlswXSA9PT0gXCIvXCIgfHwgdi5pbmNsdWRlcyhyb290RG9tYWluKSkgJiYgaWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IHYuaW5jbHVkZXMocm9vdERvbWFpbikgPyB2IDogYCR7bWFwUGFnZVVybChpZCl9JHtnZXRIYXNoRnJhZ21lbnRWYWx1ZSh2KX1gO1xuICAgICAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuUGFnZUxpbmssIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLWxpbmtcIixcbiAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgIH0sIGxpbmtQcm9wcyksIGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChjb21wb25lbnRzLkxpbmssIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLWxpbmtcIixcbiAgICAgICAgICAgICAgICBocmVmOiBsaW5rUHJvdG9jb2wgPyBgJHtsaW5rUHJvdG9jb2x9OiR7ZGVjb3JhdG9yWzFdfWAgOiBkZWNvcmF0b3JbMV1cbiAgICAgICAgICAgICAgfSwgbGlua1Byb3BzKSwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBkZWNvcmF0b3JbMV07XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdiA9PSBudWxsID8gdm9pZCAwIDogdi50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IHYuc3RhcnRfZGF0ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoc3RhcnREYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkYXRlcmFuZ2VcIikge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydERhdGUgPSB2LnN0YXJ0X2RhdGU7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZERhdGUgPSB2LmVuZF9kYXRlO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7Zm9ybWF0RGF0ZShzdGFydERhdGUpfSBcXHUyMTkyICR7Zm9ybWF0RGF0ZShlbmREYXRlKX1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZCA9IGRlY29yYXRvclsxXTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSAoX2QgPSByZWNvcmRNYXAubm90aW9uX3VzZXJbdXNlcklkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibWlzc2luZyB1c2VyXCIsIHVzZXJJZCk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IFt1c2VyLmdpdmVuX25hbWUsIHVzZXIuZmFtaWx5X25hbWVdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoR3JhY2VmdWxJbWFnZSwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLXVzZXJcIixcbiAgICAgICAgICAgICAgc3JjOiBtYXBJbWFnZVVybCh1c2VyLnByb2ZpbGVfcGhvdG8sIGJsb2NrKSxcbiAgICAgICAgICAgICAgYWx0OiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVvaVwiOiB7XG4gICAgICAgICAgICBjb25zdCBibG9ja0lkID0gZGVjb3JhdG9yWzFdO1xuICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxPYmplY3RJbnN0YW5jZSA9IChfZSA9IHJlY29yZE1hcC5ibG9ja1tibG9ja0lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChFT0ksIHtcbiAgICAgICAgICAgICAgYmxvY2s6IGV4dGVybmFsT2JqZWN0SW5zdGFuY2UsXG4gICAgICAgICAgICAgIGlubGluZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVuc3VwcG9ydGVkIHRleHQgZm9ybWF0XCIsIGRlY29yYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChSZWFjdDguRnJhZ21lbnQsIG51bGwsIHRleHQpXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFJlYWN0OC5GcmFnbWVudCwge1xuICAgICAga2V5OiBpbmRleFxuICAgIH0sIGZvcm1hdHRlZCk7XG4gIH0pKTtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL2hlYWRlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRQYWdlQnJlYWRjcnVtYnMgfSBmcm9tIFwibm90aW9uLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VIb3RrZXlzIH0gZnJvbSBcInJlYWN0LWhvdGtleXMtaG9va1wiO1xuXG4vLyBzcmMvaWNvbnMvc2VhcmNoLWljb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdDkgZnJvbSBcInJlYWN0XCI7XG52YXIgU2VhcmNoSWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBfYSA9IHByb3BzLCB7IGNsYXNzTmFtZSB9ID0gX2EsIHJlc3QgPSBfX29ialJlc3QoX2EsIFtcImNsYXNzTmFtZVwiXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgIGNsYXNzTmFtZTogY3MoXCJub3Rpb24taWNvblwiLCBjbGFzc05hbWUpLFxuICAgIHZpZXdCb3g6IFwiMCAwIDE3IDE3XCJcbiAgfSwgcmVzdCksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTYuNzgwMjcgMTMuNjcyOUM4LjI0ODA1IDEzLjY3MjkgOS42MDE1NiAxMy4xOTgyIDEwLjcwOSAxMi40MDcyTDE0Ljg3NSAxNi41NzMyQzE1LjA2ODQgMTYuNzY2NiAxNS4zMjMyIDE2Ljg2MzMgMTUuNTk1NyAxNi44NjMzQzE2LjE2NyAxNi44NjMzIDE2LjU3MTMgMTYuNDIzOCAxNi41NzEzIDE1Ljg2MTNDMTYuNTcxMyAxNS41OTc3IDE2LjQ4MzQgMTUuMzUxNiAxNi4yOSAxNS4xNTgyTDEyLjE1MDQgMTEuMDA5OEMxMy4wMjA1IDkuODY3MTkgMTMuNTM5MSA4LjQ1MjE1IDEzLjUzOTEgNi45MTQwNkMxMy41MzkxIDMuMTk2MjkgMTAuNDk4IDAuMTU1MjczIDYuNzgwMjcgMC4xNTUyNzNDMy4wNjI1IDAuMTU1MjczIDAuMDIxNDg0NCAzLjE5NjI5IDAuMDIxNDg0NCA2LjkxNDA2QzAuMDIxNDg0NCAxMC42MzE4IDMuMDYyNSAxMy42NzI5IDYuNzgwMjcgMTMuNjcyOVpNNi43ODAyNyAxMi4yMTM5QzMuODc5ODggMTIuMjEzOSAxLjQ4MDQ3IDkuODE0NDUgMS40ODA0NyA2LjkxNDA2QzEuNDgwNDcgNC4wMTM2NyAzLjg3OTg4IDEuNjE0MjYgNi43ODAyNyAxLjYxNDI2QzkuNjgwNjYgMS42MTQyNiAxMi4wODAxIDQuMDEzNjcgMTIuMDgwMSA2LjkxNDA2QzEyLjA4MDEgOS44MTQ0NSA5LjY4MDY2IDEyLjIxMzkgNi43ODAyNyAxMi4yMTM5WlwiXG4gIH0pKTtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL3NlYXJjaC1kaWFsb2cudHN4XG52YXIgaW1wb3J0X2xvZGFzaCA9IF9fdG9FU00ocmVxdWlyZV9sb2Rhc2goKSwgMSk7XG5pbXBvcnQgKiBhcyBSZWFjdDEyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0QmxvY2tQYXJlbnRQYWdlLCBnZXRCbG9ja1RpdGxlIGFzIGdldEJsb2NrVGl0bGUzIH0gZnJvbSBcIm5vdGlvbi11dGlsc1wiO1xuXG4vLyBzcmMvaWNvbnMvY2xlYXItaWNvbi50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTAgZnJvbSBcInJlYWN0XCI7XG52YXIgQ2xlYXJJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHsgY2xhc3NOYW1lIH0gPSBfYSwgcmVzdCA9IF9fb2JqUmVzdChfYSwgW1wiY2xhc3NOYW1lXCJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgY2xhc3NOYW1lOiBjcyhcIm5vdGlvbi1pY29uXCIsIGNsYXNzTmFtZSlcbiAgfSwgcmVzdCksIHtcbiAgICB2aWV3Qm94OiBcIjAgMCAzMCAzMFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTUsMEM2LjcxNiwwLDAsNi43MTYsMCwxNXM2LjcxNiwxNSwxNSwxNXMxNS02LjcxNiwxNS0xNVMyMy4yODQsMCwxNSwweiBNMjIsMjAuNkwyMC42LDIyTDE1LDE2LjRMOS40LDIyTDgsMjAuNmw1LjYtNS42IEw4LDkuNEw5LjQsOGw1LjYsNS42TDIwLjYsOEwyMiw5LjRMMTYuNCwxNUwyMiwyMC42elwiXG4gIH0pKTtcbn07XG5cbi8vIHNyYy9pY29ucy9sb2FkaW5nLWljb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdDExIGZyb20gXCJyZWFjdFwiO1xudmFyIExvYWRpbmdJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHsgY2xhc3NOYW1lIH0gPSBfYSwgcmVzdCA9IF9fb2JqUmVzdChfYSwgW1wiY2xhc3NOYW1lXCJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgY2xhc3NOYW1lOiBjcyhcIm5vdGlvbi1pY29uXCIsIGNsYXNzTmFtZSlcbiAgfSwgcmVzdCksIHtcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwge1xuICAgIHgxOiBcIjI4LjE1NDI5NjklXCIsXG4gICAgeTE6IFwiNjMuNzQwMjM0NCVcIixcbiAgICB4MjogXCI3NC42Mjg5MDYyJVwiLFxuICAgIHkyOiBcIjE3Ljc4MzIwMzElXCIsXG4gICAgaWQ6IFwibGluZWFyR3JhZGllbnQtMVwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHtcbiAgICBzdG9wQ29sb3I6IFwicmdiYSgxNjQsIDE2NCwgMTY0LCAxKVwiLFxuICAgIG9mZnNldDogXCIwJVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7XG4gICAgc3RvcENvbG9yOiBcInJnYmEoMTY0LCAxNjQsIDE2NCwgMClcIixcbiAgICBzdG9wT3BhY2l0eTogXCIwXCIsXG4gICAgb2Zmc2V0OiBcIjEwMCVcIlxuICB9KSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgaWQ6IFwiUGFnZS0xXCIsXG4gICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgZmlsbDogXCJub25lXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTIzNi4wMDAwMDAsIC0yODYuMDAwMDAwKVwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDIzOC4wMDAwMDAsIDI4Ni4wMDAwMDApXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgaWQ6IFwiT3ZhbC0yXCIsXG4gICAgc3Ryb2tlOiBcInVybCgjbGluZWFyR3JhZGllbnQtMSlcIixcbiAgICBzdHJva2VXaWR0aDogXCI0XCIsXG4gICAgY3g6IFwiMTBcIixcbiAgICBjeTogXCIxMlwiLFxuICAgIHI6IFwiMTBcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEwLDIgQzQuNDc3MTUyNSwyIDAsNi40NzcxNTI1IDAsMTJcIixcbiAgICBpZDogXCJPdmFsLTJcIixcbiAgICBzdHJva2U6IFwicmdiYSgxNjQsIDE2NCwgMTY0LCAxKVwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjRcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGlkOiBcIlJlY3RhbmdsZS0xXCIsXG4gICAgZmlsbDogXCJyZ2JhKDE2NCwgMTY0LCAxNjQsIDEpXCIsXG4gICAgeDogXCI4XCIsXG4gICAgeTogXCIwXCIsXG4gICAgd2lkdGg6IFwiNFwiLFxuICAgIGhlaWdodDogXCI0XCIsXG4gICAgcng6IFwiOFwiXG4gIH0pKSkpKTtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL3NlYXJjaC1kaWFsb2cudHN4XG52YXIgU2VhcmNoRGlhbG9nID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDEyLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgcXVlcnk6IFwiXCIsXG4gICAgICBzZWFyY2hSZXN1bHQ6IG51bGwsXG4gICAgICBzZWFyY2hFcnJvcjogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fb25BZnRlck9wZW4gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICB0aGlzLl9pbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkNoYW5nZVF1ZXJ5ID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgcXVlcnkgfSk7XG4gICAgICBpZiAoIXF1ZXJ5LnRyaW0oKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNMb2FkaW5nOiBmYWxzZSwgc2VhcmNoUmVzdWx0OiBudWxsLCBzZWFyY2hFcnJvcjogbnVsbCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VhcmNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkNsZWFyUXVlcnkgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5nZVF1ZXJ5KHsgdGFyZ2V0OiB7IHZhbHVlOiBcIlwiIH0gfSk7XG4gICAgfTtcbiAgICB0aGlzLl93YXJtdXBTZWFyY2ggPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IHNlYXJjaE5vdGlvbiwgcm9vdEJsb2NrSWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICB5aWVsZCBzZWFyY2hOb3Rpb24oe1xuICAgICAgICBxdWVyeTogXCJcIixcbiAgICAgICAgYW5jZXN0b3JJZDogcm9vdEJsb2NrSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3NlYXJjaEltcGwgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7IHNlYXJjaE5vdGlvbiwgcm9vdEJsb2NrSWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7IHF1ZXJ5IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKCFxdWVyeS50cmltKCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzTG9hZGluZzogZmFsc2UsIHNlYXJjaFJlc3VsdDogbnVsbCwgc2VhcmNoRXJyb3I6IG51bGwgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzZWFyY2hOb3Rpb24oe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgYW5jZXN0b3JJZDogcm9vdEJsb2NrSWRcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coXCJzZWFyY2hcIiwgcXVlcnksIHJlc3VsdCk7XG4gICAgICBsZXQgc2VhcmNoUmVzdWx0ID0gbnVsbDtcbiAgICAgIGxldCBzZWFyY2hFcnJvciA9IG51bGw7XG4gICAgICBpZiAocmVzdWx0LmVycm9yIHx8IHJlc3VsdC5lcnJvcklkKSB7XG4gICAgICAgIHNlYXJjaEVycm9yID0gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoUmVzdWx0ID0gX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBzZWFyY2hSZXN1bHQucmVzdWx0cy5tYXAoKHJlc3VsdDIpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIGNvbnN0IGJsb2NrID0gKF9hID0gc2VhcmNoUmVzdWx0LnJlY29yZE1hcC5ibG9ja1tyZXN1bHQyLmlkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICAgICAgICAgIGlmICghYmxvY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgdGl0bGUgPSBnZXRCbG9ja1RpdGxlMyhibG9jaywgc2VhcmNoUmVzdWx0LnJlY29yZE1hcCk7XG4gICAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQyLnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgcmVzdWx0Mi5ibG9jayA9IGJsb2NrO1xuICAgICAgICAgIHJlc3VsdDIucmVjb3JkTWFwID0gc2VhcmNoUmVzdWx0LnJlY29yZE1hcDtcbiAgICAgICAgICByZXN1bHQyLnBhZ2UgPSBnZXRCbG9ja1BhcmVudFBhZ2UoYmxvY2ssIHNlYXJjaFJlc3VsdC5yZWNvcmRNYXAsIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pIHx8IGJsb2NrO1xuICAgICAgICAgIGlmICghcmVzdWx0Mi5wYWdlLmlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoX2IgPSByZXN1bHQyLmhpZ2hsaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRleHQpIHtcbiAgICAgICAgICAgIHJlc3VsdDIuaGlnaGxpZ2h0Lmh0bWwgPSByZXN1bHQyLmhpZ2hsaWdodC50ZXh0LnJlcGxhY2UoLzxnemtOZm9VVT4vZ2ksIFwiPGI+XCIpLnJlcGxhY2UoLzxcXC9nemtOZm9VVT4vZ2ksIFwiPC9iPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0c01hcCA9IHJlc3VsdHMucmVkdWNlKFxuICAgICAgICAgIChtYXAsIHJlc3VsdDIpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1hcCksIHtcbiAgICAgICAgICAgIFtyZXN1bHQyLnBhZ2UuaWRdOiByZXN1bHQyXG4gICAgICAgICAgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgICAgc2VhcmNoUmVzdWx0LnJlc3VsdHMgPSBPYmplY3QudmFsdWVzKHNlYXJjaFJlc3VsdHNNYXApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUucXVlcnkgPT09IHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0xvYWRpbmc6IGZhbHNlLCBzZWFyY2hSZXN1bHQsIHNlYXJjaEVycm9yIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2lucHV0UmVmID0gUmVhY3QxMi5jcmVhdGVSZWYoKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLl9zZWFyY2ggPSAoMCwgaW1wb3J0X2xvZGFzaC5kZWZhdWx0KSh0aGlzLl9zZWFyY2hJbXBsLmJpbmQodGhpcyksIDFlMyk7XG4gICAgdGhpcy5fd2FybXVwU2VhcmNoKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNPcGVuLCBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaXNMb2FkaW5nLCBxdWVyeSwgc2VhcmNoUmVzdWx0LCBzZWFyY2hFcnJvciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNRdWVyeSA9ICEhcXVlcnkudHJpbSgpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KE5vdGlvbkNvbnRleHRDb25zdW1lciwgbnVsbCwgKGN0eDIpID0+IHtcbiAgICAgIGNvbnN0IHsgY29tcG9uZW50cywgZGVmYXVsdFBhZ2VJY29uLCBtYXBQYWdlVXJsIH0gPSBjdHgyO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cy5Nb2RhbCwge1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIGNvbnRlbnRMYWJlbDogXCJTZWFyY2hcIixcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1zZWFyY2hcIixcbiAgICAgICAgb3ZlcmxheUNsYXNzTmFtZTogXCJub3Rpb24tc2VhcmNoLW92ZXJsYXlcIixcbiAgICAgICAgb25SZXF1ZXN0Q2xvc2U6IG9uQ2xvc2UsXG4gICAgICAgIG9uQWZ0ZXJPcGVuOiB0aGlzLl9vbkFmdGVyT3BlblxuICAgICAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJxdWlja0ZpbmRNZW51XCJcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwic2VhcmNoQmFyXCJcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiaW5saW5lSWNvblwiXG4gICAgICB9LCBpc0xvYWRpbmcgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KExvYWRpbmdJY29uLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsb2FkaW5nSWNvblwiXG4gICAgICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoU2VhcmNoSWNvbiwgbnVsbCkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwic2VhcmNoSW5wdXRcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiU2VhcmNoXCIsXG4gICAgICAgIHZhbHVlOiBxdWVyeSxcbiAgICAgICAgcmVmOiB0aGlzLl9pbnB1dFJlZixcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMuX29uQ2hhbmdlUXVlcnlcbiAgICAgIH0pLCBxdWVyeSAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcImNsZWFyQnV0dG9uXCIsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xlYXJRdWVyeVxuICAgICAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChDbGVhckljb24sIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNsZWFySWNvblwiXG4gICAgICB9KSkpLCBoYXNRdWVyeSAmJiBzZWFyY2hSZXN1bHQgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZWFjdDEyLkZyYWdtZW50LCBudWxsLCBzZWFyY2hSZXN1bHQucmVzdWx0cy5sZW5ndGggPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KE5vdGlvbkNvbnRleHRQcm92aWRlciwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY3R4MiksIHtcbiAgICAgICAgcmVjb3JkTWFwOiBzZWFyY2hSZXN1bHQucmVjb3JkTWFwXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZXN1bHRzUGFuZVwiXG4gICAgICB9LCBzZWFyY2hSZXN1bHQucmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuUGFnZUxpbmssIHtcbiAgICAgICAgICBrZXk6IHJlc3VsdC5pZCxcbiAgICAgICAgICBjbGFzc05hbWU6IGNzKFwicmVzdWx0XCIsIFwibm90aW9uLXBhZ2UtbGlua1wiKSxcbiAgICAgICAgICBocmVmOiBtYXBQYWdlVXJsKFxuICAgICAgICAgICAgcmVzdWx0LnBhZ2UuaWQsXG4gICAgICAgICAgICBzZWFyY2hSZXN1bHQucmVjb3JkTWFwXG4gICAgICAgICAgKVxuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFBhZ2VUaXRsZSwge1xuICAgICAgICAgIGJsb2NrOiByZXN1bHQucGFnZSxcbiAgICAgICAgICBkZWZhdWx0SWNvbjogZGVmYXVsdFBhZ2VJY29uXG4gICAgICAgIH0pLCAoKF9hID0gcmVzdWx0LmhpZ2hsaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmh0bWwpICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJub3Rpb24tc2VhcmNoLXJlc3VsdC1oaWdobGlnaHRcIixcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgX19odG1sOiByZXN1bHQuaGlnaGxpZ2h0Lmh0bWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pKSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZXN1bHRzRm9vdGVyXCJcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVzdWx0c0NvdW50XCJcbiAgICAgIH0sIHNlYXJjaFJlc3VsdC50b3RhbCksIHNlYXJjaFJlc3VsdC50b3RhbCA9PT0gMSA/IFwiIHJlc3VsdFwiIDogXCIgcmVzdWx0c1wiKSkpIDogLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJub1Jlc3VsdHNQYW5lXCJcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwibm9SZXN1bHRzXCJcbiAgICAgIH0sIFwiTm8gcmVzdWx0c1wiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJub1Jlc3VsdHNEZXRhaWxcIlxuICAgICAgfSwgXCJUcnkgZGlmZmVyZW50IHNlYXJjaCB0ZXJtc1wiKSkpLCBoYXNRdWVyeSAmJiAhc2VhcmNoUmVzdWx0ICYmIHNlYXJjaEVycm9yICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwibm9SZXN1bHRzUGFuZVwiXG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5vUmVzdWx0c1wiXG4gICAgICB9LCBcIlNlYXJjaCBlcnJvclwiKSkpKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvaGVhZGVyLnRzeFxudmFyIEhlYWRlciA9ICh7IGJsb2NrIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoXCJoZWFkZXJcIiwge1xuICAgIGNsYXNzTmFtZTogXCJub3Rpb24taGVhZGVyXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1uYXYtaGVhZGVyXCJcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChCcmVhZGNydW1icywge1xuICAgIGJsb2NrXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KFNlYXJjaCwge1xuICAgIGJsb2NrXG4gIH0pKSk7XG59O1xudmFyIEJyZWFkY3J1bWJzID0gKHsgYmxvY2ssIHJvb3RPbmx5ID0gZmFsc2UgfSkgPT4ge1xuICBjb25zdCB7IHJlY29yZE1hcCwgbWFwUGFnZVVybCwgY29tcG9uZW50cyB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICBjb25zdCBicmVhZGNydW1icyA9IFJlYWN0MTMudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYnJlYWRjcnVtYnMyID0gZ2V0UGFnZUJyZWFkY3J1bWJzKHJlY29yZE1hcCwgYmxvY2suaWQpO1xuICAgIGlmIChyb290T25seSkge1xuICAgICAgcmV0dXJuIFticmVhZGNydW1iczJbMF1dLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gICAgcmV0dXJuIGJyZWFkY3J1bWJzMjtcbiAgfSwgW3JlY29yZE1hcCwgYmxvY2suaWQsIHJvb3RPbmx5XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiYnJlYWRjcnVtYnNcIixcbiAgICBrZXk6IFwiYnJlYWRjcnVtYnNcIlxuICB9LCBicmVhZGNydW1icy5tYXAoKGJyZWFkY3J1bWIsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFicmVhZGNydW1iKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFnZUxpbmtQcm9wcyA9IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudE1hcCA9IHtcbiAgICAgIHBhZ2VMaW5rOiBjb21wb25lbnRzLlBhZ2VMaW5rXG4gICAgfTtcbiAgICBpZiAoYnJlYWRjcnVtYi5hY3RpdmUpIHtcbiAgICAgIGNvbXBvbmVudE1hcC5wYWdlTGluayA9IChwcm9wcykgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZUxpbmtQcm9wcy5ocmVmID0gbWFwUGFnZVVybChicmVhZGNydW1iLnBhZ2VJZCk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KFJlYWN0MTMuRnJhZ21lbnQsIHtcbiAgICAgIGtleTogYnJlYWRjcnVtYi5wYWdlSWRcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudE1hcC5wYWdlTGluaywgX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2xhc3NOYW1lOiBjcyhcImJyZWFkY3J1bWJcIiwgYnJlYWRjcnVtYi5hY3RpdmUgJiYgXCJhY3RpdmVcIilcbiAgICB9LCBwYWdlTGlua1Byb3BzKSwgYnJlYWRjcnVtYi5pY29uICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoUGFnZUljb24sIHtcbiAgICAgIGNsYXNzTmFtZTogXCJpY29uXCIsXG4gICAgICBibG9jazogYnJlYWRjcnVtYi5ibG9ja1xuICAgIH0pLCBicmVhZGNydW1iLnRpdGxlICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJ0aXRsZVwiXG4gICAgfSwgYnJlYWRjcnVtYi50aXRsZSkpLCBpbmRleCA8IGJyZWFkY3J1bWJzLmxlbmd0aCAtIDEgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInNwYWNlclwiXG4gICAgfSwgXCIvXCIpKTtcbiAgfSkpO1xufTtcbnZhciBTZWFyY2ggPSAoeyBibG9jaywgc2VhcmNoLCB0aXRsZSA9IFwiU2VhcmNoXCIgfSkgPT4ge1xuICBjb25zdCB7IHNlYXJjaE5vdGlvbiwgcm9vdFBhZ2VJZCwgaXNTaG93aW5nU2VhcmNoLCBvbkhpZGVTZWFyY2ggfSA9IHVzZU5vdGlvbkNvbnRleHQoKTtcbiAgY29uc3Qgb25TZWFyY2hOb3Rpb24gPSBzZWFyY2ggfHwgc2VhcmNoTm90aW9uO1xuICBjb25zdCBbaXNTZWFyY2hPcGVuLCBzZXRJc1NlYXJjaE9wZW5dID0gUmVhY3QxMy51c2VTdGF0ZShpc1Nob3dpbmdTZWFyY2gpO1xuICBSZWFjdDEzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNTZWFyY2hPcGVuKGlzU2hvd2luZ1NlYXJjaCk7XG4gIH0sIFtpc1Nob3dpbmdTZWFyY2hdKTtcbiAgY29uc3Qgb25PcGVuU2VhcmNoID0gUmVhY3QxMy51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNTZWFyY2hPcGVuKHRydWUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IG9uQ2xvc2VTZWFyY2ggPSBSZWFjdDEzLnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc1NlYXJjaE9wZW4oZmFsc2UpO1xuICAgIGlmIChvbkhpZGVTZWFyY2gpIHtcbiAgICAgIG9uSGlkZVNlYXJjaCgpO1xuICAgIH1cbiAgfSwgW29uSGlkZVNlYXJjaF0pO1xuICB1c2VIb3RrZXlzKFwiY21kK3BcIiwgKGV2ZW50KSA9PiB7XG4gICAgb25PcGVuU2VhcmNoKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSk7XG4gIHVzZUhvdGtleXMoXCJjbWQra1wiLCAoZXZlbnQpID0+IHtcbiAgICBvbk9wZW5TZWFyY2goKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbiAgY29uc3QgaGFzU2VhcmNoID0gISFvblNlYXJjaE5vdGlvbjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMy5GcmFnbWVudCwgbnVsbCwgaGFzU2VhcmNoICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBjcyhcImJyZWFkY3J1bWJcIiwgXCJidXR0b25cIiwgXCJub3Rpb24tc2VhcmNoLWJ1dHRvblwiKSxcbiAgICBvbkNsaWNrOiBvbk9wZW5TZWFyY2hcbiAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChTZWFyY2hJY29uLCB7XG4gICAgY2xhc3NOYW1lOiBcInNlYXJjaEljb25cIlxuICB9KSwgdGl0bGUgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJ0aXRsZVwiXG4gIH0sIHRpdGxlKSksIGlzU2VhcmNoT3BlbiAmJiBoYXNTZWFyY2ggJiYgLyogQF9fUFVSRV9fICovIFJlYWN0MTMuY3JlYXRlRWxlbWVudChTZWFyY2hEaWFsb2csIHtcbiAgICBpc09wZW46IGlzU2VhcmNoT3BlbixcbiAgICByb290QmxvY2tJZDogcm9vdFBhZ2VJZCB8fCAoYmxvY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGJsb2NrLmlkKSxcbiAgICBvbkNsb3NlOiBvbkNsb3NlU2VhcmNoLFxuICAgIHNlYXJjaE5vdGlvbjogb25TZWFyY2hOb3Rpb25cbiAgfSkpO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvYXNzZXQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDE1IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0VGV4dENvbnRlbnQgfSBmcm9tIFwibm90aW9uLXV0aWxzXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2xpdGUteW91dHViZS1lbWJlZC50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTQgZnJvbSBcInJlYWN0XCI7XG52YXIgcXMgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcChcbiAgICAoa2V5KSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pfWBcbiAgKS5qb2luKFwiJlwiKTtcbn07XG52YXIgTGl0ZVlvdVR1YmVFbWJlZCA9ICh7XG4gIGlkLFxuICBkZWZhdWx0UGxheSA9IGZhbHNlLFxuICBtdXRlID0gZmFsc2UsXG4gIGxhenlJbWFnZSA9IGZhbHNlLFxuICBpZnJhbWVUaXRsZSA9IFwiWW91VHViZSB2aWRlb1wiLFxuICBhbHQgPSBcIlZpZGVvIHByZXZpZXdcIixcbiAgcGFyYW1zID0ge30sXG4gIGFkTGlua3NQcmVjb25uZWN0ID0gdHJ1ZSxcbiAgc3R5bGUsXG4gIGNsYXNzTmFtZVxufSkgPT4ge1xuICBjb25zdCBtdXRlUGFyYW0gPSBtdXRlIHx8IGRlZmF1bHRQbGF5ID8gXCIxXCIgOiBcIjBcIjtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBSZWFjdDE0LnVzZU1lbW8oXG4gICAgKCkgPT4gcXMoX19zcHJlYWRWYWx1ZXMoeyBhdXRvcGxheTogXCIxXCIsIG11dGU6IG11dGVQYXJhbSB9LCBwYXJhbXMpKSxcbiAgICBbbXV0ZVBhcmFtLCBwYXJhbXNdXG4gICk7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBcImhxZGVmYXVsdFwiO1xuICBjb25zdCBwb3N0ZXJVcmwgPSBgaHR0cHM6Ly9pLnl0aW1nLmNvbS92aS8ke2lkfS8ke3Jlc29sdXRpb259LmpwZ2A7XG4gIGNvbnN0IHl0VXJsID0gXCJodHRwczovL3d3dy55b3V0dWJlLW5vY29va2llLmNvbVwiO1xuICBjb25zdCBpZnJhbWVTcmMgPSBgJHt5dFVybH0vZW1iZWQvJHtpZH0/JHtxdWVyeVN0cmluZ31gO1xuICBjb25zdCBbaXNQcmVjb25uZWN0ZWQsIHNldElzUHJlY29ubmVjdGVkXSA9IFJlYWN0MTQudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaWZyYW1lSW5pdGlhbGl6ZWQsIHNldElmcmFtZUluaXRpYWxpemVkXSA9IFJlYWN0MTQudXNlU3RhdGUoZGVmYXVsdFBsYXkpO1xuICBjb25zdCBbaXNJZnJhbWVMb2FkZWQsIHNldElzSWZyYW1lTG9hZGVkXSA9IFJlYWN0MTQudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB3YXJtQ29ubmVjdGlvbnMgPSBSZWFjdDE0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaXNQcmVjb25uZWN0ZWQpXG4gICAgICByZXR1cm47XG4gICAgc2V0SXNQcmVjb25uZWN0ZWQodHJ1ZSk7XG4gIH0sIFtpc1ByZWNvbm5lY3RlZF0pO1xuICBjb25zdCBvbkxvYWRJZnJhbWUgPSBSZWFjdDE0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaWZyYW1lSW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgc2V0SWZyYW1lSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gIH0sIFtpZnJhbWVJbml0aWFsaXplZF0pO1xuICBjb25zdCBvbklmcmFtZUxvYWRlZCA9IFJlYWN0MTQudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzSWZyYW1lTG9hZGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxNC5jcmVhdGVFbGVtZW50KFJlYWN0MTQuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgIGhyZWY6IHBvc3RlclVybCxcbiAgICBhczogXCJpbWFnZVwiXG4gIH0pLCBpc1ByZWNvbm5lY3RlZCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QxNC5jcmVhdGVFbGVtZW50KFJlYWN0MTQuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICByZWw6IFwicHJlY29ubmVjdFwiLFxuICAgIGhyZWY6IHl0VXJsXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxNC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7XG4gICAgcmVsOiBcInByZWNvbm5lY3RcIixcbiAgICBocmVmOiBcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb21cIlxuICB9KSksIGlzUHJlY29ubmVjdGVkICYmIGFkTGlua3NQcmVjb25uZWN0ICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE0LmNyZWF0ZUVsZW1lbnQoUmVhY3QxNC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIHJlbDogXCJwcmVjb25uZWN0XCIsXG4gICAgaHJlZjogXCJodHRwczovL3N0YXRpYy5kb3VibGVjbGljay5uZXRcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIHJlbDogXCJwcmVjb25uZWN0XCIsXG4gICAgaHJlZjogXCJodHRwczovL2dvb2dsZWFkcy5nLmRvdWJsZWNsaWNrLm5ldFwiXG4gIH0pKSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgb25DbGljazogb25Mb2FkSWZyYW1lLFxuICAgIG9uUG9pbnRlck92ZXI6IHdhcm1Db25uZWN0aW9ucyxcbiAgICBjbGFzc05hbWU6IGNzKFxuICAgICAgXCJub3Rpb24teXQtbGl0ZVwiLFxuICAgICAgaXNJZnJhbWVMb2FkZWQgJiYgXCJub3Rpb24teXQtbG9hZGVkXCIsXG4gICAgICBpZnJhbWVJbml0aWFsaXplZCAmJiBcIm5vdGlvbi15dC1pbml0aWFsaXplZFwiLFxuICAgICAgY2xhc3NOYW1lXG4gICAgKSxcbiAgICBzdHlsZVxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxNC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICBzcmM6IHBvc3RlclVybCxcbiAgICBjbGFzc05hbWU6IFwibm90aW9uLXl0LXRodW1ibmFpbFwiLFxuICAgIGxvYWRpbmc6IGxhenlJbWFnZSA/IFwibGF6eVwiIDogdm9pZCAwLFxuICAgIGFsdFxuICB9KSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi15dC1wbGF5YnRuXCJcbiAgfSksIGlmcmFtZUluaXRpYWxpemVkICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE0LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIiwge1xuICAgIHdpZHRoOiBcIjU2MFwiLFxuICAgIGhlaWdodDogXCIzMTVcIixcbiAgICBmcmFtZUJvcmRlcjogXCIwXCIsXG4gICAgYWxsb3c6IFwiYWNjZWxlcm9tZXRlcjsgYXV0b3BsYXk7IGVuY3J5cHRlZC1tZWRpYTsgZ3lyb3Njb3BlOyBwaWN0dXJlLWluLXBpY3R1cmVcIixcbiAgICBhbGxvd0Z1bGxTY3JlZW46IHRydWUsXG4gICAgdGl0bGU6IGlmcmFtZVRpdGxlLFxuICAgIHNyYzogaWZyYW1lU3JjLFxuICAgIG9uTG9hZDogb25JZnJhbWVMb2FkZWRcbiAgfSkpKTtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL2Fzc2V0LnRzeFxudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbnZhciBzdXBwb3J0ZWRBc3NldFR5cGVzID0gW1xuICBcInZpZGVvXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJlbWJlZFwiLFxuICBcImZpZ21hXCIsXG4gIFwidHlwZWZvcm1cIixcbiAgXCJleGNhbGlkcmF3XCIsXG4gIFwibWFwc1wiLFxuICBcInR3ZWV0XCIsXG4gIFwicGRmXCIsXG4gIFwiZ2lzdFwiLFxuICBcImNvZGVwZW5cIixcbiAgXCJkcml2ZVwiXG5dO1xudmFyIEFzc2V0ID0gKHsgYmxvY2ssIHpvb21hYmxlID0gdHJ1ZSwgY2hpbGRyZW4gfSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2o7XG4gIGNvbnN0IHsgcmVjb3JkTWFwLCBtYXBJbWFnZVVybCwgY29tcG9uZW50cyB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICBpZiAoIWJsb2NrIHx8ICFzdXBwb3J0ZWRBc3NldFR5cGVzLmluY2x1ZGVzKGJsb2NrLnR5cGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICBhbGlnblNlbGY6IFwiY2VudGVyXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiXG4gIH07XG4gIGNvbnN0IGFzc2V0U3R5bGUgPSB7fTtcbiAgaWYgKGJsb2NrLmZvcm1hdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrX2FzcGVjdF9yYXRpbyxcbiAgICAgIGJsb2NrX2hlaWdodCxcbiAgICAgIGJsb2NrX3dpZHRoLFxuICAgICAgYmxvY2tfZnVsbF93aWR0aCxcbiAgICAgIGJsb2NrX3BhZ2Vfd2lkdGgsXG4gICAgICBibG9ja19wcmVzZXJ2ZV9zY2FsZVxuICAgIH0gPSBibG9jay5mb3JtYXQ7XG4gICAgaWYgKGJsb2NrX2Z1bGxfd2lkdGggfHwgYmxvY2tfcGFnZV93aWR0aCkge1xuICAgICAgaWYgKGJsb2NrX2Z1bGxfd2lkdGgpIHtcbiAgICAgICAgc3R5bGUud2lkdGggPSBcIjEwMHZ3XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFwidmlkZW9cIikge1xuICAgICAgICBpZiAoYmxvY2tfaGVpZ2h0KSB7XG4gICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYmxvY2tfaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrX2FzcGVjdF9yYXRpbykge1xuICAgICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBgJHtibG9ja19hc3BlY3RfcmF0aW8gKiAxMDB9JWA7XG4gICAgICAgIH0gZWxzZSBpZiAoYmxvY2tfcHJlc2VydmVfc2NhbGUpIHtcbiAgICAgICAgICBzdHlsZS5vYmplY3RGaXQgPSBcImNvbnRhaW5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChibG9ja19hc3BlY3RfcmF0aW8gJiYgYmxvY2sudHlwZSAhPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBgJHtibG9ja19hc3BlY3RfcmF0aW8gKiAxMDB9JWA7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrX2hlaWdodCkge1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBibG9ja19oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrX3ByZXNlcnZlX3NjYWxlKSB7XG4gICAgICAgIGlmIChibG9jay50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0gXCI3NSVcIjtcbiAgICAgICAgICBzdHlsZS5taW5IZWlnaHQgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICgoX2EgPSBibG9jay5mb3JtYXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ibG9ja19hbGlnbm1lbnQpIHtcbiAgICAgICAgY2FzZSBcImNlbnRlclwiOiB7XG4gICAgICAgICAgc3R5bGUuYWxpZ25TZWxmID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibGVmdFwiOiB7XG4gICAgICAgICAgc3R5bGUuYWxpZ25TZWxmID0gXCJzdGFydFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOiB7XG4gICAgICAgICAgc3R5bGUuYWxpZ25TZWxmID0gXCJlbmRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJsb2NrX3dpZHRoKSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYmxvY2tfd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tfcHJlc2VydmVfc2NhbGUgJiYgYmxvY2sudHlwZSAhPT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjUwJVwiO1xuICAgICAgICBzdHlsZS5taW5IZWlnaHQgPSAxMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmxvY2tfaGVpZ2h0ICYmIGJsb2NrLnR5cGUgIT09IFwiaW1hZ2VcIikge1xuICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGJsb2NrX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICBhc3NldFN0eWxlLm9iamVjdEZpdCA9IFwiY292ZXJcIjtcbiAgICB9IGVsc2UgaWYgKGJsb2NrX3ByZXNlcnZlX3NjYWxlKSB7XG4gICAgICBhc3NldFN0eWxlLm9iamVjdEZpdCA9IFwiY29udGFpblwiO1xuICAgIH1cbiAgfVxuICBsZXQgc291cmNlID0gKChfYiA9IHJlY29yZE1hcC5zaWduZWRfdXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2Jsb2NrLmlkXSkgfHwgKChfZSA9IChfZCA9IChfYyA9IGJsb2NrLnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfZFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lWzBdKTtcbiAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICBpZiAoIXNvdXJjZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChibG9jay50eXBlID09PSBcInR3ZWV0XCIpIHtcbiAgICBjb25zdCBzcmMgPSBzb3VyY2U7XG4gICAgaWYgKCFzcmMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpZCA9IHNyYy5zcGxpdChcIj9cIilbMF0uc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgIGlmICghaWQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb250ZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0MTUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXNzZXRTdHlsZSksIHtcbiAgICAgICAgbWF4V2lkdGg6IDQyMCxcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcImF1dG9cIixcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiYXV0b1wiXG4gICAgICB9KVxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE1LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cy5Ud2VldCwge1xuICAgICAgaWRcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gXCJwZGZcIikge1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiKDIyNiwgMjI2LCAyMjYpXCI7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBpZiAoIXN0eWxlLnBhZGRpbmcpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmcgPSBcIjhweCAxNnB4XCI7XG4gICAgfVxuICAgIGlmICghaXNTZXJ2ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QxNS5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuUGRmLCB7XG4gICAgICAgIGZpbGU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJsb2NrLnR5cGUgPT09IFwiZW1iZWRcIiB8fCBibG9jay50eXBlID09PSBcInZpZGVvXCIgfHwgYmxvY2sudHlwZSA9PT0gXCJmaWdtYVwiIHx8IGJsb2NrLnR5cGUgPT09IFwidHlwZWZvcm1cIiB8fCBibG9jay50eXBlID09PSBcImdpc3RcIiB8fCBibG9jay50eXBlID09PSBcIm1hcHNcIiB8fCBibG9jay50eXBlID09PSBcImV4Y2FsaWRyYXdcIiB8fCBibG9jay50eXBlID09PSBcImNvZGVwZW5cIiB8fCBibG9jay50eXBlID09PSBcImRyaXZlXCIpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJ2aWRlb1wiICYmIHNvdXJjZSAmJiBzb3VyY2UuaW5kZXhPZihcInlvdXR1YmVcIikgPCAwICYmIHNvdXJjZS5pbmRleE9mKFwieW91dHUuYmVcIikgPCAwICYmIHNvdXJjZS5pbmRleE9mKFwidmltZW9cIikgPCAwICYmIHNvdXJjZS5pbmRleE9mKFwid2lzdGlhXCIpIDwgMCAmJiBzb3VyY2UuaW5kZXhPZihcImxvb21cIikgPCAwICYmIHNvdXJjZS5pbmRleE9mKFwidmlkZW9hc2tcIikgPCAwICYmIHNvdXJjZS5pbmRleE9mKFwiZ2V0Y2xvdWRhcHBcIikgPCAwKSB7XG4gICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0gdm9pZCAwO1xuICAgICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE1LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiLCB7XG4gICAgICAgIHBsYXlzSW5saW5lOiB0cnVlLFxuICAgICAgICBjb250cm9sczogdHJ1ZSxcbiAgICAgICAgcHJlbG9hZDogXCJtZXRhZGF0YVwiLFxuICAgICAgICBzdHlsZTogYXNzZXRTdHlsZSxcbiAgICAgICAgc3JjOiBzb3VyY2UsXG4gICAgICAgIHRpdGxlOiBibG9jay50eXBlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNyYyA9ICgoX2YgPSBibG9jay5mb3JtYXQpID09IG51bGwgPyB2b2lkIDAgOiBfZi5kaXNwbGF5X3NvdXJjZSkgfHwgc291cmNlO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBjb25zdCB5b3V0dWJlVmlkZW9JZCA9IGJsb2NrLnR5cGUgPT09IFwidmlkZW9cIiA/IGdldFlvdXR1YmVJZChzcmMpIDogbnVsbDtcbiAgICAgICAgaWYgKHlvdXR1YmVWaWRlb0lkKSB7XG4gICAgICAgICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE1LmNyZWF0ZUVsZW1lbnQoTGl0ZVlvdVR1YmVFbWJlZCwge1xuICAgICAgICAgICAgaWQ6IHlvdXR1YmVWaWRlb0lkLFxuICAgICAgICAgICAgc3R5bGU6IGFzc2V0U3R5bGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibm90aW9uLWFzc2V0LW9iamVjdC1maXRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLnR5cGUgPT09IFwiZ2lzdFwiKSB7XG4gICAgICAgICAgaWYgKCFzcmMuZW5kc1dpdGgoXCIucGliYlwiKSkge1xuICAgICAgICAgICAgc3JjID0gYCR7c3JjfS5waWJiYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXRTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjUwJVwiO1xuICAgICAgICAgIGNvbnRlbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QxNS5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiBhc3NldFN0eWxlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1hc3NldC1vYmplY3QtZml0XCIsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICB0aXRsZTogXCJHaXRIdWIgR2lzdFwiLFxuICAgICAgICAgICAgZnJhbWVCb3JkZXI6IFwiMFwiLFxuICAgICAgICAgICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgICAgICAgICBzY3JvbGxpbmc6IFwiYXV0b1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE1LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1hc3NldC1vYmplY3QtZml0XCIsXG4gICAgICAgICAgICBzdHlsZTogYXNzZXRTdHlsZSxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHRpdGxlOiBgaWZyYW1lICR7YmxvY2sudHlwZX1gLFxuICAgICAgICAgICAgZnJhbWVCb3JkZXI6IFwiMFwiLFxuICAgICAgICAgICAgYWxsb3dGdWxsU2NyZWVuOiB0cnVlLFxuICAgICAgICAgICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgICAgICAgICBzY3JvbGxpbmc6IFwiYXV0b1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgaWYgKHNvdXJjZS5pbmNsdWRlcyhcImZpbGUubm90aW9uLnNvXCIpKSB7XG4gICAgICBzb3VyY2UgPSAoX2kgPSAoX2ggPSAoX2cgPSBibG9jay5wcm9wZXJ0aWVzKSA9PSBudWxsID8gdm9pZCAwIDogX2cuc291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2hbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaVswXTtcbiAgICB9XG4gICAgY29uc3Qgc3JjID0gbWFwSW1hZ2VVcmwoc291cmNlLCBibG9jayk7XG4gICAgY29uc3QgY2FwdGlvbiA9IGdldFRleHRDb250ZW50KChfaiA9IGJsb2NrLnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfai5jYXB0aW9uKTtcbiAgICBjb25zdCBhbHQgPSBjYXB0aW9uIHx8IFwibm90aW9uIGltYWdlXCI7XG4gICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE1LmNyZWF0ZUVsZW1lbnQoTGF6eUltYWdlLCB7XG4gICAgICBzcmMsXG4gICAgICBhbHQsXG4gICAgICB6b29tYWJsZSxcbiAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgc3R5bGU6IGFzc2V0U3R5bGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTUuY3JlYXRlRWxlbWVudChSZWFjdDE1LkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QxNS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZVxuICB9LCBjb250ZW50LCBibG9jay50eXBlID09PSBcImltYWdlXCIgJiYgY2hpbGRyZW4pLCBibG9jay50eXBlICE9PSBcImltYWdlXCIgJiYgY2hpbGRyZW4pO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvYXNzZXQtd3JhcHBlci50c3hcbnZhciB1cmxTdHlsZSA9IHsgd2lkdGg6IFwiMTAwJVwiIH07XG52YXIgQXNzZXRXcmFwcGVyID0gKHsgYmxvY2tJZCwgYmxvY2sgfSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3QgdmFsdWUgPSBibG9jaztcbiAgY29uc3QgeyBjb21wb25lbnRzLCBtYXBQYWdlVXJsLCByb290RG9tYWluLCB6b29tIH0gPSB1c2VOb3Rpb25Db250ZXh0KCk7XG4gIGxldCBpc1VSTCA9IGZhbHNlO1xuICBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgY29uc3QgY2FwdGlvbiA9IChfYyA9IChfYiA9IChfYSA9IHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5wcm9wZXJ0aWVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FwdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NbMF07XG4gICAgaWYgKGNhcHRpb24pIHtcbiAgICAgIGNvbnN0IGlkID0gcGFyc2VQYWdlSWQyKGNhcHRpb24sIHsgdXVpZDogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IGlzUGFnZSA9IGNhcHRpb24uY2hhckF0KDApID09PSBcIi9cIiAmJiBpZDtcbiAgICAgIGlmIChpc1BhZ2UgfHwgaXNWYWxpZFVSTChjYXB0aW9uKSkge1xuICAgICAgICBpc1VSTCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpZ3VyZSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE2LmNyZWF0ZUVsZW1lbnQoXCJmaWd1cmVcIiwge1xuICAgIGNsYXNzTmFtZTogY3MoXG4gICAgICBcIm5vdGlvbi1hc3NldC13cmFwcGVyXCIsXG4gICAgICBgbm90aW9uLWFzc2V0LXdyYXBwZXItJHtibG9jay50eXBlfWAsXG4gICAgICAoKF9kID0gdmFsdWUuZm9ybWF0KSA9PSBudWxsID8gdm9pZCAwIDogX2QuYmxvY2tfZnVsbF93aWR0aCkgJiYgXCJub3Rpb24tYXNzZXQtd3JhcHBlci1mdWxsXCIsXG4gICAgICBibG9ja0lkXG4gICAgKVxuICB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxNi5jcmVhdGVFbGVtZW50KEFzc2V0LCB7XG4gICAgYmxvY2s6IHZhbHVlLFxuICAgIHpvb21hYmxlOiB6b29tICYmICFpc1VSTFxuICB9LCAoKF9lID0gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYXB0aW9uKSAmJiAhaXNVUkwgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0MTYuY3JlYXRlRWxlbWVudChcImZpZ2NhcHRpb25cIiwge1xuICAgIGNsYXNzTmFtZTogXCJub3Rpb24tYXNzZXQtY2FwdGlvblwiXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE2LmNyZWF0ZUVsZW1lbnQoVGV4dCwge1xuICAgIHZhbHVlOiB2YWx1ZS5wcm9wZXJ0aWVzLmNhcHRpb24sXG4gICAgYmxvY2tcbiAgfSkpKSk7XG4gIGlmIChpc1VSTCkge1xuICAgIGNvbnN0IGNhcHRpb24gPSAoX2YgPSB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUucHJvcGVydGllcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhcHRpb25bMF1bMF07XG4gICAgY29uc3QgaWQgPSBwYXJzZVBhZ2VJZDIoY2FwdGlvbiwgeyB1dWlkOiB0cnVlIH0pO1xuICAgIGNvbnN0IGlzUGFnZSA9IGNhcHRpb24uY2hhckF0KDApID09PSBcIi9cIiAmJiBpZDtcbiAgICBjb25zdCBjYXB0aW9uSG9zdG5hbWUgPSBleHRyYWN0SG9zdG5hbWUoY2FwdGlvbik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE2LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cy5QYWdlTGluaywge1xuICAgICAgc3R5bGU6IHVybFN0eWxlLFxuICAgICAgaHJlZjogaXNQYWdlID8gbWFwUGFnZVVybChpZCkgOiBjYXB0aW9uLFxuICAgICAgdGFyZ2V0OiBjYXB0aW9uSG9zdG5hbWUgJiYgY2FwdGlvbkhvc3RuYW1lICE9PSByb290RG9tYWluICYmICFjYXB0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJibGFua19cIiA6IG51bGxcbiAgICB9LCBmaWd1cmUpO1xuICB9XG4gIHJldHVybiBmaWd1cmU7XG59O1xuZnVuY3Rpb24gaXNWYWxpZFVSTChzdHIpIHtcbiAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoXG4gICAgXCJeKGh0dHBzPzpcXFxcL1xcXFwvKT8oKChbYS16XFxcXGRdKFthLXpcXFxcZC1dKlthLXpcXFxcZF0pKilcXFxcLikrW2Etel17Mix9fCgoXFxcXGR7MSwzfVxcXFwuKXszfVxcXFxkezEsM30pKShcXFxcOlxcXFxkKyk/KFxcXFwvWy1hLXpcXFxcZCVfLn4rXSopKihcXFxcP1s7JmEtelxcXFxkJV8ufis9LV0qKT8oXFxcXCNbLWEtelxcXFxkX10qKT8kXCIsXG4gICAgXCJpXCJcbiAgKTtcbiAgcmV0dXJuICEhcGF0dGVybi50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBleHRyYWN0SG9zdG5hbWUodXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBuZXcgVVJMKHVybCkuaG9zdG5hbWU7XG4gICAgcmV0dXJuIGhvc3RuYW1lO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG4vLyBzcmMvY29tcG9uZW50cy9jaGVja2JveC50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTggZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9pY29ucy9jaGVjay50c3hcbmltcG9ydCAqIGFzIFJlYWN0MTcgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBTdmdDaGVjayhwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTcuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgdmlld0JveDogXCIwIDAgMTQgMTRcIlxuICB9LCBwcm9wcyksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE3LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk01LjUgMTJMMTQgMy41IDEyLjUgMmwtNyA3LTQtNC4wMDNMMCA2LjQ5OXpcIlxuICB9KSk7XG59XG52YXIgY2hlY2tfZGVmYXVsdCA9IFN2Z0NoZWNrO1xuXG4vLyBzcmMvY29tcG9uZW50cy9jaGVja2JveC50c3hcbnZhciBDaGVja2JveCA9ICh7IGlzQ2hlY2tlZCB9KSA9PiB7XG4gIGxldCBjb250ZW50ID0gbnVsbDtcbiAgaWYgKGlzQ2hlY2tlZCkge1xuICAgIGNvbnRlbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QxOC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJub3Rpb24tcHJvcGVydHktY2hlY2tib3gtY2hlY2tlZFwiXG4gICAgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTguY3JlYXRlRWxlbWVudChjaGVja19kZWZhdWx0LCBudWxsKSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE4LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1wcm9wZXJ0eS1jaGVja2JveC11bmNoZWNrZWRcIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxOC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIm5vdGlvbi1wcm9wZXJ0eSBub3Rpb24tcHJvcGVydHktY2hlY2tib3hcIlxuICB9LCBjb250ZW50KTtcbn07XG5cbi8vIHNyYy9uZXh0LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QxOSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJyZWFjdC1mYXN0LWNvbXBhcmVcIjtcbnZhciB3cmFwTmV4dEltYWdlID0gKE5leHRJbWFnZSkgPT4ge1xuICByZXR1cm4gUmVhY3QxOS5tZW1vKGZ1bmN0aW9uIFJlYWN0Tm90aW9uWE5leHRJbWFnZShfYSkge1xuICAgIHZhciBfYiA9IF9hLCB7XG4gICAgICBzcmMsXG4gICAgICBhbHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlLFxuICAgICAgbGF5b3V0XG4gICAgfSA9IF9iLCByZXN0ID0gX19vYmpSZXN0KF9iLCBbXG4gICAgICBcInNyY1wiLFxuICAgICAgXCJhbHRcIixcbiAgICAgIFwid2lkdGhcIixcbiAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgXCJzdHlsZVwiLFxuICAgICAgXCJsYXlvdXRcIlxuICAgIF0pO1xuICAgIGlmICghbGF5b3V0KSB7XG4gICAgICBsYXlvdXQgPSB3aWR0aCAmJiBoZWlnaHQgPyBcImludHJpbnNpY1wiIDogXCJmaWxsXCI7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxOS5jcmVhdGVFbGVtZW50KE5leHRJbWFnZSwgX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc3JjLFxuICAgICAgYWx0LFxuICAgICAgd2lkdGg6IGxheW91dCA9PT0gXCJpbnRyaW5zaWNcIiAmJiB3aWR0aCxcbiAgICAgIGhlaWdodDogbGF5b3V0ID09PSBcImludHJpbnNpY1wiICYmIGhlaWdodCxcbiAgICAgIG9iamVjdEZpdDogc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLm9iamVjdEZpdCxcbiAgICAgIG9iamVjdFBvc2l0aW9uOiBzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUub2JqZWN0UG9zaXRpb24sXG4gICAgICBsYXlvdXRcbiAgICB9LCByZXN0KSk7XG4gIH0sIGlzRXF1YWwpO1xufTtcbnZhciB3cmFwTmV4dExpbmsgPSAoTmV4dExpbmspID0+IGZ1bmN0aW9uIFJlYWN0Tm90aW9uWE5leHRMaW5rKF9hKSB7XG4gIHZhciBfYiA9IF9hLCB7XG4gICAgaHJlZixcbiAgICBhcyxcbiAgICBwYXNzSHJlZixcbiAgICBwcmVmZXRjaCxcbiAgICByZXBsYWNlLFxuICAgIHNjcm9sbCxcbiAgICBzaGFsbG93LFxuICAgIGxvY2FsZVxuICB9ID0gX2IsIGxpbmtQcm9wcyA9IF9fb2JqUmVzdChfYiwgW1xuICAgIFwiaHJlZlwiLFxuICAgIFwiYXNcIixcbiAgICBcInBhc3NIcmVmXCIsXG4gICAgXCJwcmVmZXRjaFwiLFxuICAgIFwicmVwbGFjZVwiLFxuICAgIFwic2Nyb2xsXCIsXG4gICAgXCJzaGFsbG93XCIsXG4gICAgXCJsb2NhbGVcIlxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE5LmNyZWF0ZUVsZW1lbnQoTmV4dExpbmssIHtcbiAgICBocmVmLFxuICAgIGFzLFxuICAgIHBhc3NIcmVmLFxuICAgIHByZWZldGNoLFxuICAgIHJlcGxhY2UsXG4gICAgc2Nyb2xsLFxuICAgIHNoYWxsb3csXG4gICAgbG9jYWxlXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDE5LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fc3ByZWFkVmFsdWVzKHt9LCBsaW5rUHJvcHMpKSk7XG59O1xuXG4vLyBzcmMvY29udGV4dC50c3hcbnZhciBEZWZhdWx0TGluayA9IChwcm9wcykgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0MjAuY3JlYXRlRWxlbWVudChcImFcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCJcbn0sIHByb3BzKSk7XG52YXIgRGVmYXVsdExpbmtNZW1vID0gUmVhY3QyMC5tZW1vKERlZmF1bHRMaW5rKTtcbnZhciBEZWZhdWx0UGFnZUxpbmsgPSAocHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIwLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcykpO1xudmFyIERlZmF1bHRQYWdlTGlua01lbW8gPSBSZWFjdDIwLm1lbW8oRGVmYXVsdFBhZ2VMaW5rKTtcbnZhciBEZWZhdWx0RW1iZWQgPSAocHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIwLmNyZWF0ZUVsZW1lbnQoQXNzZXRXcmFwcGVyLCBfX3NwcmVhZFZhbHVlcyh7fSwgcHJvcHMpKTtcbnZhciBEZWZhdWx0SGVhZGVyID0gSGVhZGVyO1xudmFyIGR1bW15Q29tcG9uZW50ID0gKG5hbWUpID0+ICgpID0+IHtcbiAgY29uc29sZS53YXJuKFxuICAgIGBXYXJuaW5nOiB1c2luZyBlbXB0eSBjb21wb25lbnQgXCIke25hbWV9XCIgKHlvdSBzaG91bGQgb3ZlcnJpZGUgdGhpcyBpbiBOb3Rpb25SZW5kZXJlci5jb21wb25lbnRzKWBcbiAgKTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGR1bW15T3ZlcnJpZGVGbiA9IChfLCBkZWZhdWx0VmFsdWVGbikgPT4gZGVmYXVsdFZhbHVlRm4oKTtcbnZhciBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgSW1hZ2U6IG51bGwsXG4gIExpbms6IERlZmF1bHRMaW5rTWVtbyxcbiAgUGFnZUxpbms6IERlZmF1bHRQYWdlTGlua01lbW8sXG4gIENoZWNrYm94LFxuICBDYWxsb3V0OiB2b2lkIDAsXG4gIENvZGU6IGR1bW15Q29tcG9uZW50KFwiQ29kZVwiKSxcbiAgRXF1YXRpb246IGR1bW15Q29tcG9uZW50KFwiRXF1YXRpb25cIiksXG4gIENvbGxlY3Rpb246IGR1bW15Q29tcG9uZW50KFwiQ29sbGVjdGlvblwiKSxcbiAgUHJvcGVydHk6IHZvaWQgMCxcbiAgcHJvcGVydHlUZXh0VmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlTZWxlY3RWYWx1ZTogZHVtbXlPdmVycmlkZUZuLFxuICBwcm9wZXJ0eVJlbGF0aW9uVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlGb3JtdWxhVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlUaXRsZVZhbHVlOiBkdW1teU92ZXJyaWRlRm4sXG4gIHByb3BlcnR5UGVyc29uVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlGaWxlVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlDaGVja2JveFZhbHVlOiBkdW1teU92ZXJyaWRlRm4sXG4gIHByb3BlcnR5VXJsVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlFbWFpbFZhbHVlOiBkdW1teU92ZXJyaWRlRm4sXG4gIHByb3BlcnR5UGhvbmVOdW1iZXJWYWx1ZTogZHVtbXlPdmVycmlkZUZuLFxuICBwcm9wZXJ0eU51bWJlclZhbHVlOiBkdW1teU92ZXJyaWRlRm4sXG4gIHByb3BlcnR5TGFzdEVkaXRlZFRpbWVWYWx1ZTogZHVtbXlPdmVycmlkZUZuLFxuICBwcm9wZXJ0eUNyZWF0ZWRUaW1lVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgcHJvcGVydHlEYXRlVmFsdWU6IGR1bW15T3ZlcnJpZGVGbixcbiAgUGRmOiBkdW1teUNvbXBvbmVudChcIlBkZlwiKSxcbiAgVHdlZXQ6IGR1bW15Q29tcG9uZW50KFwiVHdlZXRcIiksXG4gIE1vZGFsOiBkdW1teUNvbXBvbmVudChcIk1vZGFsXCIpLFxuICBIZWFkZXI6IERlZmF1bHRIZWFkZXIsXG4gIEVtYmVkOiBEZWZhdWx0RW1iZWRcbn07XG52YXIgZGVmYXVsdE5vdGlvbkNvbnRleHQgPSB7XG4gIHJlY29yZE1hcDoge1xuICAgIGJsb2NrOiB7fSxcbiAgICBjb2xsZWN0aW9uOiB7fSxcbiAgICBjb2xsZWN0aW9uX3ZpZXc6IHt9LFxuICAgIGNvbGxlY3Rpb25fcXVlcnk6IHt9LFxuICAgIG5vdGlvbl91c2VyOiB7fSxcbiAgICBzaWduZWRfdXJsczoge31cbiAgfSxcbiAgY29tcG9uZW50czogZGVmYXVsdENvbXBvbmVudHMsXG4gIG1hcFBhZ2VVcmw6IGRlZmF1bHRNYXBQYWdlVXJsKCksXG4gIG1hcEltYWdlVXJsOiBkZWZhdWx0TWFwSW1hZ2VVcmwsXG4gIHNlYXJjaE5vdGlvbjogbnVsbCxcbiAgaXNTaG93aW5nU2VhcmNoOiBmYWxzZSxcbiAgb25IaWRlU2VhcmNoOiBudWxsLFxuICBmdWxsUGFnZTogZmFsc2UsXG4gIGRhcmtNb2RlOiBmYWxzZSxcbiAgcHJldmlld0ltYWdlczogZmFsc2UsXG4gIGZvcmNlQ3VzdG9tSW1hZ2VzOiBmYWxzZSxcbiAgc2hvd0NvbGxlY3Rpb25WaWV3RHJvcGRvd246IHRydWUsXG4gIGxpbmtUYWJsZVRpdGxlUHJvcGVydGllczogdHJ1ZSxcbiAgaXNMaW5rQ29sbGVjdGlvblRvVXJsUHJvcGVydHk6IGZhbHNlLFxuICBzaG93VGFibGVPZkNvbnRlbnRzOiBmYWxzZSxcbiAgbWluVGFibGVPZkNvbnRlbnRzSXRlbXM6IDMsXG4gIGRlZmF1bHRQYWdlSWNvbjogbnVsbCxcbiAgZGVmYXVsdFBhZ2VDb3ZlcjogbnVsbCxcbiAgZGVmYXVsdFBhZ2VDb3ZlclBvc2l0aW9uOiAwLjUsXG4gIHpvb206IG51bGxcbn07XG52YXIgY3R4ID0gUmVhY3QyMC5jcmVhdGVDb250ZXh0KGRlZmF1bHROb3Rpb25Db250ZXh0KTtcbnZhciBOb3Rpb25Db250ZXh0UHJvdmlkZXIgPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHtcbiAgICBjb21wb25lbnRzOiB0aGVtZUNvbXBvbmVudHMgPSB7fSxcbiAgICBjaGlsZHJlbixcbiAgICBtYXBQYWdlVXJsLFxuICAgIG1hcEltYWdlVXJsLFxuICAgIHJvb3RQYWdlSWRcbiAgfSA9IF9iLCByZXN0ID0gX19vYmpSZXN0KF9iLCBbXG4gICAgXCJjb21wb25lbnRzXCIsXG4gICAgXCJjaGlsZHJlblwiLFxuICAgIFwibWFwUGFnZVVybFwiLFxuICAgIFwibWFwSW1hZ2VVcmxcIixcbiAgICBcInJvb3RQYWdlSWRcIlxuICBdKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzdCkpIHtcbiAgICBpZiAocmVzdFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSByZXN0W2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IHdyYXBwZWRUaGVtZUNvbXBvbmVudHMgPSBSZWFjdDIwLnVzZU1lbW8oXG4gICAgKCkgPT4gX19zcHJlYWRWYWx1ZXMoe30sIHRoZW1lQ29tcG9uZW50cyksXG4gICAgW3RoZW1lQ29tcG9uZW50c11cbiAgKTtcbiAgaWYgKHdyYXBwZWRUaGVtZUNvbXBvbmVudHMubmV4dEltYWdlKSB7XG4gICAgd3JhcHBlZFRoZW1lQ29tcG9uZW50cy5JbWFnZSA9IHdyYXBOZXh0SW1hZ2UodGhlbWVDb21wb25lbnRzLm5leHRJbWFnZSk7XG4gIH1cbiAgaWYgKHdyYXBwZWRUaGVtZUNvbXBvbmVudHMubmV4dExpbmspIHtcbiAgICB3cmFwcGVkVGhlbWVDb21wb25lbnRzLm5leHRMaW5rID0gd3JhcE5leHRMaW5rKHRoZW1lQ29tcG9uZW50cy5uZXh0TGluayk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMod3JhcHBlZFRoZW1lQ29tcG9uZW50cykpIHtcbiAgICBpZiAoIXdyYXBwZWRUaGVtZUNvbXBvbmVudHNba2V5XSkge1xuICAgICAgZGVsZXRlIHdyYXBwZWRUaGVtZUNvbXBvbmVudHNba2V5XTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBSZWFjdDIwLnVzZU1lbW8oXG4gICAgKCkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdE5vdGlvbkNvbnRleHQpLCByZXN0KSwge1xuICAgICAgcm9vdFBhZ2VJZCxcbiAgICAgIG1hcFBhZ2VVcmw6IG1hcFBhZ2VVcmwgIT0gbnVsbCA/IG1hcFBhZ2VVcmwgOiBkZWZhdWx0TWFwUGFnZVVybChyb290UGFnZUlkKSxcbiAgICAgIG1hcEltYWdlVXJsOiBtYXBJbWFnZVVybCAhPSBudWxsID8gbWFwSW1hZ2VVcmwgOiBkZWZhdWx0TWFwSW1hZ2VVcmwsXG4gICAgICBjb21wb25lbnRzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdENvbXBvbmVudHMpLCB3cmFwcGVkVGhlbWVDb21wb25lbnRzKVxuICAgIH0pLFxuICAgIFttYXBJbWFnZVVybCwgbWFwUGFnZVVybCwgd3JhcHBlZFRoZW1lQ29tcG9uZW50cywgcm9vdFBhZ2VJZCwgcmVzdF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIwLmNyZWF0ZUVsZW1lbnQoY3R4LlByb3ZpZGVyLCB7XG4gICAgdmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufTtcbnZhciBOb3Rpb25Db250ZXh0Q29uc3VtZXIgPSBjdHguQ29uc3VtZXI7XG52YXIgdXNlTm90aW9uQ29udGV4dCA9ICgpID0+IHtcbiAgcmV0dXJuIFJlYWN0MjAudXNlQ29udGV4dChjdHgpO1xufTtcblxuLy8gc3JjL3RoaXJkLXBhcnR5L2VxdWF0aW9uLnRzeFxudmFyIGthdGV4U2V0dGluZ3MgPSB7XG4gIHRocm93T25FcnJvcjogZmFsc2UsXG4gIHN0cmljdDogZmFsc2Vcbn07XG52YXIgRXF1YXRpb24gPSAoX2EpID0+IHtcbiAgdmFyIF9iID0gX2EsIHsgYmxvY2ssIG1hdGgsIGlubGluZSA9IGZhbHNlLCBjbGFzc05hbWUgfSA9IF9iLCByZXN0ID0gX19vYmpSZXN0KF9iLCBbXCJibG9ja1wiLCBcIm1hdGhcIiwgXCJpbmxpbmVcIiwgXCJjbGFzc05hbWVcIl0pO1xuICBjb25zdCB7IHJlY29yZE1hcCB9ID0gdXNlTm90aW9uQ29udGV4dCgpO1xuICBtYXRoID0gbWF0aCB8fCBnZXRCbG9ja1RpdGxlNChibG9jaywgcmVjb3JkTWFwKTtcbiAgaWYgKCFtYXRoKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MjEuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgY2xhc3NOYW1lOiBjcyhcbiAgICAgIFwibm90aW9uLWVxdWF0aW9uXCIsXG4gICAgICBpbmxpbmUgPyBcIm5vdGlvbi1lcXVhdGlvbi1pbmxpbmVcIiA6IFwibm90aW9uLWVxdWF0aW9uLWJsb2NrXCIsXG4gICAgICBjbGFzc05hbWVcbiAgICApXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIxLmNyZWF0ZUVsZW1lbnQoS2F0ZXgsIF9fc3ByZWFkVmFsdWVzKHtcbiAgICBtYXRoLFxuICAgIHNldHRpbmdzOiBrYXRleFNldHRpbmdzXG4gIH0sIHJlc3QpKSk7XG59O1xuZXhwb3J0IHtcbiAgRXF1YXRpb25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-notion-x/build/third-party/equation.js\n"));

/***/ })

}]);