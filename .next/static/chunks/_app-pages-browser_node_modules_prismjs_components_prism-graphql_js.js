/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_prismjs_components_prism-graphql_js"],{

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-graphql.js":
/*!**********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-graphql.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /\\b[A-Z]\\w*Input\\b/,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ3JhcGhxbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUErQztBQUM3RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxrQ0FBa0M7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUZBQW1GO0FBQ25GLG9CQUFvQjs7QUFFcEI7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ncmFwaHFsLmpzPzc2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiUHJpc20ubGFuZ3VhZ2VzLmdyYXBocWwgPSB7XG5cdCdjb21tZW50JzogLyMuKi8sXG5cdCdkZXNjcmlwdGlvbic6IHtcblx0XHRwYXR0ZXJuOiAvKD86XCJcIlwiKD86W15cIl18KD8hXCJcIlwiKVwiKSpcIlwiXCJ8XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKSg/PVxccypbYS16X10pL2ksXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAnc3RyaW5nJyxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdsYW5ndWFnZS1tYXJrZG93bic6IHtcblx0XHRcdFx0cGF0dGVybjogLyheXCIoPzpcIlwiKT8pKD8hXFwxKVtcXHNcXFNdKyg/PVxcMSQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogL1wiXCJcIig/OlteXCJdfCg/IVwiXCJcIilcIikqXCJcIlwifFwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIi8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdudW1iZXInOiAvKD86XFxCLXxcXGIpXFxkKyg/OlxcLlxcZCspPyg/OmVbKy1dP1xcZCspP1xcYi9pLFxuXHQnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG5cdCd2YXJpYWJsZSc6IC9cXCRbYS16X11cXHcqL2ksXG5cdCdkaXJlY3RpdmUnOiB7XG5cdFx0cGF0dGVybjogL0BbYS16X11cXHcqL2ksXG5cdFx0YWxpYXM6ICdmdW5jdGlvbidcblx0fSxcblx0J2F0dHItbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccyooPzpcXCgoPzpbXigpXCJdfFwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIikqXFwpKT86KS9pLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnYXRvbS1pbnB1dCc6IHtcblx0XHRwYXR0ZXJuOiAvXFxiW0EtWl1cXHcqSW5wdXRcXGIvLFxuXHRcdGFsaWFzOiAnY2xhc3MtbmFtZSdcblx0fSxcblx0J3NjYWxhcic6IC9cXGIoPzpCb29sZWFufEZsb2F0fElEfEludHxTdHJpbmcpXFxiLyxcblx0J2NvbnN0YW50JzogL1xcYltBLVpdW0EtWl9cXGRdKlxcYi8sXG5cdCdjbGFzcy1uYW1lJzoge1xuXHRcdHBhdHRlcm46IC8oXFxiKD86ZW51bXxpbXBsZW1lbnRzfGludGVyZmFjZXxvbnxzY2FsYXJ8dHlwZXx1bmlvbilcXHMrfCZcXHMqfDpcXHMqfFxcWylbQS1aX11cXHcqLyxcblx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdH0sXG5cdCdmcmFnbWVudCc6IHtcblx0XHRwYXR0ZXJuOiAvKFxcYmZyYWdtZW50XFxzK3xcXC57M31cXHMqKD8hb25cXGIpKVthLXpBLVpfXVxcdyovLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdmdW5jdGlvbidcblx0fSxcblx0J2RlZmluaXRpb24tbXV0YXRpb24nOiB7XG5cdFx0cGF0dGVybjogLyhcXGJtdXRhdGlvblxccyspW2EtekEtWl9dXFx3Ki8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHR9LFxuXHQnZGVmaW5pdGlvbi1xdWVyeSc6IHtcblx0XHRwYXR0ZXJuOiAvKFxcYnF1ZXJ5XFxzKylbYS16QS1aX11cXHcqLyxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdH0sXG5cdCdrZXl3b3JkJzogL1xcYig/OmRpcmVjdGl2ZXxlbnVtfGV4dGVuZHxmcmFnbWVudHxpbXBsZW1lbnRzfGlucHV0fGludGVyZmFjZXxtdXRhdGlvbnxvbnxxdWVyeXxyZXBlYXRhYmxlfHNjYWxhcnxzY2hlbWF8c3Vic2NyaXB0aW9ufHR5cGV8dW5pb24pXFxiLyxcblx0J29wZXJhdG9yJzogL1shPXwmXXxcXC57M30vLFxuXHQncHJvcGVydHktcXVlcnknOiAvXFx3Kyg/PVxccypcXCgpLyxcblx0J29iamVjdCc6IC9cXHcrKD89XFxzKlxceykvLFxuXHQncHVuY3R1YXRpb24nOiAvWyEoKXt9XFxbXFxdOj0sXS8sXG5cdCdwcm9wZXJ0eSc6IC9cXHcrL1xufTtcblxuUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIGFmdGVyVG9rZW5pemVHcmFwaHFsKGVudikge1xuXHRpZiAoZW52Lmxhbmd1YWdlICE9PSAnZ3JhcGhxbCcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKipcblx0ICogZ2V0IHRoZSBncmFwaHFsIHRva2VuIHN0cmVhbSB0aGF0IHdlIHdhbnQgdG8gY3VzdG9taXplXG5cdCAqXG5cdCAqIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXHQgKiBAdHlwZSB7VG9rZW5bXX1cblx0ICovXG5cdHZhciB2YWxpZFRva2VucyA9IGVudi50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0b2tlbikge1xuXHRcdHJldHVybiB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnICYmIHRva2VuLnR5cGUgIT09ICdjb21tZW50JyAmJiB0b2tlbi50eXBlICE9PSAnc2NhbGFyJztcblx0fSk7XG5cblx0dmFyIGN1cnJlbnRJbmRleCA9IDA7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdG9rZW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaW5kZXggaGFzIHRoZSBnaXZlbiB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG5cdCAqIEByZXR1cm5zIHtUb2tlbiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGZ1bmN0aW9uIGdldFRva2VuKG9mZnNldCkge1xuXHRcdHJldHVybiB2YWxpZFRva2Vuc1tjdXJyZW50SW5kZXggKyBvZmZzZXRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdG9rZW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaW5kZXggaGFzIHRoZSBnaXZlbiB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3JlYWRvbmx5IHN0cmluZ1tdfSB0eXBlc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzVG9rZW5UeXBlKHR5cGVzLCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdG9rZW4gPSBnZXRUb2tlbihpICsgb2Zmc2V0KTtcblx0XHRcdGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gdHlwZXNbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2luZyBicmFja2V0IHRvIGFuIG9wZW5pbmcgYnJhY2tldC5cblx0ICpcblx0ICogSXQgaXMgYXNzdW1lZCB0aGF0IGB0b2tlbltjdXJyZW50SW5kZXggLSAxXWAgaXMgYW4gb3BlbmluZyBicmFja2V0LlxuXHQgKlxuXHQgKiBJZiBubyBjbG9zaW5nIGJyYWNrZXQgY291bGQgYmUgZm91bmQsIGAtMWAgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogQHBhcmFtIHtSZWdFeHB9IG9wZW5cblx0ICogQHBhcmFtIHtSZWdFeHB9IGNsb3NlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQob3BlbiwgY2xvc2UpIHtcblx0XHR2YXIgc3RhY2tIZWlnaHQgPSAxO1xuXG5cdFx0Zm9yICh2YXIgaSA9IGN1cnJlbnRJbmRleDsgaSA8IHZhbGlkVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdG9rZW4gPSB2YWxpZFRva2Vuc1tpXTtcblx0XHRcdHZhciBjb250ZW50ID0gdG9rZW4uY29udGVudDtcblxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChvcGVuLnRlc3QoY29udGVudCkpIHtcblx0XHRcdFx0XHRzdGFja0hlaWdodCsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNsb3NlLnRlc3QoY29udGVudCkpIHtcblx0XHRcdFx0XHRzdGFja0hlaWdodC0tO1xuXG5cdFx0XHRcdFx0aWYgKHN0YWNrSGVpZ2h0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBhbGlhcyB0byB0aGUgZ2l2ZW4gdG9rZW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZEFsaWFzKHRva2VuLCBhbGlhcykge1xuXHRcdHZhciBhbGlhc2VzID0gdG9rZW4uYWxpYXM7XG5cdFx0aWYgKCFhbGlhc2VzKSB7XG5cdFx0XHR0b2tlbi5hbGlhcyA9IGFsaWFzZXMgPSBbXTtcblx0XHR9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG5cdFx0XHR0b2tlbi5hbGlhcyA9IGFsaWFzZXMgPSBbYWxpYXNlc107XG5cdFx0fVxuXHRcdGFsaWFzZXMucHVzaChhbGlhcyk7XG5cdH1cblxuXHRmb3IgKDsgY3VycmVudEluZGV4IDwgdmFsaWRUb2tlbnMubGVuZ3RoOykge1xuXHRcdHZhciBzdGFydFRva2VuID0gdmFsaWRUb2tlbnNbY3VycmVudEluZGV4KytdO1xuXG5cdFx0Ly8gYWRkIHNwZWNpYWwgYWxpYXNlcyBmb3IgbXV0YXRpb24gdG9rZW5zXG5cdFx0aWYgKHN0YXJ0VG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHN0YXJ0VG9rZW4uY29udGVudCA9PT0gJ211dGF0aW9uJykge1xuXHRcdFx0Ly8gYW55IGFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgaW5wdXQgdmFyaWFibGVzIChpZiBhbnkpXG5cdFx0XHR2YXIgaW5wdXRWYXJpYWJsZXMgPSBbXTtcblxuXHRcdFx0aWYgKGlzVG9rZW5UeXBlKFsnZGVmaW5pdGlvbi1tdXRhdGlvbicsICdwdW5jdHVhdGlvbiddKSAmJiBnZXRUb2tlbigxKS5jb250ZW50ID09PSAnKCcpIHtcblx0XHRcdFx0Ly8gZGVmaW5pdGlvblxuXG5cdFx0XHRcdGN1cnJlbnRJbmRleCArPSAyOyAvLyBza2lwICdkZWZpbml0aW9uLW11dGF0aW9uJyBhbmQgJ3B1bmN0dWF0aW9uJ1xuXG5cdFx0XHRcdHZhciBkZWZpbml0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFwoJC8sIC9eXFwpJC8pO1xuXHRcdFx0XHRpZiAoZGVmaW5pdGlvbkVuZCA9PT0gLTEpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGZpbmQgYWxsIGlucHV0IHZhcmlhYmxlc1xuXHRcdFx0XHRmb3IgKDsgY3VycmVudEluZGV4IDwgZGVmaW5pdGlvbkVuZDsgY3VycmVudEluZGV4KyspIHtcblx0XHRcdFx0XHR2YXIgdCA9IGdldFRva2VuKDApO1xuXHRcdFx0XHRcdGlmICh0LnR5cGUgPT09ICd2YXJpYWJsZScpIHtcblx0XHRcdFx0XHRcdGFkZEFsaWFzKHQsICd2YXJpYWJsZS1pbnB1dCcpO1xuXHRcdFx0XHRcdFx0aW5wdXRWYXJpYWJsZXMucHVzaCh0LmNvbnRlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRJbmRleCA9IGRlZmluaXRpb25FbmQgKyAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNUb2tlblR5cGUoWydwdW5jdHVhdGlvbicsICdwcm9wZXJ0eS1xdWVyeSddKSAmJiBnZXRUb2tlbigwKS5jb250ZW50ID09PSAneycpIHtcblx0XHRcdFx0Y3VycmVudEluZGV4Kys7IC8vIHNraXAgb3BlbmluZyBicmFja2V0XG5cblx0XHRcdFx0YWRkQWxpYXMoZ2V0VG9rZW4oMCksICdwcm9wZXJ0eS1tdXRhdGlvbicpO1xuXG5cdFx0XHRcdGlmIChpbnB1dFZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIG11dGF0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFx7JC8sIC9eXFx9JC8pO1xuXHRcdFx0XHRcdGlmIChtdXRhdGlvbkVuZCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGdpdmUgcmVmZXJlbmNlcyB0byBpbnB1dCB2YXJpYWJsZXMgYSBzcGVjaWFsIGFsaWFzXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGN1cnJlbnRJbmRleDsgaSA8IG11dGF0aW9uRW5kOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB2YXJUb2tlbiA9IHZhbGlkVG9rZW5zW2ldO1xuXHRcdFx0XHRcdFx0aWYgKHZhclRva2VuLnR5cGUgPT09ICd2YXJpYWJsZScgJiYgaW5wdXRWYXJpYWJsZXMuaW5kZXhPZih2YXJUb2tlbi5jb250ZW50KSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGFkZEFsaWFzKHZhclRva2VuLCAndmFyaWFibGUtaW5wdXQnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-graphql.js\n"));

/***/ })

}]);