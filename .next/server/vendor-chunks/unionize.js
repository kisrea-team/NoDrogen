"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unionize";
exports.ids = ["vendor-chunks/unionize"];
exports.modules = {

/***/ "(ssr)/./node_modules/unionize/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/unionize/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction unionize(record, config) {\n    var _a = config || {}, _b = _a.value, valProp = _b === void 0 ? undefined : _b, _c = _a.tag, tagProp = _c === void 0 ? 'tag' : _c;\n    var creators = {};\n    var _loop_1 = function (tag) {\n        creators[tag] = (function (value) {\n            var _a, _b;\n            if (value === void 0) { value = {}; }\n            return valProp ? (_a = {}, _a[tagProp] = tag, _a[valProp] = value, _a) : __assign({}, value, (_b = {}, _b[tagProp] = tag, _b));\n        });\n    };\n    for (var tag in record) {\n        _loop_1(tag);\n    }\n    var is = {};\n    var _loop_2 = function (tag) {\n        is[tag] = (function (variant) { return variant[tagProp] === tag; });\n    };\n    for (var tag in record) {\n        _loop_2(tag);\n    }\n    function evalMatch(variant, cases, defaultCase) {\n        if (defaultCase === void 0) { defaultCase = cases.default; }\n        var handler = cases[variant[tagProp]];\n        return handler ? handler(valProp ? variant[valProp] : variant) : defaultCase(variant);\n    }\n    var match = function (first, second) {\n        return second ? evalMatch(first, second) : function (variant) { return evalMatch(variant, first); };\n    };\n    var identity = function (x) { return x; };\n    var transform = function (first, second) {\n        return second\n            ? evalMatch(first, second, identity)\n            : function (variant) { return evalMatch(variant, first, identity); };\n    };\n    var as = {};\n    var _loop_3 = function (expectedTag) {\n        var _a;\n        as[expectedTag] = match((_a = {},\n            _a[expectedTag] = function (x) { return x; },\n            _a.default = function (val) {\n                throw new Error(\"Attempted to cast \" + val[tagProp] + \" as \" + expectedTag);\n            },\n            _a));\n    };\n    for (var expectedTag in record) {\n        _loop_3(expectedTag);\n    }\n    return Object.assign({\n        is: is,\n        as: as,\n        match: match,\n        transform: transform,\n        _Record: record,\n    }, creators);\n}\nexports.unionize = unionize;\n/**\n * Creates a pseudo-witness of a given type. That is, it pretends to return a value of\n * type `T` for any `T`, but it's really just returning `undefined`. This white lie\n * allows convenient expression of the value types in the record you pass to `unionize`.\n */\nexports.ofType = function () { return undefined; };\nexports[\"default\"] = unionize;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pb25pemUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUNBQXFDLDJEQUEyRCxpQkFBaUI7QUFDakgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBa0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90aW9uLXgtZXhhbXBsZS1mdWxsLy4vbm9kZV9tb2R1bGVzL3VuaW9uaXplL2xpYi9pbmRleC5qcz83YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHVuaW9uaXplKHJlY29yZCwgY29uZmlnKSB7XG4gICAgdmFyIF9hID0gY29uZmlnIHx8IHt9LCBfYiA9IF9hLnZhbHVlLCB2YWxQcm9wID0gX2IgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9iLCBfYyA9IF9hLnRhZywgdGFnUHJvcCA9IF9jID09PSB2b2lkIDAgPyAndGFnJyA6IF9jO1xuICAgIHZhciBjcmVhdG9ycyA9IHt9O1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICBjcmVhdG9yc1t0YWddID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiB2YWxQcm9wID8gKF9hID0ge30sIF9hW3RhZ1Byb3BdID0gdGFnLCBfYVt2YWxQcm9wXSA9IHZhbHVlLCBfYSkgOiBfX2Fzc2lnbih7fSwgdmFsdWUsIChfYiA9IHt9LCBfYlt0YWdQcm9wXSA9IHRhZywgX2IpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciB0YWcgaW4gcmVjb3JkKSB7XG4gICAgICAgIF9sb29wXzEodGFnKTtcbiAgICB9XG4gICAgdmFyIGlzID0ge307XG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIGlzW3RhZ10gPSAoZnVuY3Rpb24gKHZhcmlhbnQpIHsgcmV0dXJuIHZhcmlhbnRbdGFnUHJvcF0gPT09IHRhZzsgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciB0YWcgaW4gcmVjb3JkKSB7XG4gICAgICAgIF9sb29wXzIodGFnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXZhbE1hdGNoKHZhcmlhbnQsIGNhc2VzLCBkZWZhdWx0Q2FzZSkge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2UgPT09IHZvaWQgMCkgeyBkZWZhdWx0Q2FzZSA9IGNhc2VzLmRlZmF1bHQ7IH1cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYXNlc1t2YXJpYW50W3RhZ1Byb3BdXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZhbFByb3AgPyB2YXJpYW50W3ZhbFByb3BdIDogdmFyaWFudCkgOiBkZWZhdWx0Q2FzZSh2YXJpYW50KTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZCA/IGV2YWxNYXRjaChmaXJzdCwgc2Vjb25kKSA6IGZ1bmN0aW9uICh2YXJpYW50KSB7IHJldHVybiBldmFsTWF0Y2godmFyaWFudCwgZmlyc3QpOyB9O1xuICAgIH07XG4gICAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBzZWNvbmRcbiAgICAgICAgICAgID8gZXZhbE1hdGNoKGZpcnN0LCBzZWNvbmQsIGlkZW50aXR5KVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAodmFyaWFudCkgeyByZXR1cm4gZXZhbE1hdGNoKHZhcmlhbnQsIGZpcnN0LCBpZGVudGl0eSk7IH07XG4gICAgfTtcbiAgICB2YXIgYXMgPSB7fTtcbiAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChleHBlY3RlZFRhZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGFzW2V4cGVjdGVkVGFnXSA9IG1hdGNoKChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbZXhwZWN0ZWRUYWddID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0sXG4gICAgICAgICAgICBfYS5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjYXN0IFwiICsgdmFsW3RhZ1Byb3BdICsgXCIgYXMgXCIgKyBleHBlY3RlZFRhZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2EpKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGV4cGVjdGVkVGFnIGluIHJlY29yZCkge1xuICAgICAgICBfbG9vcF8zKGV4cGVjdGVkVGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpczogaXMsXG4gICAgICAgIGFzOiBhcyxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgX1JlY29yZDogcmVjb3JkLFxuICAgIH0sIGNyZWF0b3JzKTtcbn1cbmV4cG9ydHMudW5pb25pemUgPSB1bmlvbml6ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHBzZXVkby13aXRuZXNzIG9mIGEgZ2l2ZW4gdHlwZS4gVGhhdCBpcywgaXQgcHJldGVuZHMgdG8gcmV0dXJuIGEgdmFsdWUgb2ZcbiAqIHR5cGUgYFRgIGZvciBhbnkgYFRgLCBidXQgaXQncyByZWFsbHkganVzdCByZXR1cm5pbmcgYHVuZGVmaW5lZGAuIFRoaXMgd2hpdGUgbGllXG4gKiBhbGxvd3MgY29udmVuaWVudCBleHByZXNzaW9uIG9mIHRoZSB2YWx1ZSB0eXBlcyBpbiB0aGUgcmVjb3JkIHlvdSBwYXNzIHRvIGB1bmlvbml6ZWAuXG4gKi9cbmV4cG9ydHMub2ZUeXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5pb25pemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unionize/lib/index.js\n");

/***/ })

};
;